{"ast":null,"code":"import { format } from \"./isomorphic.node\";\n/**\n * Normalizes Ono options, accounting for defaults and optional options.\n */\n\nexport function normalizeOptions(options) {\n  options = options || {};\n  return {\n    concatMessages: options.concatMessages === undefined ? true : Boolean(options.concatMessages),\n    format: options.format === undefined ? format : typeof options.format === \"function\" ? options.format : false\n  };\n}\n/**\n * Normalizes the Ono arguments, accounting for defaults, options, and optional arguments.\n */\n\nexport function normalizeArgs(args, options) {\n  let originalError;\n  let props;\n  let formatArgs;\n  let message = \"\"; // Determine which arguments were actually specified\n\n  if (typeof args[0] === \"string\") {\n    formatArgs = args;\n  } else if (typeof args[1] === \"string\") {\n    if (args[0] instanceof Error) {\n      originalError = args[0];\n    } else {\n      props = args[0];\n    }\n\n    formatArgs = args.slice(1);\n  } else {\n    originalError = args[0];\n    props = args[1];\n    formatArgs = args.slice(2);\n  } // If there are any format arguments, then format the error message\n\n\n  if (formatArgs.length > 0) {\n    if (options.format) {\n      message = options.format.apply(undefined, formatArgs);\n    } else {\n      message = formatArgs.join(\" \");\n    }\n  }\n\n  if (options.concatMessages && originalError && originalError.message) {\n    // The inner-error's message will be added to the new message\n    message += (message ? \" \\n\" : \"\") + originalError.message;\n  }\n\n  return {\n    originalError,\n    props,\n    message\n  };\n}","map":{"version":3,"sources":["../src/normalize.ts"],"names":[],"mappings":"AAAA,SAAS,MAAT,QAAuB,mBAAvB;AAGA;;AAEG;;AACH,OAAM,SAAU,gBAAV,CAA2B,OAA3B,EAA+C;AACnD,EAAA,OAAO,GAAG,OAAO,IAAI,EAArB;AACA,SAAO;AACL,IAAA,cAAc,EAAE,OAAO,CAAC,cAAR,KAA2B,SAA3B,GAAuC,IAAvC,GAA8C,OAAO,CAAC,OAAO,CAAC,cAAT,CADhE;AAEL,IAAA,MAAM,EAAE,OAAO,CAAC,MAAR,KAAmB,SAAnB,GAA+B,MAA/B,GACH,OAAO,OAAO,CAAC,MAAf,KAA0B,UAA1B,GAAuC,OAAO,CAAC,MAA/C,GAAwD;AAHxD,GAAP;AAKD;AAED;;AAEG;;AACH,OAAM,SAAU,aAAV,CAA+D,IAA/D,EAAgF,OAAhF,EAAmG;AACvG,MAAI,aAAJ;AACA,MAAI,KAAJ;AACA,MAAI,UAAJ;AACA,MAAI,OAAO,GAAG,EAAd,CAJuG,CAMvG;;AACA,MAAI,OAAO,IAAI,CAAC,CAAD,CAAX,KAAmB,QAAvB,EAAiC;AAC/B,IAAA,UAAU,GAAG,IAAb;AACD,GAFD,MAGK,IAAI,OAAO,IAAI,CAAC,CAAD,CAAX,KAAmB,QAAvB,EAAiC;AACpC,QAAI,IAAI,CAAC,CAAD,CAAJ,YAAmB,KAAvB,EAA8B;AAC5B,MAAA,aAAa,GAAG,IAAI,CAAC,CAAD,CAApB;AACD,KAFD,MAGK;AACH,MAAA,KAAK,GAAG,IAAI,CAAC,CAAD,CAAZ;AACD;;AACD,IAAA,UAAU,GAAG,IAAI,CAAC,KAAL,CAAW,CAAX,CAAb;AACD,GARI,MASA;AACH,IAAA,aAAa,GAAG,IAAI,CAAC,CAAD,CAApB;AACA,IAAA,KAAK,GAAG,IAAI,CAAC,CAAD,CAAZ;AACA,IAAA,UAAU,GAAG,IAAI,CAAC,KAAL,CAAW,CAAX,CAAb;AACD,GAvBsG,CAyBvG;;;AACA,MAAI,UAAU,CAAC,MAAX,GAAoB,CAAxB,EAA2B;AACzB,QAAI,OAAO,CAAC,MAAZ,EAAoB;AAClB,MAAA,OAAO,GAAG,OAAO,CAAC,MAAR,CAAe,KAAf,CAAqB,SAArB,EAAgC,UAAhC,CAAV;AACD,KAFD,MAGK;AACH,MAAA,OAAO,GAAG,UAAU,CAAC,IAAX,CAAgB,GAAhB,CAAV;AACD;AACF;;AAED,MAAI,OAAO,CAAC,cAAR,IAA0B,aAA1B,IAA2C,aAAa,CAAC,OAA7D,EAAsE;AACpE;AACA,IAAA,OAAO,IAAI,CAAC,OAAO,GAAG,KAAH,GAAW,EAAnB,IAAyB,aAAa,CAAC,OAAlD;AACD;;AAED,SAAO;AAAE,IAAA,aAAF;AAAiB,IAAA,KAAjB;AAAwB,IAAA;AAAxB,GAAP;AACD","sourceRoot":"","sourcesContent":["import { format } from \"./isomorphic.node\";\n/**\n * Normalizes Ono options, accounting for defaults and optional options.\n */\nexport function normalizeOptions(options) {\n    options = options || {};\n    return {\n        concatMessages: options.concatMessages === undefined ? true : Boolean(options.concatMessages),\n        format: options.format === undefined ? format\n            : (typeof options.format === \"function\" ? options.format : false),\n    };\n}\n/**\n * Normalizes the Ono arguments, accounting for defaults, options, and optional arguments.\n */\nexport function normalizeArgs(args, options) {\n    let originalError;\n    let props;\n    let formatArgs;\n    let message = \"\";\n    // Determine which arguments were actually specified\n    if (typeof args[0] === \"string\") {\n        formatArgs = args;\n    }\n    else if (typeof args[1] === \"string\") {\n        if (args[0] instanceof Error) {\n            originalError = args[0];\n        }\n        else {\n            props = args[0];\n        }\n        formatArgs = args.slice(1);\n    }\n    else {\n        originalError = args[0];\n        props = args[1];\n        formatArgs = args.slice(2);\n    }\n    // If there are any format arguments, then format the error message\n    if (formatArgs.length > 0) {\n        if (options.format) {\n            message = options.format.apply(undefined, formatArgs);\n        }\n        else {\n            message = formatArgs.join(\" \");\n        }\n    }\n    if (options.concatMessages && originalError && originalError.message) {\n        // The inner-error's message will be added to the new message\n        message += (message ? \" \\n\" : \"\") + originalError.message;\n    }\n    return { originalError, props, message };\n}\n//# sourceMappingURL=normalize.js.map"]},"metadata":{},"sourceType":"module"}