{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.explodedStructuredArrayParser = exports.structuredArrayParser = exports.structuredStringParser = exports.generateStructuredParser = void 0;\n\nconst lodash_1 = __importDefault(require(\"lodash\"));\n\nconst common_1 = require(\"./common\");\n\nconst json_schema_infer_types_1 = __importDefault(require(\"../../utils/json-schema-infer-types\"));\n\nconst simpleStringParser_1 = require(\"./simpleStringParser\");\n/**\n * A structured parser is a parser that handles RFC6570 path-style and\n * form-style query expansions.\n *\n * @param schema - The JSON Schema this parser is expecting.\n * @param explode - True if this is a parser for an \"exploded\" expansion.\n */\n\n\nfunction generateStructuredParser(schema, explode) {\n  const allowedTypes = common_1.removeSimpleTypes(json_schema_infer_types_1.default(schema));\n\n  if (allowedTypes.length === 1 && allowedTypes[0] === 'string') {\n    return structuredStringParser;\n  } else if (allowedTypes.length === 1 && allowedTypes[0] === 'array') {\n    if (explode) {\n      return explodedStructuredArrayParser;\n    } else {\n      return structuredArrayParser;\n    }\n  } else if (!explode) {\n    return generateGenericStructuredParser(schema);\n  } else {\n    return generateGenericExplodedStructuredParser(schema);\n  }\n}\n\nexports.generateStructuredParser = generateStructuredParser;\n\nfunction structuredStringParser(location, rawParamValues) {\n  const value = rawParamValues[location.name];\n\n  if (!value) {\n    return value;\n  } else if (Array.isArray(value)) {\n    // This is supposed to be a string.  -_-\n    return value.map(decodeURIComponent);\n  } else {\n    return value ? simpleStringParser_1.simpleStringParser(value) : value;\n  }\n}\n\nexports.structuredStringParser = structuredStringParser;\n\nfunction structuredArrayParser(location, rawParamValues) {\n  const value = rawParamValues[location.name];\n\n  if (value === undefined || value === null) {\n    return value;\n  } else if (Array.isArray(value)) {\n    // We *should* not receive multiple form headers.  If this happens,\n    // it's probably because the client used explode when they shouldn't\n    // have.\n    return explodedStructuredArrayParser(location, rawParamValues);\n  } else {\n    return value ? simpleStringParser_1.simpleArrayParser(value) : value;\n  }\n}\n\nexports.structuredArrayParser = structuredArrayParser;\n\nfunction explodedStructuredArrayParser(location, rawParamValues) {\n  const value = rawParamValues[location.name];\n\n  if (value === undefined || value === null) {\n    return value;\n  } else if (Array.isArray(value)) {\n    return value.map(decodeURIComponent);\n  } else {\n    return [decodeURIComponent(value)];\n  }\n}\n\nexports.explodedStructuredArrayParser = explodedStructuredArrayParser;\n\nfunction generateGenericStructuredParser(schema) {\n  const genericSimpleParser = simpleStringParser_1.generateGenericSimpleParser(schema, false);\n  return function genericStructuredParser(location, rawParamValues) {\n    const value = rawParamValues[location.name];\n\n    if (value === undefined || value === null) {\n      return value;\n    }\n\n    if (Array.isArray(value)) {\n      // Unexploded parameters should not be an array.  Parse each member\n      // of the array, and return an array of arrays?\n      return value.map(genericSimpleParser);\n    }\n\n    return genericSimpleParser(value);\n  };\n}\n\nfunction explodedKeysStructuredParser(values) {\n  return lodash_1.default.mapValues(values, v => {\n    if (Array.isArray(v)) {\n      return v.map(decodeURIComponent);\n    } else if (v) {\n      return decodeURIComponent(v);\n    } else {\n      return v;\n    }\n  });\n}\n\nfunction generateGenericExplodedStructuredParser(schema) {\n  const allowedTypes = common_1.removeSimpleTypes(json_schema_infer_types_1.default(schema));\n  const allowedTypesMap = common_1.allowedTypesToMap(allowedTypes);\n  return function genericStructuredParser(location, rawParamValues) {\n    const value = rawParamValues[location.name];\n\n    if (value === undefined || value === null) {\n      if (allowedTypesMap.object) {\n        // TODO: Could use a list of allowed parameters to control what we return here.\n        return explodedKeysStructuredParser(rawParamValues);\n      } else {\n        return value;\n      }\n    } // We have a parameter with the same name as the one we're looking for - probably not an object.\n\n\n    if (Array.isArray(value)) {\n      if (!allowedTypesMap.array) {\n        return explodedKeysStructuredParser(rawParamValues);\n      } else {\n        return value.map(simpleStringParser_1.simpleStringParser);\n      }\n    } else if (allowedTypesMap.string) {\n      return simpleStringParser_1.simpleStringParser(value);\n    } else if (allowedTypesMap.array) {\n      return [simpleStringParser_1.simpleStringParser(value)];\n    } else {\n      return explodedKeysStructuredParser(rawParamValues);\n    }\n  };\n}","map":{"version":3,"sources":["../../../src/oas3/parameterParsers/structuredParser.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.explodedStructuredArrayParser = exports.structuredArrayParser = exports.structuredStringParser = exports.generateStructuredParser = void 0;\nconst lodash_1 = __importDefault(require(\"lodash\"));\nconst common_1 = require(\"./common\");\nconst json_schema_infer_types_1 = __importDefault(require(\"../../utils/json-schema-infer-types\"));\nconst simpleStringParser_1 = require(\"./simpleStringParser\");\n/**\n * A structured parser is a parser that handles RFC6570 path-style and\n * form-style query expansions.\n *\n * @param schema - The JSON Schema this parser is expecting.\n * @param explode - True if this is a parser for an \"exploded\" expansion.\n */\nfunction generateStructuredParser(schema, explode) {\n    const allowedTypes = common_1.removeSimpleTypes(json_schema_infer_types_1.default(schema));\n    if (allowedTypes.length === 1 && allowedTypes[0] === 'string') {\n        return structuredStringParser;\n    }\n    else if (allowedTypes.length === 1 && allowedTypes[0] === 'array') {\n        if (explode) {\n            return explodedStructuredArrayParser;\n        }\n        else {\n            return structuredArrayParser;\n        }\n    }\n    else if (!explode) {\n        return generateGenericStructuredParser(schema);\n    }\n    else {\n        return generateGenericExplodedStructuredParser(schema);\n    }\n}\nexports.generateStructuredParser = generateStructuredParser;\nfunction structuredStringParser(location, rawParamValues) {\n    const value = rawParamValues[location.name];\n    if (!value) {\n        return value;\n    }\n    else if (Array.isArray(value)) {\n        // This is supposed to be a string.  -_-\n        return value.map(decodeURIComponent);\n    }\n    else {\n        return value ? simpleStringParser_1.simpleStringParser(value) : value;\n    }\n}\nexports.structuredStringParser = structuredStringParser;\nfunction structuredArrayParser(location, rawParamValues) {\n    const value = rawParamValues[location.name];\n    if (value === undefined || value === null) {\n        return value;\n    }\n    else if (Array.isArray(value)) {\n        // We *should* not receive multiple form headers.  If this happens,\n        // it's probably because the client used explode when they shouldn't\n        // have.\n        return explodedStructuredArrayParser(location, rawParamValues);\n    }\n    else {\n        return value ? simpleStringParser_1.simpleArrayParser(value) : value;\n    }\n}\nexports.structuredArrayParser = structuredArrayParser;\nfunction explodedStructuredArrayParser(location, rawParamValues) {\n    const value = rawParamValues[location.name];\n    if (value === undefined || value === null) {\n        return value;\n    }\n    else if (Array.isArray(value)) {\n        return value.map(decodeURIComponent);\n    }\n    else {\n        return [decodeURIComponent(value)];\n    }\n}\nexports.explodedStructuredArrayParser = explodedStructuredArrayParser;\nfunction generateGenericStructuredParser(schema) {\n    const genericSimpleParser = simpleStringParser_1.generateGenericSimpleParser(schema, false);\n    return function genericStructuredParser(location, rawParamValues) {\n        const value = rawParamValues[location.name];\n        if (value === undefined || value === null) {\n            return value;\n        }\n        if (Array.isArray(value)) {\n            // Unexploded parameters should not be an array.  Parse each member\n            // of the array, and return an array of arrays?\n            return value.map(genericSimpleParser);\n        }\n        return genericSimpleParser(value);\n    };\n}\nfunction explodedKeysStructuredParser(values) {\n    return lodash_1.default.mapValues(values, (v) => {\n        if (Array.isArray(v)) {\n            return v.map(decodeURIComponent);\n        }\n        else if (v) {\n            return decodeURIComponent(v);\n        }\n        else {\n            return v;\n        }\n    });\n}\nfunction generateGenericExplodedStructuredParser(schema) {\n    const allowedTypes = common_1.removeSimpleTypes(json_schema_infer_types_1.default(schema));\n    const allowedTypesMap = common_1.allowedTypesToMap(allowedTypes);\n    return function genericStructuredParser(location, rawParamValues) {\n        const value = rawParamValues[location.name];\n        if (value === undefined || value === null) {\n            if (allowedTypesMap.object) {\n                // TODO: Could use a list of allowed parameters to control what we return here.\n                return explodedKeysStructuredParser(rawParamValues);\n            }\n            else {\n                return value;\n            }\n        }\n        // We have a parameter with the same name as the one we're looking for - probably not an object.\n        if (Array.isArray(value)) {\n            if (!allowedTypesMap.array) {\n                return explodedKeysStructuredParser(rawParamValues);\n            }\n            else {\n                return value.map(simpleStringParser_1.simpleStringParser);\n            }\n        }\n        else if (allowedTypesMap.string) {\n            return simpleStringParser_1.simpleStringParser(value);\n        }\n        else if (allowedTypesMap.array) {\n            return [simpleStringParser_1.simpleStringParser(value)];\n        }\n        else {\n            return explodedKeysStructuredParser(rawParamValues);\n        }\n    };\n}\n//# sourceMappingURL=structuredParser.js.map"]},"metadata":{},"sourceType":"script"}