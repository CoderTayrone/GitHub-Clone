{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Throttler = exports.timeToWait = void 0;\n\nconst logger_1 = require(\"../logger\");\n\nconst retries_exhausted_error_1 = require(\"./errors/retries-exhausted-error\");\n\nconst timeout_error_1 = require(\"./errors/timeout-error\");\n\nfunction backoff(retryNumber, delay, maxDelay) {\n  return new Promise(resolve => {\n    setTimeout(resolve, timeToWait(retryNumber, delay, maxDelay));\n  });\n}\n\nfunction timeToWait(retryNumber, delay, maxDelay) {\n  return Math.min(delay * Math.pow(2, retryNumber), maxDelay);\n}\n\nexports.timeToWait = timeToWait;\n\nfunction DEFAULT_HANDLER(task) {\n  return task();\n}\n\nclass Throttler {\n  constructor(options) {\n    this.name = \"\";\n    this.concurrency = 200;\n    this.handler = DEFAULT_HANDLER;\n    this.active = 0;\n    this.complete = 0;\n    this.success = 0;\n    this.errored = 0;\n    this.retried = 0;\n    this.total = 0;\n    this.taskDataMap = new Map();\n    this.waits = [];\n    this.min = 9999999999;\n    this.max = 0;\n    this.avg = 0;\n    this.retries = 0;\n    this.backoff = 200;\n    this.maxBackoff = 60000;\n    this.closed = false;\n    this.finished = false;\n    this.startTime = 0;\n\n    if (options.name) {\n      this.name = options.name;\n    }\n\n    if (options.handler) {\n      this.handler = options.handler;\n    }\n\n    if (typeof options.concurrency === \"number\") {\n      this.concurrency = options.concurrency;\n    }\n\n    if (typeof options.retries === \"number\") {\n      this.retries = options.retries;\n    }\n\n    if (typeof options.backoff === \"number\") {\n      this.backoff = options.backoff;\n    }\n\n    if (typeof options.maxBackoff === \"number\") {\n      this.maxBackoff = options.maxBackoff;\n    }\n  }\n\n  wait() {\n    const p = new Promise((resolve, reject) => {\n      this.waits.push({\n        resolve,\n        reject\n      });\n    });\n    return p;\n  }\n\n  add(task, timeoutMillis) {\n    this.addHelper(task, timeoutMillis);\n  }\n\n  run(task, timeoutMillis) {\n    return new Promise((resolve, reject) => {\n      this.addHelper(task, timeoutMillis, {\n        resolve,\n        reject\n      });\n    });\n  }\n\n  close() {\n    this.closed = true;\n    return this.finishIfIdle();\n  }\n\n  process() {\n    if (this.finishIfIdle() || this.active >= this.concurrency || !this.hasWaitingTask()) {\n      return;\n    }\n\n    this.active++;\n    this.handle(this.nextWaitingTaskIndex());\n  }\n\n  async handle(cursorIndex) {\n    const taskData = this.taskDataMap.get(cursorIndex);\n\n    if (!taskData) {\n      throw new Error(`taskData.get(${cursorIndex}) does not exist`);\n    }\n\n    const promises = [this.executeTask(cursorIndex)];\n\n    if (taskData.timeoutMillis) {\n      promises.push(this.initializeTimeout(cursorIndex));\n    }\n\n    let result;\n\n    try {\n      result = await Promise.race(promises);\n    } catch (err) {\n      this.errored++;\n      this.complete++;\n      this.active--;\n      this.onTaskFailed(err, cursorIndex);\n      return;\n    }\n\n    this.success++;\n    this.complete++;\n    this.active--;\n    this.onTaskFulfilled(result, cursorIndex);\n  }\n\n  stats() {\n    return {\n      max: this.max,\n      min: this.min,\n      avg: this.avg,\n      active: this.active,\n      complete: this.complete,\n      success: this.success,\n      errored: this.errored,\n      retried: this.retried,\n      total: this.total,\n      elapsed: Date.now() - this.startTime\n    };\n  }\n\n  taskName(cursorIndex) {\n    const taskData = this.taskDataMap.get(cursorIndex);\n\n    if (!taskData) {\n      return \"finished task\";\n    }\n\n    return typeof taskData.task === \"string\" ? taskData.task : `index ${cursorIndex}`;\n  }\n\n  addHelper(task, timeoutMillis, wait) {\n    if (this.closed) {\n      throw new Error(\"Cannot add a task to a closed throttler.\");\n    }\n\n    if (!this.startTime) {\n      this.startTime = Date.now();\n    }\n\n    this.taskDataMap.set(this.total, {\n      task,\n      wait,\n      timeoutMillis,\n      retryCount: 0,\n      isTimedOut: false\n    });\n    this.total++;\n    this.process();\n  }\n\n  finishIfIdle() {\n    if (this.closed && !this.hasWaitingTask() && this.active === 0) {\n      this.finish();\n      return true;\n    }\n\n    return false;\n  }\n\n  finish(err) {\n    this.waits.forEach(p => {\n      if (err) {\n        return p.reject(err);\n      }\n\n      this.finished = true;\n      return p.resolve();\n    });\n  }\n\n  initializeTimeout(cursorIndex) {\n    const taskData = this.taskDataMap.get(cursorIndex);\n    const timeoutMillis = taskData.timeoutMillis;\n    const timeoutPromise = new Promise((_, reject) => {\n      taskData.timeoutId = setTimeout(() => {\n        taskData.isTimedOut = true;\n        reject(new timeout_error_1.default(this.taskName(cursorIndex), timeoutMillis));\n      }, timeoutMillis);\n    });\n    return timeoutPromise;\n  }\n\n  async executeTask(cursorIndex) {\n    const taskData = this.taskDataMap.get(cursorIndex);\n    const t0 = Date.now();\n    let result;\n\n    try {\n      result = await this.handler(taskData.task);\n    } catch (err) {\n      if (taskData.retryCount === this.retries) {\n        throw new retries_exhausted_error_1.default(this.taskName(cursorIndex), this.retries, err);\n      }\n\n      await backoff(taskData.retryCount + 1, this.backoff, this.maxBackoff);\n\n      if (taskData.isTimedOut) {\n        throw new timeout_error_1.default(this.taskName(cursorIndex), taskData.timeoutMillis);\n      }\n\n      this.retried++;\n      taskData.retryCount++;\n      logger_1.logger.debug(`[${this.name}] Retrying task`, this.taskName(cursorIndex));\n      return this.executeTask(cursorIndex);\n    }\n\n    if (taskData.isTimedOut) {\n      throw new timeout_error_1.default(this.taskName(cursorIndex), taskData.timeoutMillis);\n    }\n\n    const dt = Date.now() - t0;\n    this.min = Math.min(dt, this.min);\n    this.max = Math.max(dt, this.max);\n    this.avg = (this.avg * this.complete + dt) / (this.complete + 1);\n    return result;\n  }\n\n  onTaskFulfilled(result, cursorIndex) {\n    const taskData = this.taskDataMap.get(cursorIndex);\n\n    if (taskData.wait) {\n      taskData.wait.resolve(result);\n    }\n\n    this.cleanupTask(cursorIndex);\n    this.process();\n  }\n\n  onTaskFailed(error, cursorIndex) {\n    const taskData = this.taskDataMap.get(cursorIndex);\n    logger_1.logger.debug(error);\n\n    if (taskData.wait) {\n      taskData.wait.reject(error);\n    }\n\n    this.cleanupTask(cursorIndex);\n    this.finish(error);\n  }\n\n  cleanupTask(cursorIndex) {\n    const {\n      timeoutId\n    } = this.taskDataMap.get(cursorIndex);\n\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n    }\n\n    this.taskDataMap.delete(cursorIndex);\n  }\n\n}\n\nexports.Throttler = Throttler;","map":{"version":3,"sources":["/home/dev/Documentos/Projects/github-clone/node_modules/firebase-tools/lib/throttler/throttler.js"],"names":["Object","defineProperty","exports","value","Throttler","timeToWait","logger_1","require","retries_exhausted_error_1","timeout_error_1","backoff","retryNumber","delay","maxDelay","Promise","resolve","setTimeout","Math","min","pow","DEFAULT_HANDLER","task","constructor","options","name","concurrency","handler","active","complete","success","errored","retried","total","taskDataMap","Map","waits","max","avg","retries","maxBackoff","closed","finished","startTime","wait","p","reject","push","add","timeoutMillis","addHelper","run","close","finishIfIdle","process","hasWaitingTask","handle","nextWaitingTaskIndex","cursorIndex","taskData","get","Error","promises","executeTask","initializeTimeout","result","race","err","onTaskFailed","onTaskFulfilled","stats","elapsed","Date","now","taskName","set","retryCount","isTimedOut","finish","forEach","timeoutPromise","_","timeoutId","default","t0","logger","debug","dt","cleanupTask","error","clearTimeout","delete"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Throttler = exports.timeToWait = void 0;\nconst logger_1 = require(\"../logger\");\nconst retries_exhausted_error_1 = require(\"./errors/retries-exhausted-error\");\nconst timeout_error_1 = require(\"./errors/timeout-error\");\nfunction backoff(retryNumber, delay, maxDelay) {\n    return new Promise((resolve) => {\n        setTimeout(resolve, timeToWait(retryNumber, delay, maxDelay));\n    });\n}\nfunction timeToWait(retryNumber, delay, maxDelay) {\n    return Math.min(delay * Math.pow(2, retryNumber), maxDelay);\n}\nexports.timeToWait = timeToWait;\nfunction DEFAULT_HANDLER(task) {\n    return task();\n}\nclass Throttler {\n    constructor(options) {\n        this.name = \"\";\n        this.concurrency = 200;\n        this.handler = DEFAULT_HANDLER;\n        this.active = 0;\n        this.complete = 0;\n        this.success = 0;\n        this.errored = 0;\n        this.retried = 0;\n        this.total = 0;\n        this.taskDataMap = new Map();\n        this.waits = [];\n        this.min = 9999999999;\n        this.max = 0;\n        this.avg = 0;\n        this.retries = 0;\n        this.backoff = 200;\n        this.maxBackoff = 60000;\n        this.closed = false;\n        this.finished = false;\n        this.startTime = 0;\n        if (options.name) {\n            this.name = options.name;\n        }\n        if (options.handler) {\n            this.handler = options.handler;\n        }\n        if (typeof options.concurrency === \"number\") {\n            this.concurrency = options.concurrency;\n        }\n        if (typeof options.retries === \"number\") {\n            this.retries = options.retries;\n        }\n        if (typeof options.backoff === \"number\") {\n            this.backoff = options.backoff;\n        }\n        if (typeof options.maxBackoff === \"number\") {\n            this.maxBackoff = options.maxBackoff;\n        }\n    }\n    wait() {\n        const p = new Promise((resolve, reject) => {\n            this.waits.push({ resolve, reject });\n        });\n        return p;\n    }\n    add(task, timeoutMillis) {\n        this.addHelper(task, timeoutMillis);\n    }\n    run(task, timeoutMillis) {\n        return new Promise((resolve, reject) => {\n            this.addHelper(task, timeoutMillis, { resolve, reject });\n        });\n    }\n    close() {\n        this.closed = true;\n        return this.finishIfIdle();\n    }\n    process() {\n        if (this.finishIfIdle() || this.active >= this.concurrency || !this.hasWaitingTask()) {\n            return;\n        }\n        this.active++;\n        this.handle(this.nextWaitingTaskIndex());\n    }\n    async handle(cursorIndex) {\n        const taskData = this.taskDataMap.get(cursorIndex);\n        if (!taskData) {\n            throw new Error(`taskData.get(${cursorIndex}) does not exist`);\n        }\n        const promises = [this.executeTask(cursorIndex)];\n        if (taskData.timeoutMillis) {\n            promises.push(this.initializeTimeout(cursorIndex));\n        }\n        let result;\n        try {\n            result = await Promise.race(promises);\n        }\n        catch (err) {\n            this.errored++;\n            this.complete++;\n            this.active--;\n            this.onTaskFailed(err, cursorIndex);\n            return;\n        }\n        this.success++;\n        this.complete++;\n        this.active--;\n        this.onTaskFulfilled(result, cursorIndex);\n    }\n    stats() {\n        return {\n            max: this.max,\n            min: this.min,\n            avg: this.avg,\n            active: this.active,\n            complete: this.complete,\n            success: this.success,\n            errored: this.errored,\n            retried: this.retried,\n            total: this.total,\n            elapsed: Date.now() - this.startTime,\n        };\n    }\n    taskName(cursorIndex) {\n        const taskData = this.taskDataMap.get(cursorIndex);\n        if (!taskData) {\n            return \"finished task\";\n        }\n        return typeof taskData.task === \"string\" ? taskData.task : `index ${cursorIndex}`;\n    }\n    addHelper(task, timeoutMillis, wait) {\n        if (this.closed) {\n            throw new Error(\"Cannot add a task to a closed throttler.\");\n        }\n        if (!this.startTime) {\n            this.startTime = Date.now();\n        }\n        this.taskDataMap.set(this.total, {\n            task,\n            wait,\n            timeoutMillis,\n            retryCount: 0,\n            isTimedOut: false,\n        });\n        this.total++;\n        this.process();\n    }\n    finishIfIdle() {\n        if (this.closed && !this.hasWaitingTask() && this.active === 0) {\n            this.finish();\n            return true;\n        }\n        return false;\n    }\n    finish(err) {\n        this.waits.forEach((p) => {\n            if (err) {\n                return p.reject(err);\n            }\n            this.finished = true;\n            return p.resolve();\n        });\n    }\n    initializeTimeout(cursorIndex) {\n        const taskData = this.taskDataMap.get(cursorIndex);\n        const timeoutMillis = taskData.timeoutMillis;\n        const timeoutPromise = new Promise((_, reject) => {\n            taskData.timeoutId = setTimeout(() => {\n                taskData.isTimedOut = true;\n                reject(new timeout_error_1.default(this.taskName(cursorIndex), timeoutMillis));\n            }, timeoutMillis);\n        });\n        return timeoutPromise;\n    }\n    async executeTask(cursorIndex) {\n        const taskData = this.taskDataMap.get(cursorIndex);\n        const t0 = Date.now();\n        let result;\n        try {\n            result = await this.handler(taskData.task);\n        }\n        catch (err) {\n            if (taskData.retryCount === this.retries) {\n                throw new retries_exhausted_error_1.default(this.taskName(cursorIndex), this.retries, err);\n            }\n            await backoff(taskData.retryCount + 1, this.backoff, this.maxBackoff);\n            if (taskData.isTimedOut) {\n                throw new timeout_error_1.default(this.taskName(cursorIndex), taskData.timeoutMillis);\n            }\n            this.retried++;\n            taskData.retryCount++;\n            logger_1.logger.debug(`[${this.name}] Retrying task`, this.taskName(cursorIndex));\n            return this.executeTask(cursorIndex);\n        }\n        if (taskData.isTimedOut) {\n            throw new timeout_error_1.default(this.taskName(cursorIndex), taskData.timeoutMillis);\n        }\n        const dt = Date.now() - t0;\n        this.min = Math.min(dt, this.min);\n        this.max = Math.max(dt, this.max);\n        this.avg = (this.avg * this.complete + dt) / (this.complete + 1);\n        return result;\n    }\n    onTaskFulfilled(result, cursorIndex) {\n        const taskData = this.taskDataMap.get(cursorIndex);\n        if (taskData.wait) {\n            taskData.wait.resolve(result);\n        }\n        this.cleanupTask(cursorIndex);\n        this.process();\n    }\n    onTaskFailed(error, cursorIndex) {\n        const taskData = this.taskDataMap.get(cursorIndex);\n        logger_1.logger.debug(error);\n        if (taskData.wait) {\n            taskData.wait.reject(error);\n        }\n        this.cleanupTask(cursorIndex);\n        this.finish(error);\n    }\n    cleanupTask(cursorIndex) {\n        const { timeoutId } = this.taskDataMap.get(cursorIndex);\n        if (timeoutId) {\n            clearTimeout(timeoutId);\n        }\n        this.taskDataMap.delete(cursorIndex);\n    }\n}\nexports.Throttler = Throttler;\n"]},"metadata":{},"sourceType":"script"}