{"ast":null,"code":"\"use strict\";\n\nconst http = require(\"http\");\n\nconst https = require(\"https\");\n\nconst {\n  ono\n} = require(\"@jsdevtools/ono\");\n\nconst url = require(\"../util/url\");\n\nconst {\n  ResolverError\n} = require(\"../util/errors\");\n\nmodule.exports = {\n  /**\n   * The order that this resolver will run, in relation to other resolvers.\n   *\n   * @type {number}\n   */\n  order: 200,\n\n  /**\n   * HTTP headers to send when downloading files.\n   *\n   * @example:\n   * {\n   *   \"User-Agent\": \"JSON Schema $Ref Parser\",\n   *   Accept: \"application/json\"\n   * }\n   *\n   * @type {object}\n   */\n  headers: null,\n\n  /**\n   * HTTP request timeout (in milliseconds).\n   *\n   * @type {number}\n   */\n  timeout: 5000,\n  // 5 seconds\n\n  /**\n   * The maximum number of HTTP redirects to follow.\n   * To disable automatic following of redirects, set this to zero.\n   *\n   * @type {number}\n   */\n  redirects: 5,\n\n  /**\n   * The `withCredentials` option of XMLHttpRequest.\n   * Set this to `true` if you're downloading files from a CORS-enabled server that requires authentication\n   *\n   * @type {boolean}\n   */\n  withCredentials: false,\n\n  /**\n   * Determines whether this resolver can read a given file reference.\n   * Resolvers that return true will be tried in order, until one successfully resolves the file.\n   * Resolvers that return false will not be given a chance to resolve the file.\n   *\n   * @param {object} file           - An object containing information about the referenced file\n   * @param {string} file.url       - The full URL of the referenced file\n   * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n   * @returns {boolean}\n   */\n  canRead(file) {\n    return url.isHttp(file.url);\n  },\n\n  /**\n   * Reads the given URL and returns its raw contents as a Buffer.\n   *\n   * @param {object} file           - An object containing information about the referenced file\n   * @param {string} file.url       - The full URL of the referenced file\n   * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n   * @returns {Promise<Buffer>}\n   */\n  read(file) {\n    let u = url.parse(file.url);\n\n    if (process.browser && !u.protocol) {\n      // Use the protocol of the current page\n      u.protocol = url.parse(location.href).protocol;\n    }\n\n    return download(u, this);\n  }\n\n};\n/**\n * Downloads the given file.\n *\n * @param {Url|string} u        - The url to download (can be a parsed {@link Url} object)\n * @param {object} httpOptions  - The `options.resolve.http` object\n * @param {number} [redirects]  - The redirect URLs that have already been followed\n *\n * @returns {Promise<Buffer>}\n * The promise resolves with the raw downloaded data, or rejects if there is an HTTP error.\n */\n\nfunction download(u, httpOptions, redirects) {\n  return new Promise((resolve, reject) => {\n    u = url.parse(u);\n    redirects = redirects || [];\n    redirects.push(u.href);\n    get(u, httpOptions).then(res => {\n      if (res.statusCode >= 400) {\n        throw ono({\n          status: res.statusCode\n        }, `HTTP ERROR ${res.statusCode}`);\n      } else if (res.statusCode >= 300) {\n        if (redirects.length > httpOptions.redirects) {\n          reject(new ResolverError(ono({\n            status: res.statusCode\n          }, `Error downloading ${redirects[0]}. \\nToo many redirects: \\n  ${redirects.join(\" \\n  \")}`)));\n        } else if (!res.headers.location) {\n          throw ono({\n            status: res.statusCode\n          }, `HTTP ${res.statusCode} redirect with no location header`);\n        } else {\n          // console.log('HTTP %d redirect %s -> %s', res.statusCode, u.href, res.headers.location);\n          let redirectTo = url.resolve(u, res.headers.location);\n          download(redirectTo, httpOptions, redirects).then(resolve, reject);\n        }\n      } else {\n        resolve(res.body || Buffer.alloc(0));\n      }\n    }).catch(err => {\n      reject(new ResolverError(ono(err, `Error downloading ${u.href}`), u.href));\n    });\n  });\n}\n/**\n * Sends an HTTP GET request.\n *\n * @param {Url} u - A parsed {@link Url} object\n * @param {object} httpOptions - The `options.resolve.http` object\n *\n * @returns {Promise<Response>}\n * The promise resolves with the HTTP Response object.\n */\n\n\nfunction get(u, httpOptions) {\n  return new Promise((resolve, reject) => {\n    // console.log('GET', u.href);\n    let protocol = u.protocol === \"https:\" ? https : http;\n    let req = protocol.get({\n      hostname: u.hostname,\n      port: u.port,\n      path: u.path,\n      auth: u.auth,\n      protocol: u.protocol,\n      headers: httpOptions.headers || {},\n      withCredentials: httpOptions.withCredentials\n    });\n\n    if (typeof req.setTimeout === \"function\") {\n      req.setTimeout(httpOptions.timeout);\n    }\n\n    req.on(\"timeout\", () => {\n      req.abort();\n    });\n    req.on(\"error\", reject);\n    req.once(\"response\", res => {\n      res.body = Buffer.alloc(0);\n      res.on(\"data\", data => {\n        res.body = Buffer.concat([res.body, Buffer.from(data)]);\n      });\n      res.on(\"error\", reject);\n      res.on(\"end\", () => {\n        resolve(res);\n      });\n    });\n  });\n}","map":{"version":3,"sources":["/home/dev/Documentos/Projects/github-clone/node_modules/@apidevtools/json-schema-ref-parser/lib/resolvers/http.js"],"names":["http","require","https","ono","url","ResolverError","module","exports","order","headers","timeout","redirects","withCredentials","canRead","file","isHttp","read","u","parse","process","browser","protocol","location","href","download","httpOptions","Promise","resolve","reject","push","get","then","res","statusCode","status","length","join","redirectTo","body","Buffer","alloc","catch","err","req","hostname","port","path","auth","setTimeout","on","abort","once","data","concat","from"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst http = require(\"http\");\nconst https = require(\"https\");\nconst { ono } = require(\"@jsdevtools/ono\");\nconst url = require(\"../util/url\");\nconst { ResolverError } = require(\"../util/errors\");\n\nmodule.exports = {\n  /**\n   * The order that this resolver will run, in relation to other resolvers.\n   *\n   * @type {number}\n   */\n  order: 200,\n\n  /**\n   * HTTP headers to send when downloading files.\n   *\n   * @example:\n   * {\n   *   \"User-Agent\": \"JSON Schema $Ref Parser\",\n   *   Accept: \"application/json\"\n   * }\n   *\n   * @type {object}\n   */\n  headers: null,\n\n  /**\n   * HTTP request timeout (in milliseconds).\n   *\n   * @type {number}\n   */\n  timeout: 5000, // 5 seconds\n\n  /**\n   * The maximum number of HTTP redirects to follow.\n   * To disable automatic following of redirects, set this to zero.\n   *\n   * @type {number}\n   */\n  redirects: 5,\n\n  /**\n   * The `withCredentials` option of XMLHttpRequest.\n   * Set this to `true` if you're downloading files from a CORS-enabled server that requires authentication\n   *\n   * @type {boolean}\n   */\n  withCredentials: false,\n\n  /**\n   * Determines whether this resolver can read a given file reference.\n   * Resolvers that return true will be tried in order, until one successfully resolves the file.\n   * Resolvers that return false will not be given a chance to resolve the file.\n   *\n   * @param {object} file           - An object containing information about the referenced file\n   * @param {string} file.url       - The full URL of the referenced file\n   * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n   * @returns {boolean}\n   */\n  canRead (file) {\n    return url.isHttp(file.url);\n  },\n\n  /**\n   * Reads the given URL and returns its raw contents as a Buffer.\n   *\n   * @param {object} file           - An object containing information about the referenced file\n   * @param {string} file.url       - The full URL of the referenced file\n   * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n   * @returns {Promise<Buffer>}\n   */\n  read (file) {\n    let u = url.parse(file.url);\n\n    if (process.browser && !u.protocol) {\n      // Use the protocol of the current page\n      u.protocol = url.parse(location.href).protocol;\n    }\n\n    return download(u, this);\n  }\n};\n\n/**\n * Downloads the given file.\n *\n * @param {Url|string} u        - The url to download (can be a parsed {@link Url} object)\n * @param {object} httpOptions  - The `options.resolve.http` object\n * @param {number} [redirects]  - The redirect URLs that have already been followed\n *\n * @returns {Promise<Buffer>}\n * The promise resolves with the raw downloaded data, or rejects if there is an HTTP error.\n */\nfunction download (u, httpOptions, redirects) {\n  return new Promise(((resolve, reject) => {\n    u = url.parse(u);\n    redirects = redirects || [];\n    redirects.push(u.href);\n\n    get(u, httpOptions)\n      .then((res) => {\n        if (res.statusCode >= 400) {\n          throw ono({ status: res.statusCode }, `HTTP ERROR ${res.statusCode}`);\n        }\n        else if (res.statusCode >= 300) {\n          if (redirects.length > httpOptions.redirects) {\n            reject(new ResolverError(ono({ status: res.statusCode },\n              `Error downloading ${redirects[0]}. \\nToo many redirects: \\n  ${redirects.join(\" \\n  \")}`)));\n          }\n          else if (!res.headers.location) {\n            throw ono({ status: res.statusCode }, `HTTP ${res.statusCode} redirect with no location header`);\n          }\n          else {\n            // console.log('HTTP %d redirect %s -> %s', res.statusCode, u.href, res.headers.location);\n            let redirectTo = url.resolve(u, res.headers.location);\n            download(redirectTo, httpOptions, redirects).then(resolve, reject);\n          }\n        }\n        else {\n          resolve(res.body || Buffer.alloc(0));\n        }\n      })\n      .catch((err) => {\n        reject(new ResolverError(ono(err, `Error downloading ${u.href}`), u.href));\n      });\n  }));\n}\n\n/**\n * Sends an HTTP GET request.\n *\n * @param {Url} u - A parsed {@link Url} object\n * @param {object} httpOptions - The `options.resolve.http` object\n *\n * @returns {Promise<Response>}\n * The promise resolves with the HTTP Response object.\n */\nfunction get (u, httpOptions) {\n  return new Promise(((resolve, reject) => {\n    // console.log('GET', u.href);\n\n    let protocol = u.protocol === \"https:\" ? https : http;\n    let req = protocol.get({\n      hostname: u.hostname,\n      port: u.port,\n      path: u.path,\n      auth: u.auth,\n      protocol: u.protocol,\n      headers: httpOptions.headers || {},\n      withCredentials: httpOptions.withCredentials\n    });\n\n    if (typeof req.setTimeout === \"function\") {\n      req.setTimeout(httpOptions.timeout);\n    }\n\n    req.on(\"timeout\", () => {\n      req.abort();\n    });\n\n    req.on(\"error\", reject);\n\n    req.once(\"response\", (res) => {\n      res.body = Buffer.alloc(0);\n\n      res.on(\"data\", (data) => {\n        res.body = Buffer.concat([res.body, Buffer.from(data)]);\n      });\n\n      res.on(\"error\", reject);\n\n      res.on(\"end\", () => {\n        resolve(res);\n      });\n    });\n  }));\n}\n"]},"metadata":{},"sourceType":"script"}