{"ast":null,"code":"\"use strict\";\n\nconst {\n  ono\n} = require(\"@jsdevtools/ono\");\n\nconst url = require(\"./util/url\");\n\nconst plugins = require(\"./util/plugins\");\n\nconst {\n  ResolverError,\n  ParserError,\n  UnmatchedParserError,\n  UnmatchedResolverError,\n  isHandledError\n} = require(\"./util/errors\");\n\nmodule.exports = parse;\n/**\n * Reads and parses the specified file path or URL.\n *\n * @param {string} path - This path MUST already be resolved, since `read` doesn't know the resolution context\n * @param {$Refs} $refs\n * @param {$RefParserOptions} options\n *\n * @returns {Promise}\n * The promise resolves with the parsed file contents, NOT the raw (Buffer) contents.\n */\n\nasync function parse(path, $refs, options) {\n  // Remove the URL fragment, if any\n  path = url.stripHash(path); // Add a new $Ref for this file, even though we don't have the value yet.\n  // This ensures that we don't simultaneously read & parse the same file multiple times\n\n  let $ref = $refs._add(path); // This \"file object\" will be passed to all resolvers and parsers.\n\n\n  let file = {\n    url: path,\n    extension: url.getExtension(path)\n  }; // Read the file and then parse the data\n\n  try {\n    const resolver = await readFile(file, options, $refs);\n    $ref.pathType = resolver.plugin.name;\n    file.data = resolver.result;\n    const parser = await parseFile(file, options, $refs);\n    $ref.value = parser.result;\n    return parser.result;\n  } catch (err) {\n    if (isHandledError(err)) {\n      $ref.value = err;\n    }\n\n    throw err;\n  }\n}\n/**\n * Reads the given file, using the configured resolver plugins\n *\n * @param {object} file           - An object containing information about the referenced file\n * @param {string} file.url       - The full URL of the referenced file\n * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n * @param {$RefParserOptions} options\n *\n * @returns {Promise}\n * The promise resolves with the raw file contents and the resolver that was used.\n */\n\n\nfunction readFile(file, options, $refs) {\n  return new Promise((resolve, reject) => {\n    // console.log('Reading %s', file.url);\n    // Find the resolvers that can read this file\n    let resolvers = plugins.all(options.resolve);\n    resolvers = plugins.filter(resolvers, \"canRead\", file); // Run the resolvers, in order, until one of them succeeds\n\n    plugins.sort(resolvers);\n    plugins.run(resolvers, \"read\", file, $refs).then(resolve, onError);\n\n    function onError(err) {\n      if (!err && options.continueOnError) {\n        // No resolver could be matched\n        reject(new UnmatchedResolverError(file.url));\n      } else if (!err || !(\"error\" in err)) {\n        // Throw a generic, friendly error.\n        reject(ono.syntax(`Unable to resolve $ref pointer \"${file.url}\"`));\n      } // Throw the original error, if it's one of our own (user-friendly) errors.\n      else if (err.error instanceof ResolverError) {\n        reject(err.error);\n      } else {\n        reject(new ResolverError(err, file.url));\n      }\n    }\n  });\n}\n/**\n * Parses the given file's contents, using the configured parser plugins.\n *\n * @param {object} file           - An object containing information about the referenced file\n * @param {string} file.url       - The full URL of the referenced file\n * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver\n * @param {$RefParserOptions} options\n *\n * @returns {Promise}\n * The promise resolves with the parsed file contents and the parser that was used.\n */\n\n\nfunction parseFile(file, options, $refs) {\n  return new Promise((resolve, reject) => {\n    // console.log('Parsing %s', file.url);\n    // Find the parsers that can read this file type.\n    // If none of the parsers are an exact match for this file, then we'll try ALL of them.\n    // This handles situations where the file IS a supported type, just with an unknown extension.\n    let allParsers = plugins.all(options.parse);\n    let filteredParsers = plugins.filter(allParsers, \"canParse\", file);\n    let parsers = filteredParsers.length > 0 ? filteredParsers : allParsers; // Run the parsers, in order, until one of them succeeds\n\n    plugins.sort(parsers);\n    plugins.run(parsers, \"parse\", file, $refs).then(onParsed, onError);\n\n    function onParsed(parser) {\n      if (!parser.plugin.allowEmpty && isEmpty(parser.result)) {\n        reject(ono.syntax(`Error parsing \"${file.url}\" as ${parser.plugin.name}. \\nParsed value is empty`));\n      } else {\n        resolve(parser);\n      }\n    }\n\n    function onError(err) {\n      if (!err && options.continueOnError) {\n        // No resolver could be matched\n        reject(new UnmatchedParserError(file.url));\n      } else if (!err || !(\"error\" in err)) {\n        reject(ono.syntax(`Unable to parse ${file.url}`));\n      } else if (err.error instanceof ParserError) {\n        reject(err.error);\n      } else {\n        reject(new ParserError(err.error.message, file.url));\n      }\n    }\n  });\n}\n/**\n * Determines whether the parsed value is \"empty\".\n *\n * @param {*} value\n * @returns {boolean}\n */\n\n\nfunction isEmpty(value) {\n  return value === undefined || typeof value === \"object\" && Object.keys(value).length === 0 || typeof value === \"string\" && value.trim().length === 0 || Buffer.isBuffer(value) && value.length === 0;\n}","map":{"version":3,"sources":["/home/dev/Documentos/Projects/github-clone/node_modules/@apidevtools/json-schema-ref-parser/lib/parse.js"],"names":["ono","require","url","plugins","ResolverError","ParserError","UnmatchedParserError","UnmatchedResolverError","isHandledError","module","exports","parse","path","$refs","options","stripHash","$ref","_add","file","extension","getExtension","resolver","readFile","pathType","plugin","name","data","result","parser","parseFile","value","err","Promise","resolve","reject","resolvers","all","filter","sort","run","then","onError","continueOnError","syntax","error","allParsers","filteredParsers","parsers","length","onParsed","allowEmpty","isEmpty","message","undefined","Object","keys","trim","Buffer","isBuffer"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst { ono } = require(\"@jsdevtools/ono\");\nconst url = require(\"./util/url\");\nconst plugins = require(\"./util/plugins\");\nconst { ResolverError, ParserError, UnmatchedParserError, UnmatchedResolverError, isHandledError } = require(\"./util/errors\");\n\nmodule.exports = parse;\n\n/**\n * Reads and parses the specified file path or URL.\n *\n * @param {string} path - This path MUST already be resolved, since `read` doesn't know the resolution context\n * @param {$Refs} $refs\n * @param {$RefParserOptions} options\n *\n * @returns {Promise}\n * The promise resolves with the parsed file contents, NOT the raw (Buffer) contents.\n */\nasync function parse (path, $refs, options) {\n  // Remove the URL fragment, if any\n  path = url.stripHash(path);\n\n  // Add a new $Ref for this file, even though we don't have the value yet.\n  // This ensures that we don't simultaneously read & parse the same file multiple times\n  let $ref = $refs._add(path);\n\n  // This \"file object\" will be passed to all resolvers and parsers.\n  let file = {\n    url: path,\n    extension: url.getExtension(path),\n  };\n\n  // Read the file and then parse the data\n  try {\n    const resolver = await readFile(file, options, $refs);\n    $ref.pathType = resolver.plugin.name;\n    file.data = resolver.result;\n\n    const parser = await parseFile(file, options, $refs);\n    $ref.value = parser.result;\n\n    return parser.result;\n  }\n  catch (err) {\n    if (isHandledError(err)) {\n      $ref.value = err;\n    }\n\n    throw err;\n  }\n}\n\n/**\n * Reads the given file, using the configured resolver plugins\n *\n * @param {object} file           - An object containing information about the referenced file\n * @param {string} file.url       - The full URL of the referenced file\n * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n * @param {$RefParserOptions} options\n *\n * @returns {Promise}\n * The promise resolves with the raw file contents and the resolver that was used.\n */\nfunction readFile (file, options, $refs) {\n  return new Promise(((resolve, reject) => {\n    // console.log('Reading %s', file.url);\n\n    // Find the resolvers that can read this file\n    let resolvers = plugins.all(options.resolve);\n    resolvers = plugins.filter(resolvers, \"canRead\", file);\n\n    // Run the resolvers, in order, until one of them succeeds\n    plugins.sort(resolvers);\n    plugins.run(resolvers, \"read\", file, $refs)\n      .then(resolve, onError);\n\n    function onError (err) {\n      if (!err && options.continueOnError) {\n        // No resolver could be matched\n        reject(new UnmatchedResolverError(file.url));\n      }\n      else if (!err || !(\"error\" in err)) {\n        // Throw a generic, friendly error.\n        reject(ono.syntax(`Unable to resolve $ref pointer \"${file.url}\"`));\n      }\n      // Throw the original error, if it's one of our own (user-friendly) errors.\n      else if (err.error instanceof ResolverError) {\n        reject(err.error);\n      }\n      else {\n        reject(new ResolverError(err, file.url));\n      }\n    }\n  }));\n}\n\n/**\n * Parses the given file's contents, using the configured parser plugins.\n *\n * @param {object} file           - An object containing information about the referenced file\n * @param {string} file.url       - The full URL of the referenced file\n * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver\n * @param {$RefParserOptions} options\n *\n * @returns {Promise}\n * The promise resolves with the parsed file contents and the parser that was used.\n */\nfunction parseFile (file, options, $refs) {\n  return new Promise(((resolve, reject) => {\n    // console.log('Parsing %s', file.url);\n\n    // Find the parsers that can read this file type.\n    // If none of the parsers are an exact match for this file, then we'll try ALL of them.\n    // This handles situations where the file IS a supported type, just with an unknown extension.\n    let allParsers = plugins.all(options.parse);\n    let filteredParsers = plugins.filter(allParsers, \"canParse\", file);\n    let parsers = filteredParsers.length > 0 ? filteredParsers : allParsers;\n\n    // Run the parsers, in order, until one of them succeeds\n    plugins.sort(parsers);\n    plugins.run(parsers, \"parse\", file, $refs)\n      .then(onParsed, onError);\n\n    function onParsed (parser) {\n      if (!parser.plugin.allowEmpty && isEmpty(parser.result)) {\n        reject(ono.syntax(`Error parsing \"${file.url}\" as ${parser.plugin.name}. \\nParsed value is empty`));\n      }\n      else {\n        resolve(parser);\n      }\n    }\n\n    function onError (err) {\n      if (!err && options.continueOnError) {\n        // No resolver could be matched\n        reject(new UnmatchedParserError(file.url));\n      }\n      else if (!err || !(\"error\" in err)) {\n        reject(ono.syntax(`Unable to parse ${file.url}`));\n      }\n      else if (err.error instanceof ParserError) {\n        reject(err.error);\n      }\n      else {\n        reject(new ParserError(err.error.message, file.url));\n      }\n    }\n  }));\n}\n\n/**\n * Determines whether the parsed value is \"empty\".\n *\n * @param {*} value\n * @returns {boolean}\n */\nfunction isEmpty (value) {\n  return value === undefined ||\n    (typeof value === \"object\" && Object.keys(value).length === 0) ||\n    (typeof value === \"string\" && value.trim().length === 0) ||\n    (Buffer.isBuffer(value) && value.length === 0);\n}\n"]},"metadata":{},"sourceType":"script"}