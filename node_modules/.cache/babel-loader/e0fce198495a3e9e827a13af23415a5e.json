{"ast":null,"code":"let RE2;\n\nconst minimatch = require(\"minimatch\");\n\ntry {\n  RE2 = require(\"re2\");\n} catch (er) {\n  RE2 = null;\n}\n/**\n * Evaluates whether a configured redirect/rewrite/custom header should\n * be applied to a request against a specific path. All three features\n * are configured with a hash that contains either a Node-like glob path\n * specification as its `source` or `glob` field, or a RE2 regular\n * expression as its `regex` field.\n *\n * Since Javascript lacks a native library for RE2, Superstatic uses the C\n * bindings as an optional dependency, and falls over to PCRE if the import\n * is unavailable. Under most circumstances not involving named capturing\n * groups, the two libraries should have identical behavior.\n *\n * No special consideration is taken if the configuration hash contains both\n * a glob and a regex. normalizeConfig() will error in that case.\n *\n * @param {string} path The URL path from the request.\n * @param {Object} config A dictionary from a sanitized JSON configuration.\n * @return {boolean} Whether the config should be applied to the request.\n */\n\n\nfunction configMatcher(path, config) {\n  const glob = config.glob || config.source;\n  const regex = config.regex;\n\n  if (glob) {\n    return minimatch(path, glob);\n  }\n\n  if (regex) {\n    const pattern = RE2 ? new RE2(regex, \"u\") : new RegExp(regex, \"u\");\n    return path.match(pattern) !== null;\n  }\n\n  return false;\n}\n/**\n * Creates either an RE2 or a Javascript RegExp from a provided string\n * pattern, depending on whether or not the RE2 library is available as an\n * import.\n *\n * @param {string} pattern A regular expression pattern to test against.\n * @return {regexp} A regular expression object, created by either base\n *                  RegExp or RE2, which matches the RegExp prototype\n */\n\n\nfunction createRaw(pattern) {\n  return RE2 ? new RE2(pattern, \"u\") : new RegExp(pattern, \"u\");\n}\n/**\n * Returns true if RE2, which is an optional dependency, has been loaded.\n * @return {boolean}\n */\n\n\nfunction re2Available() {\n  return RE2 ? true : false;\n}\n/**\n * Is truthy if the provided raw string pattern contains a RE2 named capture\n * group opening, ?P<, which is not interpretable when Superstatic is falling\n * back on the base Javascript RegExp implementation.\n * @param {string} pattern\n * @return {boolean}\n */\n\n\nfunction containsRE2Capture(pattern) {\n  return pattern && pattern.includes(\"?P<\");\n}\n/**\n * Is truthy if the provided raw string pattern contains a PCRE named capture\n * group opening, ?<, which is not interpretable when Superstatic has loaded\n * the RE2 bindings.\n * @param {string} pattern\n * @return {boolean}\n */\n\n\nfunction containsPCRECapture(pattern) {\n  return pattern && pattern.includes(\"?<\");\n}\n\nmodule.exports = {\n  configMatcher: configMatcher,\n  createRaw: createRaw,\n  re2Available: re2Available,\n  containsRE2Capture: containsRE2Capture,\n  containsPCRECapture: containsPCRECapture\n};","map":{"version":3,"sources":["/home/dev/Documentos/Projects/github-clone/node_modules/superstatic/lib/utils/patterns.js"],"names":["RE2","minimatch","require","er","configMatcher","path","config","glob","source","regex","pattern","RegExp","match","createRaw","re2Available","containsRE2Capture","includes","containsPCRECapture","module","exports"],"mappings":"AAAA,IAAIA,GAAJ;;AACA,MAAMC,SAAS,GAAGC,OAAO,CAAC,WAAD,CAAzB;;AACA,IAAI;AACFF,EAAAA,GAAG,GAAGE,OAAO,CAAC,KAAD,CAAb;AACD,CAFD,CAEE,OAAOC,EAAP,EAAW;AACXH,EAAAA,GAAG,GAAG,IAAN;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASI,aAAT,CAAuBC,IAAvB,EAA6BC,MAA7B,EAAqC;AACnC,QAAMC,IAAI,GAAGD,MAAM,CAACC,IAAP,IAAeD,MAAM,CAACE,MAAnC;AACA,QAAMC,KAAK,GAAGH,MAAM,CAACG,KAArB;;AACA,MAAIF,IAAJ,EAAU;AACR,WAAON,SAAS,CAACI,IAAD,EAAOE,IAAP,CAAhB;AACD;;AACD,MAAIE,KAAJ,EAAW;AACT,UAAMC,OAAO,GAAGV,GAAG,GAAG,IAAIA,GAAJ,CAAQS,KAAR,EAAe,GAAf,CAAH,GAAyB,IAAIE,MAAJ,CAAWF,KAAX,EAAkB,GAAlB,CAA5C;AACA,WAAOJ,IAAI,CAACO,KAAL,CAAWF,OAAX,MAAwB,IAA/B;AACD;;AACD,SAAO,KAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASG,SAAT,CAAmBH,OAAnB,EAA4B;AAC1B,SAAOV,GAAG,GAAG,IAAIA,GAAJ,CAAQU,OAAR,EAAiB,GAAjB,CAAH,GAA2B,IAAIC,MAAJ,CAAWD,OAAX,EAAoB,GAApB,CAArC;AACD;AAED;AACA;AACA;AACA;;;AACA,SAASI,YAAT,GAAwB;AACtB,SAAOd,GAAG,GAAG,IAAH,GAAU,KAApB;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASe,kBAAT,CAA4BL,OAA5B,EAAqC;AACnC,SAAOA,OAAO,IAAIA,OAAO,CAACM,QAAR,CAAiB,KAAjB,CAAlB;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,mBAAT,CAA6BP,OAA7B,EAAsC;AACpC,SAAOA,OAAO,IAAIA,OAAO,CAACM,QAAR,CAAiB,IAAjB,CAAlB;AACD;;AAEDE,MAAM,CAACC,OAAP,GAAiB;AACff,EAAAA,aAAa,EAAEA,aADA;AAEfS,EAAAA,SAAS,EAAEA,SAFI;AAGfC,EAAAA,YAAY,EAAEA,YAHC;AAIfC,EAAAA,kBAAkB,EAAEA,kBAJL;AAKfE,EAAAA,mBAAmB,EAAEA;AALN,CAAjB","sourcesContent":["let RE2;\nconst minimatch = require(\"minimatch\");\ntry {\n  RE2 = require(\"re2\");\n} catch (er) {\n  RE2 = null;\n}\n\n/**\n * Evaluates whether a configured redirect/rewrite/custom header should\n * be applied to a request against a specific path. All three features\n * are configured with a hash that contains either a Node-like glob path\n * specification as its `source` or `glob` field, or a RE2 regular\n * expression as its `regex` field.\n *\n * Since Javascript lacks a native library for RE2, Superstatic uses the C\n * bindings as an optional dependency, and falls over to PCRE if the import\n * is unavailable. Under most circumstances not involving named capturing\n * groups, the two libraries should have identical behavior.\n *\n * No special consideration is taken if the configuration hash contains both\n * a glob and a regex. normalizeConfig() will error in that case.\n *\n * @param {string} path The URL path from the request.\n * @param {Object} config A dictionary from a sanitized JSON configuration.\n * @return {boolean} Whether the config should be applied to the request.\n */\nfunction configMatcher(path, config) {\n  const glob = config.glob || config.source;\n  const regex = config.regex;\n  if (glob) {\n    return minimatch(path, glob);\n  }\n  if (regex) {\n    const pattern = RE2 ? new RE2(regex, \"u\") : new RegExp(regex, \"u\");\n    return path.match(pattern) !== null;\n  }\n  return false;\n}\n\n/**\n * Creates either an RE2 or a Javascript RegExp from a provided string\n * pattern, depending on whether or not the RE2 library is available as an\n * import.\n *\n * @param {string} pattern A regular expression pattern to test against.\n * @return {regexp} A regular expression object, created by either base\n *                  RegExp or RE2, which matches the RegExp prototype\n */\nfunction createRaw(pattern) {\n  return RE2 ? new RE2(pattern, \"u\") : new RegExp(pattern, \"u\");\n}\n\n/**\n * Returns true if RE2, which is an optional dependency, has been loaded.\n * @return {boolean}\n */\nfunction re2Available() {\n  return RE2 ? true : false;\n}\n\n/**\n * Is truthy if the provided raw string pattern contains a RE2 named capture\n * group opening, ?P<, which is not interpretable when Superstatic is falling\n * back on the base Javascript RegExp implementation.\n * @param {string} pattern\n * @return {boolean}\n */\nfunction containsRE2Capture(pattern) {\n  return pattern && pattern.includes(\"?P<\");\n}\n\n/**\n * Is truthy if the provided raw string pattern contains a PCRE named capture\n * group opening, ?<, which is not interpretable when Superstatic has loaded\n * the RE2 bindings.\n * @param {string} pattern\n * @return {boolean}\n */\nfunction containsPCRECapture(pattern) {\n  return pattern && pattern.includes(\"?<\");\n}\n\nmodule.exports = {\n  configMatcher: configMatcher,\n  createRaw: createRaw,\n  re2Available: re2Available,\n  containsRE2Capture: containsRE2Capture,\n  containsPCRECapture: containsPCRECapture\n};\n"]},"metadata":{},"sourceType":"script"}