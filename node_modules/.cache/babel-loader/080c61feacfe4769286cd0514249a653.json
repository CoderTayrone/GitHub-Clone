{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst json_schema_resolve_ref_1 = require(\"./json-schema-resolve-ref\");\n\nconst VALID_SCHEMA_TYPES = ['null', 'boolean', 'object', 'array', 'number', 'string', 'integer'];\nconst ALL_ALLOWED_TYPES = new Set(VALID_SCHEMA_TYPES);\nconst NO_ALLOWED_TYPES = new Set([]);\n\nfunction getType(val) {\n  if (val === null || val === undefined) {\n    return 'null';\n  } else if (typeof val === 'string') {\n    return 'string';\n  } else if (val === true || val === false) {\n    return 'boolean';\n  } else if (Array.isArray(val)) {\n    return 'array';\n  } else if (Number.isInteger(val)) {\n    return 'integer';\n  } else if (typeof val === 'number' && !isNaN(val)) {\n    return 'number';\n  } else if (typeof val === 'object') {\n    return 'object';\n  } else {\n    throw new Error(`Can't work out JSON-Schema type of ${val}`);\n  }\n}\n\nfunction toArray(val) {\n  if (Array.isArray(val)) {\n    return val;\n  } else {\n    return [val];\n  }\n}\n\nfunction union(a, b) {\n  return new Set([...a, ...b]);\n}\n\nfunction intersection(a, b) {\n  return new Set([...a].filter(x => b.has(x)));\n}\n\nfunction inferTypesOneOf(rootSchema, oneOf, stack) {\n  if (oneOf.length === 0) {\n    return ALL_ALLOWED_TYPES;\n  }\n\n  let allowedTypes = NO_ALLOWED_TYPES;\n  oneOf.forEach(childSchema => {\n    childSchema = json_schema_resolve_ref_1.resolveRef(rootSchema, childSchema);\n    const types = inferTypesPriv(rootSchema, childSchema, stack);\n    allowedTypes = union(allowedTypes, types);\n  });\n  return allowedTypes;\n}\n\nfunction inferTypesPriv(rootSchema, schema, stack) {\n  if (stack.includes(schema)) {\n    throw new Error('circular definition found');\n  } else {\n    stack = stack.concat(schema);\n  }\n\n  let allowedTypes = ALL_ALLOWED_TYPES;\n  allowedTypes = intersection(allowedTypes, inferTypesOneOf(rootSchema, schema.oneOf || [], stack));\n  allowedTypes = intersection(allowedTypes, inferTypesOneOf(rootSchema, schema.anyOf || [], stack));\n\n  if (schema.type) {\n    allowedTypes = intersection(allowedTypes, new Set(toArray(schema.type)));\n  }\n\n  if (schema.allOf) {\n    for (const childSchemaRef of schema.allOf) {\n      const childSchema = json_schema_resolve_ref_1.resolveRef(rootSchema, childSchemaRef);\n      const types = inferTypesPriv(rootSchema, childSchema, stack);\n      allowedTypes = intersection(allowedTypes, types);\n    }\n  } // TODO: Dealing with \"not\" is hard.\n\n\n  if ('const' in schema) {\n    const schemaConst = schema.const;\n    const constType = new Set([getType(schemaConst)]);\n    allowedTypes = intersection(allowedTypes, constType);\n  }\n\n  if (schema.enum) {\n    const enumTypes = new Set(schema.enum.map(getType));\n    allowedTypes = intersection(allowedTypes, enumTypes);\n  }\n\n  return allowedTypes;\n}\n/**\n * Given a JSON Schema, returns a list of types that an object which passes\n * schema validation would be allowed to have.\n *\n * @param schema - A JSON schema.  This is allowed to have `$ref`s, but they\n *   must be internal refs relative to the schema (or to the `rootDocument`\n *   if it is specified).\n * @param [options.rootDocument] - If your JSON schema is embedded in a larger\n *   JSON document, it can be provided here to resolve `$ref`s relative to that\n *   parent document.\n */\n\n\nfunction inferTypes(schema, options = {}) {\n  let result = inferTypesPriv(options.rootDocument || schema, schema, []); // Number includes integer, so if number is set, then integer needs to be as well.\n\n  if (result.has('number')) {\n    result = new Set(result);\n    result.add('integer');\n  }\n\n  return Array.from(result);\n}\n\nexports.default = inferTypes;","map":{"version":3,"sources":["../../src/utils/json-schema-infer-types.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst json_schema_resolve_ref_1 = require(\"./json-schema-resolve-ref\");\nconst VALID_SCHEMA_TYPES = ['null', 'boolean', 'object', 'array', 'number', 'string', 'integer'];\nconst ALL_ALLOWED_TYPES = new Set(VALID_SCHEMA_TYPES);\nconst NO_ALLOWED_TYPES = new Set([]);\nfunction getType(val) {\n    if (val === null || val === undefined) {\n        return 'null';\n    }\n    else if (typeof val === 'string') {\n        return 'string';\n    }\n    else if (val === true || val === false) {\n        return 'boolean';\n    }\n    else if (Array.isArray(val)) {\n        return 'array';\n    }\n    else if (Number.isInteger(val)) {\n        return 'integer';\n    }\n    else if (typeof val === 'number' && !isNaN(val)) {\n        return 'number';\n    }\n    else if (typeof val === 'object') {\n        return 'object';\n    }\n    else {\n        throw new Error(`Can't work out JSON-Schema type of ${val}`);\n    }\n}\nfunction toArray(val) {\n    if (Array.isArray(val)) {\n        return val;\n    }\n    else {\n        return [val];\n    }\n}\nfunction union(a, b) {\n    return new Set([...a, ...b]);\n}\nfunction intersection(a, b) {\n    return new Set([...a].filter((x) => b.has(x)));\n}\nfunction inferTypesOneOf(rootSchema, oneOf, stack) {\n    if (oneOf.length === 0) {\n        return ALL_ALLOWED_TYPES;\n    }\n    let allowedTypes = NO_ALLOWED_TYPES;\n    oneOf.forEach((childSchema) => {\n        childSchema = json_schema_resolve_ref_1.resolveRef(rootSchema, childSchema);\n        const types = inferTypesPriv(rootSchema, childSchema, stack);\n        allowedTypes = union(allowedTypes, types);\n    });\n    return allowedTypes;\n}\nfunction inferTypesPriv(rootSchema, schema, stack) {\n    if (stack.includes(schema)) {\n        throw new Error('circular definition found');\n    }\n    else {\n        stack = stack.concat(schema);\n    }\n    let allowedTypes = ALL_ALLOWED_TYPES;\n    allowedTypes = intersection(allowedTypes, inferTypesOneOf(rootSchema, schema.oneOf || [], stack));\n    allowedTypes = intersection(allowedTypes, inferTypesOneOf(rootSchema, schema.anyOf || [], stack));\n    if (schema.type) {\n        allowedTypes = intersection(allowedTypes, new Set(toArray(schema.type)));\n    }\n    if (schema.allOf) {\n        for (const childSchemaRef of schema.allOf) {\n            const childSchema = json_schema_resolve_ref_1.resolveRef(rootSchema, childSchemaRef);\n            const types = inferTypesPriv(rootSchema, childSchema, stack);\n            allowedTypes = intersection(allowedTypes, types);\n        }\n    }\n    // TODO: Dealing with \"not\" is hard.\n    if ('const' in schema) {\n        const schemaConst = schema.const;\n        const constType = new Set([getType(schemaConst)]);\n        allowedTypes = intersection(allowedTypes, constType);\n    }\n    if (schema.enum) {\n        const enumTypes = new Set(schema.enum.map(getType));\n        allowedTypes = intersection(allowedTypes, enumTypes);\n    }\n    return allowedTypes;\n}\n/**\n * Given a JSON Schema, returns a list of types that an object which passes\n * schema validation would be allowed to have.\n *\n * @param schema - A JSON schema.  This is allowed to have `$ref`s, but they\n *   must be internal refs relative to the schema (or to the `rootDocument`\n *   if it is specified).\n * @param [options.rootDocument] - If your JSON schema is embedded in a larger\n *   JSON document, it can be provided here to resolve `$ref`s relative to that\n *   parent document.\n */\nfunction inferTypes(schema, options = {}) {\n    let result = inferTypesPriv(options.rootDocument || schema, schema, []);\n    // Number includes integer, so if number is set, then integer needs to be as well.\n    if (result.has('number')) {\n        result = new Set(result);\n        result.add('integer');\n    }\n    return Array.from(result);\n}\nexports.default = inferTypes;\n//# sourceMappingURL=json-schema-infer-types.js.map"]},"metadata":{},"sourceType":"script"}