{"ast":null,"code":"// RTFM: http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf\nvar Uni = require('./unicode');\n\nfunction isHexDigit(x) {\n  return x >= '0' && x <= '9' || x >= 'A' && x <= 'F' || x >= 'a' && x <= 'f';\n}\n\nfunction isOctDigit(x) {\n  return x >= '0' && x <= '7';\n}\n\nfunction isDecDigit(x) {\n  return x >= '0' && x <= '9';\n}\n\nvar unescapeMap = {\n  '\\'': '\\'',\n  '\"': '\"',\n  '\\\\': '\\\\',\n  'b': '\\b',\n  'f': '\\f',\n  'n': '\\n',\n  'r': '\\r',\n  't': '\\t',\n  'v': '\\v',\n  '/': '/'\n};\n\nfunction formatError(input, msg, position, lineno, column, json5) {\n  var result = msg + ' at ' + (lineno + 1) + ':' + (column + 1),\n      tmppos = position - column - 1,\n      srcline = '',\n      underline = '';\n  var isLineTerminator = json5 ? Uni.isLineTerminator : Uni.isLineTerminatorJSON; // output no more than 70 characters before the wrong ones\n\n  if (tmppos < position - 70) {\n    tmppos = position - 70;\n  }\n\n  while (1) {\n    var chr = input[++tmppos];\n\n    if (isLineTerminator(chr) || tmppos === input.length) {\n      if (position >= tmppos) {\n        // ending line error, so show it after the last char\n        underline += '^';\n      }\n\n      break;\n    }\n\n    srcline += chr;\n\n    if (position === tmppos) {\n      underline += '^';\n    } else if (position > tmppos) {\n      underline += input[tmppos] === '\\t' ? '\\t' : ' ';\n    } // output no more than 78 characters on the string\n\n\n    if (srcline.length > 78) break;\n  }\n\n  return result + '\\n' + srcline + '\\n' + underline;\n}\n\nfunction parse(input, options) {\n  // parse as a standard JSON mode\n  var json5 = false;\n  var cjson = false;\n\n  if (options.legacy || options.mode === 'json') {// use json\n  } else if (options.mode === 'cjson') {\n    cjson = true;\n  } else if (options.mode === 'json5') {\n    json5 = true;\n  } else {\n    // use it by default\n    json5 = true;\n  }\n\n  var isLineTerminator = json5 ? Uni.isLineTerminator : Uni.isLineTerminatorJSON;\n  var isWhiteSpace = json5 ? Uni.isWhiteSpace : Uni.isWhiteSpaceJSON;\n  var length = input.length,\n      lineno = 0,\n      linestart = 0,\n      position = 0,\n      stack = [];\n\n  var tokenStart = function () {};\n\n  var tokenEnd = function (v) {\n    return v;\n  };\n  /* tokenize({\n       raw: '...',\n       type: 'whitespace'|'comment'|'key'|'literal'|'separator'|'newline',\n       value: 'number'|'string'|'whatever',\n       path: [...],\n     })\n  */\n\n\n  if (options._tokenize) {\n    ;\n\n    (function () {\n      var start = null;\n\n      tokenStart = function () {\n        if (start !== null) throw Error('internal error, token overlap');\n        start = position;\n      };\n\n      tokenEnd = function (v, type) {\n        if (start != position) {\n          var hash = {\n            raw: input.substr(start, position - start),\n            type: type,\n            stack: stack.slice(0)\n          };\n          if (v !== undefined) hash.value = v;\n\n          options._tokenize.call(null, hash);\n        }\n\n        start = null;\n        return v;\n      };\n    })();\n  }\n\n  function fail(msg) {\n    var column = position - linestart;\n\n    if (!msg) {\n      if (position < length) {\n        var token = '\\'' + JSON.stringify(input[position]).replace(/^\"|\"$/g, '').replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"') + '\\'';\n        if (!msg) msg = 'Unexpected token ' + token;\n      } else {\n        if (!msg) msg = 'Unexpected end of input';\n      }\n    }\n\n    var error = SyntaxError(formatError(input, msg, position, lineno, column, json5));\n    error.row = lineno + 1;\n    error.column = column + 1;\n    throw error;\n  }\n\n  function newline(chr) {\n    // account for <cr><lf>\n    if (chr === '\\r' && input[position] === '\\n') position++;\n    linestart = position;\n    lineno++;\n  }\n\n  function parseGeneric() {\n    var result;\n\n    while (position < length) {\n      tokenStart();\n      var chr = input[position++];\n\n      if (chr === '\"' || chr === '\\'' && json5) {\n        return tokenEnd(parseString(chr), 'literal');\n      } else if (chr === '{') {\n        tokenEnd(undefined, 'separator');\n        return parseObject();\n      } else if (chr === '[') {\n        tokenEnd(undefined, 'separator');\n        return parseArray();\n      } else if (chr === '-' || chr === '.' || isDecDigit(chr) //           + number       Infinity          NaN\n      || json5 && (chr === '+' || chr === 'I' || chr === 'N')) {\n        return tokenEnd(parseNumber(), 'literal');\n      } else if (chr === 'n') {\n        parseKeyword('null');\n        return tokenEnd(null, 'literal');\n      } else if (chr === 't') {\n        parseKeyword('true');\n        return tokenEnd(true, 'literal');\n      } else if (chr === 'f') {\n        parseKeyword('false');\n        return tokenEnd(false, 'literal');\n      } else {\n        position--;\n        return tokenEnd(undefined);\n      }\n    }\n  }\n\n  function parseKey() {\n    var result;\n\n    while (position < length) {\n      tokenStart();\n      var chr = input[position++];\n\n      if (chr === '\"' || chr === '\\'' && json5) {\n        return tokenEnd(parseString(chr), 'key');\n      } else if (chr === '{') {\n        tokenEnd(undefined, 'separator');\n        return parseObject();\n      } else if (chr === '[') {\n        tokenEnd(undefined, 'separator');\n        return parseArray();\n      } else if (chr === '.' || isDecDigit(chr)) {\n        return tokenEnd(parseNumber(true), 'key');\n      } else if (json5 && Uni.isIdentifierStart(chr) || chr === '\\\\' && input[position] === 'u') {\n        // unicode char or a unicode sequence\n        var rollback = position - 1;\n        var result = parseIdentifier();\n\n        if (result === undefined) {\n          position = rollback;\n          return tokenEnd(undefined);\n        } else {\n          return tokenEnd(result, 'key');\n        }\n      } else {\n        position--;\n        return tokenEnd(undefined);\n      }\n    }\n  }\n\n  function skipWhiteSpace() {\n    tokenStart();\n\n    while (position < length) {\n      var chr = input[position++];\n\n      if (isLineTerminator(chr)) {\n        position--;\n        tokenEnd(undefined, 'whitespace');\n        tokenStart();\n        position++;\n        newline(chr);\n        tokenEnd(undefined, 'newline');\n        tokenStart();\n      } else if (isWhiteSpace(chr)) {// nothing\n      } else if (chr === '/' && (json5 || cjson) && (input[position] === '/' || input[position] === '*')) {\n        position--;\n        tokenEnd(undefined, 'whitespace');\n        tokenStart();\n        position++;\n        skipComment(input[position++] === '*');\n        tokenEnd(undefined, 'comment');\n        tokenStart();\n      } else {\n        position--;\n        break;\n      }\n    }\n\n    return tokenEnd(undefined, 'whitespace');\n  }\n\n  function skipComment(multi) {\n    while (position < length) {\n      var chr = input[position++];\n\n      if (isLineTerminator(chr)) {\n        // LineTerminator is an end of singleline comment\n        if (!multi) {\n          // let parent function deal with newline\n          position--;\n          return;\n        }\n\n        newline(chr);\n      } else if (chr === '*' && multi) {\n        // end of multiline comment\n        if (input[position] === '/') {\n          position++;\n          return;\n        }\n      } else {// nothing\n      }\n    }\n\n    if (multi) {\n      fail('Unclosed multiline comment');\n    }\n  }\n\n  function parseKeyword(keyword) {\n    // keyword[0] is not checked because it should've checked earlier\n    var _pos = position;\n    var len = keyword.length;\n\n    for (var i = 1; i < len; i++) {\n      if (position >= length || keyword[i] != input[position]) {\n        position = _pos - 1;\n        fail();\n      }\n\n      position++;\n    }\n  }\n\n  function parseObject() {\n    var result = options.null_prototype ? Object.create(null) : {},\n        empty_object = {},\n        is_non_empty = false;\n\n    while (position < length) {\n      skipWhiteSpace();\n      var item1 = parseKey();\n      skipWhiteSpace();\n      tokenStart();\n      var chr = input[position++];\n      tokenEnd(undefined, 'separator');\n\n      if (chr === '}' && item1 === undefined) {\n        if (!json5 && is_non_empty) {\n          position--;\n          fail('Trailing comma in object');\n        }\n\n        return result;\n      } else if (chr === ':' && item1 !== undefined) {\n        skipWhiteSpace();\n        stack.push(item1);\n        var item2 = parseGeneric();\n        stack.pop();\n        if (item2 === undefined) fail('No value found for key ' + item1);\n\n        if (typeof item1 !== 'string') {\n          if (!json5 || typeof item1 !== 'number') {\n            fail('Wrong key type: ' + item1);\n          }\n        }\n\n        if ((item1 in empty_object || empty_object[item1] != null) && options.reserved_keys !== 'replace') {\n          if (options.reserved_keys === 'throw') {\n            fail('Reserved key: ' + item1);\n          } else {// silently ignore it\n          }\n        } else {\n          if (typeof options.reviver === 'function') {\n            item2 = options.reviver.call(null, item1, item2);\n          }\n\n          if (item2 !== undefined) {\n            is_non_empty = true;\n            Object.defineProperty(result, item1, {\n              value: item2,\n              enumerable: true,\n              configurable: true,\n              writable: true\n            });\n          }\n        }\n\n        skipWhiteSpace();\n        tokenStart();\n        var chr = input[position++];\n        tokenEnd(undefined, 'separator');\n\n        if (chr === ',') {\n          continue;\n        } else if (chr === '}') {\n          return result;\n        } else {\n          fail();\n        }\n      } else {\n        position--;\n        fail();\n      }\n    }\n\n    fail();\n  }\n\n  function parseArray() {\n    var result = [];\n\n    while (position < length) {\n      skipWhiteSpace();\n      stack.push(result.length);\n      var item = parseGeneric();\n      stack.pop();\n      skipWhiteSpace();\n      tokenStart();\n      var chr = input[position++];\n      tokenEnd(undefined, 'separator');\n\n      if (item !== undefined) {\n        if (typeof options.reviver === 'function') {\n          item = options.reviver.call(null, String(result.length), item);\n        }\n\n        if (item === undefined) {\n          result.length++;\n          item = true; // hack for check below, not included into result\n        } else {\n          result.push(item);\n        }\n      }\n\n      if (chr === ',') {\n        if (item === undefined) {\n          fail('Elisions are not supported');\n        }\n      } else if (chr === ']') {\n        if (!json5 && item === undefined && result.length) {\n          position--;\n          fail('Trailing comma in array');\n        }\n\n        return result;\n      } else {\n        position--;\n        fail();\n      }\n    }\n  }\n\n  function parseNumber() {\n    // rewind because we don't know first char\n    position--;\n    var start = position,\n        chr = input[position++],\n        t;\n\n    var to_num = function (is_octal) {\n      var str = input.substr(start, position - start);\n\n      if (is_octal) {\n        var result = parseInt(str.replace(/^0o?/, ''), 8);\n      } else {\n        var result = Number(str);\n      }\n\n      if (Number.isNaN(result)) {\n        position--;\n        fail('Bad numeric literal - \"' + input.substr(start, position - start + 1) + '\"');\n      } else if (!json5 && !str.match(/^-?(0|[1-9][0-9]*)(\\.[0-9]+)?(e[+-]?[0-9]+)?$/i)) {\n        // additional restrictions imposed by json\n        position--;\n        fail('Non-json numeric literal - \"' + input.substr(start, position - start + 1) + '\"');\n      } else {\n        return result;\n      }\n    }; // ex: -5982475.249875e+29384\n    //     ^ skipping this\n\n\n    if (chr === '-' || chr === '+' && json5) chr = input[position++];\n\n    if (chr === 'N' && json5) {\n      parseKeyword('NaN');\n      return NaN;\n    }\n\n    if (chr === 'I' && json5) {\n      parseKeyword('Infinity'); // returning +inf or -inf\n\n      return to_num();\n    }\n\n    if (chr >= '1' && chr <= '9') {\n      // ex: -5982475.249875e+29384\n      //        ^^^ skipping these\n      while (position < length && isDecDigit(input[position])) position++;\n\n      chr = input[position++];\n    } // special case for leading zero: 0.123456\n\n\n    if (chr === '0') {\n      chr = input[position++]; //             new syntax, \"0o777\"           old syntax, \"0777\"\n\n      var is_octal = chr === 'o' || chr === 'O' || isOctDigit(chr);\n      var is_hex = chr === 'x' || chr === 'X';\n\n      if (json5 && (is_octal || is_hex)) {\n        while (position < length && (is_hex ? isHexDigit : isOctDigit)(input[position])) position++;\n\n        var sign = 1;\n\n        if (input[start] === '-') {\n          sign = -1;\n          start++;\n        } else if (input[start] === '+') {\n          start++;\n        }\n\n        return sign * to_num(is_octal);\n      }\n    }\n\n    if (chr === '.') {\n      // ex: -5982475.249875e+29384\n      //                ^^^ skipping these\n      while (position < length && isDecDigit(input[position])) position++;\n\n      chr = input[position++];\n    }\n\n    if (chr === 'e' || chr === 'E') {\n      chr = input[position++];\n      if (chr === '-' || chr === '+') position++; // ex: -5982475.249875e+29384\n      //                       ^^^ skipping these\n\n      while (position < length && isDecDigit(input[position])) position++;\n\n      chr = input[position++];\n    } // we have char in the buffer, so count for it\n\n\n    position--;\n    return to_num();\n  }\n\n  function parseIdentifier() {\n    // rewind because we don't know first char\n    position--;\n    var result = '';\n\n    while (position < length) {\n      var chr = input[position++];\n\n      if (chr === '\\\\' && input[position] === 'u' && isHexDigit(input[position + 1]) && isHexDigit(input[position + 2]) && isHexDigit(input[position + 3]) && isHexDigit(input[position + 4])) {\n        // UnicodeEscapeSequence\n        chr = String.fromCharCode(parseInt(input.substr(position + 1, 4), 16));\n        position += 5;\n      }\n\n      if (result.length) {\n        // identifier started\n        if (Uni.isIdentifierPart(chr)) {\n          result += chr;\n        } else {\n          position--;\n          return result;\n        }\n      } else {\n        if (Uni.isIdentifierStart(chr)) {\n          result += chr;\n        } else {\n          return undefined;\n        }\n      }\n    }\n\n    fail();\n  }\n\n  function parseString(endChar) {\n    // 7.8.4 of ES262 spec\n    var result = '';\n\n    while (position < length) {\n      var chr = input[position++];\n\n      if (chr === endChar) {\n        return result;\n      } else if (chr === '\\\\') {\n        if (position >= length) fail();\n        chr = input[position++];\n\n        if (unescapeMap[chr] && (json5 || chr != 'v' && chr != \"'\")) {\n          result += unescapeMap[chr];\n        } else if (json5 && isLineTerminator(chr)) {\n          // line continuation\n          newline(chr);\n        } else if (chr === 'u' || chr === 'x' && json5) {\n          // unicode/character escape sequence\n          var off = chr === 'u' ? 4 : 2; // validation for \\uXXXX\n\n          for (var i = 0; i < off; i++) {\n            if (position >= length) fail();\n            if (!isHexDigit(input[position])) fail('Bad escape sequence');\n            position++;\n          }\n\n          result += String.fromCharCode(parseInt(input.substr(position - off, off), 16));\n        } else if (json5 && isOctDigit(chr)) {\n          if (chr < '4' && isOctDigit(input[position]) && isOctDigit(input[position + 1])) {\n            // three-digit octal\n            var digits = 3;\n          } else if (isOctDigit(input[position])) {\n            // two-digit octal\n            var digits = 2;\n          } else {\n            var digits = 1;\n          }\n\n          position += digits - 1;\n          result += String.fromCharCode(parseInt(input.substr(position - digits, digits), 8));\n          /*if (!isOctDigit(input[position])) {\n            // \\0 is allowed still\n            result += '\\0'\n          } else {\n            fail('Octal literals are not supported')\n          }*/\n        } else if (json5) {\n          // \\X -> x\n          result += chr;\n        } else {\n          position--;\n          fail();\n        }\n      } else if (isLineTerminator(chr)) {\n        fail();\n      } else {\n        if (!json5 && chr.charCodeAt(0) < 32) {\n          position--;\n          fail('Unexpected control character');\n        } // SourceCharacter but not one of \" or \\ or LineTerminator\n\n\n        result += chr;\n      }\n    }\n\n    fail();\n  }\n\n  skipWhiteSpace();\n  var return_value = parseGeneric();\n\n  if (return_value !== undefined || position < length) {\n    skipWhiteSpace();\n\n    if (position >= length) {\n      if (typeof options.reviver === 'function') {\n        return_value = options.reviver.call(null, '', return_value);\n      }\n\n      return return_value;\n    } else {\n      fail();\n    }\n  } else {\n    if (position) {\n      fail('No data, only a whitespace');\n    } else {\n      fail('No data, empty input');\n    }\n  }\n}\n/*\n * parse(text, options)\n * or\n * parse(text, reviver)\n *\n * where:\n * text - string\n * options - object\n * reviver - function\n */\n\n\nmodule.exports.parse = function parseJSON(input, options) {\n  // support legacy functions\n  if (typeof options === 'function') {\n    options = {\n      reviver: options\n    };\n  }\n\n  if (input === undefined) {\n    // parse(stringify(x)) should be equal x\n    // with JSON functions it is not 'cause of undefined\n    // so we're fixing it\n    return undefined;\n  } // JSON.parse compat\n\n\n  if (typeof input !== 'string') input = String(input);\n  if (options == null) options = {};\n  if (options.reserved_keys == null) options.reserved_keys = 'ignore';\n\n  if (options.reserved_keys === 'throw' || options.reserved_keys === 'ignore') {\n    if (options.null_prototype == null) {\n      options.null_prototype = true;\n    }\n  }\n\n  try {\n    return parse(input, options);\n  } catch (err) {\n    // jju is a recursive parser, so JSON.parse(\"{{{{{{{\") could blow up the stack\n    //\n    // this catch is used to skip all those internal calls\n    if (err instanceof SyntaxError && err.row != null && err.column != null) {\n      var old_err = err;\n      err = SyntaxError(old_err.message);\n      err.column = old_err.column;\n      err.row = old_err.row;\n    }\n\n    throw err;\n  }\n};\n\nmodule.exports.tokenize = function tokenizeJSON(input, options) {\n  if (options == null) options = {};\n\n  options._tokenize = function (smth) {\n    if (options._addstack) smth.stack.unshift.apply(smth.stack, options._addstack);\n    tokens.push(smth);\n  };\n\n  var tokens = [];\n  tokens.data = module.exports.parse(input, options);\n  return tokens;\n};","map":{"version":3,"sources":["/home/dev/Documentos/Projects/github-clone/node_modules/jju/lib/parse.js"],"names":["Uni","require","isHexDigit","x","isOctDigit","isDecDigit","unescapeMap","formatError","input","msg","position","lineno","column","json5","result","tmppos","srcline","underline","isLineTerminator","isLineTerminatorJSON","chr","length","parse","options","cjson","legacy","mode","isWhiteSpace","isWhiteSpaceJSON","linestart","stack","tokenStart","tokenEnd","v","_tokenize","start","Error","type","hash","raw","substr","slice","undefined","value","call","fail","token","JSON","stringify","replace","error","SyntaxError","row","newline","parseGeneric","parseString","parseObject","parseArray","parseNumber","parseKeyword","parseKey","isIdentifierStart","rollback","parseIdentifier","skipWhiteSpace","skipComment","multi","keyword","_pos","len","i","null_prototype","Object","create","empty_object","is_non_empty","item1","push","item2","pop","reserved_keys","reviver","defineProperty","enumerable","configurable","writable","item","String","t","to_num","is_octal","str","parseInt","Number","isNaN","match","NaN","is_hex","sign","fromCharCode","isIdentifierPart","endChar","off","digits","charCodeAt","return_value","module","exports","parseJSON","err","old_err","message","tokenize","tokenizeJSON","smth","_addstack","unshift","apply","tokens","data"],"mappings":"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","sourcesContent":["\n// RTFM: http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf\n\nvar Uni = require('./unicode')\n\nfunction isHexDigit(x) {\n  return (x >= '0' && x <= '9')\n      || (x >= 'A' && x <= 'F')\n      || (x >= 'a' && x <= 'f')\n}\n\nfunction isOctDigit(x) {\n  return x >= '0' && x <= '7'\n}\n\nfunction isDecDigit(x) {\n  return x >= '0' && x <= '9'\n}\n\nvar unescapeMap = {\n  '\\'': '\\'',\n  '\"' : '\"',\n  '\\\\': '\\\\',\n  'b' : '\\b',\n  'f' : '\\f',\n  'n' : '\\n',\n  'r' : '\\r',\n  't' : '\\t',\n  'v' : '\\v',\n  '/' : '/',\n}\n\nfunction formatError(input, msg, position, lineno, column, json5) {\n  var result = msg + ' at ' + (lineno + 1) + ':' + (column + 1)\n    , tmppos = position - column - 1\n    , srcline = ''\n    , underline = ''\n\n  var isLineTerminator = json5 ? Uni.isLineTerminator : Uni.isLineTerminatorJSON\n\n  // output no more than 70 characters before the wrong ones\n  if (tmppos < position - 70) {\n    tmppos = position - 70\n  }\n\n  while (1) {\n    var chr = input[++tmppos]\n\n    if (isLineTerminator(chr) || tmppos === input.length) {\n      if (position >= tmppos) {\n        // ending line error, so show it after the last char\n        underline += '^'\n      }\n      break\n    }\n    srcline += chr\n\n    if (position === tmppos) {\n      underline += '^'\n    } else if (position > tmppos) {\n      underline += input[tmppos] === '\\t' ? '\\t' : ' '\n    }\n\n    // output no more than 78 characters on the string\n    if (srcline.length > 78) break\n  }\n\n  return result + '\\n' + srcline + '\\n' + underline\n}\n\nfunction parse(input, options) {\n  // parse as a standard JSON mode\n  var json5 = false\n  var cjson = false\n\n  if (options.legacy || options.mode === 'json') {\n    // use json\n  } else if (options.mode === 'cjson') {\n    cjson = true\n  } else if (options.mode === 'json5') {\n    json5 = true\n  } else {\n    // use it by default\n    json5 = true\n  }\n\n  var isLineTerminator = json5 ? Uni.isLineTerminator : Uni.isLineTerminatorJSON\n  var isWhiteSpace     = json5 ? Uni.isWhiteSpace     : Uni.isWhiteSpaceJSON\n\n  var length = input.length\n    , lineno = 0\n    , linestart = 0\n    , position = 0\n    , stack = []\n\n  var tokenStart = function() {}\n  var tokenEnd = function(v) {return v}\n\n  /* tokenize({\n       raw: '...',\n       type: 'whitespace'|'comment'|'key'|'literal'|'separator'|'newline',\n       value: 'number'|'string'|'whatever',\n       path: [...],\n     })\n  */\n  if (options._tokenize) {\n    ;(function() {\n      var start = null\n      tokenStart = function() {\n        if (start !== null) throw Error('internal error, token overlap')\n        start = position\n      }\n\n      tokenEnd = function(v, type) {\n        if (start != position) {\n          var hash = {\n            raw: input.substr(start, position-start),\n            type: type,\n            stack: stack.slice(0),\n          }\n          if (v !== undefined) hash.value = v\n          options._tokenize.call(null, hash)\n        }\n        start = null\n        return v\n      }\n    })()\n  }\n\n  function fail(msg) {\n    var column = position - linestart\n\n    if (!msg) {\n      if (position < length) {\n        var token = '\\'' +\n          JSON\n            .stringify(input[position])\n            .replace(/^\"|\"$/g, '')\n            .replace(/'/g, \"\\\\'\")\n            .replace(/\\\\\"/g, '\"')\n          + '\\''\n\n        if (!msg) msg = 'Unexpected token ' + token\n      } else {\n        if (!msg) msg = 'Unexpected end of input'\n      }\n    }\n\n    var error = SyntaxError(formatError(input, msg, position, lineno, column, json5))\n    error.row = lineno + 1\n    error.column = column + 1\n    throw error\n  }\n\n  function newline(chr) {\n    // account for <cr><lf>\n    if (chr === '\\r' && input[position] === '\\n') position++\n    linestart = position\n    lineno++\n  }\n\n  function parseGeneric() {\n    var result\n\n    while (position < length) {\n      tokenStart()\n      var chr = input[position++]\n\n      if (chr === '\"' || (chr === '\\'' && json5)) {\n        return tokenEnd(parseString(chr), 'literal')\n\n      } else if (chr === '{') {\n        tokenEnd(undefined, 'separator')\n        return parseObject()\n\n      } else if (chr === '[') {\n        tokenEnd(undefined, 'separator')\n        return parseArray()\n\n      } else if (chr === '-'\n             ||  chr === '.'\n             ||  isDecDigit(chr)\n                 //           + number       Infinity          NaN\n             ||  (json5 && (chr === '+' || chr === 'I' || chr === 'N'))\n      ) {\n        return tokenEnd(parseNumber(), 'literal')\n\n      } else if (chr === 'n') {\n        parseKeyword('null')\n        return tokenEnd(null, 'literal')\n\n      } else if (chr === 't') {\n        parseKeyword('true')\n        return tokenEnd(true, 'literal')\n\n      } else if (chr === 'f') {\n        parseKeyword('false')\n        return tokenEnd(false, 'literal')\n\n      } else {\n        position--\n        return tokenEnd(undefined)\n      }\n    }\n  }\n\n  function parseKey() {\n    var result\n\n    while (position < length) {\n      tokenStart()\n      var chr = input[position++]\n\n      if (chr === '\"' || (chr === '\\'' && json5)) {\n        return tokenEnd(parseString(chr), 'key')\n\n      } else if (chr === '{') {\n        tokenEnd(undefined, 'separator')\n        return parseObject()\n\n      } else if (chr === '[') {\n        tokenEnd(undefined, 'separator')\n        return parseArray()\n\n      } else if (chr === '.'\n             ||  isDecDigit(chr)\n      ) {\n        return tokenEnd(parseNumber(true), 'key')\n\n      } else if (json5\n             &&  Uni.isIdentifierStart(chr) || (chr === '\\\\' && input[position] === 'u')) {\n        // unicode char or a unicode sequence\n        var rollback = position - 1\n        var result = parseIdentifier()\n\n        if (result === undefined) {\n          position = rollback\n          return tokenEnd(undefined)\n        } else {\n          return tokenEnd(result, 'key')\n        }\n\n      } else {\n        position--\n        return tokenEnd(undefined)\n      }\n    }\n  }\n\n  function skipWhiteSpace() {\n    tokenStart()\n    while (position < length) {\n      var chr = input[position++]\n\n      if (isLineTerminator(chr)) {\n        position--\n        tokenEnd(undefined, 'whitespace')\n        tokenStart()\n        position++\n        newline(chr)\n        tokenEnd(undefined, 'newline')\n        tokenStart()\n\n      } else if (isWhiteSpace(chr)) {\n        // nothing\n\n      } else if (chr === '/'\n             && (json5 || cjson)\n             && (input[position] === '/' || input[position] === '*')\n      ) {\n        position--\n        tokenEnd(undefined, 'whitespace')\n        tokenStart()\n        position++\n        skipComment(input[position++] === '*')\n        tokenEnd(undefined, 'comment')\n        tokenStart()\n\n      } else {\n        position--\n        break\n      }\n    }\n    return tokenEnd(undefined, 'whitespace')\n  }\n\n  function skipComment(multi) {\n    while (position < length) {\n      var chr = input[position++]\n\n      if (isLineTerminator(chr)) {\n        // LineTerminator is an end of singleline comment\n        if (!multi) {\n          // let parent function deal with newline\n          position--\n          return\n        }\n\n        newline(chr)\n\n      } else if (chr === '*' && multi) {\n        // end of multiline comment\n        if (input[position] === '/') {\n          position++\n          return\n        }\n\n      } else {\n        // nothing\n      }\n    }\n\n    if (multi) {\n      fail('Unclosed multiline comment')\n    }\n  }\n\n  function parseKeyword(keyword) {\n    // keyword[0] is not checked because it should've checked earlier\n    var _pos = position\n    var len = keyword.length\n    for (var i=1; i<len; i++) {\n      if (position >= length || keyword[i] != input[position]) {\n        position = _pos-1\n        fail()\n      }\n      position++\n    }\n  }\n\n  function parseObject() {\n    var result = options.null_prototype ? Object.create(null) : {}\n      , empty_object = {}\n      , is_non_empty = false\n\n    while (position < length) {\n      skipWhiteSpace()\n      var item1 = parseKey()\n      skipWhiteSpace()\n      tokenStart()\n      var chr = input[position++]\n      tokenEnd(undefined, 'separator')\n\n      if (chr === '}' && item1 === undefined) {\n        if (!json5 && is_non_empty) {\n          position--\n          fail('Trailing comma in object')\n        }\n        return result\n\n      } else if (chr === ':' && item1 !== undefined) {\n        skipWhiteSpace()\n        stack.push(item1)\n        var item2 = parseGeneric()\n        stack.pop()\n\n        if (item2 === undefined) fail('No value found for key ' + item1)\n        if (typeof(item1) !== 'string') {\n          if (!json5 || typeof(item1) !== 'number') {\n            fail('Wrong key type: ' + item1)\n          }\n        }\n\n        if ((item1 in empty_object || empty_object[item1] != null) && options.reserved_keys !== 'replace') {\n          if (options.reserved_keys === 'throw') {\n            fail('Reserved key: ' + item1)\n          } else {\n            // silently ignore it\n          }\n        } else {\n          if (typeof(options.reviver) === 'function') {\n            item2 = options.reviver.call(null, item1, item2)\n          }\n\n          if (item2 !== undefined) {\n            is_non_empty = true\n            Object.defineProperty(result, item1, {\n              value: item2,\n              enumerable: true,\n              configurable: true,\n              writable: true,\n            })\n          }\n        }\n\n        skipWhiteSpace()\n\n        tokenStart()\n        var chr = input[position++]\n        tokenEnd(undefined, 'separator')\n\n        if (chr === ',') {\n          continue\n\n        } else if (chr === '}') {\n          return result\n\n        } else {\n          fail()\n        }\n\n      } else {\n        position--\n        fail()\n      }\n    }\n\n    fail()\n  }\n\n  function parseArray() {\n    var result = []\n\n    while (position < length) {\n      skipWhiteSpace()\n      stack.push(result.length)\n      var item = parseGeneric()\n      stack.pop()\n      skipWhiteSpace()\n      tokenStart()\n      var chr = input[position++]\n      tokenEnd(undefined, 'separator')\n\n      if (item !== undefined) {\n        if (typeof(options.reviver) === 'function') {\n          item = options.reviver.call(null, String(result.length), item)\n        }\n        if (item === undefined) {\n          result.length++\n          item = true // hack for check below, not included into result\n        } else {\n          result.push(item)\n        }\n      }\n\n      if (chr === ',') {\n        if (item === undefined) {\n          fail('Elisions are not supported')\n        }\n\n      } else if (chr === ']') {\n        if (!json5 && item === undefined && result.length) {\n          position--\n          fail('Trailing comma in array')\n        }\n        return result\n\n      } else {\n        position--\n        fail()\n      }\n    }\n  }\n\n  function parseNumber() {\n    // rewind because we don't know first char\n    position--\n\n    var start = position\n      , chr = input[position++]\n      , t\n\n    var to_num = function(is_octal) {\n      var str = input.substr(start, position - start)\n\n      if (is_octal) {\n        var result = parseInt(str.replace(/^0o?/, ''), 8)\n      } else {\n        var result = Number(str)\n      }\n\n      if (Number.isNaN(result)) {\n        position--\n        fail('Bad numeric literal - \"' + input.substr(start, position - start + 1) + '\"')\n      } else if (!json5 && !str.match(/^-?(0|[1-9][0-9]*)(\\.[0-9]+)?(e[+-]?[0-9]+)?$/i)) {\n        // additional restrictions imposed by json\n        position--\n        fail('Non-json numeric literal - \"' + input.substr(start, position - start + 1) + '\"')\n      } else {\n        return result\n      }\n    }\n\n    // ex: -5982475.249875e+29384\n    //     ^ skipping this\n    if (chr === '-' || (chr === '+' && json5)) chr = input[position++]\n\n    if (chr === 'N' && json5) {\n      parseKeyword('NaN')\n      return NaN\n    }\n\n    if (chr === 'I' && json5) {\n      parseKeyword('Infinity')\n\n      // returning +inf or -inf\n      return to_num()\n    }\n\n    if (chr >= '1' && chr <= '9') {\n      // ex: -5982475.249875e+29384\n      //        ^^^ skipping these\n      while (position < length && isDecDigit(input[position])) position++\n      chr = input[position++]\n    }\n\n    // special case for leading zero: 0.123456\n    if (chr === '0') {\n      chr = input[position++]\n\n      //             new syntax, \"0o777\"           old syntax, \"0777\"\n      var is_octal = chr === 'o' || chr === 'O' || isOctDigit(chr)\n      var is_hex = chr === 'x' || chr === 'X'\n\n      if (json5 && (is_octal || is_hex)) {\n        while (position < length\n           &&  (is_hex ? isHexDigit : isOctDigit)( input[position] )\n        ) position++\n\n        var sign = 1\n        if (input[start] === '-') {\n          sign = -1\n          start++\n        } else if (input[start] === '+') {\n          start++\n        }\n\n        return sign * to_num(is_octal)\n      }\n    }\n\n    if (chr === '.') {\n      // ex: -5982475.249875e+29384\n      //                ^^^ skipping these\n      while (position < length && isDecDigit(input[position])) position++\n      chr = input[position++]\n    }\n\n    if (chr === 'e' || chr === 'E') {\n      chr = input[position++]\n      if (chr === '-' || chr === '+') position++\n      // ex: -5982475.249875e+29384\n      //                       ^^^ skipping these\n      while (position < length && isDecDigit(input[position])) position++\n      chr = input[position++]\n    }\n\n    // we have char in the buffer, so count for it\n    position--\n    return to_num()\n  }\n\n  function parseIdentifier() {\n    // rewind because we don't know first char\n    position--\n\n    var result = ''\n\n    while (position < length) {\n      var chr = input[position++]\n\n      if (chr === '\\\\'\n      &&  input[position] === 'u'\n      &&  isHexDigit(input[position+1])\n      &&  isHexDigit(input[position+2])\n      &&  isHexDigit(input[position+3])\n      &&  isHexDigit(input[position+4])\n      ) {\n        // UnicodeEscapeSequence\n        chr = String.fromCharCode(parseInt(input.substr(position+1, 4), 16))\n        position += 5\n      }\n\n      if (result.length) {\n        // identifier started\n        if (Uni.isIdentifierPart(chr)) {\n          result += chr\n        } else {\n          position--\n          return result\n        }\n\n      } else {\n        if (Uni.isIdentifierStart(chr)) {\n          result += chr\n        } else {\n          return undefined\n        }\n      }\n    }\n\n    fail()\n  }\n\n  function parseString(endChar) {\n    // 7.8.4 of ES262 spec\n    var result = ''\n\n    while (position < length) {\n      var chr = input[position++]\n\n      if (chr === endChar) {\n        return result\n\n      } else if (chr === '\\\\') {\n        if (position >= length) fail()\n        chr = input[position++]\n\n        if (unescapeMap[chr] && (json5 || (chr != 'v' && chr != \"'\"))) {\n          result += unescapeMap[chr]\n\n        } else if (json5 && isLineTerminator(chr)) {\n          // line continuation\n          newline(chr)\n\n        } else if (chr === 'u' || (chr === 'x' && json5)) {\n          // unicode/character escape sequence\n          var off = chr === 'u' ? 4 : 2\n\n          // validation for \\uXXXX\n          for (var i=0; i<off; i++) {\n            if (position >= length) fail()\n            if (!isHexDigit(input[position])) fail('Bad escape sequence')\n            position++\n          }\n\n          result += String.fromCharCode(parseInt(input.substr(position-off, off), 16))\n        } else if (json5 && isOctDigit(chr)) {\n          if (chr < '4' && isOctDigit(input[position]) && isOctDigit(input[position+1])) {\n            // three-digit octal\n            var digits = 3\n          } else if (isOctDigit(input[position])) {\n            // two-digit octal\n            var digits = 2\n          } else {\n            var digits = 1\n          }\n          position += digits - 1\n          result += String.fromCharCode(parseInt(input.substr(position-digits, digits), 8))\n          /*if (!isOctDigit(input[position])) {\n            // \\0 is allowed still\n            result += '\\0'\n          } else {\n            fail('Octal literals are not supported')\n          }*/\n\n        } else if (json5) {\n          // \\X -> x\n          result += chr\n\n        } else {\n          position--\n          fail()\n        }\n\n      } else if (isLineTerminator(chr)) {\n        fail()\n\n      } else {\n        if (!json5 && chr.charCodeAt(0) < 32) {\n          position--\n          fail('Unexpected control character')\n        }\n\n        // SourceCharacter but not one of \" or \\ or LineTerminator\n        result += chr\n      }\n    }\n\n    fail()\n  }\n\n  skipWhiteSpace()\n  var return_value = parseGeneric()\n  if (return_value !== undefined || position < length) {\n    skipWhiteSpace()\n\n    if (position >= length) {\n      if (typeof(options.reviver) === 'function') {\n        return_value = options.reviver.call(null, '', return_value)\n      }\n      return return_value\n    } else {\n      fail()\n    }\n\n  } else {\n    if (position) {\n      fail('No data, only a whitespace')\n    } else {\n      fail('No data, empty input')\n    }\n  }\n}\n\n/*\n * parse(text, options)\n * or\n * parse(text, reviver)\n *\n * where:\n * text - string\n * options - object\n * reviver - function\n */\nmodule.exports.parse = function parseJSON(input, options) {\n  // support legacy functions\n  if (typeof(options) === 'function') {\n    options = {\n      reviver: options\n    }\n  }\n\n  if (input === undefined) {\n    // parse(stringify(x)) should be equal x\n    // with JSON functions it is not 'cause of undefined\n    // so we're fixing it\n    return undefined\n  }\n\n  // JSON.parse compat\n  if (typeof(input) !== 'string') input = String(input)\n  if (options == null) options = {}\n  if (options.reserved_keys == null) options.reserved_keys = 'ignore'\n\n  if (options.reserved_keys === 'throw' || options.reserved_keys === 'ignore') {\n    if (options.null_prototype == null) {\n      options.null_prototype = true\n    }\n  }\n\n  try {\n    return parse(input, options)\n  } catch(err) {\n    // jju is a recursive parser, so JSON.parse(\"{{{{{{{\") could blow up the stack\n    //\n    // this catch is used to skip all those internal calls\n    if (err instanceof SyntaxError && err.row != null && err.column != null) {\n      var old_err = err\n      err = SyntaxError(old_err.message)\n      err.column = old_err.column\n      err.row = old_err.row\n    }\n    throw err\n  }\n}\n\nmodule.exports.tokenize = function tokenizeJSON(input, options) {\n  if (options == null) options = {}\n\n  options._tokenize = function(smth) {\n    if (options._addstack) smth.stack.unshift.apply(smth.stack, options._addstack)\n    tokens.push(smth)\n  }\n\n  var tokens = []\n  tokens.data = module.exports.parse(input, options)\n  return tokens\n}\n\n"]},"metadata":{},"sourceType":"script"}