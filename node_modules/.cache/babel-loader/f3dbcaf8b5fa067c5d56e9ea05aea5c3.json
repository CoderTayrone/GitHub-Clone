{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Config = void 0;\n\nconst _ = require(\"lodash\");\n\nconst clc = require(\"cli-color\");\n\nconst fs = require(\"fs-extra\");\n\nconst path = require(\"path\");\n\nconst cjson = require(\"cjson\");\n\nconst detectProjectRoot_1 = require(\"./detectProjectRoot\");\n\nconst error_1 = require(\"./error\");\n\nconst fsutils = require(\"./fsutils\");\n\nconst prompt_1 = require(\"./prompt\");\n\nconst projectPath_1 = require(\"./projectPath\");\n\nconst utils = require(\"./utils\");\n\nconst firebaseConfigValidate_1 = require(\"./firebaseConfigValidate\");\n\nconst logger_1 = require(\"./logger\");\n\nconst loadCJSON = require(\"./loadCJSON\");\n\nconst parseBoltRules = require(\"./parseBoltRules\");\n\nclass Config {\n  constructor(src, options) {\n    this.data = {};\n    this.defaults = {};\n    this.notes = {};\n    this.options = options || {};\n    this.projectDir = options.projectDir || detectProjectRoot_1.detectProjectRoot(options);\n    this._src = src;\n\n    if (this._src.firebase) {\n      this.defaults.project = this._src.firebase;\n      utils.logWarning(clc.bold('\"firebase\"') + \" key in firebase.json is deprecated. Run \" + clc.bold(\"firebase use --add\") + \" instead\");\n    }\n\n    if (_.has(this._src, \"rules\")) {\n      _.set(this._src, \"database.rules\", this._src.rules);\n    }\n\n    Config.MATERIALIZE_TARGETS.forEach(target => {\n      if (_.get(this._src, target)) {\n        _.set(this.data, target, this.materialize(target));\n      }\n    });\n\n    if (this.projectDir && !this.get(\"functions.source\") && fsutils.dirExistsSync(this.path(\"functions\"))) {\n      this.set(\"functions.source\", Config.DEFAULT_FUNCTIONS_SOURCE);\n    }\n  }\n\n  materialize(target) {\n    const val = _.get(this._src, target);\n\n    if (typeof val === \"string\") {\n      let out = this.parseFile(target, val);\n      const segments = target.split(\".\");\n      const lastSegment = segments[segments.length - 1];\n\n      if (Object.keys(out).length === 1 && _.has(out, lastSegment)) {\n        out = out[lastSegment];\n      }\n\n      return out;\n    } else if (val !== null && typeof val === \"object\") {\n      return val;\n    }\n\n    throw new error_1.FirebaseError('Parse Error: \"' + target + '\" must be object or import path', {\n      exit: 1\n    });\n  }\n\n  parseFile(target, filePath) {\n    const fullPath = projectPath_1.resolveProjectPath(this.options, filePath);\n    const ext = path.extname(filePath);\n\n    if (!fsutils.fileExistsSync(fullPath)) {\n      throw new error_1.FirebaseError(\"Parse Error: Imported file \" + filePath + \" does not exist\", {\n        exit: 1\n      });\n    }\n\n    switch (ext) {\n      case \".json\":\n        if (target === \"database\") {\n          this.notes.databaseRules = \"json\";\n        } else if (target === \"database.rules\") {\n          this.notes.databaseRulesFile = filePath;\n\n          try {\n            return fs.readFileSync(fullPath, \"utf8\");\n          } catch (e) {\n            if (e.code === \"ENOENT\") {\n              throw new error_1.FirebaseError(`File not found: ${fullPath}`, {\n                original: e\n              });\n            }\n\n            throw e;\n          }\n        }\n\n        return loadCJSON(fullPath);\n\n      case \".bolt\":\n        if (target === \"database\") {\n          this.notes.databaseRules = \"bolt\";\n        }\n\n        return parseBoltRules(fullPath);\n\n      default:\n        throw new error_1.FirebaseError(\"Parse Error: \" + filePath + \" is not of a supported config file type\", {\n          exit: 1\n        });\n    }\n  }\n\n  get src() {\n    return this._src;\n  }\n\n  get(key, fallback) {\n    return _.get(this.data, key, fallback);\n  }\n\n  set(key, value) {\n    _.set(this._src, key, value);\n\n    return _.set(this.data, key, value);\n  }\n\n  has(key) {\n    return _.has(this.data, key);\n  }\n\n  path(pathName) {\n    const outPath = path.normalize(path.join(this.projectDir, pathName));\n\n    if (path.relative(this.projectDir, outPath).includes(\"..\")) {\n      throw new error_1.FirebaseError(clc.bold(pathName) + \" is outside of project directory\", {\n        exit: 1\n      });\n    }\n\n    return outPath;\n  }\n\n  readProjectFile(p, options) {\n    options = options || {};\n\n    try {\n      const content = fs.readFileSync(this.path(p), \"utf8\");\n\n      if (options.json) {\n        return JSON.parse(content);\n      }\n\n      return content;\n    } catch (e) {\n      if (options.fallback) {\n        return options.fallback;\n      }\n\n      if (e.code === \"ENOENT\") {\n        throw new error_1.FirebaseError(`File not found: ${this.path(p)}`, {\n          original: e\n        });\n      }\n\n      throw e;\n    }\n  }\n\n  writeProjectFile(p, content) {\n    if (typeof content !== \"string\") {\n      content = JSON.stringify(content, null, 2) + \"\\n\";\n    }\n\n    fs.ensureFileSync(this.path(p));\n    fs.writeFileSync(this.path(p), content, \"utf8\");\n  }\n\n  askWriteProjectFile(p, content) {\n    const writeTo = this.path(p);\n    let next;\n\n    if (fsutils.fileExistsSync(writeTo)) {\n      next = prompt_1.promptOnce({\n        type: \"confirm\",\n        message: \"File \" + clc.underline(p) + \" already exists. Overwrite?\",\n        default: false\n      });\n    } else {\n      next = Promise.resolve(true);\n    }\n\n    return next.then(result => {\n      if (result) {\n        this.writeProjectFile(p, content);\n        utils.logSuccess(\"Wrote \" + clc.bold(p));\n      } else {\n        utils.logBullet(\"Skipping write of \" + clc.bold(p));\n      }\n    });\n  }\n\n  static load(options, allowMissing) {\n    const pd = detectProjectRoot_1.detectProjectRoot(options);\n    const filename = options.configPath || Config.FILENAME;\n\n    if (pd) {\n      try {\n        const filePath = path.resolve(pd, path.basename(filename));\n        const data = cjson.load(filePath);\n        const validator = firebaseConfigValidate_1.getValidator();\n        const valid = validator(data);\n\n        if (!valid && validator.errors) {\n          for (const e of validator.errors) {\n            logger_1.logger.debug(firebaseConfigValidate_1.getErrorMessage(e));\n          }\n        }\n\n        return new Config(data, options);\n      } catch (e) {\n        throw new error_1.FirebaseError(`There was an error loading ${filename}:\\n\\n` + e.message, {\n          exit: 1\n        });\n      }\n    }\n\n    if (allowMissing) {\n      return null;\n    }\n\n    throw new error_1.FirebaseError(\"Not in a Firebase app directory (could not locate firebase.json)\", {\n      exit: 1\n    });\n  }\n\n}\n\nexports.Config = Config;\nConfig.DEFAULT_FUNCTIONS_SOURCE = \"functions\";\nConfig.FILENAME = \"firebase.json\";\nConfig.MATERIALIZE_TARGETS = [\"database\", \"emulators\", \"firestore\", \"functions\", \"hosting\", \"storage\", \"remoteconfig\"];","map":{"version":3,"sources":["/home/dev/Documentos/Projects/github-clone/node_modules/firebase-tools/lib/config.js"],"names":["Object","defineProperty","exports","value","Config","_","require","clc","fs","path","cjson","detectProjectRoot_1","error_1","fsutils","prompt_1","projectPath_1","utils","firebaseConfigValidate_1","logger_1","loadCJSON","parseBoltRules","constructor","src","options","data","defaults","notes","projectDir","detectProjectRoot","_src","firebase","project","logWarning","bold","has","set","rules","MATERIALIZE_TARGETS","forEach","target","get","materialize","dirExistsSync","DEFAULT_FUNCTIONS_SOURCE","val","out","parseFile","segments","split","lastSegment","length","keys","FirebaseError","exit","filePath","fullPath","resolveProjectPath","ext","extname","fileExistsSync","databaseRules","databaseRulesFile","readFileSync","e","code","original","key","fallback","pathName","outPath","normalize","join","relative","includes","readProjectFile","p","content","json","JSON","parse","writeProjectFile","stringify","ensureFileSync","writeFileSync","askWriteProjectFile","writeTo","next","promptOnce","type","message","underline","default","Promise","resolve","then","result","logSuccess","logBullet","load","allowMissing","pd","filename","configPath","FILENAME","basename","validator","getValidator","valid","errors","logger","debug","getErrorMessage"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Config = void 0;\nconst _ = require(\"lodash\");\nconst clc = require(\"cli-color\");\nconst fs = require(\"fs-extra\");\nconst path = require(\"path\");\nconst cjson = require(\"cjson\");\nconst detectProjectRoot_1 = require(\"./detectProjectRoot\");\nconst error_1 = require(\"./error\");\nconst fsutils = require(\"./fsutils\");\nconst prompt_1 = require(\"./prompt\");\nconst projectPath_1 = require(\"./projectPath\");\nconst utils = require(\"./utils\");\nconst firebaseConfigValidate_1 = require(\"./firebaseConfigValidate\");\nconst logger_1 = require(\"./logger\");\nconst loadCJSON = require(\"./loadCJSON\");\nconst parseBoltRules = require(\"./parseBoltRules\");\nclass Config {\n    constructor(src, options) {\n        this.data = {};\n        this.defaults = {};\n        this.notes = {};\n        this.options = options || {};\n        this.projectDir = options.projectDir || detectProjectRoot_1.detectProjectRoot(options);\n        this._src = src;\n        if (this._src.firebase) {\n            this.defaults.project = this._src.firebase;\n            utils.logWarning(clc.bold('\"firebase\"') +\n                \" key in firebase.json is deprecated. Run \" +\n                clc.bold(\"firebase use --add\") +\n                \" instead\");\n        }\n        if (_.has(this._src, \"rules\")) {\n            _.set(this._src, \"database.rules\", this._src.rules);\n        }\n        Config.MATERIALIZE_TARGETS.forEach((target) => {\n            if (_.get(this._src, target)) {\n                _.set(this.data, target, this.materialize(target));\n            }\n        });\n        if (this.projectDir &&\n            !this.get(\"functions.source\") &&\n            fsutils.dirExistsSync(this.path(\"functions\"))) {\n            this.set(\"functions.source\", Config.DEFAULT_FUNCTIONS_SOURCE);\n        }\n    }\n    materialize(target) {\n        const val = _.get(this._src, target);\n        if (typeof val === \"string\") {\n            let out = this.parseFile(target, val);\n            const segments = target.split(\".\");\n            const lastSegment = segments[segments.length - 1];\n            if (Object.keys(out).length === 1 && _.has(out, lastSegment)) {\n                out = out[lastSegment];\n            }\n            return out;\n        }\n        else if (val !== null && typeof val === \"object\") {\n            return val;\n        }\n        throw new error_1.FirebaseError('Parse Error: \"' + target + '\" must be object or import path', {\n            exit: 1,\n        });\n    }\n    parseFile(target, filePath) {\n        const fullPath = projectPath_1.resolveProjectPath(this.options, filePath);\n        const ext = path.extname(filePath);\n        if (!fsutils.fileExistsSync(fullPath)) {\n            throw new error_1.FirebaseError(\"Parse Error: Imported file \" + filePath + \" does not exist\", {\n                exit: 1,\n            });\n        }\n        switch (ext) {\n            case \".json\":\n                if (target === \"database\") {\n                    this.notes.databaseRules = \"json\";\n                }\n                else if (target === \"database.rules\") {\n                    this.notes.databaseRulesFile = filePath;\n                    try {\n                        return fs.readFileSync(fullPath, \"utf8\");\n                    }\n                    catch (e) {\n                        if (e.code === \"ENOENT\") {\n                            throw new error_1.FirebaseError(`File not found: ${fullPath}`, { original: e });\n                        }\n                        throw e;\n                    }\n                }\n                return loadCJSON(fullPath);\n            case \".bolt\":\n                if (target === \"database\") {\n                    this.notes.databaseRules = \"bolt\";\n                }\n                return parseBoltRules(fullPath);\n            default:\n                throw new error_1.FirebaseError(\"Parse Error: \" + filePath + \" is not of a supported config file type\", { exit: 1 });\n        }\n    }\n    get src() {\n        return this._src;\n    }\n    get(key, fallback) {\n        return _.get(this.data, key, fallback);\n    }\n    set(key, value) {\n        _.set(this._src, key, value);\n        return _.set(this.data, key, value);\n    }\n    has(key) {\n        return _.has(this.data, key);\n    }\n    path(pathName) {\n        const outPath = path.normalize(path.join(this.projectDir, pathName));\n        if (path.relative(this.projectDir, outPath).includes(\"..\")) {\n            throw new error_1.FirebaseError(clc.bold(pathName) + \" is outside of project directory\", { exit: 1 });\n        }\n        return outPath;\n    }\n    readProjectFile(p, options) {\n        options = options || {};\n        try {\n            const content = fs.readFileSync(this.path(p), \"utf8\");\n            if (options.json) {\n                return JSON.parse(content);\n            }\n            return content;\n        }\n        catch (e) {\n            if (options.fallback) {\n                return options.fallback;\n            }\n            if (e.code === \"ENOENT\") {\n                throw new error_1.FirebaseError(`File not found: ${this.path(p)}`, { original: e });\n            }\n            throw e;\n        }\n    }\n    writeProjectFile(p, content) {\n        if (typeof content !== \"string\") {\n            content = JSON.stringify(content, null, 2) + \"\\n\";\n        }\n        fs.ensureFileSync(this.path(p));\n        fs.writeFileSync(this.path(p), content, \"utf8\");\n    }\n    askWriteProjectFile(p, content) {\n        const writeTo = this.path(p);\n        let next;\n        if (fsutils.fileExistsSync(writeTo)) {\n            next = prompt_1.promptOnce({\n                type: \"confirm\",\n                message: \"File \" + clc.underline(p) + \" already exists. Overwrite?\",\n                default: false,\n            });\n        }\n        else {\n            next = Promise.resolve(true);\n        }\n        return next.then((result) => {\n            if (result) {\n                this.writeProjectFile(p, content);\n                utils.logSuccess(\"Wrote \" + clc.bold(p));\n            }\n            else {\n                utils.logBullet(\"Skipping write of \" + clc.bold(p));\n            }\n        });\n    }\n    static load(options, allowMissing) {\n        const pd = detectProjectRoot_1.detectProjectRoot(options);\n        const filename = options.configPath || Config.FILENAME;\n        if (pd) {\n            try {\n                const filePath = path.resolve(pd, path.basename(filename));\n                const data = cjson.load(filePath);\n                const validator = firebaseConfigValidate_1.getValidator();\n                const valid = validator(data);\n                if (!valid && validator.errors) {\n                    for (const e of validator.errors) {\n                        logger_1.logger.debug(firebaseConfigValidate_1.getErrorMessage(e));\n                    }\n                }\n                return new Config(data, options);\n            }\n            catch (e) {\n                throw new error_1.FirebaseError(`There was an error loading ${filename}:\\n\\n` + e.message, {\n                    exit: 1,\n                });\n            }\n        }\n        if (allowMissing) {\n            return null;\n        }\n        throw new error_1.FirebaseError(\"Not in a Firebase app directory (could not locate firebase.json)\", {\n            exit: 1,\n        });\n    }\n}\nexports.Config = Config;\nConfig.DEFAULT_FUNCTIONS_SOURCE = \"functions\";\nConfig.FILENAME = \"firebase.json\";\nConfig.MATERIALIZE_TARGETS = [\n    \"database\",\n    \"emulators\",\n    \"firestore\",\n    \"functions\",\n    \"hosting\",\n    \"storage\",\n    \"remoteconfig\",\n];\n"]},"metadata":{},"sourceType":"script"}