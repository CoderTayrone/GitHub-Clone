{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst http_1 = __importDefault(require(\"http\"));\n\nconst https_1 = __importDefault(require(\"https\"));\n\nconst once_1 = __importDefault(require(\"@tootallnate/once\"));\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst url_1 = require(\"url\");\n\nconst http_error_1 = __importDefault(require(\"./http-error\"));\n\nconst notfound_1 = __importDefault(require(\"./notfound\"));\n\nconst notmodified_1 = __importDefault(require(\"./notmodified\"));\n\nconst debug = debug_1.default('get-uri:http');\n/**\n * Returns a Readable stream from an \"http:\" URI.\n */\n\nfunction get(parsed, opts) {\n  return __awaiter(this, void 0, void 0, function* () {\n    debug('GET %o', parsed.href);\n    const cache = getCache(parsed, opts.cache); // first check the previous Expires and/or Cache-Control headers\n    // of a previous response if a `cache` was provided\n\n    if (cache && isFresh(cache) && typeof cache.statusCode === 'number') {\n      // check for a 3xx \"redirect\" status code on the previous cache\n      const type = cache.statusCode / 100 | 0;\n\n      if (type === 3 && cache.headers.location) {\n        debug('cached redirect');\n        throw new Error('TODO: implement cached redirects!');\n      } // otherwise we assume that it's the destination endpoint,\n      // since there's nowhere else to redirect to\n\n\n      throw new notmodified_1.default();\n    } // 5 redirects allowed by default\n\n\n    const maxRedirects = typeof opts.maxRedirects === 'number' ? opts.maxRedirects : 5;\n    debug('allowing %o max redirects', maxRedirects);\n    let mod;\n\n    if (opts.http) {\n      // the `https` module passed in from the \"http.js\" file\n      mod = opts.http;\n      debug('using secure `https` core module');\n    } else {\n      mod = http_1.default;\n      debug('using `http` core module');\n    }\n\n    const options = Object.assign(Object.assign({}, opts), parsed); // add \"cache validation\" headers if a `cache` was provided\n\n    if (cache) {\n      if (!options.headers) {\n        options.headers = {};\n      }\n\n      const lastModified = cache.headers['last-modified'];\n\n      if (lastModified) {\n        options.headers['If-Modified-Since'] = lastModified;\n        debug('added \"If-Modified-Since\" request header: %o', lastModified);\n      }\n\n      const etag = cache.headers.etag;\n\n      if (etag) {\n        options.headers['If-None-Match'] = etag;\n        debug('added \"If-None-Match\" request header: %o', etag);\n      }\n    }\n\n    const req = mod.get(options);\n    const res = yield once_1.default(req, 'response');\n    const code = res.statusCode || 0; // assign a Date to this response for the \"Cache-Control\" delta calculation\n\n    res.date = Date.now();\n    res.parsed = parsed;\n    debug('got %o response status code', code); // any 2xx response is a \"success\" code\n\n    let type = code / 100 | 0; // check for a 3xx \"redirect\" status code\n\n    let location = res.headers.location;\n\n    if (type === 3 && location) {\n      if (!opts.redirects) opts.redirects = [];\n      let redirects = opts.redirects;\n\n      if (redirects.length < maxRedirects) {\n        debug('got a \"redirect\" status code with Location: %o', location); // flush this response - we're not going to use it\n\n        res.resume(); // hang on to this Response object for the \"redirects\" Array\n\n        redirects.push(res);\n        let newUri = url_1.resolve(parsed.href, location);\n        debug('resolved redirect URL: %o', newUri);\n        let left = maxRedirects - redirects.length;\n        debug('%o more redirects allowed after this one', left); // check if redirecting to a different protocol\n\n        let parsedUrl = url_1.parse(newUri);\n\n        if (parsedUrl.protocol !== parsed.protocol) {\n          opts.http = parsedUrl.protocol === 'https:' ? https_1.default : undefined;\n        }\n\n        return get(parsedUrl, opts);\n      }\n    } // if we didn't get a 2xx \"success\" status code, then create an Error object\n\n\n    if (type !== 2) {\n      res.resume();\n\n      if (code === 304) {\n        throw new notmodified_1.default();\n      } else if (code === 404) {\n        throw new notfound_1.default();\n      } // other HTTP-level error\n\n\n      throw new http_error_1.default(code);\n    }\n\n    if (opts.redirects) {\n      // store a reference to the \"redirects\" Array on the Response object so that\n      // they can be inspected during a subsequent call to GET the same URI\n      res.redirects = opts.redirects;\n    }\n\n    return res;\n  });\n}\n\nexports.default = get;\n/**\n * Returns `true` if the provided cache's \"freshness\" is valid. That is, either\n * the Cache-Control header or Expires header values are still within the allowed\n * time period.\n *\n * @return {Boolean}\n * @api private\n */\n\nfunction isFresh(cache) {\n  let fresh = false;\n  let expires = parseInt(cache.headers.expires || '', 10);\n  const cacheControl = cache.headers['cache-control'];\n\n  if (cacheControl) {\n    // for Cache-Control rules, see: http://www.mnot.net/cache_docs/#CACHE-CONTROL\n    debug('Cache-Control: %o', cacheControl);\n    const parts = cacheControl.split(/,\\s*?\\b/);\n\n    for (let i = 0; i < parts.length; i++) {\n      const part = parts[i];\n      const subparts = part.split('=');\n      const name = subparts[0];\n\n      switch (name) {\n        case 'max-age':\n          expires = (cache.date || 0) + parseInt(subparts[1], 10) * 1000;\n          fresh = Date.now() < expires;\n\n          if (fresh) {\n            debug('cache is \"fresh\" due to previous %o Cache-Control param', part);\n          }\n\n          return fresh;\n\n        case 'must-revalidate':\n          // XXX: what we supposed to do here?\n          break;\n\n        case 'no-cache':\n        case 'no-store':\n          debug('cache is \"stale\" due to explicit %o Cache-Control param', name);\n          return false;\n\n        default:\n          // ignore unknown cache value\n          break;\n      }\n    }\n  } else if (expires) {\n    // for Expires rules, see: http://www.mnot.net/cache_docs/#EXPIRES\n    debug('Expires: %o', expires);\n    fresh = Date.now() < expires;\n\n    if (fresh) {\n      debug('cache is \"fresh\" due to previous Expires response header');\n    }\n\n    return fresh;\n  }\n\n  return false;\n}\n/**\n * Attempts to return a previous Response object from a previous GET call to the\n * same URI.\n *\n * @api private\n */\n\n\nfunction getCache(parsed, cache) {\n  if (cache) {\n    if (cache.parsed && cache.parsed.href === parsed.href) {\n      return cache;\n    }\n\n    if (cache.redirects) {\n      for (let i = 0; i < cache.redirects.length; i++) {\n        const c = getCache(parsed, cache.redirects[i]);\n\n        if (c) {\n          return c;\n        }\n      }\n    }\n  }\n\n  return null;\n}","map":{"version":3,"sources":["../src/http.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst http_1 = __importDefault(require(\"http\"));\nconst https_1 = __importDefault(require(\"https\"));\nconst once_1 = __importDefault(require(\"@tootallnate/once\"));\nconst debug_1 = __importDefault(require(\"debug\"));\nconst url_1 = require(\"url\");\nconst http_error_1 = __importDefault(require(\"./http-error\"));\nconst notfound_1 = __importDefault(require(\"./notfound\"));\nconst notmodified_1 = __importDefault(require(\"./notmodified\"));\nconst debug = debug_1.default('get-uri:http');\n/**\n * Returns a Readable stream from an \"http:\" URI.\n */\nfunction get(parsed, opts) {\n    return __awaiter(this, void 0, void 0, function* () {\n        debug('GET %o', parsed.href);\n        const cache = getCache(parsed, opts.cache);\n        // first check the previous Expires and/or Cache-Control headers\n        // of a previous response if a `cache` was provided\n        if (cache && isFresh(cache) && typeof cache.statusCode === 'number') {\n            // check for a 3xx \"redirect\" status code on the previous cache\n            const type = (cache.statusCode / 100) | 0;\n            if (type === 3 && cache.headers.location) {\n                debug('cached redirect');\n                throw new Error('TODO: implement cached redirects!');\n            }\n            // otherwise we assume that it's the destination endpoint,\n            // since there's nowhere else to redirect to\n            throw new notmodified_1.default();\n        }\n        // 5 redirects allowed by default\n        const maxRedirects = typeof opts.maxRedirects === 'number' ? opts.maxRedirects : 5;\n        debug('allowing %o max redirects', maxRedirects);\n        let mod;\n        if (opts.http) {\n            // the `https` module passed in from the \"http.js\" file\n            mod = opts.http;\n            debug('using secure `https` core module');\n        }\n        else {\n            mod = http_1.default;\n            debug('using `http` core module');\n        }\n        const options = Object.assign(Object.assign({}, opts), parsed);\n        // add \"cache validation\" headers if a `cache` was provided\n        if (cache) {\n            if (!options.headers) {\n                options.headers = {};\n            }\n            const lastModified = cache.headers['last-modified'];\n            if (lastModified) {\n                options.headers['If-Modified-Since'] = lastModified;\n                debug('added \"If-Modified-Since\" request header: %o', lastModified);\n            }\n            const etag = cache.headers.etag;\n            if (etag) {\n                options.headers['If-None-Match'] = etag;\n                debug('added \"If-None-Match\" request header: %o', etag);\n            }\n        }\n        const req = mod.get(options);\n        const res = yield once_1.default(req, 'response');\n        const code = res.statusCode || 0;\n        // assign a Date to this response for the \"Cache-Control\" delta calculation\n        res.date = Date.now();\n        res.parsed = parsed;\n        debug('got %o response status code', code);\n        // any 2xx response is a \"success\" code\n        let type = (code / 100) | 0;\n        // check for a 3xx \"redirect\" status code\n        let location = res.headers.location;\n        if (type === 3 && location) {\n            if (!opts.redirects)\n                opts.redirects = [];\n            let redirects = opts.redirects;\n            if (redirects.length < maxRedirects) {\n                debug('got a \"redirect\" status code with Location: %o', location);\n                // flush this response - we're not going to use it\n                res.resume();\n                // hang on to this Response object for the \"redirects\" Array\n                redirects.push(res);\n                let newUri = url_1.resolve(parsed.href, location);\n                debug('resolved redirect URL: %o', newUri);\n                let left = maxRedirects - redirects.length;\n                debug('%o more redirects allowed after this one', left);\n                // check if redirecting to a different protocol\n                let parsedUrl = url_1.parse(newUri);\n                if (parsedUrl.protocol !== parsed.protocol) {\n                    opts.http = parsedUrl.protocol === 'https:' ? https_1.default : undefined;\n                }\n                return get(parsedUrl, opts);\n            }\n        }\n        // if we didn't get a 2xx \"success\" status code, then create an Error object\n        if (type !== 2) {\n            res.resume();\n            if (code === 304) {\n                throw new notmodified_1.default();\n            }\n            else if (code === 404) {\n                throw new notfound_1.default();\n            }\n            // other HTTP-level error\n            throw new http_error_1.default(code);\n        }\n        if (opts.redirects) {\n            // store a reference to the \"redirects\" Array on the Response object so that\n            // they can be inspected during a subsequent call to GET the same URI\n            res.redirects = opts.redirects;\n        }\n        return res;\n    });\n}\nexports.default = get;\n/**\n * Returns `true` if the provided cache's \"freshness\" is valid. That is, either\n * the Cache-Control header or Expires header values are still within the allowed\n * time period.\n *\n * @return {Boolean}\n * @api private\n */\nfunction isFresh(cache) {\n    let fresh = false;\n    let expires = parseInt(cache.headers.expires || '', 10);\n    const cacheControl = cache.headers['cache-control'];\n    if (cacheControl) {\n        // for Cache-Control rules, see: http://www.mnot.net/cache_docs/#CACHE-CONTROL\n        debug('Cache-Control: %o', cacheControl);\n        const parts = cacheControl.split(/,\\s*?\\b/);\n        for (let i = 0; i < parts.length; i++) {\n            const part = parts[i];\n            const subparts = part.split('=');\n            const name = subparts[0];\n            switch (name) {\n                case 'max-age':\n                    expires = (cache.date || 0) + parseInt(subparts[1], 10) * 1000;\n                    fresh = Date.now() < expires;\n                    if (fresh) {\n                        debug('cache is \"fresh\" due to previous %o Cache-Control param', part);\n                    }\n                    return fresh;\n                case 'must-revalidate':\n                    // XXX: what we supposed to do here?\n                    break;\n                case 'no-cache':\n                case 'no-store':\n                    debug('cache is \"stale\" due to explicit %o Cache-Control param', name);\n                    return false;\n                default:\n                    // ignore unknown cache value\n                    break;\n            }\n        }\n    }\n    else if (expires) {\n        // for Expires rules, see: http://www.mnot.net/cache_docs/#EXPIRES\n        debug('Expires: %o', expires);\n        fresh = Date.now() < expires;\n        if (fresh) {\n            debug('cache is \"fresh\" due to previous Expires response header');\n        }\n        return fresh;\n    }\n    return false;\n}\n/**\n * Attempts to return a previous Response object from a previous GET call to the\n * same URI.\n *\n * @api private\n */\nfunction getCache(parsed, cache) {\n    if (cache) {\n        if (cache.parsed && cache.parsed.href === parsed.href) {\n            return cache;\n        }\n        if (cache.redirects) {\n            for (let i = 0; i < cache.redirects.length; i++) {\n                const c = getCache(parsed, cache.redirects[i]);\n                if (c) {\n                    return c;\n                }\n            }\n        }\n    }\n    return null;\n}\n//# sourceMappingURL=http.js.map"]},"metadata":{},"sourceType":"script"}