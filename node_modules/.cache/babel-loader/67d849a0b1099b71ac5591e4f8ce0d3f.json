{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setAccountInfoImpl = exports.resetPassword = exports.SESSION_COOKIE_MAX_VALID_DURATION = exports.CUSTOM_TOKEN_AUDIENCE = exports.authOperations = void 0;\n\nconst url_1 = require(\"url\");\n\nconst jsonwebtoken_1 = require(\"jsonwebtoken\");\n\nconst utils_1 = require(\"./utils\");\n\nconst errors_1 = require(\"./errors\");\n\nconst types_1 = require(\"../types\");\n\nconst emulatorLogger_1 = require(\"../emulatorLogger\");\n\nconst state_1 = require(\"./state\");\n\nexports.authOperations = {\n  identitytoolkit: {\n    getProjects,\n    getRecaptchaParams,\n    accounts: {\n      createAuthUri,\n      delete: deleteAccount,\n      lookup,\n      resetPassword,\n      sendOobCode,\n      sendVerificationCode,\n      signInWithCustomToken,\n      signInWithEmailLink,\n      signInWithIdp,\n      signInWithPassword,\n      signInWithPhoneNumber,\n      signUp,\n      update: setAccountInfo\n    },\n    projects: {\n      createSessionCookie,\n      queryAccounts,\n      accounts: {\n        _: signUp,\n        delete: deleteAccount,\n        lookup,\n        query: queryAccounts,\n        sendOobCode,\n        update: setAccountInfo,\n        batchCreate,\n        batchDelete,\n        batchGet\n      }\n    }\n  },\n  securetoken: {\n    token: grantToken\n  },\n  emulator: {\n    projects: {\n      accounts: {\n        delete: deleteAllAccountsInProject\n      },\n      config: {\n        get: getEmulatorProjectConfig,\n        update: updateEmulatorProjectConfig\n      },\n      oobCodes: {\n        list: listOobCodesInProject\n      },\n      verificationCodes: {\n        list: listVerificationCodesInProject\n      }\n    }\n  }\n};\nconst PASSWORD_MIN_LENGTH = 6;\nexports.CUSTOM_TOKEN_AUDIENCE = \"https://identitytoolkit.googleapis.com/google.identity.identitytoolkit.v1.IdentityToolkit\";\n\nfunction signUp(state, reqBody, ctx) {\n  var _a;\n\n  let provider;\n  const updates = {\n    lastLoginAt: Date.now().toString()\n  };\n\n  if ((_a = ctx.security) === null || _a === void 0 ? void 0 : _a.Oauth2) {\n    if (reqBody.idToken) {\n      errors_1.assert(!reqBody.localId, \"UNEXPECTED_PARAMETER : User ID\");\n    }\n\n    if (reqBody.localId) {\n      errors_1.assert(!state.getUserByLocalId(reqBody.localId), \"DUPLICATE_LOCAL_ID\");\n    }\n\n    updates.displayName = reqBody.displayName;\n    updates.photoUrl = reqBody.photoUrl;\n    updates.emailVerified = reqBody.emailVerified || false;\n\n    if (reqBody.phoneNumber) {\n      errors_1.assert(utils_1.isValidPhoneNumber(reqBody.phoneNumber), \"INVALID_PHONE_NUMBER : Invalid format.\");\n      errors_1.assert(!state.getUserByPhoneNumber(reqBody.phoneNumber), \"PHONE_NUMBER_EXISTS\");\n      updates.phoneNumber = reqBody.phoneNumber;\n    }\n\n    if (reqBody.disabled) {\n      updates.disabled = true;\n    }\n  } else {\n    errors_1.assert(!reqBody.localId, \"UNEXPECTED_PARAMETER : User ID\");\n\n    if (reqBody.idToken || reqBody.password || reqBody.email) {\n      updates.displayName = reqBody.displayName;\n      updates.emailVerified = false;\n      errors_1.assert(reqBody.email, \"MISSING_EMAIL\");\n      errors_1.assert(reqBody.password, \"MISSING_PASSWORD\");\n      provider = state_1.PROVIDER_PASSWORD;\n    } else {\n      provider = state_1.PROVIDER_ANONYMOUS;\n    }\n  }\n\n  if (reqBody.email) {\n    errors_1.assert(utils_1.isValidEmailAddress(reqBody.email), \"INVALID_EMAIL\");\n    const email = utils_1.canonicalizeEmailAddress(reqBody.email);\n    errors_1.assert(!state.getUserByEmail(email), \"EMAIL_EXISTS\");\n    updates.email = email;\n  }\n\n  if (reqBody.password) {\n    errors_1.assert(reqBody.password.length >= PASSWORD_MIN_LENGTH, `WEAK_PASSWORD : Password should be at least ${PASSWORD_MIN_LENGTH} characters`);\n    updates.salt = \"fakeSalt\" + utils_1.randomId(20);\n    updates.passwordHash = hashPassword(reqBody.password, updates.salt);\n    updates.passwordUpdatedAt = Date.now();\n    updates.validSince = utils_1.toUnixTimestamp(new Date()).toString();\n  }\n\n  if (reqBody.mfaInfo) {\n    updates.mfaInfo = getMfaEnrollmentsFromRequest(state, reqBody.mfaInfo, {\n      generateEnrollmentIds: true\n    });\n  }\n\n  let user;\n\n  if (reqBody.idToken) {\n    ({\n      user\n    } = parseIdToken(state, reqBody.idToken));\n  }\n\n  if (!user) {\n    if (reqBody.localId) {\n      user = state.createUserWithLocalId(reqBody.localId, updates);\n      errors_1.assert(user, \"DUPLICATE_LOCAL_ID\");\n    } else {\n      user = state.createUser(updates);\n    }\n  } else {\n    user = state.updateUserByLocalId(user.localId, updates);\n  }\n\n  return Object.assign({\n    kind: \"identitytoolkit#SignupNewUserResponse\",\n    localId: user.localId,\n    displayName: user.displayName,\n    email: user.email\n  }, provider ? issueTokens(state, user, provider) : {});\n}\n\nfunction lookup(state, reqBody, ctx) {\n  var _a, _b, _c, _d, _e;\n\n  const seenLocalIds = new Set();\n  const users = [];\n\n  function tryAddUser(maybeUser) {\n    if (maybeUser && !seenLocalIds.has(maybeUser.localId)) {\n      users.push(maybeUser);\n      seenLocalIds.add(maybeUser.localId);\n    }\n  }\n\n  if ((_a = ctx.security) === null || _a === void 0 ? void 0 : _a.Oauth2) {\n    if (reqBody.initialEmail) {\n      throw new errors_1.NotImplementedError(\"Lookup by initialEmail is not implemented.\");\n    }\n\n    for (const localId of (_b = reqBody.localId) !== null && _b !== void 0 ? _b : []) {\n      tryAddUser(state.getUserByLocalId(localId));\n    }\n\n    for (const email of (_c = reqBody.email) !== null && _c !== void 0 ? _c : []) {\n      tryAddUser(state.getUserByEmail(email));\n    }\n\n    for (const phoneNumber of (_d = reqBody.phoneNumber) !== null && _d !== void 0 ? _d : []) {\n      tryAddUser(state.getUserByPhoneNumber(phoneNumber));\n    }\n\n    for (const {\n      providerId,\n      rawId\n    } of (_e = reqBody.federatedUserId) !== null && _e !== void 0 ? _e : []) {\n      if (!providerId || !rawId) {\n        continue;\n      }\n\n      tryAddUser(state.getUserByProviderRawId(providerId, rawId));\n    }\n  } else {\n    errors_1.assert(reqBody.idToken, \"MISSING_ID_TOKEN\");\n    const {\n      user\n    } = parseIdToken(state, reqBody.idToken);\n    users.push(redactPasswordHash(user));\n  }\n\n  return {\n    kind: \"identitytoolkit#GetAccountInfoResponse\",\n    users: users.length ? users : undefined\n  };\n}\n\nfunction batchCreate(state, reqBody) {\n  var _a, _b;\n\n  errors_1.assert((_a = reqBody.users) === null || _a === void 0 ? void 0 : _a.length, \"MISSING_USER_ACCOUNT\");\n\n  if (reqBody.sanityCheck) {\n    if (state.oneAccountPerEmail) {\n      const existingEmails = new Set();\n\n      for (const userInfo of reqBody.users) {\n        if (userInfo.email) {\n          errors_1.assert(!existingEmails.has(userInfo.email), `DUPLICATE_EMAIL : ${userInfo.email}`);\n          existingEmails.add(userInfo.email);\n        }\n      }\n    }\n\n    const existingProviderAccounts = new Set();\n\n    for (const userInfo of reqBody.users) {\n      for (const {\n        providerId,\n        rawId\n      } of (_b = userInfo.providerUserInfo) !== null && _b !== void 0 ? _b : []) {\n        const key = `${providerId}:${rawId}`;\n        errors_1.assert(!existingProviderAccounts.has(key), `DUPLICATE_RAW_ID : Provider id(${providerId}), Raw id(${rawId})`);\n        existingProviderAccounts.add(key);\n      }\n    }\n  }\n\n  if (!reqBody.allowOverwrite) {\n    const existingLocalIds = new Set();\n\n    for (const userInfo of reqBody.users) {\n      const localId = userInfo.localId || \"\";\n      errors_1.assert(!existingLocalIds.has(localId), `DUPLICATE_LOCAL_ID : ${localId}`);\n      existingLocalIds.add(localId);\n    }\n  }\n\n  const errors = [];\n\n  for (let index = 0; index < reqBody.users.length; index++) {\n    const userInfo = reqBody.users[index];\n\n    try {\n      errors_1.assert(userInfo.localId, \"localId is missing\");\n      const uploadTime = new Date();\n      const fields = {\n        displayName: userInfo.displayName,\n        photoUrl: userInfo.photoUrl,\n        lastLoginAt: userInfo.lastLoginAt\n      };\n\n      if (userInfo.passwordHash) {\n        fields.passwordHash = userInfo.passwordHash;\n        fields.salt = userInfo.salt;\n        fields.passwordUpdatedAt = uploadTime.getTime();\n      } else if (userInfo.rawPassword) {\n        fields.salt = userInfo.salt || \"fakeSalt\" + utils_1.randomId(20);\n        fields.passwordHash = hashPassword(userInfo.rawPassword, fields.salt);\n        fields.passwordUpdatedAt = uploadTime.getTime();\n      }\n\n      if (userInfo.customAttributes) {\n        validateSerializedCustomClaims(userInfo.customAttributes);\n        fields.customAttributes = userInfo.customAttributes;\n      }\n\n      if (userInfo.providerUserInfo) {\n        fields.providerUserInfo = [];\n\n        for (const providerUserInfo of userInfo.providerUserInfo) {\n          const {\n            providerId,\n            rawId,\n            federatedId\n          } = providerUserInfo;\n\n          if (providerId === state_1.PROVIDER_PASSWORD || providerId === state_1.PROVIDER_PHONE) {\n            continue;\n          }\n\n          if (!rawId || !providerId) {\n            if (!federatedId) {\n              errors_1.assert(false, \"federatedId or (providerId & rawId) is required\");\n            } else {\n              errors_1.assert(false, \"((Parsing federatedId is not implemented in Auth Emulator; please specify providerId AND rawId as a workaround.))\");\n            }\n          }\n\n          const existingUserWithRawId = state.getUserByProviderRawId(providerId, rawId);\n          errors_1.assert(!existingUserWithRawId || existingUserWithRawId.localId === userInfo.localId, \"raw id exists in other account in database\");\n          fields.providerUserInfo.push(Object.assign(Object.assign({}, providerUserInfo), {\n            providerId,\n            rawId\n          }));\n        }\n      }\n\n      if (userInfo.phoneNumber) {\n        errors_1.assert(utils_1.isValidPhoneNumber(userInfo.phoneNumber), \"phone number format is invalid\");\n        fields.phoneNumber = userInfo.phoneNumber;\n      }\n\n      fields.validSince = utils_1.toUnixTimestamp(uploadTime).toString();\n      fields.createdAt = uploadTime.getTime().toString();\n\n      if (fields.createdAt && !isNaN(Number(userInfo.createdAt))) {\n        fields.createdAt = userInfo.createdAt;\n      }\n\n      if (userInfo.email) {\n        const email = userInfo.email;\n        errors_1.assert(utils_1.isValidEmailAddress(email), \"email is invalid\");\n        const existingUserWithEmail = state.getUserByEmail(email);\n        errors_1.assert(!existingUserWithEmail || existingUserWithEmail.localId === userInfo.localId, reqBody.sanityCheck && state.oneAccountPerEmail ? \"email exists in other account in database\" : `((Auth Emulator does not support importing duplicate email: ${email}))`);\n        fields.email = utils_1.canonicalizeEmailAddress(email);\n      }\n\n      fields.emailVerified = !!userInfo.emailVerified;\n      fields.disabled = !!userInfo.disabled;\n\n      if (state.getUserByLocalId(userInfo.localId)) {\n        errors_1.assert(reqBody.allowOverwrite, \"localId belongs to an existing account - can not overwrite.\");\n      }\n\n      state.overwriteUserWithLocalId(userInfo.localId, fields);\n    } catch (e) {\n      if (e instanceof errors_1.BadRequestError) {\n        let message = e.message;\n\n        if (message === \"INVALID_CLAIMS\") {\n          message = \"Invalid custom claims provided.\";\n        } else if (message === \"CLAIMS_TOO_LARGE\") {\n          message = \"Custom claims provided are too large.\";\n        } else if (message.startsWith(\"FORBIDDEN_CLAIM\")) {\n          message = \"Custom claims provided include a reserved claim.\";\n        }\n\n        errors.push({\n          index,\n          message\n        });\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  return {\n    kind: \"identitytoolkit#UploadAccountResponse\",\n    error: errors\n  };\n}\n\nfunction batchDelete(state, reqBody) {\n  var _a;\n\n  const errors = [];\n  const localIds = (_a = reqBody.localIds) !== null && _a !== void 0 ? _a : [];\n  errors_1.assert(localIds.length > 0 && localIds.length <= 1000, \"LOCAL_ID_LIST_EXCEEDS_LIMIT\");\n\n  for (let index = 0; index < localIds.length; index++) {\n    const localId = localIds[index];\n    const user = state.getUserByLocalId(localId);\n\n    if (!user) {\n      continue;\n    } else if (!user.disabled && !reqBody.force) {\n      errors.push({\n        index,\n        localId,\n        message: \"NOT_DISABLED : Disable the account before batch deletion.\"\n      });\n    } else {\n      state.deleteUser(user);\n    }\n  }\n\n  return {\n    errors: errors.length ? errors : undefined\n  };\n}\n\nfunction batchGet(state, reqBody, ctx) {\n  const maxResults = Math.min(Math.floor(ctx.params.query.maxResults) || 20, 1000);\n  const users = state.queryUsers({}, {\n    sortByField: \"localId\",\n    order: \"ASC\",\n    startToken: ctx.params.query.nextPageToken\n  });\n  let newPageToken = undefined;\n\n  if (maxResults >= 0 && users.length >= maxResults) {\n    users.length = maxResults;\n\n    if (users.length) {\n      newPageToken = users[users.length - 1].localId;\n    }\n  }\n\n  return {\n    kind: \"identitytoolkit#DownloadAccountResponse\",\n    users,\n    nextPageToken: newPageToken\n  };\n}\n\nfunction createAuthUri(state, reqBody) {\n  var _a;\n\n  const sessionId = reqBody.sessionId || utils_1.randomId(27);\n\n  if (reqBody.providerId) {\n    throw new errors_1.NotImplementedError(\"Sign-in with IDP is not yet supported.\");\n  }\n\n  errors_1.assert(reqBody.identifier, \"MISSING_IDENTIFIER\");\n  errors_1.assert(reqBody.continueUri, \"MISSING_CONTINUE_URI\");\n  errors_1.assert(utils_1.isValidEmailAddress(reqBody.identifier), \"INVALID_IDENTIFIER\");\n  const email = utils_1.canonicalizeEmailAddress(reqBody.identifier);\n  errors_1.assert(utils_1.parseAbsoluteUri(reqBody.continueUri), \"INVALID_CONTINUE_URI\");\n  const allProviders = [];\n  const signinMethods = [];\n  let registered = false;\n  const users = state.getUsersByEmailOrProviderEmail(email);\n\n  if (state.oneAccountPerEmail) {\n    if (users.length) {\n      registered = true;\n      (_a = users[0].providerUserInfo) === null || _a === void 0 ? void 0 : _a.forEach(({\n        providerId\n      }) => {\n        if (providerId === state_1.PROVIDER_PASSWORD) {\n          allProviders.push(providerId);\n\n          if (users[0].passwordHash) {\n            signinMethods.push(state_1.PROVIDER_PASSWORD);\n          }\n\n          if (users[0].emailLinkSignin) {\n            signinMethods.push(state_1.SIGNIN_METHOD_EMAIL_LINK);\n          }\n        } else if (providerId !== state_1.PROVIDER_PHONE) {\n          allProviders.push(providerId);\n          signinMethods.push(providerId);\n        }\n      });\n    }\n  } else {\n    const user = users.find(u => u.email);\n\n    if (user) {\n      registered = true;\n\n      if (user.passwordHash || user.emailLinkSignin) {\n        allProviders.push(state_1.PROVIDER_PASSWORD);\n\n        if (users[0].passwordHash) {\n          signinMethods.push(state_1.PROVIDER_PASSWORD);\n        }\n\n        if (users[0].emailLinkSignin) {\n          signinMethods.push(state_1.SIGNIN_METHOD_EMAIL_LINK);\n        }\n      }\n    }\n  }\n\n  return {\n    kind: \"identitytoolkit#CreateAuthUriResponse\",\n    registered,\n    allProviders,\n    sessionId,\n    signinMethods\n  };\n}\n\nconst SESSION_COOKIE_MIN_VALID_DURATION = 5 * 60;\nexports.SESSION_COOKIE_MAX_VALID_DURATION = 14 * 24 * 60 * 60;\n\nfunction createSessionCookie(state, reqBody, ctx) {\n  errors_1.assert(reqBody.idToken, \"MISSING_ID_TOKEN\");\n  const validDuration = Number(reqBody.validDuration) || exports.SESSION_COOKIE_MAX_VALID_DURATION;\n  errors_1.assert(validDuration >= SESSION_COOKIE_MIN_VALID_DURATION && validDuration <= exports.SESSION_COOKIE_MAX_VALID_DURATION, \"INVALID_DURATION\");\n  const {\n    payload\n  } = parseIdToken(state, reqBody.idToken);\n  const issuedAt = utils_1.toUnixTimestamp(new Date());\n  const expiresAt = issuedAt + validDuration;\n  const sessionCookie = jsonwebtoken_1.sign(Object.assign(Object.assign({}, payload), {\n    iat: issuedAt,\n    exp: expiresAt,\n    iss: `https://session.firebase.google.com/${payload.aud}`\n  }), \"\", {\n    algorithm: \"none\"\n  });\n  return {\n    sessionCookie\n  };\n}\n\nfunction deleteAccount(state, reqBody, ctx) {\n  var _a;\n\n  let user;\n\n  if ((_a = ctx.security) === null || _a === void 0 ? void 0 : _a.Oauth2) {\n    errors_1.assert(reqBody.localId, \"MISSING_LOCAL_ID\");\n    const maybeUser = state.getUserByLocalId(reqBody.localId);\n    errors_1.assert(maybeUser, \"USER_NOT_FOUND\");\n    user = maybeUser;\n  } else {\n    errors_1.assert(reqBody.idToken, \"MISSING_ID_TOKEN\");\n    user = parseIdToken(state, reqBody.idToken).user;\n  }\n\n  state.deleteUser(user);\n  return {\n    kind: \"identitytoolkit#DeleteAccountResponse\"\n  };\n}\n\nfunction getProjects(state) {\n  return {\n    projectId: state.projectNumber,\n    authorizedDomains: [\"localhost\"]\n  };\n}\n\nfunction getRecaptchaParams() {\n  return {\n    kind: \"identitytoolkit#GetRecaptchaParamResponse\",\n    recaptchaStoken: \"This-is-a-fake-token__Dont-send-this-to-the-Recaptcha-service__The-Auth-Emulator-does-not-support-Recaptcha\",\n    recaptchaSiteKey: \"Fake-key__Do-not-send-this-to-Recaptcha_\"\n  };\n}\n\nfunction queryAccounts(state, reqBody) {\n  var _a;\n\n  if ((_a = reqBody.expression) === null || _a === void 0 ? void 0 : _a.length) {\n    throw new errors_1.NotImplementedError(\"expression is not implemented.\");\n  }\n\n  if (reqBody.returnUserInfo === false) {\n    return {\n      recordsCount: state.getUserCount().toString()\n    };\n  }\n\n  if (reqBody.limit) {\n    throw new errors_1.NotImplementedError(\"limit is not implemented.\");\n  }\n\n  reqBody.offset = reqBody.offset || \"0\";\n\n  if (reqBody.offset !== \"0\") {\n    throw new errors_1.NotImplementedError(\"offset is not implemented.\");\n  }\n\n  if (!reqBody.order || reqBody.order === \"ORDER_UNSPECIFIED\") {\n    reqBody.order = \"ASC\";\n  }\n\n  if (!reqBody.sortBy || reqBody.sortBy === \"SORT_BY_FIELD_UNSPECIFIED\") {\n    reqBody.sortBy = \"USER_ID\";\n  }\n\n  let sortByField;\n\n  if (reqBody.sortBy === \"USER_ID\") {\n    sortByField = \"localId\";\n  } else {\n    throw new errors_1.NotImplementedError(\"Only sorting by USER_ID is implemented.\");\n  }\n\n  const users = state.queryUsers({}, {\n    order: reqBody.order,\n    sortByField\n  });\n  return {\n    recordsCount: users.length.toString(),\n    userInfo: users\n  };\n}\n\nfunction resetPassword(state, reqBody) {\n  var _a;\n\n  errors_1.assert(reqBody.oobCode, \"MISSING_OOB_CODE\");\n  const oob = state.validateOobCode(reqBody.oobCode);\n  errors_1.assert(oob, \"INVALID_OOB_CODE\");\n\n  if (reqBody.newPassword) {\n    errors_1.assert(oob.requestType === \"PASSWORD_RESET\", \"INVALID_OOB_CODE\");\n    errors_1.assert(reqBody.newPassword.length >= PASSWORD_MIN_LENGTH, `WEAK_PASSWORD : Password should be at least ${PASSWORD_MIN_LENGTH} characters`);\n    state.deleteOobCode(reqBody.oobCode);\n    const user = state.getUserByEmail(oob.email);\n    errors_1.assert(user, \"INVALID_OOB_CODE\");\n    const salt = \"fakeSalt\" + utils_1.randomId(20);\n    const passwordHash = hashPassword(reqBody.newPassword, salt);\n    state.updateUserByLocalId(user.localId, {\n      emailVerified: true,\n      passwordHash,\n      salt,\n      passwordUpdatedAt: Date.now(),\n      validSince: utils_1.toUnixTimestamp(new Date()).toString()\n    }, {\n      deleteProviders: (_a = user.providerUserInfo) === null || _a === void 0 ? void 0 : _a.map(info => info.providerId)\n    });\n  }\n\n  return {\n    kind: \"identitytoolkit#ResetPasswordResponse\",\n    requestType: oob.requestType,\n    email: oob.requestType === \"EMAIL_SIGNIN\" ? undefined : oob.email\n  };\n}\n\nexports.resetPassword = resetPassword;\n\nfunction sendOobCode(state, reqBody, ctx) {\n  var _a;\n\n  errors_1.assert(reqBody.requestType && reqBody.requestType !== \"OOB_REQ_TYPE_UNSPECIFIED\", \"MISSING_REQ_TYPE\");\n\n  if (reqBody.returnOobLink) {\n    errors_1.assert((_a = ctx.security) === null || _a === void 0 ? void 0 : _a.Oauth2, \"INSUFFICIENT_PERMISSION\");\n  }\n\n  if (reqBody.continueUrl) {\n    errors_1.assert(utils_1.parseAbsoluteUri(reqBody.continueUrl), \"INVALID_CONTINUE_URI: ((expected an absolute URI with valid scheme and host))\");\n  }\n\n  let email;\n  let mode;\n\n  switch (reqBody.requestType) {\n    case \"EMAIL_SIGNIN\":\n      mode = \"signIn\";\n      errors_1.assert(reqBody.email, \"MISSING_EMAIL\");\n      email = utils_1.canonicalizeEmailAddress(reqBody.email);\n      break;\n\n    case \"PASSWORD_RESET\":\n      mode = \"resetPassword\";\n      errors_1.assert(reqBody.email, \"MISSING_EMAIL\");\n      email = utils_1.canonicalizeEmailAddress(reqBody.email);\n      errors_1.assert(state.getUserByEmail(email), \"EMAIL_NOT_FOUND\");\n      break;\n\n    case \"VERIFY_EMAIL\":\n      mode = \"verifyEmail\";\n\n      if (reqBody.returnOobLink && !reqBody.idToken) {\n        errors_1.assert(reqBody.email, \"MISSING_EMAIL\");\n        email = utils_1.canonicalizeEmailAddress(reqBody.email);\n        const maybeUser = state.getUserByEmail(email);\n        errors_1.assert(maybeUser, \"USER_NOT_FOUND\");\n      } else {\n        const user = parseIdToken(state, reqBody.idToken || \"\").user;\n        errors_1.assert(user.email, \"MISSING_EMAIL\");\n        email = user.email;\n      }\n\n      break;\n\n    default:\n      throw new errors_1.NotImplementedError(reqBody.requestType);\n  }\n\n  if (reqBody.canHandleCodeInApp) {\n    emulatorLogger_1.EmulatorLogger.forEmulator(types_1.Emulators.AUTH).log(\"WARN\", \"canHandleCodeInApp is unsupported in Auth Emulator. All OOB operations will complete via web.\");\n  }\n\n  const url = utils_1.authEmulatorUrl(ctx.req);\n  const oobRecord = createOobRecord(state, email, url, {\n    requestType: reqBody.requestType,\n    mode,\n    continueUrl: reqBody.continueUrl\n  });\n\n  if (reqBody.returnOobLink) {\n    return {\n      kind: \"identitytoolkit#GetOobConfirmationCodeResponse\",\n      email,\n      oobCode: oobRecord.oobCode,\n      oobLink: oobRecord.oobLink\n    };\n  } else {\n    logOobMessage(oobRecord);\n    return {\n      kind: \"identitytoolkit#GetOobConfirmationCodeResponse\",\n      email\n    };\n  }\n}\n\nfunction sendVerificationCode(state, reqBody) {\n  errors_1.assert(reqBody.phoneNumber && utils_1.isValidPhoneNumber(reqBody.phoneNumber), \"INVALID_PHONE_NUMBER : Invalid format.\");\n  const {\n    sessionInfo,\n    phoneNumber,\n    code\n  } = state.createVerificationCode(reqBody.phoneNumber);\n  emulatorLogger_1.EmulatorLogger.forEmulator(types_1.Emulators.AUTH).log(\"BULLET\", `To verify the phone number ${phoneNumber}, use the code ${code}.`);\n  return {\n    sessionInfo\n  };\n}\n\nfunction setAccountInfo(state, reqBody, ctx) {\n  var _a;\n\n  const url = utils_1.authEmulatorUrl(ctx.req);\n  return setAccountInfoImpl(state, reqBody, {\n    privileged: !!((_a = ctx.security) === null || _a === void 0 ? void 0 : _a.Oauth2),\n    emulatorUrl: url\n  });\n}\n\nfunction setAccountInfoImpl(state, reqBody, {\n  privileged = false,\n  emulatorUrl = undefined\n} = {}) {\n  var _a, _b;\n\n  const unimplementedFields = [\"provider\", \"upgradeToFederatedLogin\", \"captchaChallenge\", \"captchaResponse\", \"linkProviderUserInfo\"];\n\n  for (const field of unimplementedFields) {\n    if (field in reqBody) {\n      throw new errors_1.NotImplementedError(`${field} is not implemented yet.`);\n    }\n  }\n\n  if (!privileged) {\n    errors_1.assert(reqBody.idToken || reqBody.oobCode, \"INVALID_REQ_TYPE : Unsupported request parameters.\");\n    errors_1.assert(reqBody.customAttributes == null, \"INSUFFICIENT_PERMISSION\");\n  } else {\n    errors_1.assert(reqBody.localId, \"MISSING_LOCAL_ID\");\n  }\n\n  if (reqBody.customAttributes) {\n    validateSerializedCustomClaims(reqBody.customAttributes);\n  }\n\n  reqBody.deleteAttribute = reqBody.deleteAttribute || [];\n\n  for (const attr of reqBody.deleteAttribute) {\n    if (attr === \"PROVIDER\" || attr === \"RAW_USER_INFO\") {\n      throw new errors_1.NotImplementedError(`deleteAttribute: ${attr}`);\n    }\n  }\n\n  const updates = {};\n  let user;\n  let signInProvider;\n  let isEmailUpdate = false;\n\n  if (reqBody.oobCode) {\n    const oob = state.validateOobCode(reqBody.oobCode);\n    errors_1.assert(oob, \"INVALID_OOB_CODE\");\n\n    switch (oob.requestType) {\n      case \"VERIFY_EMAIL\":\n        {\n          state.deleteOobCode(reqBody.oobCode);\n          signInProvider = state_1.PROVIDER_PASSWORD;\n          const maybeUser = state.getUserByEmail(oob.email);\n          errors_1.assert(maybeUser, \"INVALID_OOB_CODE\");\n          user = maybeUser;\n          updates.emailVerified = true;\n\n          if (oob.email !== user.email) {\n            updates.email = oob.email;\n          }\n\n          break;\n        }\n\n      case \"RECOVER_EMAIL\":\n        {\n          state.deleteOobCode(reqBody.oobCode);\n          const maybeUser = state.getUserByInitialEmail(oob.email);\n          errors_1.assert(maybeUser, \"INVALID_OOB_CODE\");\n          errors_1.assert(!state.getUserByEmail(oob.email), \"EMAIL_EXISTS\");\n          user = maybeUser;\n\n          if (oob.email !== user.email) {\n            updates.email = oob.email;\n            updates.emailVerified = true;\n          }\n\n          break;\n        }\n\n      default:\n        throw new errors_1.NotImplementedError(oob.requestType);\n    }\n  } else {\n    if (reqBody.idToken) {\n      ({\n        user,\n        signInProvider\n      } = parseIdToken(state, reqBody.idToken));\n      errors_1.assert(reqBody.disableUser == null, \"OPERATION_NOT_ALLOWED\");\n    } else {\n      errors_1.assert(reqBody.localId, \"MISSING_LOCAL_ID\");\n      const maybeUser = state.getUserByLocalId(reqBody.localId);\n      errors_1.assert(maybeUser, \"USER_NOT_FOUND\");\n      user = maybeUser;\n    }\n\n    if (reqBody.email) {\n      errors_1.assert(utils_1.isValidEmailAddress(reqBody.email), \"INVALID_EMAIL\");\n      const newEmail = utils_1.canonicalizeEmailAddress(reqBody.email);\n\n      if (newEmail !== user.email) {\n        errors_1.assert(!state.getUserByEmail(newEmail), \"EMAIL_EXISTS\");\n        updates.email = newEmail;\n        updates.emailVerified = false;\n        isEmailUpdate = true;\n\n        if (signInProvider !== state_1.PROVIDER_ANONYMOUS && user.email && !user.initialEmail) {\n          updates.initialEmail = user.email;\n        }\n      }\n    }\n\n    if (reqBody.password) {\n      errors_1.assert(reqBody.password.length >= PASSWORD_MIN_LENGTH, `WEAK_PASSWORD : Password should be at least ${PASSWORD_MIN_LENGTH} characters`);\n      updates.salt = \"fakeSalt\" + utils_1.randomId(20);\n      updates.passwordHash = hashPassword(reqBody.password, updates.salt);\n      updates.passwordUpdatedAt = Date.now();\n      signInProvider = state_1.PROVIDER_PASSWORD;\n    }\n\n    if (reqBody.password || reqBody.validSince || updates.email) {\n      updates.validSince = utils_1.toUnixTimestamp(new Date()).toString();\n    }\n\n    if (reqBody.mfa) {\n      if (reqBody.mfa.enrollments && reqBody.mfa.enrollments.length > 0) {\n        updates.mfaInfo = getMfaEnrollmentsFromRequest(state, reqBody.mfa.enrollments);\n      } else {\n        updates.mfaInfo = undefined;\n      }\n    }\n\n    const fieldsToCopy = [\"displayName\", \"photoUrl\"];\n\n    if (privileged) {\n      if (reqBody.disableUser != null) {\n        updates.disabled = reqBody.disableUser;\n      }\n\n      if (reqBody.phoneNumber && reqBody.phoneNumber !== user.phoneNumber) {\n        errors_1.assert(utils_1.isValidPhoneNumber(reqBody.phoneNumber), \"INVALID_PHONE_NUMBER : Invalid format.\");\n        errors_1.assert(!state.getUserByPhoneNumber(reqBody.phoneNumber), \"PHONE_NUMBER_EXISTS\");\n        updates.phoneNumber = reqBody.phoneNumber;\n      }\n\n      fieldsToCopy.push(\"emailVerified\", \"customAttributes\", \"createdAt\", \"lastLoginAt\", \"validSince\");\n    }\n\n    for (const field of fieldsToCopy) {\n      if (reqBody[field] != null) {\n        utils_1.mirrorFieldTo(updates, field, reqBody);\n      }\n    }\n\n    for (const attr of reqBody.deleteAttribute) {\n      switch (attr) {\n        case \"USER_ATTRIBUTE_NAME_UNSPECIFIED\":\n          continue;\n\n        case \"DISPLAY_NAME\":\n          updates.displayName = undefined;\n          break;\n\n        case \"PHOTO_URL\":\n          updates.photoUrl = undefined;\n          break;\n\n        case \"PASSWORD\":\n          updates.passwordHash = undefined;\n          updates.salt = undefined;\n          break;\n\n        case \"EMAIL\":\n          updates.email = undefined;\n          updates.emailVerified = undefined;\n          updates.emailLinkSignin = undefined;\n          break;\n      }\n    }\n\n    if ((_a = reqBody.deleteProvider) === null || _a === void 0 ? void 0 : _a.includes(state_1.PROVIDER_PASSWORD)) {\n      updates.email = undefined;\n      updates.emailVerified = undefined;\n      updates.emailLinkSignin = undefined;\n      updates.passwordHash = undefined;\n      updates.salt = undefined;\n    }\n\n    if ((_b = reqBody.deleteProvider) === null || _b === void 0 ? void 0 : _b.includes(state_1.PROVIDER_PHONE)) {\n      updates.phoneNumber = undefined;\n    }\n  }\n\n  user = state.updateUserByLocalId(user.localId, updates, {\n    deleteProviders: reqBody.deleteProvider\n  });\n\n  if (signInProvider !== state_1.PROVIDER_ANONYMOUS && user.initialEmail && isEmailUpdate) {\n    if (!emulatorUrl) {\n      throw new Error(\"Internal assertion error: missing emulatorUrl param\");\n    }\n\n    sendOobForEmailReset(state, user.initialEmail, emulatorUrl);\n  }\n\n  return redactPasswordHash(Object.assign({\n    kind: \"identitytoolkit#SetAccountInfoResponse\",\n    localId: user.localId,\n    emailVerified: user.emailVerified,\n    providerUserInfo: user.providerUserInfo,\n    email: user.email,\n    displayName: user.displayName,\n    photoUrl: user.photoUrl,\n    passwordHash: user.passwordHash\n  }, updates.validSince && signInProvider ? issueTokens(state, user, signInProvider) : {}));\n}\n\nexports.setAccountInfoImpl = setAccountInfoImpl;\n\nfunction sendOobForEmailReset(state, initialEmail, url) {\n  const oobRecord = createOobRecord(state, initialEmail, url, {\n    requestType: \"RECOVER_EMAIL\",\n    mode: \"recoverEmail\"\n  });\n  logOobMessage(oobRecord);\n}\n\nfunction createOobRecord(state, email, url, params) {\n  const oobRecord = state.createOob(email, params.requestType, oobCode => {\n    url.pathname = \"/emulator/action\";\n    url.searchParams.set(\"mode\", params.mode);\n    url.searchParams.set(\"lang\", \"en\");\n    url.searchParams.set(\"oobCode\", oobCode);\n    url.searchParams.set(\"apiKey\", \"fake-api-key\");\n\n    if (params.continueUrl) {\n      url.searchParams.set(\"continueUrl\", params.continueUrl);\n    }\n\n    return url.toString();\n  });\n  return oobRecord;\n}\n\nfunction logOobMessage(oobRecord) {\n  const oobLink = oobRecord.oobLink;\n  const email = oobRecord.email;\n  let maybeMessage;\n\n  switch (oobRecord.requestType) {\n    case \"EMAIL_SIGNIN\":\n      maybeMessage = `To sign in as ${email}, follow this link: ${oobLink}`;\n      break;\n\n    case \"PASSWORD_RESET\":\n      maybeMessage = `To reset the password for ${email}, follow this link: ${oobLink}&newPassword=NEW_PASSWORD_HERE`;\n      break;\n\n    case \"VERIFY_EMAIL\":\n      maybeMessage = `To verify the email address ${email}, follow this link: ${oobLink}`;\n      break;\n\n    case \"RECOVER_EMAIL\":\n      maybeMessage = `To reset your email address to ${email}, follow this link: ${oobLink}`;\n      break;\n  }\n\n  if (maybeMessage) {\n    emulatorLogger_1.EmulatorLogger.forEmulator(types_1.Emulators.AUTH).log(\"BULLET\", maybeMessage);\n  }\n}\n\nfunction signInWithCustomToken(state, reqBody) {\n  var _a;\n\n  errors_1.assert(reqBody.token, \"MISSING_CUSTOM_TOKEN\");\n  let payload;\n\n  if (reqBody.token.startsWith(\"{\")) {\n    try {\n      payload = JSON.parse(reqBody.token);\n    } catch (_b) {\n      throw new errors_1.BadRequestError(\"INVALID_CUSTOM_TOKEN : ((Auth Emulator only accepts strict JSON or JWTs as fake custom tokens.))\");\n    }\n  } else {\n    const decoded = jsonwebtoken_1.decode(reqBody.token, {\n      complete: true\n    });\n    errors_1.assert(decoded, \"INVALID_CUSTOM_TOKEN : Invalid assertion format\");\n\n    if (decoded.header.alg !== \"none\") {\n      emulatorLogger_1.EmulatorLogger.forEmulator(types_1.Emulators.AUTH).log(\"WARN\", \"Received a signed custom token. Auth Emulator does not validate JWTs and IS NOT SECURE\");\n    }\n\n    errors_1.assert(decoded.payload.aud === exports.CUSTOM_TOKEN_AUDIENCE, `INVALID_CUSTOM_TOKEN : ((Invalid aud (audience): ${decoded.payload.aud} ` + \"Note: Firebase ID Tokens / third-party tokens cannot be used with signInWithCustomToken.))\");\n    payload = decoded.payload;\n  }\n\n  const localId = (_a = coercePrimitiveToString(payload.uid)) !== null && _a !== void 0 ? _a : coercePrimitiveToString(payload.user_id);\n  errors_1.assert(localId, \"MISSING_IDENTIFIER\");\n  let claims = {};\n\n  if (\"claims\" in payload) {\n    validateCustomClaims(payload.claims);\n    claims = payload.claims;\n  }\n\n  let user = state.getUserByLocalId(localId);\n  const isNewUser = !user;\n  const updates = {\n    customAuth: true,\n    lastLoginAt: Date.now().toString()\n  };\n\n  if (user) {\n    errors_1.assert(!user.disabled, \"USER_DISABLED\");\n    user = state.updateUserByLocalId(localId, updates);\n  } else {\n    user = state.createUserWithLocalId(localId, updates);\n\n    if (!user) {\n      throw new Error(`Internal assertion error: trying to create duplicate localId: ${localId}`);\n    }\n  }\n\n  if (user.mfaInfo) {\n    throw new errors_1.NotImplementedError(\"MFA Login not yet implemented.\");\n  }\n\n  return Object.assign({\n    kind: \"identitytoolkit#VerifyCustomTokenResponse\",\n    isNewUser\n  }, issueTokens(state, user, state_1.PROVIDER_CUSTOM, claims));\n}\n\nfunction signInWithEmailLink(state, reqBody) {\n  const userFromIdToken = reqBody.idToken ? parseIdToken(state, reqBody.idToken).user : undefined;\n  errors_1.assert(reqBody.email, \"MISSING_EMAIL\");\n  const email = utils_1.canonicalizeEmailAddress(reqBody.email);\n  errors_1.assert(reqBody.oobCode, \"MISSING_OOB_CODE\");\n  const oob = state.validateOobCode(reqBody.oobCode);\n  errors_1.assert(oob && oob.requestType === \"EMAIL_SIGNIN\", \"INVALID_OOB_CODE\");\n  errors_1.assert(email === oob.email, \"INVALID_EMAIL : The email provided does not match the sign-in email address.\");\n  state.deleteOobCode(reqBody.oobCode);\n  const updates = {\n    email,\n    emailVerified: true,\n    emailLinkSignin: true,\n    lastLoginAt: Date.now().toString()\n  };\n  let user = state.getUserByEmail(email);\n  const isNewUser = !user && !userFromIdToken;\n\n  if (!user) {\n    if (userFromIdToken) {\n      user = state.updateUserByLocalId(userFromIdToken.localId, updates);\n    } else {\n      user = state.createUser(updates);\n    }\n  } else {\n    errors_1.assert(!user.disabled, \"USER_DISABLED\");\n    errors_1.assert(!userFromIdToken || userFromIdToken.localId === user.localId, \"EMAIL_EXISTS\");\n    user = state.updateUserByLocalId(user.localId, updates);\n  }\n\n  if (user.mfaInfo) {\n    throw new errors_1.NotImplementedError(\"MFA Login not yet implemented.\");\n  }\n\n  const tokens = issueTokens(state, user, state_1.PROVIDER_PASSWORD);\n  return Object.assign({\n    kind: \"identitytoolkit#EmailLinkSigninResponse\",\n    email,\n    localId: user.localId,\n    isNewUser\n  }, tokens);\n}\n\nfunction signInWithIdp(state, reqBody) {\n  var _a;\n\n  if (reqBody.returnRefreshToken) {\n    throw new errors_1.NotImplementedError(\"returnRefreshToken is not implemented yet.\");\n  }\n\n  if (reqBody.pendingIdToken) {\n    throw new errors_1.NotImplementedError(\"pendingIdToken is not implemented yet.\");\n  }\n\n  const normalizedUri = getNormalizedUri(reqBody);\n  const providerId = (_a = normalizedUri.searchParams.get(\"providerId\")) === null || _a === void 0 ? void 0 : _a.toLowerCase();\n  errors_1.assert(providerId, `INVALID_CREDENTIAL_OR_PROVIDER_ID : Invalid IdP response/credential: ${normalizedUri.toString()}`);\n  const oauthIdToken = normalizedUri.searchParams.get(\"id_token\") || undefined;\n  const oauthAccessToken = normalizedUri.searchParams.get(\"access_token\") || undefined;\n  const claims = parseClaims(oauthIdToken) || parseClaims(oauthAccessToken);\n\n  if (!claims) {\n    if (oauthIdToken) {\n      throw new errors_1.BadRequestError(`INVALID_IDP_RESPONSE : Unable to parse id_token: ${oauthIdToken} ((Auth Emulator only accepts strict JSON or JWTs as fake id_tokens.))`);\n    } else if (oauthAccessToken) {\n      if (providerId === \"google.com\" || providerId === \"apple.com\") {\n        throw new errors_1.NotImplementedError(`The Auth Emulator only support sign-in with ${providerId} using id_token, not access_token. Please update your code to use id_token.`);\n      } else {\n        throw new errors_1.NotImplementedError(`The Auth Emulator does not support ${providerId} sign-in with credentials.`);\n      }\n    } else {\n      throw new errors_1.NotImplementedError(\"The Auth Emulator only supports sign-in with credentials (id_token required).\");\n    }\n  }\n\n  let {\n    response,\n    rawId\n  } = fakeFetchUserInfoFromIdp(providerId, claims);\n  response.oauthAccessToken = oauthAccessToken || `FirebaseAuthEmulatorFakeAccessToken_${providerId}`;\n  response.oauthIdToken = oauthIdToken;\n  const userFromIdToken = reqBody.idToken ? parseIdToken(state, reqBody.idToken).user : undefined;\n  const userMatchingProvider = state.getUserByProviderRawId(providerId, rawId);\n  let accountUpdates;\n\n  try {\n    if (userFromIdToken) {\n      errors_1.assert(!userMatchingProvider, \"FEDERATED_USER_ID_ALREADY_LINKED\");\n      ({\n        accountUpdates,\n        response\n      } = handleLinkIdp(state, response, userFromIdToken));\n    } else if (state.oneAccountPerEmail) {\n      const userMatchingEmail = response.email ? state.getUserByEmail(response.email) : undefined;\n      ({\n        accountUpdates,\n        response\n      } = handleIdpSigninEmailRequired(response, rawId, userMatchingProvider, userMatchingEmail));\n    } else {\n      ({\n        accountUpdates,\n        response\n      } = handleIdpSigninEmailNotRequired(response, userMatchingProvider));\n    }\n  } catch (err) {\n    if (reqBody.returnIdpCredential && err instanceof errors_1.BadRequestError) {\n      response.errorMessage = err.message;\n      return response;\n    } else {\n      throw err;\n    }\n  }\n\n  if (response.needConfirmation) {\n    return response;\n  }\n\n  const providerUserInfo = {\n    providerId,\n    rawId,\n    federatedId: rawId,\n    displayName: response.displayName,\n    photoUrl: response.photoUrl,\n    email: response.email,\n    screenName: response.screenName\n  };\n  let user;\n\n  if (response.isNewUser) {\n    user = state.createUser(Object.assign(Object.assign({}, accountUpdates.fields), {\n      lastLoginAt: Date.now().toString(),\n      providerUserInfo: [providerUserInfo]\n    }));\n    response.localId = user.localId;\n  } else {\n    if (!response.localId) {\n      throw new Error(\"Internal assertion error: localId not set for exising user.\");\n    }\n\n    user = state.updateUserByLocalId(response.localId, Object.assign(Object.assign({}, accountUpdates.fields), {\n      lastLoginAt: Date.now().toString()\n    }), {\n      upsertProviders: [providerUserInfo]\n    });\n  }\n\n  if (user.mfaInfo) {\n    throw new errors_1.NotImplementedError(\"MFA Login not yet implemented.\");\n  }\n\n  if (user.email === response.email) {\n    response.emailVerified = user.emailVerified;\n  }\n\n  Object.assign(response, issueTokens(state, user, providerId));\n  return response;\n}\n\nfunction signInWithPassword(state, reqBody) {\n  errors_1.assert(reqBody.email, \"MISSING_EMAIL\");\n  errors_1.assert(reqBody.password, \"MISSING_PASSWORD\");\n\n  if (reqBody.captchaResponse || reqBody.captchaChallenge) {\n    throw new errors_1.NotImplementedError(\"captcha unimplemented\");\n  }\n\n  if (reqBody.idToken || reqBody.pendingIdToken) {\n    throw new errors_1.NotImplementedError(\"idToken / pendingIdToken is no longer in use and unsupported by the Auth Emulator.\");\n  }\n\n  const email = utils_1.canonicalizeEmailAddress(reqBody.email);\n  let user = state.getUserByEmail(email);\n  errors_1.assert(user, \"EMAIL_NOT_FOUND\");\n  errors_1.assert(!user.disabled, \"USER_DISABLED\");\n  errors_1.assert(user.passwordHash && user.salt, \"INVALID_PASSWORD\");\n  errors_1.assert(user.passwordHash === hashPassword(reqBody.password, user.salt), \"INVALID_PASSWORD\");\n\n  if (user.mfaInfo) {\n    throw new errors_1.NotImplementedError(\"MFA Login not yet implemented.\");\n  }\n\n  user = state.updateUserByLocalId(user.localId, {\n    lastLoginAt: Date.now().toString()\n  });\n  const tokens = issueTokens(state, user, state_1.PROVIDER_PASSWORD);\n  return Object.assign({\n    kind: \"identitytoolkit#VerifyPasswordResponse\",\n    registered: true,\n    localId: user.localId,\n    email,\n    displayName: user.displayName,\n    profilePicture: user.photoUrl\n  }, tokens);\n}\n\nfunction signInWithPhoneNumber(state, reqBody) {\n  let phoneNumber;\n\n  if (reqBody.temporaryProof) {\n    errors_1.assert(reqBody.phoneNumber, \"MISSING_PHONE_NUMBER\");\n    const proof = state.validateTemporaryProof(reqBody.temporaryProof, reqBody.phoneNumber);\n    errors_1.assert(proof, \"INVALID_TEMPORARY_PROOF\");\n    ({\n      phoneNumber\n    } = proof);\n  } else {\n    errors_1.assert(reqBody.sessionInfo, \"MISSING_SESSION_INFO\");\n    errors_1.assert(reqBody.code, \"MISSING_CODE\");\n    phoneNumber = verifyPhoneNumber(state, reqBody.sessionInfo, reqBody.code);\n  }\n\n  let user = state.getUserByPhoneNumber(phoneNumber);\n  let isNewUser = false;\n  const updates = {\n    phoneNumber,\n    lastLoginAt: Date.now().toString()\n  };\n  const userFromIdToken = reqBody.idToken ? parseIdToken(state, reqBody.idToken).user : undefined;\n\n  if (!user) {\n    if (userFromIdToken) {\n      user = state.updateUserByLocalId(userFromIdToken.localId, updates);\n    } else {\n      isNewUser = true;\n      user = state.createUser(updates);\n    }\n  } else {\n    errors_1.assert(!user.disabled, \"USER_DISABLED\");\n\n    if (userFromIdToken && userFromIdToken.localId !== user.localId) {\n      if (!reqBody.temporaryProof) {\n        return Object.assign({}, state.createTemporaryProof(phoneNumber));\n      }\n\n      throw new errors_1.BadRequestError(\"PHONE_NUMBER_EXISTS\");\n    }\n\n    user = state.updateUserByLocalId(user.localId, updates);\n  }\n\n  if (user.mfaInfo) {\n    throw new errors_1.NotImplementedError(\"MFA Login not yet implemented.\");\n  }\n\n  const tokens = issueTokens(state, user, state_1.PROVIDER_PHONE);\n  return Object.assign({\n    isNewUser,\n    phoneNumber,\n    localId: user.localId\n  }, tokens);\n}\n\nfunction grantToken(state, reqBody) {\n  errors_1.assert(reqBody.grantType, \"MISSING_GRANT_TYPE\");\n  errors_1.assert(reqBody.grantType === \"refresh_token\", \"INVALID_GRANT_TYPE\");\n  errors_1.assert(reqBody.refreshToken, \"MISSING_REFRESH_TOKEN\");\n  const refreshTokenRecord = state.validateRefreshToken(reqBody.refreshToken);\n  errors_1.assert(refreshTokenRecord, \"INVALID_REFRESH_TOKEN\");\n  errors_1.assert(!refreshTokenRecord.user.disabled, \"USER_DISABLED\");\n  const tokens = issueTokens(state, refreshTokenRecord.user, refreshTokenRecord.provider, refreshTokenRecord.extraClaims);\n  return {\n    id_token: tokens.idToken,\n    access_token: tokens.idToken,\n    expires_in: tokens.expiresIn,\n    refresh_token: tokens.refreshToken,\n    token_type: \"Bearer\",\n    user_id: refreshTokenRecord.user.localId,\n    project_id: state.projectNumber\n  };\n}\n\nfunction deleteAllAccountsInProject(state) {\n  state.deleteAllAccounts();\n  return {};\n}\n\nfunction getEmulatorProjectConfig(state) {\n  return {\n    signIn: {\n      allowDuplicateEmails: !state.oneAccountPerEmail\n    }\n  };\n}\n\nfunction updateEmulatorProjectConfig(state, reqBody) {\n  var _a;\n\n  const allowDuplicateEmails = (_a = reqBody.signIn) === null || _a === void 0 ? void 0 : _a.allowDuplicateEmails;\n\n  if (allowDuplicateEmails != null) {\n    state.oneAccountPerEmail = !allowDuplicateEmails;\n  }\n\n  return getEmulatorProjectConfig(state);\n}\n\nfunction listOobCodesInProject(state) {\n  return {\n    oobCodes: [...state.listOobCodes()]\n  };\n}\n\nfunction listVerificationCodesInProject(state) {\n  return {\n    verificationCodes: [...state.listVerificationCodes()]\n  };\n}\n\nfunction coercePrimitiveToString(value) {\n  switch (typeof value) {\n    case \"string\":\n      return value;\n\n    case \"number\":\n    case \"boolean\":\n      return value.toString();\n\n    default:\n      return undefined;\n  }\n}\n\nfunction redactPasswordHash(user) {\n  return user;\n}\n\nfunction hashPassword(password, salt) {\n  return `fakeHash:salt=${salt}:password=${password}`;\n}\n\nfunction issueTokens(state, user, signInProvider, extraClaims = {}) {\n  state.updateUserByLocalId(user.localId, {\n    lastRefreshAt: new Date().toISOString()\n  });\n  const expiresInSeconds = 60 * 60;\n  const idToken = generateJwt(state.projectId, user, signInProvider, expiresInSeconds, extraClaims);\n  const refreshToken = state.createRefreshTokenFor(user, signInProvider, extraClaims);\n  return {\n    idToken,\n    refreshToken,\n    expiresIn: expiresInSeconds.toString()\n  };\n}\n\nfunction parseIdToken(state, idToken) {\n  const decoded = jsonwebtoken_1.decode(idToken, {\n    complete: true\n  });\n  errors_1.assert(decoded, \"INVALID_ID_TOKEN\");\n\n  if (decoded.header.alg !== \"none\") {\n    emulatorLogger_1.EmulatorLogger.forEmulator(types_1.Emulators.AUTH).log(\"WARN\", \"Received a signed JWT. Auth Emulator does not validate JWTs and IS NOT SECURE\");\n  }\n\n  const user = state.getUserByLocalId(decoded.payload.user_id);\n  errors_1.assert(user, \"USER_NOT_FOUND\");\n  errors_1.assert(!user.validSince || decoded.payload.iat >= Number(user.validSince), \"TOKEN_EXPIRED\");\n  errors_1.assert(!user.disabled, \"USER_DISABLED\");\n  const signInProvider = decoded.payload.firebase.sign_in_provider;\n  return {\n    user,\n    signInProvider,\n    payload: decoded.payload\n  };\n}\n\nfunction generateJwt(projectId, user, signInProvider, expiresInSeconds, extraClaims = {}) {\n  const identities = {};\n\n  if (user.email) {\n    identities[\"email\"] = [user.email];\n  }\n\n  if (user.providerUserInfo) {\n    for (const providerInfo of user.providerUserInfo) {\n      if (providerInfo.providerId && providerInfo.providerId !== state_1.PROVIDER_PASSWORD && providerInfo.rawId) {\n        const ids = identities[providerInfo.providerId] || [];\n        ids.push(providerInfo.rawId);\n        identities[providerInfo.providerId] = ids;\n      }\n    }\n  }\n\n  const customAttributes = JSON.parse(user.customAttributes || \"{}\");\n  const customPayloadFields = Object.assign(Object.assign(Object.assign({\n    name: user.displayName,\n    picture: user.photoUrl\n  }, customAttributes), extraClaims), {\n    email: user.email,\n    email_verified: user.emailVerified,\n    phone_number: user.phoneNumber,\n    provider_id: signInProvider === \"anonymous\" ? signInProvider : undefined,\n    auth_time: utils_1.toUnixTimestamp(getAuthTime(user)),\n    user_id: user.localId,\n    firebase: {\n      identities,\n      sign_in_provider: signInProvider\n    }\n  });\n  const jwtStr = jsonwebtoken_1.sign(customPayloadFields, \"\", {\n    algorithm: \"none\",\n    expiresIn: expiresInSeconds,\n    subject: user.localId,\n    issuer: `https://securetoken.google.com/${projectId}`,\n    audience: projectId\n  });\n  return jwtStr;\n}\n\nfunction getAuthTime(user) {\n  if (user.lastLoginAt != null) {\n    const millisSinceEpoch = parseInt(user.lastLoginAt, 10);\n    const authTime = new Date(millisSinceEpoch);\n\n    if (isNaN(authTime.getTime())) {\n      throw new Error(`Internal assertion error: invalid user.lastLoginAt = ${user.lastLoginAt}`);\n    }\n\n    return authTime;\n  } else if (user.lastRefreshAt != null) {\n    const authTime = new Date(user.lastRefreshAt);\n\n    if (isNaN(authTime.getTime())) {\n      throw new Error(`Internal assertion error: invalid user.lastRefreshAt = ${user.lastRefreshAt}`);\n    }\n\n    return authTime;\n  } else {\n    throw new Error(`Internal assertion error: Missing user.lastLoginAt and user.lastRefreshAt`);\n  }\n}\n\nfunction verifyPhoneNumber(state, sessionInfo, code) {\n  const verification = state.getVerificationCodeBySessionInfo(sessionInfo);\n  errors_1.assert(verification, \"INVALID_SESSION_INFO\");\n  errors_1.assert(verification.code === code, \"INVALID_CODE\");\n  state.deleteVerificationCodeBySessionInfo(sessionInfo);\n  return verification.phoneNumber;\n}\n\nconst CUSTOM_ATTRIBUTES_MAX_LENGTH = 1000;\n\nfunction validateSerializedCustomClaims(claims) {\n  errors_1.assert(claims.length <= CUSTOM_ATTRIBUTES_MAX_LENGTH, \"CLAIMS_TOO_LARGE\");\n  let parsed;\n\n  try {\n    parsed = JSON.parse(claims);\n  } catch (_a) {\n    throw new errors_1.BadRequestError(\"INVALID_CLAIMS\");\n  }\n\n  validateCustomClaims(parsed);\n}\n\nconst FORBIDDEN_CUSTOM_CLAIMS = [\"iss\", \"aud\", \"sub\", \"iat\", \"exp\", \"nbf\", \"jti\", \"nonce\", \"azp\", \"acr\", \"amr\", \"cnf\", \"auth_time\", \"firebase\", \"at_hash\", \"c_hash\"];\n\nfunction validateCustomClaims(claims) {\n  errors_1.assert(typeof claims === \"object\" && claims != null && !Array.isArray(claims), \"INVALID_CLAIMS\");\n\n  for (const reservedField of FORBIDDEN_CUSTOM_CLAIMS) {\n    errors_1.assert(!(reservedField in claims), `FORBIDDEN_CLAIM : ${reservedField}`);\n  }\n}\n\nfunction newRandomId(length, existingIds) {\n  for (let i = 0; i < 10; i++) {\n    const id = utils_1.randomId(length);\n\n    if (!(existingIds === null || existingIds === void 0 ? void 0 : existingIds.has(id))) {\n      return id;\n    }\n  }\n\n  throw new errors_1.InternalError(\"INTERNAL_ERROR : Failed to generate a random ID after 10 attempts\", \"INTERNAL\");\n}\n\nfunction getMfaEnrollmentsFromRequest(state, request, options) {\n  const enrollments = [];\n  const phoneNumbers = new Set();\n  const enrollmentIds = new Set();\n\n  for (const enrollment of request) {\n    errors_1.assert(enrollment.phoneInfo && utils_1.isValidPhoneNumber(enrollment.phoneInfo), \"INVALID_MFA_PHONE_NUMBER : Invalid format.\");\n\n    if (!phoneNumbers.has(enrollment.phoneInfo)) {\n      const mfaEnrollmentId = (options === null || options === void 0 ? void 0 : options.generateEnrollmentIds) ? newRandomId(28, enrollmentIds) : enrollment.mfaEnrollmentId;\n      errors_1.assert(mfaEnrollmentId, \"INVALID_MFA_ENROLLMENT_ID : mfaEnrollmentId must be defined.\");\n      errors_1.assert(!enrollmentIds.has(mfaEnrollmentId), \"DUPLICATE_MFA_ENROLLMENT_ID\");\n      enrollments.push(Object.assign(Object.assign({}, enrollment), {\n        mfaEnrollmentId\n      }));\n      phoneNumbers.add(enrollment.phoneInfo);\n      enrollmentIds.add(mfaEnrollmentId);\n    }\n  }\n\n  return state.validateMfaEnrollments(enrollments);\n}\n\nfunction getNormalizedUri(reqBody) {\n  errors_1.assert(reqBody.requestUri, \"MISSING_REQUEST_URI\");\n  const normalizedUri = utils_1.parseAbsoluteUri(reqBody.requestUri);\n  errors_1.assert(normalizedUri, \"INVALID_REQUEST_URI\");\n\n  if (reqBody.postBody) {\n    const postBodyParams = new url_1.URLSearchParams(reqBody.postBody);\n\n    for (const key of postBodyParams.keys()) {\n      normalizedUri.searchParams.set(key, postBodyParams.get(key));\n    }\n  }\n\n  const fragment = normalizedUri.hash.replace(/^#/, \"\");\n\n  if (fragment) {\n    const fragmentParams = new url_1.URLSearchParams(fragment);\n\n    for (const key of fragmentParams.keys()) {\n      normalizedUri.searchParams.set(key, fragmentParams.get(key));\n    }\n\n    normalizedUri.hash = \"\";\n  }\n\n  return normalizedUri;\n}\n\nfunction parseClaims(idTokenOrJsonClaims) {\n  if (!idTokenOrJsonClaims) {\n    return undefined;\n  }\n\n  let claims;\n\n  if (idTokenOrJsonClaims.startsWith(\"{\")) {\n    try {\n      claims = JSON.parse(idTokenOrJsonClaims);\n    } catch (_a) {\n      throw new errors_1.BadRequestError(`INVALID_IDP_RESPONSE : Unable to parse id_token: ${idTokenOrJsonClaims} ((Auth Emulator failed to parse fake id_token as strict JSON.))`);\n    }\n  } else {\n    const decoded = jsonwebtoken_1.decode(idTokenOrJsonClaims, {\n      json: true\n    });\n\n    if (!decoded) {\n      return undefined;\n    }\n\n    claims = decoded;\n  }\n\n  errors_1.assert(claims.sub, 'INVALID_IDP_RESPONSE : Invalid Idp Response: id_token missing required fields. ((Missing \"sub\" field. This field is required and must be a unique identifier.))');\n  errors_1.assert(typeof claims.sub === \"string\", 'INVALID_IDP_RESPONSE : ((The \"sub\" field must be a string.))');\n  return claims;\n}\n\nfunction fakeFetchUserInfoFromIdp(providerId, claims) {\n  const rawId = claims.sub;\n  const email = claims.email ? utils_1.canonicalizeEmailAddress(claims.email) : undefined;\n  const emailVerified = !!claims.email_verified;\n  const displayName = claims.name;\n  const photoUrl = claims.picture;\n  const response = {\n    kind: \"identitytoolkit#VerifyAssertionResponse\",\n    context: \"\",\n    providerId,\n    displayName,\n    fullName: displayName,\n    screenName: claims.screen_name,\n    email,\n    emailVerified,\n    photoUrl\n  };\n  let federatedId;\n\n  switch (providerId) {\n    case \"google.com\":\n      {\n        federatedId = `https://accounts.google.com/${rawId}`;\n        let granted_scopes = \"openid https://www.googleapis.com/auth/userinfo.profile\";\n\n        if (email) {\n          granted_scopes += \" https://www.googleapis.com/auth/userinfo.email\";\n        }\n\n        response.firstName = claims.given_name;\n        response.lastName = claims.family_name;\n        response.rawUserInfo = JSON.stringify({\n          granted_scopes,\n          id: rawId,\n          name: displayName,\n          given_name: claims.given_name,\n          family_name: claims.family_name,\n          verified_email: emailVerified,\n          locale: \"en\",\n          email,\n          picture: photoUrl\n        });\n        break;\n      }\n\n    default:\n      federatedId = rawId;\n      response.rawUserInfo = JSON.stringify(claims);\n      break;\n  }\n\n  response.federatedId = federatedId;\n  return {\n    response,\n    rawId\n  };\n}\n\nfunction handleLinkIdp(state, response, userFromIdToken) {\n  if (state.oneAccountPerEmail && response.email) {\n    const userMatchingEmail = state.getUserByEmail(response.email);\n    errors_1.assert(!userMatchingEmail || userMatchingEmail.localId === userFromIdToken.localId, \"EMAIL_EXISTS\");\n  }\n\n  response.localId = userFromIdToken.localId;\n  const fields = {};\n\n  if (state.oneAccountPerEmail && response.email && !userFromIdToken.email) {\n    fields.email = response.email;\n    fields.emailVerified = response.emailVerified;\n  }\n\n  if (response.email && response.emailVerified && (fields.email || userFromIdToken.email) === response.email) {\n    fields.emailVerified = true;\n  }\n\n  return {\n    accountUpdates: {\n      fields\n    },\n    response\n  };\n}\n\nfunction handleIdpSigninEmailNotRequired(response, userMatchingProvider) {\n  if (userMatchingProvider) {\n    return {\n      response: Object.assign(Object.assign({}, response), {\n        localId: userMatchingProvider.localId\n      }),\n      accountUpdates: {}\n    };\n  } else {\n    return handleIdpSignUp(response, {\n      emailRequired: false\n    });\n  }\n}\n\nfunction handleIdpSigninEmailRequired(response, rawId, userMatchingProvider, userMatchingEmail) {\n  var _a, _b, _c;\n\n  if (userMatchingProvider) {\n    return {\n      response: Object.assign(Object.assign({}, response), {\n        localId: userMatchingProvider.localId\n      }),\n      accountUpdates: {}\n    };\n  } else if (userMatchingEmail) {\n    if (response.emailVerified) {\n      if ((_a = userMatchingEmail.providerUserInfo) === null || _a === void 0 ? void 0 : _a.some(info => info.providerId === response.providerId && info.rawId !== rawId)) {\n        response.emailRecycled = true;\n      }\n\n      response.localId = userMatchingEmail.localId;\n      const accountUpdates = {\n        fields: {}\n      };\n\n      if (!userMatchingEmail.emailVerified) {\n        accountUpdates.fields.passwordHash = undefined;\n        accountUpdates.fields.phoneNumber = undefined;\n        accountUpdates.fields.validSince = utils_1.toUnixTimestamp(new Date()).toString();\n        accountUpdates.deleteProviders = (_b = userMatchingEmail.providerUserInfo) === null || _b === void 0 ? void 0 : _b.map(info => info.providerId);\n      }\n\n      accountUpdates.fields.dateOfBirth = response.dateOfBirth;\n      accountUpdates.fields.displayName = response.displayName;\n      accountUpdates.fields.language = response.language;\n      accountUpdates.fields.photoUrl = response.photoUrl;\n      accountUpdates.fields.screenName = response.screenName;\n      accountUpdates.fields.emailVerified = true;\n      return {\n        response,\n        accountUpdates\n      };\n    } else {\n      response.needConfirmation = true;\n      response.localId = userMatchingEmail.localId;\n      response.verifiedProvider = (_c = userMatchingEmail.providerUserInfo) === null || _c === void 0 ? void 0 : _c.map(info => info.providerId).filter(id => id !== state_1.PROVIDER_PASSWORD && id !== state_1.PROVIDER_PHONE);\n      return {\n        response,\n        accountUpdates: {}\n      };\n    }\n  } else {\n    return handleIdpSignUp(response, {\n      emailRequired: true\n    });\n  }\n}\n\nfunction handleIdpSignUp(response, options) {\n  const accountUpdates = {\n    fields: {\n      dateOfBirth: response.dateOfBirth,\n      displayName: response.displayName,\n      language: response.language,\n      photoUrl: response.photoUrl,\n      screenName: response.screenName\n    }\n  };\n\n  if (options.emailRequired && response.email) {\n    accountUpdates.fields.email = response.email;\n    accountUpdates.fields.emailVerified = response.emailVerified;\n  }\n\n  return {\n    response: Object.assign(Object.assign({}, response), {\n      isNewUser: true\n    }),\n    accountUpdates\n  };\n}","map":{"version":3,"sources":["/home/dev/Documentos/Projects/github-clone/node_modules/firebase-tools/lib/emulator/auth/operations.js"],"names":["Object","defineProperty","exports","value","setAccountInfoImpl","resetPassword","SESSION_COOKIE_MAX_VALID_DURATION","CUSTOM_TOKEN_AUDIENCE","authOperations","url_1","require","jsonwebtoken_1","utils_1","errors_1","types_1","emulatorLogger_1","state_1","identitytoolkit","getProjects","getRecaptchaParams","accounts","createAuthUri","delete","deleteAccount","lookup","sendOobCode","sendVerificationCode","signInWithCustomToken","signInWithEmailLink","signInWithIdp","signInWithPassword","signInWithPhoneNumber","signUp","update","setAccountInfo","projects","createSessionCookie","queryAccounts","_","query","batchCreate","batchDelete","batchGet","securetoken","token","grantToken","emulator","deleteAllAccountsInProject","config","get","getEmulatorProjectConfig","updateEmulatorProjectConfig","oobCodes","list","listOobCodesInProject","verificationCodes","listVerificationCodesInProject","PASSWORD_MIN_LENGTH","state","reqBody","ctx","_a","provider","updates","lastLoginAt","Date","now","toString","security","Oauth2","idToken","assert","localId","getUserByLocalId","displayName","photoUrl","emailVerified","phoneNumber","isValidPhoneNumber","getUserByPhoneNumber","disabled","password","email","PROVIDER_PASSWORD","PROVIDER_ANONYMOUS","isValidEmailAddress","canonicalizeEmailAddress","getUserByEmail","length","salt","randomId","passwordHash","hashPassword","passwordUpdatedAt","validSince","toUnixTimestamp","mfaInfo","getMfaEnrollmentsFromRequest","generateEnrollmentIds","user","parseIdToken","createUserWithLocalId","createUser","updateUserByLocalId","assign","kind","issueTokens","_b","_c","_d","_e","seenLocalIds","Set","users","tryAddUser","maybeUser","has","push","add","initialEmail","NotImplementedError","providerId","rawId","federatedUserId","getUserByProviderRawId","redactPasswordHash","undefined","sanityCheck","oneAccountPerEmail","existingEmails","userInfo","existingProviderAccounts","providerUserInfo","key","allowOverwrite","existingLocalIds","errors","index","uploadTime","fields","getTime","rawPassword","customAttributes","validateSerializedCustomClaims","federatedId","PROVIDER_PHONE","existingUserWithRawId","createdAt","isNaN","Number","existingUserWithEmail","overwriteUserWithLocalId","e","BadRequestError","message","startsWith","error","localIds","force","deleteUser","maxResults","Math","min","floor","params","queryUsers","sortByField","order","startToken","nextPageToken","newPageToken","sessionId","identifier","continueUri","parseAbsoluteUri","allProviders","signinMethods","registered","getUsersByEmailOrProviderEmail","forEach","emailLinkSignin","SIGNIN_METHOD_EMAIL_LINK","find","u","SESSION_COOKIE_MIN_VALID_DURATION","validDuration","payload","issuedAt","expiresAt","sessionCookie","sign","iat","exp","iss","aud","algorithm","projectId","projectNumber","authorizedDomains","recaptchaStoken","recaptchaSiteKey","expression","returnUserInfo","recordsCount","getUserCount","limit","offset","sortBy","oobCode","oob","validateOobCode","newPassword","requestType","deleteOobCode","deleteProviders","map","info","returnOobLink","continueUrl","mode","canHandleCodeInApp","EmulatorLogger","forEmulator","Emulators","AUTH","log","url","authEmulatorUrl","req","oobRecord","createOobRecord","oobLink","logOobMessage","sessionInfo","code","createVerificationCode","privileged","emulatorUrl","unimplementedFields","field","deleteAttribute","attr","signInProvider","isEmailUpdate","getUserByInitialEmail","disableUser","newEmail","mfa","enrollments","fieldsToCopy","mirrorFieldTo","deleteProvider","includes","Error","sendOobForEmailReset","createOob","pathname","searchParams","set","maybeMessage","JSON","parse","decoded","decode","complete","header","alg","coercePrimitiveToString","uid","user_id","claims","validateCustomClaims","isNewUser","customAuth","PROVIDER_CUSTOM","userFromIdToken","tokens","returnRefreshToken","pendingIdToken","normalizedUri","getNormalizedUri","toLowerCase","oauthIdToken","oauthAccessToken","parseClaims","response","fakeFetchUserInfoFromIdp","userMatchingProvider","accountUpdates","handleLinkIdp","userMatchingEmail","handleIdpSigninEmailRequired","handleIdpSigninEmailNotRequired","err","returnIdpCredential","errorMessage","needConfirmation","screenName","upsertProviders","captchaResponse","captchaChallenge","profilePicture","temporaryProof","proof","validateTemporaryProof","verifyPhoneNumber","createTemporaryProof","grantType","refreshToken","refreshTokenRecord","validateRefreshToken","extraClaims","id_token","access_token","expires_in","expiresIn","refresh_token","token_type","project_id","deleteAllAccounts","signIn","allowDuplicateEmails","listOobCodes","listVerificationCodes","lastRefreshAt","toISOString","expiresInSeconds","generateJwt","createRefreshTokenFor","firebase","sign_in_provider","identities","providerInfo","ids","customPayloadFields","name","picture","email_verified","phone_number","provider_id","auth_time","getAuthTime","jwtStr","subject","issuer","audience","millisSinceEpoch","parseInt","authTime","verification","getVerificationCodeBySessionInfo","deleteVerificationCodeBySessionInfo","CUSTOM_ATTRIBUTES_MAX_LENGTH","parsed","FORBIDDEN_CUSTOM_CLAIMS","Array","isArray","reservedField","newRandomId","existingIds","i","id","InternalError","request","options","phoneNumbers","enrollmentIds","enrollment","phoneInfo","mfaEnrollmentId","validateMfaEnrollments","requestUri","postBody","postBodyParams","URLSearchParams","keys","fragment","hash","replace","fragmentParams","idTokenOrJsonClaims","json","sub","context","fullName","screen_name","granted_scopes","firstName","given_name","lastName","family_name","rawUserInfo","stringify","verified_email","locale","handleIdpSignUp","emailRequired","some","emailRecycled","dateOfBirth","language","verifiedProvider","filter"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.setAccountInfoImpl = exports.resetPassword = exports.SESSION_COOKIE_MAX_VALID_DURATION = exports.CUSTOM_TOKEN_AUDIENCE = exports.authOperations = void 0;\nconst url_1 = require(\"url\");\nconst jsonwebtoken_1 = require(\"jsonwebtoken\");\nconst utils_1 = require(\"./utils\");\nconst errors_1 = require(\"./errors\");\nconst types_1 = require(\"../types\");\nconst emulatorLogger_1 = require(\"../emulatorLogger\");\nconst state_1 = require(\"./state\");\nexports.authOperations = {\n    identitytoolkit: {\n        getProjects,\n        getRecaptchaParams,\n        accounts: {\n            createAuthUri,\n            delete: deleteAccount,\n            lookup,\n            resetPassword,\n            sendOobCode,\n            sendVerificationCode,\n            signInWithCustomToken,\n            signInWithEmailLink,\n            signInWithIdp,\n            signInWithPassword,\n            signInWithPhoneNumber,\n            signUp,\n            update: setAccountInfo,\n        },\n        projects: {\n            createSessionCookie,\n            queryAccounts,\n            accounts: {\n                _: signUp,\n                delete: deleteAccount,\n                lookup,\n                query: queryAccounts,\n                sendOobCode,\n                update: setAccountInfo,\n                batchCreate,\n                batchDelete,\n                batchGet,\n            },\n        },\n    },\n    securetoken: {\n        token: grantToken,\n    },\n    emulator: {\n        projects: {\n            accounts: {\n                delete: deleteAllAccountsInProject,\n            },\n            config: {\n                get: getEmulatorProjectConfig,\n                update: updateEmulatorProjectConfig,\n            },\n            oobCodes: {\n                list: listOobCodesInProject,\n            },\n            verificationCodes: {\n                list: listVerificationCodesInProject,\n            },\n        },\n    },\n};\nconst PASSWORD_MIN_LENGTH = 6;\nexports.CUSTOM_TOKEN_AUDIENCE = \"https://identitytoolkit.googleapis.com/google.identity.identitytoolkit.v1.IdentityToolkit\";\nfunction signUp(state, reqBody, ctx) {\n    var _a;\n    let provider;\n    const updates = {\n        lastLoginAt: Date.now().toString(),\n    };\n    if ((_a = ctx.security) === null || _a === void 0 ? void 0 : _a.Oauth2) {\n        if (reqBody.idToken) {\n            errors_1.assert(!reqBody.localId, \"UNEXPECTED_PARAMETER : User ID\");\n        }\n        if (reqBody.localId) {\n            errors_1.assert(!state.getUserByLocalId(reqBody.localId), \"DUPLICATE_LOCAL_ID\");\n        }\n        updates.displayName = reqBody.displayName;\n        updates.photoUrl = reqBody.photoUrl;\n        updates.emailVerified = reqBody.emailVerified || false;\n        if (reqBody.phoneNumber) {\n            errors_1.assert(utils_1.isValidPhoneNumber(reqBody.phoneNumber), \"INVALID_PHONE_NUMBER : Invalid format.\");\n            errors_1.assert(!state.getUserByPhoneNumber(reqBody.phoneNumber), \"PHONE_NUMBER_EXISTS\");\n            updates.phoneNumber = reqBody.phoneNumber;\n        }\n        if (reqBody.disabled) {\n            updates.disabled = true;\n        }\n    }\n    else {\n        errors_1.assert(!reqBody.localId, \"UNEXPECTED_PARAMETER : User ID\");\n        if (reqBody.idToken || reqBody.password || reqBody.email) {\n            updates.displayName = reqBody.displayName;\n            updates.emailVerified = false;\n            errors_1.assert(reqBody.email, \"MISSING_EMAIL\");\n            errors_1.assert(reqBody.password, \"MISSING_PASSWORD\");\n            provider = state_1.PROVIDER_PASSWORD;\n        }\n        else {\n            provider = state_1.PROVIDER_ANONYMOUS;\n        }\n    }\n    if (reqBody.email) {\n        errors_1.assert(utils_1.isValidEmailAddress(reqBody.email), \"INVALID_EMAIL\");\n        const email = utils_1.canonicalizeEmailAddress(reqBody.email);\n        errors_1.assert(!state.getUserByEmail(email), \"EMAIL_EXISTS\");\n        updates.email = email;\n    }\n    if (reqBody.password) {\n        errors_1.assert(reqBody.password.length >= PASSWORD_MIN_LENGTH, `WEAK_PASSWORD : Password should be at least ${PASSWORD_MIN_LENGTH} characters`);\n        updates.salt = \"fakeSalt\" + utils_1.randomId(20);\n        updates.passwordHash = hashPassword(reqBody.password, updates.salt);\n        updates.passwordUpdatedAt = Date.now();\n        updates.validSince = utils_1.toUnixTimestamp(new Date()).toString();\n    }\n    if (reqBody.mfaInfo) {\n        updates.mfaInfo = getMfaEnrollmentsFromRequest(state, reqBody.mfaInfo, {\n            generateEnrollmentIds: true,\n        });\n    }\n    let user;\n    if (reqBody.idToken) {\n        ({ user } = parseIdToken(state, reqBody.idToken));\n    }\n    if (!user) {\n        if (reqBody.localId) {\n            user = state.createUserWithLocalId(reqBody.localId, updates);\n            errors_1.assert(user, \"DUPLICATE_LOCAL_ID\");\n        }\n        else {\n            user = state.createUser(updates);\n        }\n    }\n    else {\n        user = state.updateUserByLocalId(user.localId, updates);\n    }\n    return Object.assign({ kind: \"identitytoolkit#SignupNewUserResponse\", localId: user.localId, displayName: user.displayName, email: user.email }, (provider ? issueTokens(state, user, provider) : {}));\n}\nfunction lookup(state, reqBody, ctx) {\n    var _a, _b, _c, _d, _e;\n    const seenLocalIds = new Set();\n    const users = [];\n    function tryAddUser(maybeUser) {\n        if (maybeUser && !seenLocalIds.has(maybeUser.localId)) {\n            users.push(maybeUser);\n            seenLocalIds.add(maybeUser.localId);\n        }\n    }\n    if ((_a = ctx.security) === null || _a === void 0 ? void 0 : _a.Oauth2) {\n        if (reqBody.initialEmail) {\n            throw new errors_1.NotImplementedError(\"Lookup by initialEmail is not implemented.\");\n        }\n        for (const localId of (_b = reqBody.localId) !== null && _b !== void 0 ? _b : []) {\n            tryAddUser(state.getUserByLocalId(localId));\n        }\n        for (const email of (_c = reqBody.email) !== null && _c !== void 0 ? _c : []) {\n            tryAddUser(state.getUserByEmail(email));\n        }\n        for (const phoneNumber of (_d = reqBody.phoneNumber) !== null && _d !== void 0 ? _d : []) {\n            tryAddUser(state.getUserByPhoneNumber(phoneNumber));\n        }\n        for (const { providerId, rawId } of (_e = reqBody.federatedUserId) !== null && _e !== void 0 ? _e : []) {\n            if (!providerId || !rawId) {\n                continue;\n            }\n            tryAddUser(state.getUserByProviderRawId(providerId, rawId));\n        }\n    }\n    else {\n        errors_1.assert(reqBody.idToken, \"MISSING_ID_TOKEN\");\n        const { user } = parseIdToken(state, reqBody.idToken);\n        users.push(redactPasswordHash(user));\n    }\n    return {\n        kind: \"identitytoolkit#GetAccountInfoResponse\",\n        users: users.length ? users : undefined,\n    };\n}\nfunction batchCreate(state, reqBody) {\n    var _a, _b;\n    errors_1.assert((_a = reqBody.users) === null || _a === void 0 ? void 0 : _a.length, \"MISSING_USER_ACCOUNT\");\n    if (reqBody.sanityCheck) {\n        if (state.oneAccountPerEmail) {\n            const existingEmails = new Set();\n            for (const userInfo of reqBody.users) {\n                if (userInfo.email) {\n                    errors_1.assert(!existingEmails.has(userInfo.email), `DUPLICATE_EMAIL : ${userInfo.email}`);\n                    existingEmails.add(userInfo.email);\n                }\n            }\n        }\n        const existingProviderAccounts = new Set();\n        for (const userInfo of reqBody.users) {\n            for (const { providerId, rawId } of (_b = userInfo.providerUserInfo) !== null && _b !== void 0 ? _b : []) {\n                const key = `${providerId}:${rawId}`;\n                errors_1.assert(!existingProviderAccounts.has(key), `DUPLICATE_RAW_ID : Provider id(${providerId}), Raw id(${rawId})`);\n                existingProviderAccounts.add(key);\n            }\n        }\n    }\n    if (!reqBody.allowOverwrite) {\n        const existingLocalIds = new Set();\n        for (const userInfo of reqBody.users) {\n            const localId = userInfo.localId || \"\";\n            errors_1.assert(!existingLocalIds.has(localId), `DUPLICATE_LOCAL_ID : ${localId}`);\n            existingLocalIds.add(localId);\n        }\n    }\n    const errors = [];\n    for (let index = 0; index < reqBody.users.length; index++) {\n        const userInfo = reqBody.users[index];\n        try {\n            errors_1.assert(userInfo.localId, \"localId is missing\");\n            const uploadTime = new Date();\n            const fields = {\n                displayName: userInfo.displayName,\n                photoUrl: userInfo.photoUrl,\n                lastLoginAt: userInfo.lastLoginAt,\n            };\n            if (userInfo.passwordHash) {\n                fields.passwordHash = userInfo.passwordHash;\n                fields.salt = userInfo.salt;\n                fields.passwordUpdatedAt = uploadTime.getTime();\n            }\n            else if (userInfo.rawPassword) {\n                fields.salt = userInfo.salt || \"fakeSalt\" + utils_1.randomId(20);\n                fields.passwordHash = hashPassword(userInfo.rawPassword, fields.salt);\n                fields.passwordUpdatedAt = uploadTime.getTime();\n            }\n            if (userInfo.customAttributes) {\n                validateSerializedCustomClaims(userInfo.customAttributes);\n                fields.customAttributes = userInfo.customAttributes;\n            }\n            if (userInfo.providerUserInfo) {\n                fields.providerUserInfo = [];\n                for (const providerUserInfo of userInfo.providerUserInfo) {\n                    const { providerId, rawId, federatedId } = providerUserInfo;\n                    if (providerId === state_1.PROVIDER_PASSWORD || providerId === state_1.PROVIDER_PHONE) {\n                        continue;\n                    }\n                    if (!rawId || !providerId) {\n                        if (!federatedId) {\n                            errors_1.assert(false, \"federatedId or (providerId & rawId) is required\");\n                        }\n                        else {\n                            errors_1.assert(false, \"((Parsing federatedId is not implemented in Auth Emulator; please specify providerId AND rawId as a workaround.))\");\n                        }\n                    }\n                    const existingUserWithRawId = state.getUserByProviderRawId(providerId, rawId);\n                    errors_1.assert(!existingUserWithRawId || existingUserWithRawId.localId === userInfo.localId, \"raw id exists in other account in database\");\n                    fields.providerUserInfo.push(Object.assign(Object.assign({}, providerUserInfo), { providerId, rawId }));\n                }\n            }\n            if (userInfo.phoneNumber) {\n                errors_1.assert(utils_1.isValidPhoneNumber(userInfo.phoneNumber), \"phone number format is invalid\");\n                fields.phoneNumber = userInfo.phoneNumber;\n            }\n            fields.validSince = utils_1.toUnixTimestamp(uploadTime).toString();\n            fields.createdAt = uploadTime.getTime().toString();\n            if (fields.createdAt && !isNaN(Number(userInfo.createdAt))) {\n                fields.createdAt = userInfo.createdAt;\n            }\n            if (userInfo.email) {\n                const email = userInfo.email;\n                errors_1.assert(utils_1.isValidEmailAddress(email), \"email is invalid\");\n                const existingUserWithEmail = state.getUserByEmail(email);\n                errors_1.assert(!existingUserWithEmail || existingUserWithEmail.localId === userInfo.localId, reqBody.sanityCheck && state.oneAccountPerEmail\n                    ? \"email exists in other account in database\"\n                    : `((Auth Emulator does not support importing duplicate email: ${email}))`);\n                fields.email = utils_1.canonicalizeEmailAddress(email);\n            }\n            fields.emailVerified = !!userInfo.emailVerified;\n            fields.disabled = !!userInfo.disabled;\n            if (state.getUserByLocalId(userInfo.localId)) {\n                errors_1.assert(reqBody.allowOverwrite, \"localId belongs to an existing account - can not overwrite.\");\n            }\n            state.overwriteUserWithLocalId(userInfo.localId, fields);\n        }\n        catch (e) {\n            if (e instanceof errors_1.BadRequestError) {\n                let message = e.message;\n                if (message === \"INVALID_CLAIMS\") {\n                    message = \"Invalid custom claims provided.\";\n                }\n                else if (message === \"CLAIMS_TOO_LARGE\") {\n                    message = \"Custom claims provided are too large.\";\n                }\n                else if (message.startsWith(\"FORBIDDEN_CLAIM\")) {\n                    message = \"Custom claims provided include a reserved claim.\";\n                }\n                errors.push({\n                    index,\n                    message,\n                });\n            }\n            else {\n                throw e;\n            }\n        }\n    }\n    return {\n        kind: \"identitytoolkit#UploadAccountResponse\",\n        error: errors,\n    };\n}\nfunction batchDelete(state, reqBody) {\n    var _a;\n    const errors = [];\n    const localIds = (_a = reqBody.localIds) !== null && _a !== void 0 ? _a : [];\n    errors_1.assert(localIds.length > 0 && localIds.length <= 1000, \"LOCAL_ID_LIST_EXCEEDS_LIMIT\");\n    for (let index = 0; index < localIds.length; index++) {\n        const localId = localIds[index];\n        const user = state.getUserByLocalId(localId);\n        if (!user) {\n            continue;\n        }\n        else if (!user.disabled && !reqBody.force) {\n            errors.push({\n                index,\n                localId,\n                message: \"NOT_DISABLED : Disable the account before batch deletion.\",\n            });\n        }\n        else {\n            state.deleteUser(user);\n        }\n    }\n    return { errors: errors.length ? errors : undefined };\n}\nfunction batchGet(state, reqBody, ctx) {\n    const maxResults = Math.min(Math.floor(ctx.params.query.maxResults) || 20, 1000);\n    const users = state.queryUsers({}, { sortByField: \"localId\", order: \"ASC\", startToken: ctx.params.query.nextPageToken });\n    let newPageToken = undefined;\n    if (maxResults >= 0 && users.length >= maxResults) {\n        users.length = maxResults;\n        if (users.length) {\n            newPageToken = users[users.length - 1].localId;\n        }\n    }\n    return {\n        kind: \"identitytoolkit#DownloadAccountResponse\",\n        users,\n        nextPageToken: newPageToken,\n    };\n}\nfunction createAuthUri(state, reqBody) {\n    var _a;\n    const sessionId = reqBody.sessionId || utils_1.randomId(27);\n    if (reqBody.providerId) {\n        throw new errors_1.NotImplementedError(\"Sign-in with IDP is not yet supported.\");\n    }\n    errors_1.assert(reqBody.identifier, \"MISSING_IDENTIFIER\");\n    errors_1.assert(reqBody.continueUri, \"MISSING_CONTINUE_URI\");\n    errors_1.assert(utils_1.isValidEmailAddress(reqBody.identifier), \"INVALID_IDENTIFIER\");\n    const email = utils_1.canonicalizeEmailAddress(reqBody.identifier);\n    errors_1.assert(utils_1.parseAbsoluteUri(reqBody.continueUri), \"INVALID_CONTINUE_URI\");\n    const allProviders = [];\n    const signinMethods = [];\n    let registered = false;\n    const users = state.getUsersByEmailOrProviderEmail(email);\n    if (state.oneAccountPerEmail) {\n        if (users.length) {\n            registered = true;\n            (_a = users[0].providerUserInfo) === null || _a === void 0 ? void 0 : _a.forEach(({ providerId }) => {\n                if (providerId === state_1.PROVIDER_PASSWORD) {\n                    allProviders.push(providerId);\n                    if (users[0].passwordHash) {\n                        signinMethods.push(state_1.PROVIDER_PASSWORD);\n                    }\n                    if (users[0].emailLinkSignin) {\n                        signinMethods.push(state_1.SIGNIN_METHOD_EMAIL_LINK);\n                    }\n                }\n                else if (providerId !== state_1.PROVIDER_PHONE) {\n                    allProviders.push(providerId);\n                    signinMethods.push(providerId);\n                }\n            });\n        }\n    }\n    else {\n        const user = users.find((u) => u.email);\n        if (user) {\n            registered = true;\n            if (user.passwordHash || user.emailLinkSignin) {\n                allProviders.push(state_1.PROVIDER_PASSWORD);\n                if (users[0].passwordHash) {\n                    signinMethods.push(state_1.PROVIDER_PASSWORD);\n                }\n                if (users[0].emailLinkSignin) {\n                    signinMethods.push(state_1.SIGNIN_METHOD_EMAIL_LINK);\n                }\n            }\n        }\n    }\n    return {\n        kind: \"identitytoolkit#CreateAuthUriResponse\",\n        registered,\n        allProviders,\n        sessionId,\n        signinMethods,\n    };\n}\nconst SESSION_COOKIE_MIN_VALID_DURATION = 5 * 60;\nexports.SESSION_COOKIE_MAX_VALID_DURATION = 14 * 24 * 60 * 60;\nfunction createSessionCookie(state, reqBody, ctx) {\n    errors_1.assert(reqBody.idToken, \"MISSING_ID_TOKEN\");\n    const validDuration = Number(reqBody.validDuration) || exports.SESSION_COOKIE_MAX_VALID_DURATION;\n    errors_1.assert(validDuration >= SESSION_COOKIE_MIN_VALID_DURATION &&\n        validDuration <= exports.SESSION_COOKIE_MAX_VALID_DURATION, \"INVALID_DURATION\");\n    const { payload } = parseIdToken(state, reqBody.idToken);\n    const issuedAt = utils_1.toUnixTimestamp(new Date());\n    const expiresAt = issuedAt + validDuration;\n    const sessionCookie = jsonwebtoken_1.sign(Object.assign(Object.assign({}, payload), { iat: issuedAt, exp: expiresAt, iss: `https://session.firebase.google.com/${payload.aud}` }), \"\", {\n        algorithm: \"none\",\n    });\n    return { sessionCookie };\n}\nfunction deleteAccount(state, reqBody, ctx) {\n    var _a;\n    let user;\n    if ((_a = ctx.security) === null || _a === void 0 ? void 0 : _a.Oauth2) {\n        errors_1.assert(reqBody.localId, \"MISSING_LOCAL_ID\");\n        const maybeUser = state.getUserByLocalId(reqBody.localId);\n        errors_1.assert(maybeUser, \"USER_NOT_FOUND\");\n        user = maybeUser;\n    }\n    else {\n        errors_1.assert(reqBody.idToken, \"MISSING_ID_TOKEN\");\n        user = parseIdToken(state, reqBody.idToken).user;\n    }\n    state.deleteUser(user);\n    return {\n        kind: \"identitytoolkit#DeleteAccountResponse\",\n    };\n}\nfunction getProjects(state) {\n    return {\n        projectId: state.projectNumber,\n        authorizedDomains: [\n            \"localhost\",\n        ],\n    };\n}\nfunction getRecaptchaParams() {\n    return {\n        kind: \"identitytoolkit#GetRecaptchaParamResponse\",\n        recaptchaStoken: \"This-is-a-fake-token__Dont-send-this-to-the-Recaptcha-service__The-Auth-Emulator-does-not-support-Recaptcha\",\n        recaptchaSiteKey: \"Fake-key__Do-not-send-this-to-Recaptcha_\",\n    };\n}\nfunction queryAccounts(state, reqBody) {\n    var _a;\n    if ((_a = reqBody.expression) === null || _a === void 0 ? void 0 : _a.length) {\n        throw new errors_1.NotImplementedError(\"expression is not implemented.\");\n    }\n    if (reqBody.returnUserInfo === false) {\n        return {\n            recordsCount: state.getUserCount().toString(),\n        };\n    }\n    if (reqBody.limit) {\n        throw new errors_1.NotImplementedError(\"limit is not implemented.\");\n    }\n    reqBody.offset = reqBody.offset || \"0\";\n    if (reqBody.offset !== \"0\") {\n        throw new errors_1.NotImplementedError(\"offset is not implemented.\");\n    }\n    if (!reqBody.order || reqBody.order === \"ORDER_UNSPECIFIED\") {\n        reqBody.order = \"ASC\";\n    }\n    if (!reqBody.sortBy || reqBody.sortBy === \"SORT_BY_FIELD_UNSPECIFIED\") {\n        reqBody.sortBy = \"USER_ID\";\n    }\n    let sortByField;\n    if (reqBody.sortBy === \"USER_ID\") {\n        sortByField = \"localId\";\n    }\n    else {\n        throw new errors_1.NotImplementedError(\"Only sorting by USER_ID is implemented.\");\n    }\n    const users = state.queryUsers({}, { order: reqBody.order, sortByField });\n    return {\n        recordsCount: users.length.toString(),\n        userInfo: users,\n    };\n}\nfunction resetPassword(state, reqBody) {\n    var _a;\n    errors_1.assert(reqBody.oobCode, \"MISSING_OOB_CODE\");\n    const oob = state.validateOobCode(reqBody.oobCode);\n    errors_1.assert(oob, \"INVALID_OOB_CODE\");\n    if (reqBody.newPassword) {\n        errors_1.assert(oob.requestType === \"PASSWORD_RESET\", \"INVALID_OOB_CODE\");\n        errors_1.assert(reqBody.newPassword.length >= PASSWORD_MIN_LENGTH, `WEAK_PASSWORD : Password should be at least ${PASSWORD_MIN_LENGTH} characters`);\n        state.deleteOobCode(reqBody.oobCode);\n        const user = state.getUserByEmail(oob.email);\n        errors_1.assert(user, \"INVALID_OOB_CODE\");\n        const salt = \"fakeSalt\" + utils_1.randomId(20);\n        const passwordHash = hashPassword(reqBody.newPassword, salt);\n        state.updateUserByLocalId(user.localId, {\n            emailVerified: true,\n            passwordHash,\n            salt,\n            passwordUpdatedAt: Date.now(),\n            validSince: utils_1.toUnixTimestamp(new Date()).toString(),\n        }, { deleteProviders: (_a = user.providerUserInfo) === null || _a === void 0 ? void 0 : _a.map((info) => info.providerId) });\n    }\n    return {\n        kind: \"identitytoolkit#ResetPasswordResponse\",\n        requestType: oob.requestType,\n        email: oob.requestType === \"EMAIL_SIGNIN\" ? undefined : oob.email,\n    };\n}\nexports.resetPassword = resetPassword;\nfunction sendOobCode(state, reqBody, ctx) {\n    var _a;\n    errors_1.assert(reqBody.requestType && reqBody.requestType !== \"OOB_REQ_TYPE_UNSPECIFIED\", \"MISSING_REQ_TYPE\");\n    if (reqBody.returnOobLink) {\n        errors_1.assert((_a = ctx.security) === null || _a === void 0 ? void 0 : _a.Oauth2, \"INSUFFICIENT_PERMISSION\");\n    }\n    if (reqBody.continueUrl) {\n        errors_1.assert(utils_1.parseAbsoluteUri(reqBody.continueUrl), \"INVALID_CONTINUE_URI: ((expected an absolute URI with valid scheme and host))\");\n    }\n    let email;\n    let mode;\n    switch (reqBody.requestType) {\n        case \"EMAIL_SIGNIN\":\n            mode = \"signIn\";\n            errors_1.assert(reqBody.email, \"MISSING_EMAIL\");\n            email = utils_1.canonicalizeEmailAddress(reqBody.email);\n            break;\n        case \"PASSWORD_RESET\":\n            mode = \"resetPassword\";\n            errors_1.assert(reqBody.email, \"MISSING_EMAIL\");\n            email = utils_1.canonicalizeEmailAddress(reqBody.email);\n            errors_1.assert(state.getUserByEmail(email), \"EMAIL_NOT_FOUND\");\n            break;\n        case \"VERIFY_EMAIL\":\n            mode = \"verifyEmail\";\n            if (reqBody.returnOobLink && !reqBody.idToken) {\n                errors_1.assert(reqBody.email, \"MISSING_EMAIL\");\n                email = utils_1.canonicalizeEmailAddress(reqBody.email);\n                const maybeUser = state.getUserByEmail(email);\n                errors_1.assert(maybeUser, \"USER_NOT_FOUND\");\n            }\n            else {\n                const user = parseIdToken(state, reqBody.idToken || \"\").user;\n                errors_1.assert(user.email, \"MISSING_EMAIL\");\n                email = user.email;\n            }\n            break;\n        default:\n            throw new errors_1.NotImplementedError(reqBody.requestType);\n    }\n    if (reqBody.canHandleCodeInApp) {\n        emulatorLogger_1.EmulatorLogger.forEmulator(types_1.Emulators.AUTH).log(\"WARN\", \"canHandleCodeInApp is unsupported in Auth Emulator. All OOB operations will complete via web.\");\n    }\n    const url = utils_1.authEmulatorUrl(ctx.req);\n    const oobRecord = createOobRecord(state, email, url, {\n        requestType: reqBody.requestType,\n        mode,\n        continueUrl: reqBody.continueUrl,\n    });\n    if (reqBody.returnOobLink) {\n        return {\n            kind: \"identitytoolkit#GetOobConfirmationCodeResponse\",\n            email,\n            oobCode: oobRecord.oobCode,\n            oobLink: oobRecord.oobLink,\n        };\n    }\n    else {\n        logOobMessage(oobRecord);\n        return {\n            kind: \"identitytoolkit#GetOobConfirmationCodeResponse\",\n            email,\n        };\n    }\n}\nfunction sendVerificationCode(state, reqBody) {\n    errors_1.assert(reqBody.phoneNumber && utils_1.isValidPhoneNumber(reqBody.phoneNumber), \"INVALID_PHONE_NUMBER : Invalid format.\");\n    const { sessionInfo, phoneNumber, code } = state.createVerificationCode(reqBody.phoneNumber);\n    emulatorLogger_1.EmulatorLogger.forEmulator(types_1.Emulators.AUTH).log(\"BULLET\", `To verify the phone number ${phoneNumber}, use the code ${code}.`);\n    return {\n        sessionInfo,\n    };\n}\nfunction setAccountInfo(state, reqBody, ctx) {\n    var _a;\n    const url = utils_1.authEmulatorUrl(ctx.req);\n    return setAccountInfoImpl(state, reqBody, {\n        privileged: !!((_a = ctx.security) === null || _a === void 0 ? void 0 : _a.Oauth2),\n        emulatorUrl: url,\n    });\n}\nfunction setAccountInfoImpl(state, reqBody, { privileged = false, emulatorUrl = undefined } = {}) {\n    var _a, _b;\n    const unimplementedFields = [\n        \"provider\",\n        \"upgradeToFederatedLogin\",\n        \"captchaChallenge\",\n        \"captchaResponse\",\n        \"linkProviderUserInfo\",\n    ];\n    for (const field of unimplementedFields) {\n        if (field in reqBody) {\n            throw new errors_1.NotImplementedError(`${field} is not implemented yet.`);\n        }\n    }\n    if (!privileged) {\n        errors_1.assert(reqBody.idToken || reqBody.oobCode, \"INVALID_REQ_TYPE : Unsupported request parameters.\");\n        errors_1.assert(reqBody.customAttributes == null, \"INSUFFICIENT_PERMISSION\");\n    }\n    else {\n        errors_1.assert(reqBody.localId, \"MISSING_LOCAL_ID\");\n    }\n    if (reqBody.customAttributes) {\n        validateSerializedCustomClaims(reqBody.customAttributes);\n    }\n    reqBody.deleteAttribute = reqBody.deleteAttribute || [];\n    for (const attr of reqBody.deleteAttribute) {\n        if (attr === \"PROVIDER\" || attr === \"RAW_USER_INFO\") {\n            throw new errors_1.NotImplementedError(`deleteAttribute: ${attr}`);\n        }\n    }\n    const updates = {};\n    let user;\n    let signInProvider;\n    let isEmailUpdate = false;\n    if (reqBody.oobCode) {\n        const oob = state.validateOobCode(reqBody.oobCode);\n        errors_1.assert(oob, \"INVALID_OOB_CODE\");\n        switch (oob.requestType) {\n            case \"VERIFY_EMAIL\": {\n                state.deleteOobCode(reqBody.oobCode);\n                signInProvider = state_1.PROVIDER_PASSWORD;\n                const maybeUser = state.getUserByEmail(oob.email);\n                errors_1.assert(maybeUser, \"INVALID_OOB_CODE\");\n                user = maybeUser;\n                updates.emailVerified = true;\n                if (oob.email !== user.email) {\n                    updates.email = oob.email;\n                }\n                break;\n            }\n            case \"RECOVER_EMAIL\": {\n                state.deleteOobCode(reqBody.oobCode);\n                const maybeUser = state.getUserByInitialEmail(oob.email);\n                errors_1.assert(maybeUser, \"INVALID_OOB_CODE\");\n                errors_1.assert(!state.getUserByEmail(oob.email), \"EMAIL_EXISTS\");\n                user = maybeUser;\n                if (oob.email !== user.email) {\n                    updates.email = oob.email;\n                    updates.emailVerified = true;\n                }\n                break;\n            }\n            default:\n                throw new errors_1.NotImplementedError(oob.requestType);\n        }\n    }\n    else {\n        if (reqBody.idToken) {\n            ({ user, signInProvider } = parseIdToken(state, reqBody.idToken));\n            errors_1.assert(reqBody.disableUser == null, \"OPERATION_NOT_ALLOWED\");\n        }\n        else {\n            errors_1.assert(reqBody.localId, \"MISSING_LOCAL_ID\");\n            const maybeUser = state.getUserByLocalId(reqBody.localId);\n            errors_1.assert(maybeUser, \"USER_NOT_FOUND\");\n            user = maybeUser;\n        }\n        if (reqBody.email) {\n            errors_1.assert(utils_1.isValidEmailAddress(reqBody.email), \"INVALID_EMAIL\");\n            const newEmail = utils_1.canonicalizeEmailAddress(reqBody.email);\n            if (newEmail !== user.email) {\n                errors_1.assert(!state.getUserByEmail(newEmail), \"EMAIL_EXISTS\");\n                updates.email = newEmail;\n                updates.emailVerified = false;\n                isEmailUpdate = true;\n                if (signInProvider !== state_1.PROVIDER_ANONYMOUS && user.email && !user.initialEmail) {\n                    updates.initialEmail = user.email;\n                }\n            }\n        }\n        if (reqBody.password) {\n            errors_1.assert(reqBody.password.length >= PASSWORD_MIN_LENGTH, `WEAK_PASSWORD : Password should be at least ${PASSWORD_MIN_LENGTH} characters`);\n            updates.salt = \"fakeSalt\" + utils_1.randomId(20);\n            updates.passwordHash = hashPassword(reqBody.password, updates.salt);\n            updates.passwordUpdatedAt = Date.now();\n            signInProvider = state_1.PROVIDER_PASSWORD;\n        }\n        if (reqBody.password || reqBody.validSince || updates.email) {\n            updates.validSince = utils_1.toUnixTimestamp(new Date()).toString();\n        }\n        if (reqBody.mfa) {\n            if (reqBody.mfa.enrollments && reqBody.mfa.enrollments.length > 0) {\n                updates.mfaInfo = getMfaEnrollmentsFromRequest(state, reqBody.mfa.enrollments);\n            }\n            else {\n                updates.mfaInfo = undefined;\n            }\n        }\n        const fieldsToCopy = [\n            \"displayName\",\n            \"photoUrl\",\n        ];\n        if (privileged) {\n            if (reqBody.disableUser != null) {\n                updates.disabled = reqBody.disableUser;\n            }\n            if (reqBody.phoneNumber && reqBody.phoneNumber !== user.phoneNumber) {\n                errors_1.assert(utils_1.isValidPhoneNumber(reqBody.phoneNumber), \"INVALID_PHONE_NUMBER : Invalid format.\");\n                errors_1.assert(!state.getUserByPhoneNumber(reqBody.phoneNumber), \"PHONE_NUMBER_EXISTS\");\n                updates.phoneNumber = reqBody.phoneNumber;\n            }\n            fieldsToCopy.push(\"emailVerified\", \"customAttributes\", \"createdAt\", \"lastLoginAt\", \"validSince\");\n        }\n        for (const field of fieldsToCopy) {\n            if (reqBody[field] != null) {\n                utils_1.mirrorFieldTo(updates, field, reqBody);\n            }\n        }\n        for (const attr of reqBody.deleteAttribute) {\n            switch (attr) {\n                case \"USER_ATTRIBUTE_NAME_UNSPECIFIED\":\n                    continue;\n                case \"DISPLAY_NAME\":\n                    updates.displayName = undefined;\n                    break;\n                case \"PHOTO_URL\":\n                    updates.photoUrl = undefined;\n                    break;\n                case \"PASSWORD\":\n                    updates.passwordHash = undefined;\n                    updates.salt = undefined;\n                    break;\n                case \"EMAIL\":\n                    updates.email = undefined;\n                    updates.emailVerified = undefined;\n                    updates.emailLinkSignin = undefined;\n                    break;\n            }\n        }\n        if ((_a = reqBody.deleteProvider) === null || _a === void 0 ? void 0 : _a.includes(state_1.PROVIDER_PASSWORD)) {\n            updates.email = undefined;\n            updates.emailVerified = undefined;\n            updates.emailLinkSignin = undefined;\n            updates.passwordHash = undefined;\n            updates.salt = undefined;\n        }\n        if ((_b = reqBody.deleteProvider) === null || _b === void 0 ? void 0 : _b.includes(state_1.PROVIDER_PHONE)) {\n            updates.phoneNumber = undefined;\n        }\n    }\n    user = state.updateUserByLocalId(user.localId, updates, {\n        deleteProviders: reqBody.deleteProvider,\n    });\n    if (signInProvider !== state_1.PROVIDER_ANONYMOUS && user.initialEmail && isEmailUpdate) {\n        if (!emulatorUrl) {\n            throw new Error(\"Internal assertion error: missing emulatorUrl param\");\n        }\n        sendOobForEmailReset(state, user.initialEmail, emulatorUrl);\n    }\n    return redactPasswordHash(Object.assign({ kind: \"identitytoolkit#SetAccountInfoResponse\", localId: user.localId, emailVerified: user.emailVerified, providerUserInfo: user.providerUserInfo, email: user.email, displayName: user.displayName, photoUrl: user.photoUrl, passwordHash: user.passwordHash }, (updates.validSince && signInProvider ? issueTokens(state, user, signInProvider) : {})));\n}\nexports.setAccountInfoImpl = setAccountInfoImpl;\nfunction sendOobForEmailReset(state, initialEmail, url) {\n    const oobRecord = createOobRecord(state, initialEmail, url, {\n        requestType: \"RECOVER_EMAIL\",\n        mode: \"recoverEmail\",\n    });\n    logOobMessage(oobRecord);\n}\nfunction createOobRecord(state, email, url, params) {\n    const oobRecord = state.createOob(email, params.requestType, (oobCode) => {\n        url.pathname = \"/emulator/action\";\n        url.searchParams.set(\"mode\", params.mode);\n        url.searchParams.set(\"lang\", \"en\");\n        url.searchParams.set(\"oobCode\", oobCode);\n        url.searchParams.set(\"apiKey\", \"fake-api-key\");\n        if (params.continueUrl) {\n            url.searchParams.set(\"continueUrl\", params.continueUrl);\n        }\n        return url.toString();\n    });\n    return oobRecord;\n}\nfunction logOobMessage(oobRecord) {\n    const oobLink = oobRecord.oobLink;\n    const email = oobRecord.email;\n    let maybeMessage;\n    switch (oobRecord.requestType) {\n        case \"EMAIL_SIGNIN\":\n            maybeMessage = `To sign in as ${email}, follow this link: ${oobLink}`;\n            break;\n        case \"PASSWORD_RESET\":\n            maybeMessage = `To reset the password for ${email}, follow this link: ${oobLink}&newPassword=NEW_PASSWORD_HERE`;\n            break;\n        case \"VERIFY_EMAIL\":\n            maybeMessage = `To verify the email address ${email}, follow this link: ${oobLink}`;\n            break;\n        case \"RECOVER_EMAIL\":\n            maybeMessage = `To reset your email address to ${email}, follow this link: ${oobLink}`;\n            break;\n    }\n    if (maybeMessage) {\n        emulatorLogger_1.EmulatorLogger.forEmulator(types_1.Emulators.AUTH).log(\"BULLET\", maybeMessage);\n    }\n}\nfunction signInWithCustomToken(state, reqBody) {\n    var _a;\n    errors_1.assert(reqBody.token, \"MISSING_CUSTOM_TOKEN\");\n    let payload;\n    if (reqBody.token.startsWith(\"{\")) {\n        try {\n            payload = JSON.parse(reqBody.token);\n        }\n        catch (_b) {\n            throw new errors_1.BadRequestError(\"INVALID_CUSTOM_TOKEN : ((Auth Emulator only accepts strict JSON or JWTs as fake custom tokens.))\");\n        }\n    }\n    else {\n        const decoded = jsonwebtoken_1.decode(reqBody.token, { complete: true });\n        errors_1.assert(decoded, \"INVALID_CUSTOM_TOKEN : Invalid assertion format\");\n        if (decoded.header.alg !== \"none\") {\n            emulatorLogger_1.EmulatorLogger.forEmulator(types_1.Emulators.AUTH).log(\"WARN\", \"Received a signed custom token. Auth Emulator does not validate JWTs and IS NOT SECURE\");\n        }\n        errors_1.assert(decoded.payload.aud === exports.CUSTOM_TOKEN_AUDIENCE, `INVALID_CUSTOM_TOKEN : ((Invalid aud (audience): ${decoded.payload.aud} ` +\n            \"Note: Firebase ID Tokens / third-party tokens cannot be used with signInWithCustomToken.))\");\n        payload = decoded.payload;\n    }\n    const localId = (_a = coercePrimitiveToString(payload.uid)) !== null && _a !== void 0 ? _a : coercePrimitiveToString(payload.user_id);\n    errors_1.assert(localId, \"MISSING_IDENTIFIER\");\n    let claims = {};\n    if (\"claims\" in payload) {\n        validateCustomClaims(payload.claims);\n        claims = payload.claims;\n    }\n    let user = state.getUserByLocalId(localId);\n    const isNewUser = !user;\n    const updates = {\n        customAuth: true,\n        lastLoginAt: Date.now().toString(),\n    };\n    if (user) {\n        errors_1.assert(!user.disabled, \"USER_DISABLED\");\n        user = state.updateUserByLocalId(localId, updates);\n    }\n    else {\n        user = state.createUserWithLocalId(localId, updates);\n        if (!user) {\n            throw new Error(`Internal assertion error: trying to create duplicate localId: ${localId}`);\n        }\n    }\n    if (user.mfaInfo) {\n        throw new errors_1.NotImplementedError(\"MFA Login not yet implemented.\");\n    }\n    return Object.assign({ kind: \"identitytoolkit#VerifyCustomTokenResponse\", isNewUser }, issueTokens(state, user, state_1.PROVIDER_CUSTOM, claims));\n}\nfunction signInWithEmailLink(state, reqBody) {\n    const userFromIdToken = reqBody.idToken ? parseIdToken(state, reqBody.idToken).user : undefined;\n    errors_1.assert(reqBody.email, \"MISSING_EMAIL\");\n    const email = utils_1.canonicalizeEmailAddress(reqBody.email);\n    errors_1.assert(reqBody.oobCode, \"MISSING_OOB_CODE\");\n    const oob = state.validateOobCode(reqBody.oobCode);\n    errors_1.assert(oob && oob.requestType === \"EMAIL_SIGNIN\", \"INVALID_OOB_CODE\");\n    errors_1.assert(email === oob.email, \"INVALID_EMAIL : The email provided does not match the sign-in email address.\");\n    state.deleteOobCode(reqBody.oobCode);\n    const updates = {\n        email,\n        emailVerified: true,\n        emailLinkSignin: true,\n        lastLoginAt: Date.now().toString(),\n    };\n    let user = state.getUserByEmail(email);\n    const isNewUser = !user && !userFromIdToken;\n    if (!user) {\n        if (userFromIdToken) {\n            user = state.updateUserByLocalId(userFromIdToken.localId, updates);\n        }\n        else {\n            user = state.createUser(updates);\n        }\n    }\n    else {\n        errors_1.assert(!user.disabled, \"USER_DISABLED\");\n        errors_1.assert(!userFromIdToken || userFromIdToken.localId === user.localId, \"EMAIL_EXISTS\");\n        user = state.updateUserByLocalId(user.localId, updates);\n    }\n    if (user.mfaInfo) {\n        throw new errors_1.NotImplementedError(\"MFA Login not yet implemented.\");\n    }\n    const tokens = issueTokens(state, user, state_1.PROVIDER_PASSWORD);\n    return Object.assign({ kind: \"identitytoolkit#EmailLinkSigninResponse\", email, localId: user.localId, isNewUser }, tokens);\n}\nfunction signInWithIdp(state, reqBody) {\n    var _a;\n    if (reqBody.returnRefreshToken) {\n        throw new errors_1.NotImplementedError(\"returnRefreshToken is not implemented yet.\");\n    }\n    if (reqBody.pendingIdToken) {\n        throw new errors_1.NotImplementedError(\"pendingIdToken is not implemented yet.\");\n    }\n    const normalizedUri = getNormalizedUri(reqBody);\n    const providerId = (_a = normalizedUri.searchParams.get(\"providerId\")) === null || _a === void 0 ? void 0 : _a.toLowerCase();\n    errors_1.assert(providerId, `INVALID_CREDENTIAL_OR_PROVIDER_ID : Invalid IdP response/credential: ${normalizedUri.toString()}`);\n    const oauthIdToken = normalizedUri.searchParams.get(\"id_token\") || undefined;\n    const oauthAccessToken = normalizedUri.searchParams.get(\"access_token\") || undefined;\n    const claims = parseClaims(oauthIdToken) || parseClaims(oauthAccessToken);\n    if (!claims) {\n        if (oauthIdToken) {\n            throw new errors_1.BadRequestError(`INVALID_IDP_RESPONSE : Unable to parse id_token: ${oauthIdToken} ((Auth Emulator only accepts strict JSON or JWTs as fake id_tokens.))`);\n        }\n        else if (oauthAccessToken) {\n            if (providerId === \"google.com\" || providerId === \"apple.com\") {\n                throw new errors_1.NotImplementedError(`The Auth Emulator only support sign-in with ${providerId} using id_token, not access_token. Please update your code to use id_token.`);\n            }\n            else {\n                throw new errors_1.NotImplementedError(`The Auth Emulator does not support ${providerId} sign-in with credentials.`);\n            }\n        }\n        else {\n            throw new errors_1.NotImplementedError(\"The Auth Emulator only supports sign-in with credentials (id_token required).\");\n        }\n    }\n    let { response, rawId } = fakeFetchUserInfoFromIdp(providerId, claims);\n    response.oauthAccessToken =\n        oauthAccessToken || `FirebaseAuthEmulatorFakeAccessToken_${providerId}`;\n    response.oauthIdToken = oauthIdToken;\n    const userFromIdToken = reqBody.idToken ? parseIdToken(state, reqBody.idToken).user : undefined;\n    const userMatchingProvider = state.getUserByProviderRawId(providerId, rawId);\n    let accountUpdates;\n    try {\n        if (userFromIdToken) {\n            errors_1.assert(!userMatchingProvider, \"FEDERATED_USER_ID_ALREADY_LINKED\");\n            ({ accountUpdates, response } = handleLinkIdp(state, response, userFromIdToken));\n        }\n        else if (state.oneAccountPerEmail) {\n            const userMatchingEmail = response.email ? state.getUserByEmail(response.email) : undefined;\n            ({ accountUpdates, response } = handleIdpSigninEmailRequired(response, rawId, userMatchingProvider, userMatchingEmail));\n        }\n        else {\n            ({ accountUpdates, response } = handleIdpSigninEmailNotRequired(response, userMatchingProvider));\n        }\n    }\n    catch (err) {\n        if (reqBody.returnIdpCredential && err instanceof errors_1.BadRequestError) {\n            response.errorMessage = err.message;\n            return response;\n        }\n        else {\n            throw err;\n        }\n    }\n    if (response.needConfirmation) {\n        return response;\n    }\n    const providerUserInfo = {\n        providerId,\n        rawId,\n        federatedId: rawId,\n        displayName: response.displayName,\n        photoUrl: response.photoUrl,\n        email: response.email,\n        screenName: response.screenName,\n    };\n    let user;\n    if (response.isNewUser) {\n        user = state.createUser(Object.assign(Object.assign({}, accountUpdates.fields), { lastLoginAt: Date.now().toString(), providerUserInfo: [providerUserInfo] }));\n        response.localId = user.localId;\n    }\n    else {\n        if (!response.localId) {\n            throw new Error(\"Internal assertion error: localId not set for exising user.\");\n        }\n        user = state.updateUserByLocalId(response.localId, Object.assign(Object.assign({}, accountUpdates.fields), { lastLoginAt: Date.now().toString() }), {\n            upsertProviders: [providerUserInfo],\n        });\n    }\n    if (user.mfaInfo) {\n        throw new errors_1.NotImplementedError(\"MFA Login not yet implemented.\");\n    }\n    if (user.email === response.email) {\n        response.emailVerified = user.emailVerified;\n    }\n    Object.assign(response, issueTokens(state, user, providerId));\n    return response;\n}\nfunction signInWithPassword(state, reqBody) {\n    errors_1.assert(reqBody.email, \"MISSING_EMAIL\");\n    errors_1.assert(reqBody.password, \"MISSING_PASSWORD\");\n    if (reqBody.captchaResponse || reqBody.captchaChallenge) {\n        throw new errors_1.NotImplementedError(\"captcha unimplemented\");\n    }\n    if (reqBody.idToken || reqBody.pendingIdToken) {\n        throw new errors_1.NotImplementedError(\"idToken / pendingIdToken is no longer in use and unsupported by the Auth Emulator.\");\n    }\n    const email = utils_1.canonicalizeEmailAddress(reqBody.email);\n    let user = state.getUserByEmail(email);\n    errors_1.assert(user, \"EMAIL_NOT_FOUND\");\n    errors_1.assert(!user.disabled, \"USER_DISABLED\");\n    errors_1.assert(user.passwordHash && user.salt, \"INVALID_PASSWORD\");\n    errors_1.assert(user.passwordHash === hashPassword(reqBody.password, user.salt), \"INVALID_PASSWORD\");\n    if (user.mfaInfo) {\n        throw new errors_1.NotImplementedError(\"MFA Login not yet implemented.\");\n    }\n    user = state.updateUserByLocalId(user.localId, { lastLoginAt: Date.now().toString() });\n    const tokens = issueTokens(state, user, state_1.PROVIDER_PASSWORD);\n    return Object.assign({ kind: \"identitytoolkit#VerifyPasswordResponse\", registered: true, localId: user.localId, email, displayName: user.displayName, profilePicture: user.photoUrl }, tokens);\n}\nfunction signInWithPhoneNumber(state, reqBody) {\n    let phoneNumber;\n    if (reqBody.temporaryProof) {\n        errors_1.assert(reqBody.phoneNumber, \"MISSING_PHONE_NUMBER\");\n        const proof = state.validateTemporaryProof(reqBody.temporaryProof, reqBody.phoneNumber);\n        errors_1.assert(proof, \"INVALID_TEMPORARY_PROOF\");\n        ({ phoneNumber } = proof);\n    }\n    else {\n        errors_1.assert(reqBody.sessionInfo, \"MISSING_SESSION_INFO\");\n        errors_1.assert(reqBody.code, \"MISSING_CODE\");\n        phoneNumber = verifyPhoneNumber(state, reqBody.sessionInfo, reqBody.code);\n    }\n    let user = state.getUserByPhoneNumber(phoneNumber);\n    let isNewUser = false;\n    const updates = {\n        phoneNumber,\n        lastLoginAt: Date.now().toString(),\n    };\n    const userFromIdToken = reqBody.idToken ? parseIdToken(state, reqBody.idToken).user : undefined;\n    if (!user) {\n        if (userFromIdToken) {\n            user = state.updateUserByLocalId(userFromIdToken.localId, updates);\n        }\n        else {\n            isNewUser = true;\n            user = state.createUser(updates);\n        }\n    }\n    else {\n        errors_1.assert(!user.disabled, \"USER_DISABLED\");\n        if (userFromIdToken && userFromIdToken.localId !== user.localId) {\n            if (!reqBody.temporaryProof) {\n                return Object.assign({}, state.createTemporaryProof(phoneNumber));\n            }\n            throw new errors_1.BadRequestError(\"PHONE_NUMBER_EXISTS\");\n        }\n        user = state.updateUserByLocalId(user.localId, updates);\n    }\n    if (user.mfaInfo) {\n        throw new errors_1.NotImplementedError(\"MFA Login not yet implemented.\");\n    }\n    const tokens = issueTokens(state, user, state_1.PROVIDER_PHONE);\n    return Object.assign({ isNewUser,\n        phoneNumber, localId: user.localId }, tokens);\n}\nfunction grantToken(state, reqBody) {\n    errors_1.assert(reqBody.grantType, \"MISSING_GRANT_TYPE\");\n    errors_1.assert(reqBody.grantType === \"refresh_token\", \"INVALID_GRANT_TYPE\");\n    errors_1.assert(reqBody.refreshToken, \"MISSING_REFRESH_TOKEN\");\n    const refreshTokenRecord = state.validateRefreshToken(reqBody.refreshToken);\n    errors_1.assert(refreshTokenRecord, \"INVALID_REFRESH_TOKEN\");\n    errors_1.assert(!refreshTokenRecord.user.disabled, \"USER_DISABLED\");\n    const tokens = issueTokens(state, refreshTokenRecord.user, refreshTokenRecord.provider, refreshTokenRecord.extraClaims);\n    return {\n        id_token: tokens.idToken,\n        access_token: tokens.idToken,\n        expires_in: tokens.expiresIn,\n        refresh_token: tokens.refreshToken,\n        token_type: \"Bearer\",\n        user_id: refreshTokenRecord.user.localId,\n        project_id: state.projectNumber,\n    };\n}\nfunction deleteAllAccountsInProject(state) {\n    state.deleteAllAccounts();\n    return {};\n}\nfunction getEmulatorProjectConfig(state) {\n    return {\n        signIn: {\n            allowDuplicateEmails: !state.oneAccountPerEmail,\n        },\n    };\n}\nfunction updateEmulatorProjectConfig(state, reqBody) {\n    var _a;\n    const allowDuplicateEmails = (_a = reqBody.signIn) === null || _a === void 0 ? void 0 : _a.allowDuplicateEmails;\n    if (allowDuplicateEmails != null) {\n        state.oneAccountPerEmail = !allowDuplicateEmails;\n    }\n    return getEmulatorProjectConfig(state);\n}\nfunction listOobCodesInProject(state) {\n    return {\n        oobCodes: [...state.listOobCodes()],\n    };\n}\nfunction listVerificationCodesInProject(state) {\n    return {\n        verificationCodes: [...state.listVerificationCodes()],\n    };\n}\nfunction coercePrimitiveToString(value) {\n    switch (typeof value) {\n        case \"string\":\n            return value;\n        case \"number\":\n        case \"boolean\":\n            return value.toString();\n        default:\n            return undefined;\n    }\n}\nfunction redactPasswordHash(user) {\n    return user;\n}\nfunction hashPassword(password, salt) {\n    return `fakeHash:salt=${salt}:password=${password}`;\n}\nfunction issueTokens(state, user, signInProvider, extraClaims = {}) {\n    state.updateUserByLocalId(user.localId, { lastRefreshAt: new Date().toISOString() });\n    const expiresInSeconds = 60 * 60;\n    const idToken = generateJwt(state.projectId, user, signInProvider, expiresInSeconds, extraClaims);\n    const refreshToken = state.createRefreshTokenFor(user, signInProvider, extraClaims);\n    return {\n        idToken,\n        refreshToken,\n        expiresIn: expiresInSeconds.toString(),\n    };\n}\nfunction parseIdToken(state, idToken) {\n    const decoded = jsonwebtoken_1.decode(idToken, { complete: true });\n    errors_1.assert(decoded, \"INVALID_ID_TOKEN\");\n    if (decoded.header.alg !== \"none\") {\n        emulatorLogger_1.EmulatorLogger.forEmulator(types_1.Emulators.AUTH).log(\"WARN\", \"Received a signed JWT. Auth Emulator does not validate JWTs and IS NOT SECURE\");\n    }\n    const user = state.getUserByLocalId(decoded.payload.user_id);\n    errors_1.assert(user, \"USER_NOT_FOUND\");\n    errors_1.assert(!user.validSince || decoded.payload.iat >= Number(user.validSince), \"TOKEN_EXPIRED\");\n    errors_1.assert(!user.disabled, \"USER_DISABLED\");\n    const signInProvider = decoded.payload.firebase.sign_in_provider;\n    return { user, signInProvider, payload: decoded.payload };\n}\nfunction generateJwt(projectId, user, signInProvider, expiresInSeconds, extraClaims = {}) {\n    const identities = {};\n    if (user.email) {\n        identities[\"email\"] = [user.email];\n    }\n    if (user.providerUserInfo) {\n        for (const providerInfo of user.providerUserInfo) {\n            if (providerInfo.providerId &&\n                providerInfo.providerId !== state_1.PROVIDER_PASSWORD &&\n                providerInfo.rawId) {\n                const ids = identities[providerInfo.providerId] || [];\n                ids.push(providerInfo.rawId);\n                identities[providerInfo.providerId] = ids;\n            }\n        }\n    }\n    const customAttributes = JSON.parse(user.customAttributes || \"{}\");\n    const customPayloadFields = Object.assign(Object.assign(Object.assign({ name: user.displayName, picture: user.photoUrl }, customAttributes), extraClaims), { email: user.email, email_verified: user.emailVerified, phone_number: user.phoneNumber, provider_id: signInProvider === \"anonymous\" ? signInProvider : undefined, auth_time: utils_1.toUnixTimestamp(getAuthTime(user)), user_id: user.localId, firebase: {\n            identities,\n            sign_in_provider: signInProvider,\n        } });\n    const jwtStr = jsonwebtoken_1.sign(customPayloadFields, \"\", {\n        algorithm: \"none\",\n        expiresIn: expiresInSeconds,\n        subject: user.localId,\n        issuer: `https://securetoken.google.com/${projectId}`,\n        audience: projectId,\n    });\n    return jwtStr;\n}\nfunction getAuthTime(user) {\n    if (user.lastLoginAt != null) {\n        const millisSinceEpoch = parseInt(user.lastLoginAt, 10);\n        const authTime = new Date(millisSinceEpoch);\n        if (isNaN(authTime.getTime())) {\n            throw new Error(`Internal assertion error: invalid user.lastLoginAt = ${user.lastLoginAt}`);\n        }\n        return authTime;\n    }\n    else if (user.lastRefreshAt != null) {\n        const authTime = new Date(user.lastRefreshAt);\n        if (isNaN(authTime.getTime())) {\n            throw new Error(`Internal assertion error: invalid user.lastRefreshAt = ${user.lastRefreshAt}`);\n        }\n        return authTime;\n    }\n    else {\n        throw new Error(`Internal assertion error: Missing user.lastLoginAt and user.lastRefreshAt`);\n    }\n}\nfunction verifyPhoneNumber(state, sessionInfo, code) {\n    const verification = state.getVerificationCodeBySessionInfo(sessionInfo);\n    errors_1.assert(verification, \"INVALID_SESSION_INFO\");\n    errors_1.assert(verification.code === code, \"INVALID_CODE\");\n    state.deleteVerificationCodeBySessionInfo(sessionInfo);\n    return verification.phoneNumber;\n}\nconst CUSTOM_ATTRIBUTES_MAX_LENGTH = 1000;\nfunction validateSerializedCustomClaims(claims) {\n    errors_1.assert(claims.length <= CUSTOM_ATTRIBUTES_MAX_LENGTH, \"CLAIMS_TOO_LARGE\");\n    let parsed;\n    try {\n        parsed = JSON.parse(claims);\n    }\n    catch (_a) {\n        throw new errors_1.BadRequestError(\"INVALID_CLAIMS\");\n    }\n    validateCustomClaims(parsed);\n}\nconst FORBIDDEN_CUSTOM_CLAIMS = [\n    \"iss\",\n    \"aud\",\n    \"sub\",\n    \"iat\",\n    \"exp\",\n    \"nbf\",\n    \"jti\",\n    \"nonce\",\n    \"azp\",\n    \"acr\",\n    \"amr\",\n    \"cnf\",\n    \"auth_time\",\n    \"firebase\",\n    \"at_hash\",\n    \"c_hash\",\n];\nfunction validateCustomClaims(claims) {\n    errors_1.assert(typeof claims === \"object\" && claims != null && !Array.isArray(claims), \"INVALID_CLAIMS\");\n    for (const reservedField of FORBIDDEN_CUSTOM_CLAIMS) {\n        errors_1.assert(!(reservedField in claims), `FORBIDDEN_CLAIM : ${reservedField}`);\n    }\n}\nfunction newRandomId(length, existingIds) {\n    for (let i = 0; i < 10; i++) {\n        const id = utils_1.randomId(length);\n        if (!(existingIds === null || existingIds === void 0 ? void 0 : existingIds.has(id))) {\n            return id;\n        }\n    }\n    throw new errors_1.InternalError(\"INTERNAL_ERROR : Failed to generate a random ID after 10 attempts\", \"INTERNAL\");\n}\nfunction getMfaEnrollmentsFromRequest(state, request, options) {\n    const enrollments = [];\n    const phoneNumbers = new Set();\n    const enrollmentIds = new Set();\n    for (const enrollment of request) {\n        errors_1.assert(enrollment.phoneInfo && utils_1.isValidPhoneNumber(enrollment.phoneInfo), \"INVALID_MFA_PHONE_NUMBER : Invalid format.\");\n        if (!phoneNumbers.has(enrollment.phoneInfo)) {\n            const mfaEnrollmentId = (options === null || options === void 0 ? void 0 : options.generateEnrollmentIds) ? newRandomId(28, enrollmentIds)\n                : enrollment.mfaEnrollmentId;\n            errors_1.assert(mfaEnrollmentId, \"INVALID_MFA_ENROLLMENT_ID : mfaEnrollmentId must be defined.\");\n            errors_1.assert(!enrollmentIds.has(mfaEnrollmentId), \"DUPLICATE_MFA_ENROLLMENT_ID\");\n            enrollments.push(Object.assign(Object.assign({}, enrollment), { mfaEnrollmentId }));\n            phoneNumbers.add(enrollment.phoneInfo);\n            enrollmentIds.add(mfaEnrollmentId);\n        }\n    }\n    return state.validateMfaEnrollments(enrollments);\n}\nfunction getNormalizedUri(reqBody) {\n    errors_1.assert(reqBody.requestUri, \"MISSING_REQUEST_URI\");\n    const normalizedUri = utils_1.parseAbsoluteUri(reqBody.requestUri);\n    errors_1.assert(normalizedUri, \"INVALID_REQUEST_URI\");\n    if (reqBody.postBody) {\n        const postBodyParams = new url_1.URLSearchParams(reqBody.postBody);\n        for (const key of postBodyParams.keys()) {\n            normalizedUri.searchParams.set(key, postBodyParams.get(key));\n        }\n    }\n    const fragment = normalizedUri.hash.replace(/^#/, \"\");\n    if (fragment) {\n        const fragmentParams = new url_1.URLSearchParams(fragment);\n        for (const key of fragmentParams.keys()) {\n            normalizedUri.searchParams.set(key, fragmentParams.get(key));\n        }\n        normalizedUri.hash = \"\";\n    }\n    return normalizedUri;\n}\nfunction parseClaims(idTokenOrJsonClaims) {\n    if (!idTokenOrJsonClaims) {\n        return undefined;\n    }\n    let claims;\n    if (idTokenOrJsonClaims.startsWith(\"{\")) {\n        try {\n            claims = JSON.parse(idTokenOrJsonClaims);\n        }\n        catch (_a) {\n            throw new errors_1.BadRequestError(`INVALID_IDP_RESPONSE : Unable to parse id_token: ${idTokenOrJsonClaims} ((Auth Emulator failed to parse fake id_token as strict JSON.))`);\n        }\n    }\n    else {\n        const decoded = jsonwebtoken_1.decode(idTokenOrJsonClaims, { json: true });\n        if (!decoded) {\n            return undefined;\n        }\n        claims = decoded;\n    }\n    errors_1.assert(claims.sub, 'INVALID_IDP_RESPONSE : Invalid Idp Response: id_token missing required fields. ((Missing \"sub\" field. This field is required and must be a unique identifier.))');\n    errors_1.assert(typeof claims.sub === \"string\", 'INVALID_IDP_RESPONSE : ((The \"sub\" field must be a string.))');\n    return claims;\n}\nfunction fakeFetchUserInfoFromIdp(providerId, claims) {\n    const rawId = claims.sub;\n    const email = claims.email ? utils_1.canonicalizeEmailAddress(claims.email) : undefined;\n    const emailVerified = !!claims.email_verified;\n    const displayName = claims.name;\n    const photoUrl = claims.picture;\n    const response = {\n        kind: \"identitytoolkit#VerifyAssertionResponse\",\n        context: \"\",\n        providerId,\n        displayName,\n        fullName: displayName,\n        screenName: claims.screen_name,\n        email,\n        emailVerified,\n        photoUrl,\n    };\n    let federatedId;\n    switch (providerId) {\n        case \"google.com\": {\n            federatedId = `https://accounts.google.com/${rawId}`;\n            let granted_scopes = \"openid https://www.googleapis.com/auth/userinfo.profile\";\n            if (email) {\n                granted_scopes += \" https://www.googleapis.com/auth/userinfo.email\";\n            }\n            response.firstName = claims.given_name;\n            response.lastName = claims.family_name;\n            response.rawUserInfo = JSON.stringify({\n                granted_scopes,\n                id: rawId,\n                name: displayName,\n                given_name: claims.given_name,\n                family_name: claims.family_name,\n                verified_email: emailVerified,\n                locale: \"en\",\n                email,\n                picture: photoUrl,\n            });\n            break;\n        }\n        default:\n            federatedId = rawId;\n            response.rawUserInfo = JSON.stringify(claims);\n            break;\n    }\n    response.federatedId = federatedId;\n    return { response, rawId };\n}\nfunction handleLinkIdp(state, response, userFromIdToken) {\n    if (state.oneAccountPerEmail && response.email) {\n        const userMatchingEmail = state.getUserByEmail(response.email);\n        errors_1.assert(!userMatchingEmail || userMatchingEmail.localId === userFromIdToken.localId, \"EMAIL_EXISTS\");\n    }\n    response.localId = userFromIdToken.localId;\n    const fields = {};\n    if (state.oneAccountPerEmail && response.email && !userFromIdToken.email) {\n        fields.email = response.email;\n        fields.emailVerified = response.emailVerified;\n    }\n    if (response.email &&\n        response.emailVerified &&\n        (fields.email || userFromIdToken.email) === response.email) {\n        fields.emailVerified = true;\n    }\n    return { accountUpdates: { fields }, response };\n}\nfunction handleIdpSigninEmailNotRequired(response, userMatchingProvider) {\n    if (userMatchingProvider) {\n        return {\n            response: Object.assign(Object.assign({}, response), { localId: userMatchingProvider.localId }),\n            accountUpdates: {},\n        };\n    }\n    else {\n        return handleIdpSignUp(response, { emailRequired: false });\n    }\n}\nfunction handleIdpSigninEmailRequired(response, rawId, userMatchingProvider, userMatchingEmail) {\n    var _a, _b, _c;\n    if (userMatchingProvider) {\n        return {\n            response: Object.assign(Object.assign({}, response), { localId: userMatchingProvider.localId }),\n            accountUpdates: {},\n        };\n    }\n    else if (userMatchingEmail) {\n        if (response.emailVerified) {\n            if ((_a = userMatchingEmail.providerUserInfo) === null || _a === void 0 ? void 0 : _a.some((info) => info.providerId === response.providerId && info.rawId !== rawId)) {\n                response.emailRecycled = true;\n            }\n            response.localId = userMatchingEmail.localId;\n            const accountUpdates = {\n                fields: {},\n            };\n            if (!userMatchingEmail.emailVerified) {\n                accountUpdates.fields.passwordHash = undefined;\n                accountUpdates.fields.phoneNumber = undefined;\n                accountUpdates.fields.validSince = utils_1.toUnixTimestamp(new Date()).toString();\n                accountUpdates.deleteProviders = (_b = userMatchingEmail.providerUserInfo) === null || _b === void 0 ? void 0 : _b.map((info) => info.providerId);\n            }\n            accountUpdates.fields.dateOfBirth = response.dateOfBirth;\n            accountUpdates.fields.displayName = response.displayName;\n            accountUpdates.fields.language = response.language;\n            accountUpdates.fields.photoUrl = response.photoUrl;\n            accountUpdates.fields.screenName = response.screenName;\n            accountUpdates.fields.emailVerified = true;\n            return { response, accountUpdates };\n        }\n        else {\n            response.needConfirmation = true;\n            response.localId = userMatchingEmail.localId;\n            response.verifiedProvider = (_c = userMatchingEmail.providerUserInfo) === null || _c === void 0 ? void 0 : _c.map((info) => info.providerId).filter((id) => id !== state_1.PROVIDER_PASSWORD && id !== state_1.PROVIDER_PHONE);\n            return { response, accountUpdates: {} };\n        }\n    }\n    else {\n        return handleIdpSignUp(response, { emailRequired: true });\n    }\n}\nfunction handleIdpSignUp(response, options) {\n    const accountUpdates = {\n        fields: {\n            dateOfBirth: response.dateOfBirth,\n            displayName: response.displayName,\n            language: response.language,\n            photoUrl: response.photoUrl,\n            screenName: response.screenName,\n        },\n    };\n    if (options.emailRequired && response.email) {\n        accountUpdates.fields.email = response.email;\n        accountUpdates.fields.emailVerified = response.emailVerified;\n    }\n    return {\n        response: Object.assign(Object.assign({}, response), { isNewUser: true }),\n        accountUpdates,\n    };\n}\n"]},"metadata":{},"sourceType":"script"}