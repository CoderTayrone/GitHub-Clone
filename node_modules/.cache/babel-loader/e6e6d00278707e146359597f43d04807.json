{"ast":null,"code":"// It is expected that, when .add() returns false, the consumer\n// of the DirWriter will pause until a \"drain\" event occurs. Note\n// that this is *almost always going to be the case*, unless the\n// thing being written is some sort of unsupported type, and thus\n// skipped over.\nmodule.exports = DirWriter;\n\nvar Writer = require('./writer.js');\n\nvar inherits = require('inherits');\n\nvar mkdir = require('mkdirp');\n\nvar path = require('path');\n\nvar collect = require('./collect.js');\n\ninherits(DirWriter, Writer);\n\nfunction DirWriter(props) {\n  var self = this;\n\n  if (!(self instanceof DirWriter)) {\n    self.error('DirWriter must be called as constructor.', null, true);\n  } // should already be established as a Directory type\n\n\n  if (props.type !== 'Directory' || !props.Directory) {\n    self.error('Non-directory type ' + props.type + ' ' + JSON.stringify(props), null, true);\n  }\n\n  Writer.call(this, props);\n}\n\nDirWriter.prototype._create = function () {\n  var self = this;\n  mkdir(self._path, Writer.dirmode, function (er) {\n    if (er) return self.error(er); // ready to start getting entries!\n\n    self.ready = true;\n    self.emit('ready');\n\n    self._process();\n  });\n}; // a DirWriter has an add(entry) method, but its .write() doesn't\n// do anything.  Why a no-op rather than a throw?  Because this\n// leaves open the door for writing directory metadata for\n// gnu/solaris style dumpdirs.\n\n\nDirWriter.prototype.write = function () {\n  return true;\n};\n\nDirWriter.prototype.end = function () {\n  this._ended = true;\n\n  this._process();\n};\n\nDirWriter.prototype.add = function (entry) {\n  var self = this; // console.error('\\tadd', entry._path, '->', self._path)\n\n  collect(entry);\n\n  if (!self.ready || self._currentEntry) {\n    self._buffer.push(entry);\n\n    return false;\n  } // create a new writer, and pipe the incoming entry into it.\n\n\n  if (self._ended) {\n    return self.error('add after end');\n  }\n\n  self._buffer.push(entry);\n\n  self._process();\n\n  return this._buffer.length === 0;\n};\n\nDirWriter.prototype._process = function () {\n  var self = this; // console.error('DW Process p=%j', self._processing, self.basename)\n\n  if (self._processing) return;\n\n  var entry = self._buffer.shift();\n\n  if (!entry) {\n    // console.error(\"DW Drain\")\n    self.emit('drain');\n    if (self._ended) self._finish();\n    return;\n  }\n\n  self._processing = true; // console.error(\"DW Entry\", entry._path)\n\n  self.emit('entry', entry); // ok, add this entry\n  //\n  // don't allow recursive copying\n\n  var p = entry;\n  var pp;\n\n  do {\n    pp = p._path || p.path;\n\n    if (pp === self.root._path || pp === self._path || pp && pp.indexOf(self._path) === 0) {\n      // console.error('DW Exit (recursive)', entry.basename, self._path)\n      self._processing = false;\n      if (entry._collected) entry.pipe();\n      return self._process();\n    }\n\n    p = p.parent;\n  } while (p); // console.error(\"DW not recursive\")\n  // chop off the entry's root dir, replace with ours\n\n\n  var props = {\n    parent: self,\n    root: self.root || self,\n    type: entry.type,\n    depth: self.depth + 1\n  };\n  pp = entry._path || entry.path || entry.props.path;\n\n  if (entry.parent) {\n    pp = pp.substr(entry.parent._path.length + 1);\n  } // get rid of any ../../ shenanigans\n\n\n  props.path = path.join(self.path, path.join('/', pp)); // if i have a filter, the child should inherit it.\n\n  props.filter = self.filter; // all the rest of the stuff, copy over from the source.\n\n  Object.keys(entry.props).forEach(function (k) {\n    if (!props.hasOwnProperty(k)) {\n      props[k] = entry.props[k];\n    }\n  }); // not sure at this point what kind of writer this is.\n\n  var child = self._currentChild = new Writer(props);\n  child.on('ready', function () {\n    // console.error(\"DW Child Ready\", child.type, child._path)\n    // console.error(\"  resuming\", entry._path)\n    entry.pipe(child);\n    entry.resume();\n  }); // XXX Make this work in node.\n  // Long filenames should not break stuff.\n\n  child.on('error', function (er) {\n    if (child._swallowErrors) {\n      self.warn(er);\n      child.emit('end');\n      child.emit('close');\n    } else {\n      self.emit('error', er);\n    }\n  }); // we fire _end internally *after* end, so that we don't move on\n  // until any \"end\" listeners have had their chance to do stuff.\n\n  child.on('close', onend);\n  var ended = false;\n\n  function onend() {\n    if (ended) return;\n    ended = true; // console.error(\"* DW Child end\", child.basename)\n\n    self._currentChild = null;\n    self._processing = false;\n\n    self._process();\n  }\n};","map":{"version":3,"sources":["/home/dev/Documentos/Projects/github-clone/node_modules/fstream/lib/dir-writer.js"],"names":["module","exports","DirWriter","Writer","require","inherits","mkdir","path","collect","props","self","error","type","Directory","JSON","stringify","call","prototype","_create","_path","dirmode","er","ready","emit","_process","write","end","_ended","add","entry","_currentEntry","_buffer","push","length","_processing","shift","_finish","p","pp","root","indexOf","_collected","pipe","parent","depth","substr","join","filter","Object","keys","forEach","k","hasOwnProperty","child","_currentChild","on","resume","_swallowErrors","warn","onend","ended"],"mappings":"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","sourcesContent":["// It is expected that, when .add() returns false, the consumer\n// of the DirWriter will pause until a \"drain\" event occurs. Note\n// that this is *almost always going to be the case*, unless the\n// thing being written is some sort of unsupported type, and thus\n// skipped over.\n\nmodule.exports = DirWriter\n\nvar Writer = require('./writer.js')\nvar inherits = require('inherits')\nvar mkdir = require('mkdirp')\nvar path = require('path')\nvar collect = require('./collect.js')\n\ninherits(DirWriter, Writer)\n\nfunction DirWriter (props) {\n  var self = this\n  if (!(self instanceof DirWriter)) {\n    self.error('DirWriter must be called as constructor.', null, true)\n  }\n\n  // should already be established as a Directory type\n  if (props.type !== 'Directory' || !props.Directory) {\n    self.error('Non-directory type ' + props.type + ' ' +\n      JSON.stringify(props), null, true)\n  }\n\n  Writer.call(this, props)\n}\n\nDirWriter.prototype._create = function () {\n  var self = this\n  mkdir(self._path, Writer.dirmode, function (er) {\n    if (er) return self.error(er)\n    // ready to start getting entries!\n    self.ready = true\n    self.emit('ready')\n    self._process()\n  })\n}\n\n// a DirWriter has an add(entry) method, but its .write() doesn't\n// do anything.  Why a no-op rather than a throw?  Because this\n// leaves open the door for writing directory metadata for\n// gnu/solaris style dumpdirs.\nDirWriter.prototype.write = function () {\n  return true\n}\n\nDirWriter.prototype.end = function () {\n  this._ended = true\n  this._process()\n}\n\nDirWriter.prototype.add = function (entry) {\n  var self = this\n\n  // console.error('\\tadd', entry._path, '->', self._path)\n  collect(entry)\n  if (!self.ready || self._currentEntry) {\n    self._buffer.push(entry)\n    return false\n  }\n\n  // create a new writer, and pipe the incoming entry into it.\n  if (self._ended) {\n    return self.error('add after end')\n  }\n\n  self._buffer.push(entry)\n  self._process()\n\n  return this._buffer.length === 0\n}\n\nDirWriter.prototype._process = function () {\n  var self = this\n\n  // console.error('DW Process p=%j', self._processing, self.basename)\n\n  if (self._processing) return\n\n  var entry = self._buffer.shift()\n  if (!entry) {\n    // console.error(\"DW Drain\")\n    self.emit('drain')\n    if (self._ended) self._finish()\n    return\n  }\n\n  self._processing = true\n  // console.error(\"DW Entry\", entry._path)\n\n  self.emit('entry', entry)\n\n  // ok, add this entry\n  //\n  // don't allow recursive copying\n  var p = entry\n  var pp\n  do {\n    pp = p._path || p.path\n    if (pp === self.root._path || pp === self._path ||\n      (pp && pp.indexOf(self._path) === 0)) {\n      // console.error('DW Exit (recursive)', entry.basename, self._path)\n      self._processing = false\n      if (entry._collected) entry.pipe()\n      return self._process()\n    }\n    p = p.parent\n  } while (p)\n\n  // console.error(\"DW not recursive\")\n\n  // chop off the entry's root dir, replace with ours\n  var props = {\n    parent: self,\n    root: self.root || self,\n    type: entry.type,\n    depth: self.depth + 1\n  }\n\n  pp = entry._path || entry.path || entry.props.path\n  if (entry.parent) {\n    pp = pp.substr(entry.parent._path.length + 1)\n  }\n  // get rid of any ../../ shenanigans\n  props.path = path.join(self.path, path.join('/', pp))\n\n  // if i have a filter, the child should inherit it.\n  props.filter = self.filter\n\n  // all the rest of the stuff, copy over from the source.\n  Object.keys(entry.props).forEach(function (k) {\n    if (!props.hasOwnProperty(k)) {\n      props[k] = entry.props[k]\n    }\n  })\n\n  // not sure at this point what kind of writer this is.\n  var child = self._currentChild = new Writer(props)\n  child.on('ready', function () {\n    // console.error(\"DW Child Ready\", child.type, child._path)\n    // console.error(\"  resuming\", entry._path)\n    entry.pipe(child)\n    entry.resume()\n  })\n\n  // XXX Make this work in node.\n  // Long filenames should not break stuff.\n  child.on('error', function (er) {\n    if (child._swallowErrors) {\n      self.warn(er)\n      child.emit('end')\n      child.emit('close')\n    } else {\n      self.emit('error', er)\n    }\n  })\n\n  // we fire _end internally *after* end, so that we don't move on\n  // until any \"end\" listeners have had their chance to do stuff.\n  child.on('close', onend)\n  var ended = false\n  function onend () {\n    if (ended) return\n    ended = true\n    // console.error(\"* DW Child end\", child.basename)\n    self._currentChild = null\n    self._processing = false\n    self._process()\n  }\n}\n"]},"metadata":{},"sourceType":"script"}