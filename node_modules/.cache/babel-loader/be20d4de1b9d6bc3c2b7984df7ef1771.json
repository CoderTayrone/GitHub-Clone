{"ast":null,"code":"var binary = require('binary');\n\nmodule.exports = function (extraField, vars) {\n  var extra; // Find the ZIP64 header, if present.\n\n  while (!extra && extraField && extraField.length) {\n    var candidateExtra = binary.parse(extraField).word16lu('signature').word16lu('partsize').word64lu('uncompressedSize').word64lu('compressedSize').word64lu('offset').word64lu('disknum').vars;\n\n    if (candidateExtra.signature === 0x0001) {\n      extra = candidateExtra;\n    } else {\n      // Advance the buffer to the next part.\n      // The total size of this part is the 4 byte header + partsize.\n      extraField = extraField.slice(candidateExtra.partsize + 4);\n    }\n  }\n\n  extra = extra || {};\n  if (vars.compressedSize === 0xffffffff) vars.compressedSize = extra.compressedSize;\n  if (vars.uncompressedSize === 0xffffffff) vars.uncompressedSize = extra.uncompressedSize;\n  if (vars.offsetToLocalFileHeader === 0xffffffff) vars.offsetToLocalFileHeader = extra.offset;\n  return extra;\n};","map":{"version":3,"sources":["/home/dev/Documentos/Projects/github-clone/node_modules/unzipper/lib/parseExtraField.js"],"names":["binary","require","module","exports","extraField","vars","extra","length","candidateExtra","parse","word16lu","word64lu","signature","slice","partsize","compressedSize","uncompressedSize","offsetToLocalFileHeader","offset"],"mappings":"AAAA,IAAIA,MAAM,GAAGC,OAAO,CAAC,QAAD,CAApB;;AAEAC,MAAM,CAACC,OAAP,GAAiB,UAASC,UAAT,EAAqBC,IAArB,EAA2B;AAC1C,MAAIC,KAAJ,CAD0C,CAE1C;;AACA,SAAM,CAACA,KAAD,IAAUF,UAAV,IAAwBA,UAAU,CAACG,MAAzC,EAAiD;AAC/C,QAAIC,cAAc,GAAGR,MAAM,CAACS,KAAP,CAAaL,UAAb,EAClBM,QADkB,CACT,WADS,EAElBA,QAFkB,CAET,UAFS,EAGlBC,QAHkB,CAGT,kBAHS,EAIlBA,QAJkB,CAIT,gBAJS,EAKlBA,QALkB,CAKT,QALS,EAMlBA,QANkB,CAMT,SANS,EAOlBN,IAPH;;AASA,QAAGG,cAAc,CAACI,SAAf,KAA6B,MAAhC,EAAwC;AACtCN,MAAAA,KAAK,GAAGE,cAAR;AACD,KAFD,MAEO;AACL;AACA;AACAJ,MAAAA,UAAU,GAAGA,UAAU,CAACS,KAAX,CAAiBL,cAAc,CAACM,QAAf,GAA0B,CAA3C,CAAb;AACD;AACF;;AAEDR,EAAAA,KAAK,GAAGA,KAAK,IAAI,EAAjB;AAEA,MAAID,IAAI,CAACU,cAAL,KAAwB,UAA5B,EACEV,IAAI,CAACU,cAAL,GAAsBT,KAAK,CAACS,cAA5B;AAEF,MAAIV,IAAI,CAACW,gBAAL,KAA2B,UAA/B,EACEX,IAAI,CAACW,gBAAL,GAAuBV,KAAK,CAACU,gBAA7B;AAEF,MAAIX,IAAI,CAACY,uBAAL,KAAiC,UAArC,EACEZ,IAAI,CAACY,uBAAL,GAA8BX,KAAK,CAACY,MAApC;AAEF,SAAOZ,KAAP;AACD,CAlCD","sourcesContent":["var binary = require('binary');\n\nmodule.exports = function(extraField, vars) {\n  var extra;\n  // Find the ZIP64 header, if present.\n  while(!extra && extraField && extraField.length) {\n    var candidateExtra = binary.parse(extraField)\n      .word16lu('signature')\n      .word16lu('partsize')\n      .word64lu('uncompressedSize')\n      .word64lu('compressedSize')\n      .word64lu('offset')\n      .word64lu('disknum')\n      .vars;\n\n    if(candidateExtra.signature === 0x0001) {\n      extra = candidateExtra;\n    } else {\n      // Advance the buffer to the next part.\n      // The total size of this part is the 4 byte header + partsize.\n      extraField = extraField.slice(candidateExtra.partsize + 4);\n    }\n  }\n\n  extra = extra || {};\n\n  if (vars.compressedSize === 0xffffffff)\n    vars.compressedSize = extra.compressedSize;\n\n  if (vars.uncompressedSize  === 0xffffffff)\n    vars.uncompressedSize= extra.uncompressedSize;\n\n  if (vars.offsetToLocalFileHeader === 0xffffffff)\n    vars.offsetToLocalFileHeader= extra.offset;\n\n  return extra;\n};\n"]},"metadata":{},"sourceType":"script"}