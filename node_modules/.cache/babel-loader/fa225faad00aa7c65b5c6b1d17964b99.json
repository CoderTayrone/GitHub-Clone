{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.JsonReference = exports.JsonPointer = void 0;\n\nconst util_1 = require(\"./util\");\n\nfunction isObject(value) {\n  return typeof value === 'object' && value !== null;\n}\n\nfunction shouldDescend(obj) {\n  return isObject(obj) && !JsonReference.isReference(obj);\n}\n\nfunction descendingVisit(target, visitor, encoder) {\n  const distinctObjects = new Map();\n  const q = [{\n    obj: target,\n    path: []\n  }];\n\n  while (q.length) {\n    const {\n      obj,\n      path\n    } = q.shift();\n    visitor(encoder(path), obj);\n\n    if (shouldDescend(obj)) {\n      distinctObjects.set(obj, new JsonPointer(util_1.encodeUriFragmentIdentifier(path)));\n\n      if (!Array.isArray(obj)) {\n        const keys = Object.keys(obj);\n        const len = keys.length;\n        let i = -1;\n\n        while (++i < len) {\n          const it = obj[keys[i]];\n\n          if (isObject(it) && distinctObjects.has(it)) {\n            q.push({\n              obj: new JsonReference(distinctObjects.get(it)),\n              path: path.concat(keys[i])\n            });\n          } else {\n            q.push({\n              obj: it,\n              path: path.concat(keys[i])\n            });\n          }\n        }\n      } else {\n        let j = -1;\n        const len = obj.length;\n\n        while (++j < len) {\n          const it = obj[j];\n\n          if (isObject(it) && distinctObjects.has(it)) {\n            q.push({\n              obj: new JsonReference(distinctObjects.get(it)),\n              path: path.concat([j + ''])\n            });\n          } else {\n            q.push({\n              obj: it,\n              path: path.concat([j + ''])\n            });\n          }\n        }\n      }\n    }\n  }\n}\n\nconst $ptr = Symbol('pointer');\nconst $frg = Symbol('fragmentId');\nconst $get = Symbol('getter');\n\nclass JsonPointer {\n  constructor(ptr) {\n    this.path = util_1.decodePtrInit(ptr);\n  }\n\n  static create(pointer) {\n    return new JsonPointer(pointer);\n  }\n\n  static has(target, pointer) {\n    if (typeof pointer === 'string' || Array.isArray(pointer)) {\n      pointer = new JsonPointer(pointer);\n    }\n\n    return pointer.has(target);\n  }\n\n  static get(target, pointer) {\n    if (typeof pointer === 'string' || Array.isArray(pointer)) {\n      pointer = new JsonPointer(pointer);\n    }\n\n    return pointer.get(target);\n  }\n\n  static set(target, pointer, val, force = false) {\n    if (typeof pointer === 'string' || Array.isArray(pointer)) {\n      pointer = new JsonPointer(pointer);\n    }\n\n    return pointer.set(target, val, force);\n  }\n\n  static unset(target, pointer) {\n    if (typeof pointer === 'string' || Array.isArray(pointer)) {\n      pointer = new JsonPointer(pointer);\n    }\n\n    return pointer.unset(target);\n  }\n\n  static decode(pointer) {\n    return util_1.pickDecoder(pointer)(pointer);\n  }\n\n  static visit(target, visitor, fragmentId = false) {\n    descendingVisit(target, visitor, fragmentId ? util_1.encodeUriFragmentIdentifier : util_1.encodePointer);\n  }\n\n  static listPointers(target) {\n    const res = [];\n    descendingVisit(target, (pointer, value) => {\n      res.push({\n        pointer,\n        value\n      });\n    }, util_1.encodePointer);\n    return res;\n  }\n\n  static listFragmentIds(target) {\n    const res = [];\n    descendingVisit(target, (fragmentId, value) => {\n      res.push({\n        fragmentId,\n        value\n      });\n    }, util_1.encodeUriFragmentIdentifier);\n    return res;\n  }\n\n  static flatten(target, fragmentId = false) {\n    const res = {};\n    descendingVisit(target, (p, v) => {\n      res[p] = v;\n    }, fragmentId ? util_1.encodeUriFragmentIdentifier : util_1.encodePointer);\n    return res;\n  }\n\n  static map(target, fragmentId = false) {\n    const res = new Map();\n    descendingVisit(target, res.set.bind(res), fragmentId ? util_1.encodeUriFragmentIdentifier : util_1.encodePointer);\n    return res;\n  }\n\n  get(target) {\n    if (!this[$get]) {\n      this[$get] = util_1.compilePointerDereference(this.path);\n    }\n\n    return this[$get](target);\n  }\n\n  set(target, value, force = false) {\n    return util_1.setValueAtPath(target, value, this.path, force);\n  }\n\n  unset(target) {\n    return util_1.unsetValueAtPath(target, this.path);\n  }\n\n  has(target) {\n    return typeof this.get(target) !== 'undefined';\n  }\n\n  parent(target) {\n    const p = this.path;\n    if (p.length == 1) return undefined;\n    const parent = new JsonPointer(p.slice(0, p.length - 1));\n    return parent.get(target);\n  }\n\n  relative(ptr) {\n    const p = this.path;\n    const decoded = util_1.decodeRelativePointer(ptr);\n    const n = parseInt(decoded[0]);\n    if (n > p.length) throw new Error('Relative location does not exist.');\n    const r = p.slice(0, p.length - n).concat(decoded.slice(1));\n\n    if (decoded[0][decoded[0].length - 1] == '#') {\n      const name = r[r.length - 1];\n      throw new Error(`We won't compile a pointer that will always return '${name}'. Use JsonPointer.rel(target, ptr) instead.`);\n    }\n\n    return new JsonPointer(r);\n  }\n\n  rel(target, ptr) {\n    const p = this.path;\n    const decoded = util_1.decodeRelativePointer(ptr);\n    const n = parseInt(decoded[0]);\n\n    if (n > p.length) {\n      return undefined;\n    }\n\n    const r = p.slice(0, p.length - n).concat(decoded.slice(1));\n    const other = new JsonPointer(r);\n\n    if (decoded[0][decoded[0].length - 1] == '#') {\n      const name = r[r.length - 1];\n      const parent = other.parent(target);\n      return Array.isArray(parent) ? parseInt(name, 10) : name;\n    }\n\n    return other.get(target);\n  }\n\n  concat(ptr) {\n    return new JsonPointer(this.path.concat(ptr instanceof JsonPointer ? ptr.path : util_1.decodePtrInit(ptr)));\n  }\n\n  get pointer() {\n    if (this[$ptr] === undefined) {\n      this[$ptr] = util_1.encodePointer(this.path);\n    }\n\n    return this[$ptr];\n  }\n\n  get uriFragmentIdentifier() {\n    if (!this[$frg]) {\n      this[$frg] = util_1.encodeUriFragmentIdentifier(this.path);\n    }\n\n    return this[$frg];\n  }\n\n  toString() {\n    return this.pointer;\n  }\n\n}\n\nexports.JsonPointer = JsonPointer;\nconst $pointer = Symbol('pointer');\n\nclass JsonReference {\n  constructor(pointer) {\n    this[$pointer] = pointer instanceof JsonPointer ? pointer : new JsonPointer(pointer);\n    this.$ref = this[$pointer].uriFragmentIdentifier;\n  }\n\n  static isReference(candidate) {\n    if (!candidate) return false;\n    const ref = candidate;\n    return typeof ref.$ref === 'string' && typeof ref.resolve === 'function';\n  }\n\n  resolve(target) {\n    return this[$pointer].get(target);\n  }\n\n  pointer() {\n    return this[$pointer];\n  }\n\n  toString() {\n    return this.$ref;\n  }\n\n}\n\nexports.JsonReference = JsonReference;","map":{"version":3,"sources":["../src/pointer.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.JsonReference = exports.JsonPointer = void 0;\nconst util_1 = require(\"./util\");\nfunction isObject(value) {\n    return typeof value === 'object' && value !== null;\n}\nfunction shouldDescend(obj) {\n    return isObject(obj) && !JsonReference.isReference(obj);\n}\nfunction descendingVisit(target, visitor, encoder) {\n    const distinctObjects = new Map();\n    const q = [{ obj: target, path: [] }];\n    while (q.length) {\n        const { obj, path } = q.shift();\n        visitor(encoder(path), obj);\n        if (shouldDescend(obj)) {\n            distinctObjects.set(obj, new JsonPointer(util_1.encodeUriFragmentIdentifier(path)));\n            if (!Array.isArray(obj)) {\n                const keys = Object.keys(obj);\n                const len = keys.length;\n                let i = -1;\n                while (++i < len) {\n                    const it = obj[keys[i]];\n                    if (isObject(it) && distinctObjects.has(it)) {\n                        q.push({\n                            obj: new JsonReference(distinctObjects.get(it)),\n                            path: path.concat(keys[i]),\n                        });\n                    }\n                    else {\n                        q.push({\n                            obj: it,\n                            path: path.concat(keys[i]),\n                        });\n                    }\n                }\n            }\n            else {\n                let j = -1;\n                const len = obj.length;\n                while (++j < len) {\n                    const it = obj[j];\n                    if (isObject(it) && distinctObjects.has(it)) {\n                        q.push({\n                            obj: new JsonReference(distinctObjects.get(it)),\n                            path: path.concat([j + '']),\n                        });\n                    }\n                    else {\n                        q.push({\n                            obj: it,\n                            path: path.concat([j + '']),\n                        });\n                    }\n                }\n            }\n        }\n    }\n}\nconst $ptr = Symbol('pointer');\nconst $frg = Symbol('fragmentId');\nconst $get = Symbol('getter');\nclass JsonPointer {\n    constructor(ptr) {\n        this.path = util_1.decodePtrInit(ptr);\n    }\n    static create(pointer) {\n        return new JsonPointer(pointer);\n    }\n    static has(target, pointer) {\n        if (typeof pointer === 'string' || Array.isArray(pointer)) {\n            pointer = new JsonPointer(pointer);\n        }\n        return pointer.has(target);\n    }\n    static get(target, pointer) {\n        if (typeof pointer === 'string' || Array.isArray(pointer)) {\n            pointer = new JsonPointer(pointer);\n        }\n        return pointer.get(target);\n    }\n    static set(target, pointer, val, force = false) {\n        if (typeof pointer === 'string' || Array.isArray(pointer)) {\n            pointer = new JsonPointer(pointer);\n        }\n        return pointer.set(target, val, force);\n    }\n    static unset(target, pointer) {\n        if (typeof pointer === 'string' || Array.isArray(pointer)) {\n            pointer = new JsonPointer(pointer);\n        }\n        return pointer.unset(target);\n    }\n    static decode(pointer) {\n        return util_1.pickDecoder(pointer)(pointer);\n    }\n    static visit(target, visitor, fragmentId = false) {\n        descendingVisit(target, visitor, fragmentId ? util_1.encodeUriFragmentIdentifier : util_1.encodePointer);\n    }\n    static listPointers(target) {\n        const res = [];\n        descendingVisit(target, (pointer, value) => {\n            res.push({ pointer, value });\n        }, util_1.encodePointer);\n        return res;\n    }\n    static listFragmentIds(target) {\n        const res = [];\n        descendingVisit(target, (fragmentId, value) => {\n            res.push({ fragmentId, value });\n        }, util_1.encodeUriFragmentIdentifier);\n        return res;\n    }\n    static flatten(target, fragmentId = false) {\n        const res = {};\n        descendingVisit(target, (p, v) => {\n            res[p] = v;\n        }, fragmentId ? util_1.encodeUriFragmentIdentifier : util_1.encodePointer);\n        return res;\n    }\n    static map(target, fragmentId = false) {\n        const res = new Map();\n        descendingVisit(target, res.set.bind(res), fragmentId ? util_1.encodeUriFragmentIdentifier : util_1.encodePointer);\n        return res;\n    }\n    get(target) {\n        if (!this[$get]) {\n            this[$get] = util_1.compilePointerDereference(this.path);\n        }\n        return this[$get](target);\n    }\n    set(target, value, force = false) {\n        return util_1.setValueAtPath(target, value, this.path, force);\n    }\n    unset(target) {\n        return util_1.unsetValueAtPath(target, this.path);\n    }\n    has(target) {\n        return typeof this.get(target) !== 'undefined';\n    }\n    parent(target) {\n        const p = this.path;\n        if (p.length == 1)\n            return undefined;\n        const parent = new JsonPointer(p.slice(0, p.length - 1));\n        return parent.get(target);\n    }\n    relative(ptr) {\n        const p = this.path;\n        const decoded = util_1.decodeRelativePointer(ptr);\n        const n = parseInt(decoded[0]);\n        if (n > p.length)\n            throw new Error('Relative location does not exist.');\n        const r = p.slice(0, p.length - n).concat(decoded.slice(1));\n        if (decoded[0][decoded[0].length - 1] == '#') {\n            const name = r[r.length - 1];\n            throw new Error(`We won't compile a pointer that will always return '${name}'. Use JsonPointer.rel(target, ptr) instead.`);\n        }\n        return new JsonPointer(r);\n    }\n    rel(target, ptr) {\n        const p = this.path;\n        const decoded = util_1.decodeRelativePointer(ptr);\n        const n = parseInt(decoded[0]);\n        if (n > p.length) {\n            return undefined;\n        }\n        const r = p.slice(0, p.length - n).concat(decoded.slice(1));\n        const other = new JsonPointer(r);\n        if (decoded[0][decoded[0].length - 1] == '#') {\n            const name = r[r.length - 1];\n            const parent = other.parent(target);\n            return Array.isArray(parent) ? parseInt(name, 10) : name;\n        }\n        return other.get(target);\n    }\n    concat(ptr) {\n        return new JsonPointer(this.path.concat(ptr instanceof JsonPointer ? ptr.path : util_1.decodePtrInit(ptr)));\n    }\n    get pointer() {\n        if (this[$ptr] === undefined) {\n            this[$ptr] = util_1.encodePointer(this.path);\n        }\n        return this[$ptr];\n    }\n    get uriFragmentIdentifier() {\n        if (!this[$frg]) {\n            this[$frg] = util_1.encodeUriFragmentIdentifier(this.path);\n        }\n        return this[$frg];\n    }\n    toString() {\n        return this.pointer;\n    }\n}\nexports.JsonPointer = JsonPointer;\nconst $pointer = Symbol('pointer');\nclass JsonReference {\n    constructor(pointer) {\n        this[$pointer] =\n            pointer instanceof JsonPointer ? pointer : new JsonPointer(pointer);\n        this.$ref = this[$pointer].uriFragmentIdentifier;\n    }\n    static isReference(candidate) {\n        if (!candidate)\n            return false;\n        const ref = candidate;\n        return typeof ref.$ref === 'string' && typeof ref.resolve === 'function';\n    }\n    resolve(target) {\n        return this[$pointer].get(target);\n    }\n    pointer() {\n        return this[$pointer];\n    }\n    toString() {\n        return this.$ref;\n    }\n}\nexports.JsonReference = JsonReference;\n//# sourceMappingURL=pointer.js.map"]},"metadata":{},"sourceType":"script"}