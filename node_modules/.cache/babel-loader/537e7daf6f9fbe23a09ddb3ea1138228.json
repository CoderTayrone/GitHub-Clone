{"ast":null,"code":"/**\n * Copyright 2015 Google Inc. All Rights Reserved.\n * Use of this source code is governed by a BSD-style\n * license that can be found in the LICENSE file or at\n * https://github.com/firebase/superstatic/blob/master/LICENSE\n */\nconst _ = require(\"lodash\");\n\nconst pathjoin = require(\"join-path\");\n\nconst pathutils = require(\"../utils/pathutils\");\n\nconst url = require(\"fast-url-parser\");\n/**\n * We cannot redirect to \"\", redirect to \"/\" instead.\n * @param {string} path path\n * @return {string} noramlized path\n */\n\n\nfunction normalizeRedirectPath(path) {\n  return path || \"/\";\n}\n\nmodule.exports = function () {\n  return function (req, res, next) {\n    const config = req.superstatic;\n    const trailingSlashBehavior = config.trailingSlash;\n    const parsedUrl = url.parse(req.url);\n    const pathname = pathutils.normalizeMultiSlashes(parsedUrl.pathname);\n    const search = parsedUrl.search || \"\";\n    const cleanUrlRules = !!_.get(req, \"superstatic.cleanUrls\"); // Exact file always wins.\n\n    return providerResult(req, res, pathname).then(result => {\n      if (result) {\n        // If we are using cleanURLs, we'll trim off any `.html` (or `/index.html`), if it exists.\n        if (cleanUrlRules) {\n          if (_.endsWith(pathname, \".html\")) {\n            let redirPath = pathutils.removeTrailingString(pathname, \".html\");\n\n            if (_.endsWith(redirPath, \"/index\")) {\n              redirPath = pathutils.removeTrailingString(redirPath, \"/index\");\n            }\n\n            if (trailingSlashBehavior === true) {\n              redirPath = pathutils.addTrailingSlash(redirPath);\n            }\n\n            return res.superstatic.handle({\n              redirect: normalizeRedirectPath(redirPath + search)\n            });\n          }\n        }\n\n        return res.superstatic.handleFileStream({\n          file: pathname\n        }, result);\n      } // Now, let's consider the trailing slash.\n\n\n      const hasTrailingSlash = pathutils.hasTrailingSlash(pathname); // We want to check for some other files, namely an `index.html` if this were a directory.\n\n      const pathAsDirectoryWithIndex = pathutils.asDirectoryIndex(pathutils.addTrailingSlash(pathname));\n      return providerResult(req, res, pathAsDirectoryWithIndex).then(pathAsDirectoryWithIndexResult => {\n        // If an exact file wins now, we know that this path leads us to a directory.\n        if (pathAsDirectoryWithIndexResult) {\n          if (trailingSlashBehavior === undefined && !hasTrailingSlash && !cleanUrlRules) {\n            return res.superstatic.handle({\n              redirect: pathutils.addTrailingSlash(pathname) + search\n            });\n          }\n\n          if (trailingSlashBehavior === false && hasTrailingSlash && pathname !== \"/\") {\n            // No infinite redirects\n            return res.superstatic.handle({\n              redirect: normalizeRedirectPath(pathutils.removeTrailingSlash(pathname) + search)\n            });\n          }\n\n          if (trailingSlashBehavior === true && !hasTrailingSlash) {\n            return res.superstatic.handle({\n              redirect: pathutils.addTrailingSlash(pathname) + search\n            });\n          } // If we haven't returned yet, our path is \"correct\" and we should be serving a file, not redirecting.\n\n\n          return res.superstatic.handleFileStream({\n            file: pathAsDirectoryWithIndex\n          }, pathAsDirectoryWithIndexResult);\n        } // Let's check on the clean URLs property.\n        // We want to know if a specific mutation of the path exists.\n\n\n        if (cleanUrlRules) {\n          let appendedPath = pathname;\n\n          if (hasTrailingSlash) {\n            if (trailingSlashBehavior !== undefined) {\n              // We want to remove the trailing slash and see if a file exists with an .html attached.\n              appendedPath = pathutils.removeTrailingString(pathname, \"/\") + \".html\";\n            }\n          } else {\n            // Let's see if our path is a simple clean URL missing a .HTML5\n            appendedPath += \".html\";\n          }\n\n          return providerResult(req, res, appendedPath).then(appendedPathResult => {\n            if (appendedPathResult) {\n              // Okay, back to trailing slash behavior\n              if (trailingSlashBehavior === false && hasTrailingSlash) {\n                // If we had a slash to begin with, and we could be serving a file without it, we'll remove the slash.\n                // (This works because we are in the cleanURL block.)\n                return res.superstatic.handle({\n                  redirect: normalizeRedirectPath(pathutils.removeTrailingSlash(pathname) + search)\n                });\n              }\n\n              if (trailingSlashBehavior === true && !hasTrailingSlash) {\n                // If we are missing a slash and need to add it, we want to make sure our appended path is cleaned up.\n                appendedPath = pathutils.removeTrailingString(appendedPath, \".html\");\n                appendedPath = pathutils.removeTrailingString(appendedPath, \"/index\");\n                return res.superstatic.handle({\n                  redirect: pathutils.addTrailingSlash(appendedPath) + search\n                });\n              } // If we've gotten this far and still have `/index.html` on the end, we want to remove it from the URL.\n\n\n              if (_.endsWith(appendedPath, \"/index.html\")) {\n                return res.superstatic.handle({\n                  redirect: normalizeRedirectPath(pathutils.removeTrailingString(appendedPath, \"/index.html\") + search)\n                });\n              } // And if we should be serving a file and we're at the right path, we'll serve the file.\n\n\n              return res.superstatic.handleFileStream({\n                file: appendedPath\n              }, appendedPathResult);\n            }\n\n            return next();\n          });\n        }\n\n        return next();\n      });\n    }).catch(err => {\n      res.superstatic.handleError(err);\n    });\n  };\n};\n/**\n * Uses the provider to look for a file given a path.\n * This also takes into account i18n settings.\n * @param {*} req\n * @param {*} res\n * @param {string} p the path to search for.\n * @return {Promise<*>} a non-null value if a file is found.\n */\n\n\nfunction providerResult(req, res, p) {\n  return Promise.resolve().then(() => {\n    const promises = [];\n    const i18n = req.superstatic.i18n;\n\n    if (i18n && i18n.root) {\n      // The path order is:\n      // (1) root/language_country/path (for each language)\n      // (2) root/ALL_country/path (if country is set)\n      // (3) root/language_ALL/path or root/language/path (for each language)\n      const country = getCountryCode(req.headers);\n      const languages = getI18nLanguages(req.headers); // (1)\n\n      if (country) {\n        for (const l of languages) {\n          promises.push(res.superstatic.provider(req, pathjoin(i18n.root, `${l}_${country}`, p)));\n        } // (2)\n\n\n        promises.push(res.superstatic.provider(req, pathjoin(i18n.root, `ALL_${country}`, p)));\n      } // (3)\n\n\n      for (const l of languages) {\n        promises.push(res.superstatic.provider(req, pathjoin(i18n.root, `${l}_ALL`, p)));\n        promises.push(res.superstatic.provider(req, pathjoin(i18n.root, `${l}`, p)));\n      }\n    }\n\n    promises.push(res.superstatic.provider(req, p));\n    return Promise.all(promises);\n  }).then(results => {\n    for (const r of results) {\n      if (r) {\n        return r;\n      }\n    }\n  });\n}\n/**\n * Fetches the country code from the headers object.\n * @param {object} headers\n * @return {string} country code, or an empty string.\n */\n\n\nfunction getCountryCode(headers) {\n  const overrideValue = cookieValue(headers.cookie, \"firebase-country-override\");\n\n  if (overrideValue) {\n    return overrideValue;\n  }\n\n  return headers[\"x-country-code\"] || \"\";\n}\n/**\n * Fetches the languages from the accept-language header.\n * @param {object} headers\n * @return {Array<string>} ordered list of languages from the header.\n */\n\n\nfunction getI18nLanguages(headers) {\n  const overrideValue = cookieValue(headers.cookie, \"firebase-language-override\");\n\n  if (overrideValue) {\n    return overrideValue.includes(\",\") ? overrideValue.split(\",\") : [overrideValue];\n  }\n\n  const acceptLanguage = headers[\"accept-language\"];\n\n  if (!acceptLanguage) {\n    return [];\n  }\n\n  const languagesSeen = {};\n  const languagesOrdered = [];\n\n  for (const v of acceptLanguage.split(\",\")) {\n    const l = v.split(\"-\")[0];\n\n    if (!l) {\n      continue;\n    }\n\n    if (!languagesSeen[l]) {\n      languagesOrdered.push(l);\n    }\n\n    languagesSeen[l] = true;\n  }\n\n  return languagesOrdered;\n}\n/**\n * Fetches a value from a cookie string.\n * @param {string|undefined} cookieString full cookie string.\n * @param {string} key key to look for.\n * @return {string} the value.\n */\n\n\nfunction cookieValue(cookieString, key) {\n  if (!cookieString) {\n    return \"\";\n  }\n\n  const cookies = cookieString.split(\";\").map(c => c.trim());\n\n  for (const cookie of cookies) {\n    if (cookie.startsWith(key)) {\n      const s = cookie.split(\"=\", 2);\n      return s.length === 2 ? s[1] : \"\";\n    }\n  }\n\n  return \"\";\n}","map":{"version":3,"sources":["/home/dev/Documentos/Projects/github-clone/node_modules/superstatic/lib/middleware/files.js"],"names":["_","require","pathjoin","pathutils","url","normalizeRedirectPath","path","module","exports","req","res","next","config","superstatic","trailingSlashBehavior","trailingSlash","parsedUrl","parse","pathname","normalizeMultiSlashes","search","cleanUrlRules","get","providerResult","then","result","endsWith","redirPath","removeTrailingString","addTrailingSlash","handle","redirect","handleFileStream","file","hasTrailingSlash","pathAsDirectoryWithIndex","asDirectoryIndex","pathAsDirectoryWithIndexResult","undefined","removeTrailingSlash","appendedPath","appendedPathResult","catch","err","handleError","p","Promise","resolve","promises","i18n","root","country","getCountryCode","headers","languages","getI18nLanguages","l","push","provider","all","results","r","overrideValue","cookieValue","cookie","includes","split","acceptLanguage","languagesSeen","languagesOrdered","v","cookieString","key","cookies","map","c","trim","startsWith","s","length"],"mappings":"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","sourcesContent":["/**\n * Copyright 2015 Google Inc. All Rights Reserved.\n * Use of this source code is governed by a BSD-style\n * license that can be found in the LICENSE file or at\n * https://github.com/firebase/superstatic/blob/master/LICENSE\n */\n\nconst _ = require(\"lodash\");\nconst pathjoin = require(\"join-path\");\nconst pathutils = require(\"../utils/pathutils\");\nconst url = require(\"fast-url-parser\");\n\n/**\n * We cannot redirect to \"\", redirect to \"/\" instead.\n * @param {string} path path\n * @return {string} noramlized path\n */\nfunction normalizeRedirectPath(path) {\n  return path || \"/\";\n}\n\nmodule.exports = function() {\n  return function(req, res, next) {\n    const config = req.superstatic;\n    const trailingSlashBehavior = config.trailingSlash;\n\n    const parsedUrl = url.parse(req.url);\n    const pathname = pathutils.normalizeMultiSlashes(parsedUrl.pathname);\n    const search = parsedUrl.search || \"\";\n\n    const cleanUrlRules = !!_.get(req, \"superstatic.cleanUrls\");\n\n    // Exact file always wins.\n    return providerResult(req, res, pathname)\n      .then((result) => {\n        if (result) {\n          // If we are using cleanURLs, we'll trim off any `.html` (or `/index.html`), if it exists.\n          if (cleanUrlRules) {\n            if (_.endsWith(pathname, \".html\")) {\n              let redirPath = pathutils.removeTrailingString(pathname, \".html\");\n              if (_.endsWith(redirPath, \"/index\")) {\n                redirPath = pathutils.removeTrailingString(redirPath, \"/index\");\n              }\n              if (trailingSlashBehavior === true) {\n                redirPath = pathutils.addTrailingSlash(redirPath);\n              }\n              return res.superstatic.handle({\n                redirect: normalizeRedirectPath(redirPath + search)\n              });\n            }\n          }\n          return res.superstatic.handleFileStream({ file: pathname }, result);\n        }\n\n        // Now, let's consider the trailing slash.\n        const hasTrailingSlash = pathutils.hasTrailingSlash(pathname);\n\n        // We want to check for some other files, namely an `index.html` if this were a directory.\n        const pathAsDirectoryWithIndex = pathutils.asDirectoryIndex(\n          pathutils.addTrailingSlash(pathname)\n        );\n        return providerResult(req, res, pathAsDirectoryWithIndex).then(\n          (pathAsDirectoryWithIndexResult) => {\n            // If an exact file wins now, we know that this path leads us to a directory.\n            if (pathAsDirectoryWithIndexResult) {\n              if (\n                trailingSlashBehavior === undefined &&\n                !hasTrailingSlash &&\n                !cleanUrlRules\n              ) {\n                return res.superstatic.handle({\n                  redirect: pathutils.addTrailingSlash(pathname) + search\n                });\n              }\n              if (\n                trailingSlashBehavior === false &&\n                hasTrailingSlash &&\n                pathname !== \"/\"\n              ) {\n                // No infinite redirects\n                return res.superstatic.handle({\n                  redirect: normalizeRedirectPath(\n                    pathutils.removeTrailingSlash(pathname) + search\n                  )\n                });\n              }\n              if (trailingSlashBehavior === true && !hasTrailingSlash) {\n                return res.superstatic.handle({\n                  redirect: pathutils.addTrailingSlash(pathname) + search\n                });\n              }\n              // If we haven't returned yet, our path is \"correct\" and we should be serving a file, not redirecting.\n              return res.superstatic.handleFileStream(\n                { file: pathAsDirectoryWithIndex },\n                pathAsDirectoryWithIndexResult\n              );\n            }\n\n            // Let's check on the clean URLs property.\n            // We want to know if a specific mutation of the path exists.\n            if (cleanUrlRules) {\n              let appendedPath = pathname;\n              if (hasTrailingSlash) {\n                if (trailingSlashBehavior !== undefined) {\n                  // We want to remove the trailing slash and see if a file exists with an .html attached.\n                  appendedPath =\n                    pathutils.removeTrailingString(pathname, \"/\") + \".html\";\n                }\n              } else {\n                // Let's see if our path is a simple clean URL missing a .HTML5\n                appendedPath += \".html\";\n              }\n\n              return providerResult(req, res, appendedPath).then(\n                (appendedPathResult) => {\n                  if (appendedPathResult) {\n                    // Okay, back to trailing slash behavior\n                    if (trailingSlashBehavior === false && hasTrailingSlash) {\n                      // If we had a slash to begin with, and we could be serving a file without it, we'll remove the slash.\n                      // (This works because we are in the cleanURL block.)\n                      return res.superstatic.handle({\n                        redirect: normalizeRedirectPath(\n                          pathutils.removeTrailingSlash(pathname) + search\n                        )\n                      });\n                    }\n                    if (trailingSlashBehavior === true && !hasTrailingSlash) {\n                      // If we are missing a slash and need to add it, we want to make sure our appended path is cleaned up.\n                      appendedPath = pathutils.removeTrailingString(\n                        appendedPath,\n                        \".html\"\n                      );\n                      appendedPath = pathutils.removeTrailingString(\n                        appendedPath,\n                        \"/index\"\n                      );\n                      return res.superstatic.handle({\n                        redirect:\n                          pathutils.addTrailingSlash(appendedPath) + search\n                      });\n                    }\n                    // If we've gotten this far and still have `/index.html` on the end, we want to remove it from the URL.\n                    if (_.endsWith(appendedPath, \"/index.html\")) {\n                      return res.superstatic.handle({\n                        redirect: normalizeRedirectPath(\n                          pathutils.removeTrailingString(\n                            appendedPath,\n                            \"/index.html\"\n                          ) + search\n                        )\n                      });\n                    }\n                    // And if we should be serving a file and we're at the right path, we'll serve the file.\n                    return res.superstatic.handleFileStream(\n                      { file: appendedPath },\n                      appendedPathResult\n                    );\n                  }\n\n                  return next();\n                }\n              );\n            }\n\n            return next();\n          }\n        );\n      })\n      .catch((err) => {\n        res.superstatic.handleError(err);\n      });\n  };\n};\n\n/**\n * Uses the provider to look for a file given a path.\n * This also takes into account i18n settings.\n * @param {*} req\n * @param {*} res\n * @param {string} p the path to search for.\n * @return {Promise<*>} a non-null value if a file is found.\n */\nfunction providerResult(req, res, p) {\n  return Promise.resolve()\n    .then(() => {\n      const promises = [];\n\n      const i18n = req.superstatic.i18n;\n      if (i18n && i18n.root) {\n        // The path order is:\n        // (1) root/language_country/path (for each language)\n        // (2) root/ALL_country/path (if country is set)\n        // (3) root/language_ALL/path or root/language/path (for each language)\n        const country = getCountryCode(req.headers);\n        const languages = getI18nLanguages(req.headers);\n        // (1)\n        if (country) {\n          for (const l of languages) {\n            promises.push(\n              res.superstatic.provider(\n                req,\n                pathjoin(i18n.root, `${l}_${country}`, p)\n              )\n            );\n          }\n          // (2)\n          promises.push(\n            res.superstatic.provider(\n              req,\n              pathjoin(i18n.root, `ALL_${country}`, p)\n            )\n          );\n        }\n        // (3)\n        for (const l of languages) {\n          promises.push(\n            res.superstatic.provider(req, pathjoin(i18n.root, `${l}_ALL`, p))\n          );\n          promises.push(\n            res.superstatic.provider(req, pathjoin(i18n.root, `${l}`, p))\n          );\n        }\n      }\n\n      promises.push(res.superstatic.provider(req, p));\n      return Promise.all(promises);\n    })\n    .then((results) => {\n      for (const r of results) {\n        if (r) {\n          return r;\n        }\n      }\n    });\n}\n\n/**\n * Fetches the country code from the headers object.\n * @param {object} headers\n * @return {string} country code, or an empty string.\n */\nfunction getCountryCode(headers) {\n  const overrideValue = cookieValue(\n    headers.cookie,\n    \"firebase-country-override\"\n  );\n  if (overrideValue) {\n    return overrideValue;\n  }\n  return headers[\"x-country-code\"] || \"\";\n}\n\n/**\n * Fetches the languages from the accept-language header.\n * @param {object} headers\n * @return {Array<string>} ordered list of languages from the header.\n */\nfunction getI18nLanguages(headers) {\n  const overrideValue = cookieValue(\n    headers.cookie,\n    \"firebase-language-override\"\n  );\n  if (overrideValue) {\n    return overrideValue.includes(\",\")\n      ? overrideValue.split(\",\")\n      : [overrideValue];\n  }\n\n  const acceptLanguage = headers[\"accept-language\"];\n  if (!acceptLanguage) {\n    return [];\n  }\n\n  const languagesSeen = {};\n  const languagesOrdered = [];\n  for (const v of acceptLanguage.split(\",\")) {\n    const l = v.split(\"-\")[0];\n    if (!l) {\n      continue;\n    }\n    if (!languagesSeen[l]) {\n      languagesOrdered.push(l);\n    }\n    languagesSeen[l] = true;\n  }\n  return languagesOrdered;\n}\n\n/**\n * Fetches a value from a cookie string.\n * @param {string|undefined} cookieString full cookie string.\n * @param {string} key key to look for.\n * @return {string} the value.\n */\nfunction cookieValue(cookieString, key) {\n  if (!cookieString) {\n    return \"\";\n  }\n  const cookies = cookieString.split(\";\").map((c) => c.trim());\n  for (const cookie of cookies) {\n    if (cookie.startsWith(key)) {\n      const s = cookie.split(\"=\", 2);\n      return s.length === 2 ? s[1] : \"\";\n    }\n  }\n  return \"\";\n}\n"]},"metadata":{},"sourceType":"script"}