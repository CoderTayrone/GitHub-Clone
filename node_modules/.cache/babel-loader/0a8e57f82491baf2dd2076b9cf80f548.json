{"ast":null,"code":"/**\n * Copyright 2015 Google Inc. All Rights Reserved.\n * Use of this source code is governed by a BSD-style\n * license that can be found in the LICENSE file or at\n * https://github.com/firebase/superstatic/blob/master/LICENSE\n */\nconst crypto = require(\"crypto\");\n\nconst fs = require(\"fs\");\n\nconst pathjoin = require(\"join-path\");\n\nconst RSVP = require(\"rsvp\");\n\nconst _ = require(\"lodash\");\n\nconst statPromise = RSVP.denodeify(fs.stat);\n\nconst multiStat = function (paths) {\n  const pathname = paths.shift();\n  return statPromise(pathname).then(stat => {\n    stat.path = pathname;\n    return stat;\n  }, err => {\n    if (paths.length) {\n      return multiStat(paths);\n    }\n\n    return RSVP.reject(err);\n  });\n};\n\nmodule.exports = function (options) {\n  const etagCache = {};\n  const cwd = options.cwd || process.cwd();\n  let publicPaths = options.public || [\".\"];\n\n  if (!_.isArray(publicPaths)) {\n    publicPaths = [publicPaths];\n  }\n\n  function _fetchEtag(pathname, stat) {\n    return new RSVP.Promise((resolve, reject) => {\n      const cached = etagCache[pathname];\n\n      if (cached && cached.timestamp === stat.mtime) {\n        return resolve(cached.value);\n      } // the file you want to get the hash\n\n\n      const fd = fs.createReadStream(pathname);\n      const hash = crypto.createHash(\"md5\");\n      hash.setEncoding(\"hex\");\n      fd.on(\"error\", err => {\n        reject(err);\n      });\n      fd.on(\"end\", () => {\n        hash.end();\n        const etag = hash.read();\n        etagCache[pathname] = {\n          timestamp: stat.mtime,\n          value: etag\n        };\n        resolve(etag);\n      }); // read all file and pipe it (write it) to the hash object\n\n      return fd.pipe(hash);\n    });\n  }\n\n  return function (req, pathname) {\n    pathname = decodeURI(pathname); // jumping to parent directories is not allowed\n\n    if (pathname.indexOf(\"../\") >= 0 || pathname.indexOf(\"..\\\\\") >= 0 || pathname.toLowerCase().indexOf(\"..%5c\") >= 0) {\n      return RSVP.resolve(null);\n    }\n\n    const result = {};\n    let foundPath;\n    const fullPathnames = publicPaths.map(p => {\n      return pathjoin(cwd, p, pathname);\n    });\n    return multiStat(fullPathnames).then(stat => {\n      foundPath = stat.path;\n      result.modified = stat.mtime.getTime();\n      result.size = stat.size;\n      return _fetchEtag(stat.path, stat);\n    }).then(etag => {\n      result.etag = etag;\n      result.stream = fs.createReadStream(foundPath);\n      return result;\n    }).catch(err => {\n      if (err.code === \"ENOENT\" || err.code === \"ENOTDIR\" || err.code === \"EISDIR\" || err.code === \"EINVAL\") {\n        return null;\n      }\n\n      return RSVP.reject(err);\n    });\n  };\n};","map":{"version":3,"sources":["/home/dev/Documentos/Projects/github-clone/node_modules/superstatic/lib/providers/fs.js"],"names":["crypto","require","fs","pathjoin","RSVP","_","statPromise","denodeify","stat","multiStat","paths","pathname","shift","then","path","err","length","reject","module","exports","options","etagCache","cwd","process","publicPaths","public","isArray","_fetchEtag","Promise","resolve","cached","timestamp","mtime","value","fd","createReadStream","hash","createHash","setEncoding","on","end","etag","read","pipe","req","decodeURI","indexOf","toLowerCase","result","foundPath","fullPathnames","map","p","modified","getTime","size","stream","catch","code"],"mappings":"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","sourcesContent":["/**\n * Copyright 2015 Google Inc. All Rights Reserved.\n * Use of this source code is governed by a BSD-style\n * license that can be found in the LICENSE file or at\n * https://github.com/firebase/superstatic/blob/master/LICENSE\n */\n\nconst crypto = require(\"crypto\");\nconst fs = require(\"fs\");\nconst pathjoin = require(\"join-path\");\nconst RSVP = require(\"rsvp\");\nconst _ = require(\"lodash\");\n\nconst statPromise = RSVP.denodeify(fs.stat);\nconst multiStat = function(paths) {\n  const pathname = paths.shift();\n  return statPromise(pathname).then(\n    (stat) => {\n      stat.path = pathname;\n      return stat;\n    },\n    (err) => {\n      if (paths.length) {\n        return multiStat(paths);\n      }\n      return RSVP.reject(err);\n    }\n  );\n};\n\nmodule.exports = function(options) {\n  const etagCache = {};\n  const cwd = options.cwd || process.cwd();\n  let publicPaths = options.public || [\".\"];\n  if (!_.isArray(publicPaths)) {\n    publicPaths = [publicPaths];\n  }\n\n  function _fetchEtag(pathname, stat) {\n    return new RSVP.Promise((resolve, reject) => {\n      const cached = etagCache[pathname];\n      if (cached && cached.timestamp === stat.mtime) {\n        return resolve(cached.value);\n      }\n\n      // the file you want to get the hash\n      const fd = fs.createReadStream(pathname);\n      const hash = crypto.createHash(\"md5\");\n      hash.setEncoding(\"hex\");\n\n      fd.on(\"error\", (err) => {\n        reject(err);\n      });\n\n      fd.on(\"end\", () => {\n        hash.end();\n        const etag = hash.read();\n        etagCache[pathname] = {\n          timestamp: stat.mtime,\n          value: etag\n        };\n        resolve(etag);\n      });\n\n      // read all file and pipe it (write it) to the hash object\n      return fd.pipe(hash);\n    });\n  }\n\n  return function(req, pathname) {\n    pathname = decodeURI(pathname);\n    // jumping to parent directories is not allowed\n    if (\n      pathname.indexOf(\"../\") >= 0 ||\n      pathname.indexOf(\"..\\\\\") >= 0 ||\n      pathname.toLowerCase().indexOf(\"..%5c\") >= 0\n    ) {\n      return RSVP.resolve(null);\n    }\n\n    const result = {};\n    let foundPath;\n    const fullPathnames = publicPaths.map((p) => {\n      return pathjoin(cwd, p, pathname);\n    });\n\n    return multiStat(fullPathnames)\n      .then((stat) => {\n        foundPath = stat.path;\n        result.modified = stat.mtime.getTime();\n        result.size = stat.size;\n        return _fetchEtag(stat.path, stat);\n      })\n      .then((etag) => {\n        result.etag = etag;\n        result.stream = fs.createReadStream(foundPath);\n        return result;\n      })\n      .catch((err) => {\n        if (\n          err.code === \"ENOENT\" ||\n          err.code === \"ENOTDIR\" ||\n          err.code === \"EISDIR\" ||\n          err.code === \"EINVAL\"\n        ) {\n          return null;\n        }\n        return RSVP.reject(err);\n      });\n  };\n};\n"]},"metadata":{},"sourceType":"script"}