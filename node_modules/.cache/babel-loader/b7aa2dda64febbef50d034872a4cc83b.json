{"ast":null,"code":"\"use strict\";\n\nlet isWindows = /^win/.test(process.platform),\n    forwardSlashPattern = /\\//g,\n    protocolPattern = /^(\\w{2,}):\\/\\//i,\n    url = module.exports,\n    jsonPointerSlash = /~1/g,\n    jsonPointerTilde = /~0/g; // RegExp patterns to URL-encode special characters in local filesystem paths\n\nlet urlEncodePatterns = [/\\?/g, \"%3F\", /\\#/g, \"%23\"]; // RegExp patterns to URL-decode special characters for local filesystem paths\n\nlet urlDecodePatterns = [/\\%23/g, \"#\", /\\%24/g, \"$\", /\\%26/g, \"&\", /\\%2C/g, \",\", /\\%40/g, \"@\"];\nexports.parse = require(\"url\").parse;\nexports.resolve = require(\"url\").resolve;\n/**\n * Returns the current working directory (in Node) or the current page URL (in browsers).\n *\n * @returns {string}\n */\n\nexports.cwd = function cwd() {\n  if (process.browser) {\n    return location.href;\n  }\n\n  let path = process.cwd();\n  let lastChar = path.slice(-1);\n\n  if (lastChar === \"/\" || lastChar === \"\\\\\") {\n    return path;\n  } else {\n    return path + \"/\";\n  }\n};\n/**\n * Returns the protocol of the given URL, or `undefined` if it has no protocol.\n *\n * @param   {string} path\n * @returns {?string}\n */\n\n\nexports.getProtocol = function getProtocol(path) {\n  let match = protocolPattern.exec(path);\n\n  if (match) {\n    return match[1].toLowerCase();\n  }\n};\n/**\n * Returns the lowercased file extension of the given URL,\n * or an empty string if it has no extension.\n *\n * @param   {string} path\n * @returns {string}\n */\n\n\nexports.getExtension = function getExtension(path) {\n  let lastDot = path.lastIndexOf(\".\");\n\n  if (lastDot >= 0) {\n    return url.stripQuery(path.substr(lastDot).toLowerCase());\n  }\n\n  return \"\";\n};\n/**\n * Removes the query, if any, from the given path.\n *\n * @param   {string} path\n * @returns {string}\n */\n\n\nexports.stripQuery = function stripQuery(path) {\n  let queryIndex = path.indexOf(\"?\");\n\n  if (queryIndex >= 0) {\n    path = path.substr(0, queryIndex);\n  }\n\n  return path;\n};\n/**\n * Returns the hash (URL fragment), of the given path.\n * If there is no hash, then the root hash (\"#\") is returned.\n *\n * @param   {string} path\n * @returns {string}\n */\n\n\nexports.getHash = function getHash(path) {\n  let hashIndex = path.indexOf(\"#\");\n\n  if (hashIndex >= 0) {\n    return path.substr(hashIndex);\n  }\n\n  return \"#\";\n};\n/**\n * Removes the hash (URL fragment), if any, from the given path.\n *\n * @param   {string} path\n * @returns {string}\n */\n\n\nexports.stripHash = function stripHash(path) {\n  let hashIndex = path.indexOf(\"#\");\n\n  if (hashIndex >= 0) {\n    path = path.substr(0, hashIndex);\n  }\n\n  return path;\n};\n/**\n * Determines whether the given path is an HTTP(S) URL.\n *\n * @param   {string} path\n * @returns {boolean}\n */\n\n\nexports.isHttp = function isHttp(path) {\n  let protocol = url.getProtocol(path);\n\n  if (protocol === \"http\" || protocol === \"https\") {\n    return true;\n  } else if (protocol === undefined) {\n    // There is no protocol.  If we're running in a browser, then assume it's HTTP.\n    return process.browser;\n  } else {\n    // It's some other protocol, such as \"ftp://\", \"mongodb://\", etc.\n    return false;\n  }\n};\n/**\n * Determines whether the given path is a filesystem path.\n * This includes \"file://\" URLs.\n *\n * @param   {string} path\n * @returns {boolean}\n */\n\n\nexports.isFileSystemPath = function isFileSystemPath(path) {\n  if (process.browser) {\n    // We're running in a browser, so assume that all paths are URLs.\n    // This way, even relative paths will be treated as URLs rather than as filesystem paths\n    return false;\n  }\n\n  let protocol = url.getProtocol(path);\n  return protocol === undefined || protocol === \"file\";\n};\n/**\n * Converts a filesystem path to a properly-encoded URL.\n *\n * This is intended to handle situations where JSON Schema $Ref Parser is called\n * with a filesystem path that contains characters which are not allowed in URLs.\n *\n * @example\n * The following filesystem paths would be converted to the following URLs:\n *\n *    <\"!@#$%^&*+=?'>.json              ==>   %3C%22!@%23$%25%5E&*+=%3F\\'%3E.json\n *    C:\\\\My Documents\\\\File (1).json   ==>   C:/My%20Documents/File%20(1).json\n *    file://Project #42/file.json      ==>   file://Project%20%2342/file.json\n *\n * @param {string} path\n * @returns {string}\n */\n\n\nexports.fromFileSystemPath = function fromFileSystemPath(path) {\n  // Step 1: On Windows, replace backslashes with forward slashes,\n  // rather than encoding them as \"%5C\"\n  if (isWindows) {\n    path = path.replace(/\\\\/g, \"/\");\n  } // Step 2: `encodeURI` will take care of MOST characters\n\n\n  path = encodeURI(path); // Step 3: Manually encode characters that are not encoded by `encodeURI`.\n  // This includes characters such as \"#\" and \"?\", which have special meaning in URLs,\n  // but are just normal characters in a filesystem path.\n\n  for (let i = 0; i < urlEncodePatterns.length; i += 2) {\n    path = path.replace(urlEncodePatterns[i], urlEncodePatterns[i + 1]);\n  }\n\n  return path;\n};\n/**\n * Converts a URL to a local filesystem path.\n *\n * @param {string}  path\n * @param {boolean} [keepFileProtocol] - If true, then \"file://\" will NOT be stripped\n * @returns {string}\n */\n\n\nexports.toFileSystemPath = function toFileSystemPath(path, keepFileProtocol) {\n  // Step 1: `decodeURI` will decode characters such as Cyrillic characters, spaces, etc.\n  path = decodeURI(path); // Step 2: Manually decode characters that are not decoded by `decodeURI`.\n  // This includes characters such as \"#\" and \"?\", which have special meaning in URLs,\n  // but are just normal characters in a filesystem path.\n\n  for (let i = 0; i < urlDecodePatterns.length; i += 2) {\n    path = path.replace(urlDecodePatterns[i], urlDecodePatterns[i + 1]);\n  } // Step 3: If it's a \"file://\" URL, then format it consistently\n  // or convert it to a local filesystem path\n\n\n  let isFileUrl = path.substr(0, 7).toLowerCase() === \"file://\";\n\n  if (isFileUrl) {\n    // Strip-off the protocol, and the initial \"/\", if there is one\n    path = path[7] === \"/\" ? path.substr(8) : path.substr(7); // insert a colon (\":\") after the drive letter on Windows\n\n    if (isWindows && path[1] === \"/\") {\n      path = path[0] + \":\" + path.substr(1);\n    }\n\n    if (keepFileProtocol) {\n      // Return the consistently-formatted \"file://\" URL\n      path = \"file:///\" + path;\n    } else {\n      // Convert the \"file://\" URL to a local filesystem path.\n      // On Windows, it will start with something like \"C:/\".\n      // On Posix, it will start with \"/\"\n      isFileUrl = false;\n      path = isWindows ? path : \"/\" + path;\n    }\n  } // Step 4: Normalize Windows paths (unless it's a \"file://\" URL)\n\n\n  if (isWindows && !isFileUrl) {\n    // Replace forward slashes with backslashes\n    path = path.replace(forwardSlashPattern, \"\\\\\"); // Capitalize the drive letter\n\n    if (path.substr(1, 2) === \":\\\\\") {\n      path = path[0].toUpperCase() + path.substr(1);\n    }\n  }\n\n  return path;\n};\n/**\n * Converts a $ref pointer to a valid JSON Path.\n *\n * @param {string}  pointer\n * @returns {Array<number | string>}\n */\n\n\nexports.safePointerToPath = function safePointerToPath(pointer) {\n  if (pointer.length <= 1 || pointer[0] !== \"#\" || pointer[1] !== \"/\") {\n    return [];\n  }\n\n  return pointer.slice(2).split(\"/\").map(value => {\n    return decodeURIComponent(value).replace(jsonPointerSlash, \"/\").replace(jsonPointerTilde, \"~\");\n  });\n};","map":{"version":3,"sources":["/home/dev/Documentos/Projects/github-clone/node_modules/@apidevtools/json-schema-ref-parser/lib/util/url.js"],"names":["isWindows","test","process","platform","forwardSlashPattern","protocolPattern","url","module","exports","jsonPointerSlash","jsonPointerTilde","urlEncodePatterns","urlDecodePatterns","parse","require","resolve","cwd","browser","location","href","path","lastChar","slice","getProtocol","match","exec","toLowerCase","getExtension","lastDot","lastIndexOf","stripQuery","substr","queryIndex","indexOf","getHash","hashIndex","stripHash","isHttp","protocol","undefined","isFileSystemPath","fromFileSystemPath","replace","encodeURI","i","length","toFileSystemPath","keepFileProtocol","decodeURI","isFileUrl","toUpperCase","safePointerToPath","pointer","split","map","value","decodeURIComponent"],"mappings":"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","sourcesContent":["\"use strict\";\n\nlet isWindows = /^win/.test(process.platform),\n    forwardSlashPattern = /\\//g,\n    protocolPattern = /^(\\w{2,}):\\/\\//i,\n    url = module.exports,\n    jsonPointerSlash = /~1/g,\n    jsonPointerTilde = /~0/g;\n\n// RegExp patterns to URL-encode special characters in local filesystem paths\nlet urlEncodePatterns = [\n  /\\?/g, \"%3F\",\n  /\\#/g, \"%23\",\n];\n\n// RegExp patterns to URL-decode special characters for local filesystem paths\nlet urlDecodePatterns = [\n  /\\%23/g, \"#\",\n  /\\%24/g, \"$\",\n  /\\%26/g, \"&\",\n  /\\%2C/g, \",\",\n  /\\%40/g, \"@\"\n];\n\nexports.parse = require(\"url\").parse;\nexports.resolve = require(\"url\").resolve;\n\n/**\n * Returns the current working directory (in Node) or the current page URL (in browsers).\n *\n * @returns {string}\n */\nexports.cwd = function cwd () {\n  if (process.browser) {\n    return location.href;\n  }\n\n  let path = process.cwd();\n\n  let lastChar = path.slice(-1);\n  if (lastChar === \"/\" || lastChar === \"\\\\\") {\n    return path;\n  }\n  else {\n    return path + \"/\";\n  }\n};\n\n/**\n * Returns the protocol of the given URL, or `undefined` if it has no protocol.\n *\n * @param   {string} path\n * @returns {?string}\n */\nexports.getProtocol = function getProtocol (path) {\n  let match = protocolPattern.exec(path);\n  if (match) {\n    return match[1].toLowerCase();\n  }\n};\n\n/**\n * Returns the lowercased file extension of the given URL,\n * or an empty string if it has no extension.\n *\n * @param   {string} path\n * @returns {string}\n */\nexports.getExtension = function getExtension (path) {\n  let lastDot = path.lastIndexOf(\".\");\n  if (lastDot >= 0) {\n    return url.stripQuery(path.substr(lastDot).toLowerCase());\n  }\n  return \"\";\n};\n\n/**\n * Removes the query, if any, from the given path.\n *\n * @param   {string} path\n * @returns {string}\n */\nexports.stripQuery = function stripQuery (path) {\n  let queryIndex = path.indexOf(\"?\");\n  if (queryIndex >= 0) {\n    path = path.substr(0, queryIndex);\n  }\n  return path;\n};\n\n/**\n * Returns the hash (URL fragment), of the given path.\n * If there is no hash, then the root hash (\"#\") is returned.\n *\n * @param   {string} path\n * @returns {string}\n */\nexports.getHash = function getHash (path) {\n  let hashIndex = path.indexOf(\"#\");\n  if (hashIndex >= 0) {\n    return path.substr(hashIndex);\n  }\n  return \"#\";\n};\n\n/**\n * Removes the hash (URL fragment), if any, from the given path.\n *\n * @param   {string} path\n * @returns {string}\n */\nexports.stripHash = function stripHash (path) {\n  let hashIndex = path.indexOf(\"#\");\n  if (hashIndex >= 0) {\n    path = path.substr(0, hashIndex);\n  }\n  return path;\n};\n\n/**\n * Determines whether the given path is an HTTP(S) URL.\n *\n * @param   {string} path\n * @returns {boolean}\n */\nexports.isHttp = function isHttp (path) {\n  let protocol = url.getProtocol(path);\n  if (protocol === \"http\" || protocol === \"https\") {\n    return true;\n  }\n  else if (protocol === undefined) {\n    // There is no protocol.  If we're running in a browser, then assume it's HTTP.\n    return process.browser;\n  }\n  else {\n    // It's some other protocol, such as \"ftp://\", \"mongodb://\", etc.\n    return false;\n  }\n};\n\n/**\n * Determines whether the given path is a filesystem path.\n * This includes \"file://\" URLs.\n *\n * @param   {string} path\n * @returns {boolean}\n */\nexports.isFileSystemPath = function isFileSystemPath (path) {\n  if (process.browser) {\n    // We're running in a browser, so assume that all paths are URLs.\n    // This way, even relative paths will be treated as URLs rather than as filesystem paths\n    return false;\n  }\n\n  let protocol = url.getProtocol(path);\n  return protocol === undefined || protocol === \"file\";\n};\n\n/**\n * Converts a filesystem path to a properly-encoded URL.\n *\n * This is intended to handle situations where JSON Schema $Ref Parser is called\n * with a filesystem path that contains characters which are not allowed in URLs.\n *\n * @example\n * The following filesystem paths would be converted to the following URLs:\n *\n *    <\"!@#$%^&*+=?'>.json              ==>   %3C%22!@%23$%25%5E&*+=%3F\\'%3E.json\n *    C:\\\\My Documents\\\\File (1).json   ==>   C:/My%20Documents/File%20(1).json\n *    file://Project #42/file.json      ==>   file://Project%20%2342/file.json\n *\n * @param {string} path\n * @returns {string}\n */\nexports.fromFileSystemPath = function fromFileSystemPath (path) {\n  // Step 1: On Windows, replace backslashes with forward slashes,\n  // rather than encoding them as \"%5C\"\n  if (isWindows) {\n    path = path.replace(/\\\\/g, \"/\");\n  }\n\n  // Step 2: `encodeURI` will take care of MOST characters\n  path = encodeURI(path);\n\n  // Step 3: Manually encode characters that are not encoded by `encodeURI`.\n  // This includes characters such as \"#\" and \"?\", which have special meaning in URLs,\n  // but are just normal characters in a filesystem path.\n  for (let i = 0; i < urlEncodePatterns.length; i += 2) {\n    path = path.replace(urlEncodePatterns[i], urlEncodePatterns[i + 1]);\n  }\n\n  return path;\n};\n\n/**\n * Converts a URL to a local filesystem path.\n *\n * @param {string}  path\n * @param {boolean} [keepFileProtocol] - If true, then \"file://\" will NOT be stripped\n * @returns {string}\n */\nexports.toFileSystemPath = function toFileSystemPath (path, keepFileProtocol) {\n  // Step 1: `decodeURI` will decode characters such as Cyrillic characters, spaces, etc.\n  path = decodeURI(path);\n\n  // Step 2: Manually decode characters that are not decoded by `decodeURI`.\n  // This includes characters such as \"#\" and \"?\", which have special meaning in URLs,\n  // but are just normal characters in a filesystem path.\n  for (let i = 0; i < urlDecodePatterns.length; i += 2) {\n    path = path.replace(urlDecodePatterns[i], urlDecodePatterns[i + 1]);\n  }\n\n  // Step 3: If it's a \"file://\" URL, then format it consistently\n  // or convert it to a local filesystem path\n  let isFileUrl = path.substr(0, 7).toLowerCase() === \"file://\";\n  if (isFileUrl) {\n    // Strip-off the protocol, and the initial \"/\", if there is one\n    path = path[7] === \"/\" ? path.substr(8) : path.substr(7);\n\n    // insert a colon (\":\") after the drive letter on Windows\n    if (isWindows && path[1] === \"/\") {\n      path = path[0] + \":\" + path.substr(1);\n    }\n\n    if (keepFileProtocol) {\n      // Return the consistently-formatted \"file://\" URL\n      path = \"file:///\" + path;\n    }\n    else {\n      // Convert the \"file://\" URL to a local filesystem path.\n      // On Windows, it will start with something like \"C:/\".\n      // On Posix, it will start with \"/\"\n      isFileUrl = false;\n      path = isWindows ? path : \"/\" + path;\n    }\n  }\n\n  // Step 4: Normalize Windows paths (unless it's a \"file://\" URL)\n  if (isWindows && !isFileUrl) {\n    // Replace forward slashes with backslashes\n    path = path.replace(forwardSlashPattern, \"\\\\\");\n\n    // Capitalize the drive letter\n    if (path.substr(1, 2) === \":\\\\\") {\n      path = path[0].toUpperCase() + path.substr(1);\n    }\n  }\n\n  return path;\n};\n\n/**\n * Converts a $ref pointer to a valid JSON Path.\n *\n * @param {string}  pointer\n * @returns {Array<number | string>}\n */\nexports.safePointerToPath = function safePointerToPath (pointer) {\n  if (pointer.length <= 1 || pointer[0] !== \"#\" || pointer[1] !== \"/\") {\n    return [];\n  }\n\n  return pointer\n    .slice(2)\n    .split(\"/\")\n    .map((value) => {\n      return decodeURIComponent(value)\n        .replace(jsonPointerSlash, \"/\")\n        .replace(jsonPointerTilde, \"~\");\n    });\n};\n"]},"metadata":{},"sourceType":"script"}