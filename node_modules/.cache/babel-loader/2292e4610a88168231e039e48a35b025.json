{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RulesDeploy = exports.RulesetServiceType = void 0;\n\nconst _ = require(\"lodash\");\n\nconst clc = require(\"cli-color\");\n\nconst fs = require(\"fs\");\n\nconst gcp = require(\"./gcp\");\n\nconst logger_1 = require(\"./logger\");\n\nconst error_1 = require(\"./error\");\n\nconst utils = require(\"./utils\");\n\nconst prompt_1 = require(\"./prompt\");\n\nconst QUOTA_EXCEEDED_STATUS_CODE = 429;\nconst RULESET_COUNT_LIMIT = 1000;\nconst RULESETS_TO_GC = 10;\nvar RulesetServiceType;\n\n(function (RulesetServiceType) {\n  RulesetServiceType[\"CLOUD_FIRESTORE\"] = \"cloud.firestore\";\n  RulesetServiceType[\"FIREBASE_STORAGE\"] = \"firebase.storage\";\n})(RulesetServiceType = exports.RulesetServiceType || (exports.RulesetServiceType = {}));\n\nconst RulesetType = {\n  [RulesetServiceType.CLOUD_FIRESTORE]: \"firestore\",\n  [RulesetServiceType.FIREBASE_STORAGE]: \"storage\"\n};\n\nclass RulesDeploy {\n  constructor(options, type) {\n    this.options = options;\n    this.type = type;\n    this.project = options.project;\n    this.rulesFiles = {};\n    this.rulesetNames = {};\n  }\n\n  addFile(path) {\n    const fullPath = this.options.config.path(path);\n    let src;\n\n    try {\n      src = fs.readFileSync(fullPath, \"utf8\");\n    } catch (e) {\n      logger_1.logger.debug(\"[rules read error]\", e.stack);\n      throw new error_1.FirebaseError(\"Error reading rules file \" + clc.bold(path));\n    }\n\n    this.rulesFiles[path] = [{\n      name: path,\n      content: src\n    }];\n  }\n\n  async compile() {\n    await Promise.all(Object.keys(this.rulesFiles).map(filename => {\n      return this.compileRuleset(filename, this.rulesFiles[filename]);\n    }));\n  }\n\n  async getCurrentRules(service) {\n    const latestName = await gcp.rules.getLatestRulesetName(this.options.project, service);\n    let latestContent = null;\n\n    if (latestName) {\n      latestContent = await gcp.rules.getRulesetContent(latestName);\n    }\n\n    return {\n      latestName,\n      latestContent\n    };\n  }\n\n  async createRulesets(service) {\n    const createdRulesetNames = [];\n    const {\n      latestName: latestRulesetName,\n      latestContent: latestRulesetContent\n    } = await this.getCurrentRules(service);\n    const newRulesetsByFilename = new Map();\n\n    for (const filename of Object.keys(this.rulesFiles)) {\n      const files = this.rulesFiles[filename];\n\n      if (latestRulesetName && _.isEqual(files, latestRulesetContent)) {\n        utils.logBullet(`${clc.bold.cyan(RulesetType[this.type] + \":\")} latest version of ${clc.bold(filename)} already up to date, skipping upload...`);\n        this.rulesetNames[filename] = latestRulesetName;\n        continue;\n      }\n\n      utils.logBullet(`${clc.bold.cyan(RulesetType[this.type] + \":\")} uploading rules ${clc.bold(filename)}...`);\n      newRulesetsByFilename.set(filename, gcp.rules.createRuleset(this.options.project, files));\n    }\n\n    try {\n      await Promise.all(newRulesetsByFilename.values());\n\n      for (const [filename, rulesetName] of newRulesetsByFilename) {\n        this.rulesetNames[filename] = await rulesetName;\n        createdRulesetNames.push(await rulesetName);\n      }\n    } catch (err) {\n      if (err.status !== QUOTA_EXCEEDED_STATUS_CODE) {\n        throw err;\n      }\n\n      utils.logBullet(clc.bold.yellow(RulesetType[this.type] + \":\") + \" quota exceeded error while uploading rules\");\n      const history = await gcp.rules.listAllRulesets(this.options.project);\n\n      if (history.length > RULESET_COUNT_LIMIT) {\n        const confirm = await prompt_1.promptOnce({\n          type: \"confirm\",\n          name: \"force\",\n          message: `You have ${history.length} rules, do you want to delete the oldest ${RULESETS_TO_GC} to free up space?`,\n          default: false\n        }, this.options);\n\n        if (confirm) {\n          const releases = await gcp.rules.listAllReleases(this.options.project);\n\n          const unreleased = _.reject(history, ruleset => {\n            return !!releases.find(release => release.rulesetName === ruleset.name);\n          });\n\n          const entriesToDelete = unreleased.reverse().slice(0, RULESETS_TO_GC);\n\n          for (const entry of entriesToDelete) {\n            await gcp.rules.deleteRuleset(this.options.project, gcp.rules.getRulesetId(entry));\n            logger_1.logger.debug(`[rules] Deleted ${entry.name}`);\n          }\n\n          utils.logBullet(clc.bold.yellow(RulesetType[this.type] + \":\") + \" retrying rules upload\");\n          return this.createRulesets(service);\n        }\n      }\n    }\n\n    return createdRulesetNames;\n  }\n\n  async release(filename, resourceName, subResourceName) {\n    if (resourceName === RulesetServiceType.FIREBASE_STORAGE && !subResourceName) {\n      throw new error_1.FirebaseError(`Cannot release resource type \"${resourceName}\"`);\n    }\n\n    await gcp.rules.updateOrCreateRelease(this.options.project, this.rulesetNames[filename], resourceName === RulesetServiceType.FIREBASE_STORAGE ? `${resourceName}/${subResourceName}` : resourceName);\n    utils.logSuccess(`${clc.bold.green(RulesetType[this.type] + \":\")} released rules ${clc.bold(filename)} to ${clc.bold(resourceName)}`);\n  }\n\n  async compileRuleset(filename, files) {\n    utils.logBullet(`${clc.bold.cyan(this.type + \":\")} checking ${clc.bold(filename)} for compilation errors...`);\n    const response = await gcp.rules.testRuleset(this.options.project, files);\n\n    if (_.get(response, \"body.issues\", []).length) {\n      const warnings = [];\n      const errors = [];\n      response.body.issues.forEach(issue => {\n        const issueMessage = `[${issue.severity.substring(0, 1)}] ${issue.sourcePosition.line}:${issue.sourcePosition.column} - ${issue.description}`;\n\n        if (issue.severity === \"ERROR\") {\n          errors.push(issueMessage);\n        } else {\n          warnings.push(issueMessage);\n        }\n      });\n\n      if (warnings.length > 0) {\n        warnings.forEach(warning => {\n          utils.logWarning(warning);\n        });\n      }\n\n      if (errors.length > 0) {\n        const add = errors.length === 1 ? \"\" : \"s\";\n        const message = `Compilation error${add} in ${clc.bold(filename)}:\\n${errors.join(\"\\n\")}`;\n        throw new error_1.FirebaseError(message, {\n          exit: 1\n        });\n      }\n    }\n\n    utils.logSuccess(`${clc.bold.green(this.type + \":\")} rules file ${clc.bold(filename)} compiled successfully`);\n  }\n\n}\n\nexports.RulesDeploy = RulesDeploy;","map":{"version":3,"sources":["/home/dev/Documentos/Projects/github-clone/node_modules/firebase-tools/lib/rulesDeploy.js"],"names":["Object","defineProperty","exports","value","RulesDeploy","RulesetServiceType","_","require","clc","fs","gcp","logger_1","error_1","utils","prompt_1","QUOTA_EXCEEDED_STATUS_CODE","RULESET_COUNT_LIMIT","RULESETS_TO_GC","RulesetType","CLOUD_FIRESTORE","FIREBASE_STORAGE","constructor","options","type","project","rulesFiles","rulesetNames","addFile","path","fullPath","config","src","readFileSync","e","logger","debug","stack","FirebaseError","bold","name","content","compile","Promise","all","keys","map","filename","compileRuleset","getCurrentRules","service","latestName","rules","getLatestRulesetName","latestContent","getRulesetContent","createRulesets","createdRulesetNames","latestRulesetName","latestRulesetContent","newRulesetsByFilename","Map","files","isEqual","logBullet","cyan","set","createRuleset","values","rulesetName","push","err","status","yellow","history","listAllRulesets","length","confirm","promptOnce","message","default","releases","listAllReleases","unreleased","reject","ruleset","find","release","entriesToDelete","reverse","slice","entry","deleteRuleset","getRulesetId","resourceName","subResourceName","updateOrCreateRelease","logSuccess","green","response","testRuleset","get","warnings","errors","body","issues","forEach","issue","issueMessage","severity","substring","sourcePosition","line","column","description","warning","logWarning","add","join","exit"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RulesDeploy = exports.RulesetServiceType = void 0;\nconst _ = require(\"lodash\");\nconst clc = require(\"cli-color\");\nconst fs = require(\"fs\");\nconst gcp = require(\"./gcp\");\nconst logger_1 = require(\"./logger\");\nconst error_1 = require(\"./error\");\nconst utils = require(\"./utils\");\nconst prompt_1 = require(\"./prompt\");\nconst QUOTA_EXCEEDED_STATUS_CODE = 429;\nconst RULESET_COUNT_LIMIT = 1000;\nconst RULESETS_TO_GC = 10;\nvar RulesetServiceType;\n(function (RulesetServiceType) {\n    RulesetServiceType[\"CLOUD_FIRESTORE\"] = \"cloud.firestore\";\n    RulesetServiceType[\"FIREBASE_STORAGE\"] = \"firebase.storage\";\n})(RulesetServiceType = exports.RulesetServiceType || (exports.RulesetServiceType = {}));\nconst RulesetType = {\n    [RulesetServiceType.CLOUD_FIRESTORE]: \"firestore\",\n    [RulesetServiceType.FIREBASE_STORAGE]: \"storage\",\n};\nclass RulesDeploy {\n    constructor(options, type) {\n        this.options = options;\n        this.type = type;\n        this.project = options.project;\n        this.rulesFiles = {};\n        this.rulesetNames = {};\n    }\n    addFile(path) {\n        const fullPath = this.options.config.path(path);\n        let src;\n        try {\n            src = fs.readFileSync(fullPath, \"utf8\");\n        }\n        catch (e) {\n            logger_1.logger.debug(\"[rules read error]\", e.stack);\n            throw new error_1.FirebaseError(\"Error reading rules file \" + clc.bold(path));\n        }\n        this.rulesFiles[path] = [{ name: path, content: src }];\n    }\n    async compile() {\n        await Promise.all(Object.keys(this.rulesFiles).map((filename) => {\n            return this.compileRuleset(filename, this.rulesFiles[filename]);\n        }));\n    }\n    async getCurrentRules(service) {\n        const latestName = await gcp.rules.getLatestRulesetName(this.options.project, service);\n        let latestContent = null;\n        if (latestName) {\n            latestContent = await gcp.rules.getRulesetContent(latestName);\n        }\n        return { latestName, latestContent };\n    }\n    async createRulesets(service) {\n        const createdRulesetNames = [];\n        const { latestName: latestRulesetName, latestContent: latestRulesetContent, } = await this.getCurrentRules(service);\n        const newRulesetsByFilename = new Map();\n        for (const filename of Object.keys(this.rulesFiles)) {\n            const files = this.rulesFiles[filename];\n            if (latestRulesetName && _.isEqual(files, latestRulesetContent)) {\n                utils.logBullet(`${clc.bold.cyan(RulesetType[this.type] + \":\")} latest version of ${clc.bold(filename)} already up to date, skipping upload...`);\n                this.rulesetNames[filename] = latestRulesetName;\n                continue;\n            }\n            utils.logBullet(`${clc.bold.cyan(RulesetType[this.type] + \":\")} uploading rules ${clc.bold(filename)}...`);\n            newRulesetsByFilename.set(filename, gcp.rules.createRuleset(this.options.project, files));\n        }\n        try {\n            await Promise.all(newRulesetsByFilename.values());\n            for (const [filename, rulesetName] of newRulesetsByFilename) {\n                this.rulesetNames[filename] = await rulesetName;\n                createdRulesetNames.push(await rulesetName);\n            }\n        }\n        catch (err) {\n            if (err.status !== QUOTA_EXCEEDED_STATUS_CODE) {\n                throw err;\n            }\n            utils.logBullet(clc.bold.yellow(RulesetType[this.type] + \":\") +\n                \" quota exceeded error while uploading rules\");\n            const history = await gcp.rules.listAllRulesets(this.options.project);\n            if (history.length > RULESET_COUNT_LIMIT) {\n                const confirm = await prompt_1.promptOnce({\n                    type: \"confirm\",\n                    name: \"force\",\n                    message: `You have ${history.length} rules, do you want to delete the oldest ${RULESETS_TO_GC} to free up space?`,\n                    default: false,\n                }, this.options);\n                if (confirm) {\n                    const releases = await gcp.rules.listAllReleases(this.options.project);\n                    const unreleased = _.reject(history, (ruleset) => {\n                        return !!releases.find((release) => release.rulesetName === ruleset.name);\n                    });\n                    const entriesToDelete = unreleased.reverse().slice(0, RULESETS_TO_GC);\n                    for (const entry of entriesToDelete) {\n                        await gcp.rules.deleteRuleset(this.options.project, gcp.rules.getRulesetId(entry));\n                        logger_1.logger.debug(`[rules] Deleted ${entry.name}`);\n                    }\n                    utils.logBullet(clc.bold.yellow(RulesetType[this.type] + \":\") + \" retrying rules upload\");\n                    return this.createRulesets(service);\n                }\n            }\n        }\n        return createdRulesetNames;\n    }\n    async release(filename, resourceName, subResourceName) {\n        if (resourceName === RulesetServiceType.FIREBASE_STORAGE && !subResourceName) {\n            throw new error_1.FirebaseError(`Cannot release resource type \"${resourceName}\"`);\n        }\n        await gcp.rules.updateOrCreateRelease(this.options.project, this.rulesetNames[filename], resourceName === RulesetServiceType.FIREBASE_STORAGE\n            ? `${resourceName}/${subResourceName}`\n            : resourceName);\n        utils.logSuccess(`${clc.bold.green(RulesetType[this.type] + \":\")} released rules ${clc.bold(filename)} to ${clc.bold(resourceName)}`);\n    }\n    async compileRuleset(filename, files) {\n        utils.logBullet(`${clc.bold.cyan(this.type + \":\")} checking ${clc.bold(filename)} for compilation errors...`);\n        const response = await gcp.rules.testRuleset(this.options.project, files);\n        if (_.get(response, \"body.issues\", []).length) {\n            const warnings = [];\n            const errors = [];\n            response.body.issues.forEach((issue) => {\n                const issueMessage = `[${issue.severity.substring(0, 1)}] ${issue.sourcePosition.line}:${issue.sourcePosition.column} - ${issue.description}`;\n                if (issue.severity === \"ERROR\") {\n                    errors.push(issueMessage);\n                }\n                else {\n                    warnings.push(issueMessage);\n                }\n            });\n            if (warnings.length > 0) {\n                warnings.forEach((warning) => {\n                    utils.logWarning(warning);\n                });\n            }\n            if (errors.length > 0) {\n                const add = errors.length === 1 ? \"\" : \"s\";\n                const message = `Compilation error${add} in ${clc.bold(filename)}:\\n${errors.join(\"\\n\")}`;\n                throw new error_1.FirebaseError(message, { exit: 1 });\n            }\n        }\n        utils.logSuccess(`${clc.bold.green(this.type + \":\")} rules file ${clc.bold(filename)} compiled successfully`);\n    }\n}\nexports.RulesDeploy = RulesDeploy;\n"]},"metadata":{},"sourceType":"script"}