{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst stream_1 = require(\"stream\");\n\nconst crypto_1 = require(\"crypto\");\n\nconst data_uri_to_buffer_1 = __importDefault(require(\"data-uri-to-buffer\"));\n\nconst notmodified_1 = __importDefault(require(\"./notmodified\"));\n\nconst debug = debug_1.default('get-uri:data');\n\nclass DataReadable extends stream_1.Readable {\n  constructor(hash, buf) {\n    super();\n    this.push(buf);\n    this.push(null);\n    this.hash = hash;\n  }\n\n}\n/**\n * Returns a Readable stream from a \"data:\" URI.\n */\n\n\nfunction get({\n  href: uri\n}, {\n  cache\n}) {\n  return __awaiter(this, void 0, void 0, function* () {\n    // need to create a SHA1 hash of the URI string, for cacheability checks\n    // in future `getUri()` calls with the same data URI passed in.\n    const shasum = crypto_1.createHash('sha1');\n    shasum.update(uri);\n    const hash = shasum.digest('hex');\n    debug('generated SHA1 hash for \"data:\" URI: %o', hash); // check if the cache is the same \"data:\" URI that was previously passed in.\n\n    if (cache && cache.hash === hash) {\n      debug('got matching cache SHA1 hash: %o', hash);\n      throw new notmodified_1.default();\n    } else {\n      debug('creating Readable stream from \"data:\" URI buffer');\n      const buf = data_uri_to_buffer_1.default(uri);\n      return new DataReadable(hash, buf);\n    }\n  });\n}\n\nexports.default = get;","map":{"version":3,"sources":["../src/data.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,MAAA,OAAA,GAAA,eAAA,CAAA,OAAA,CAAA,OAAA,CAAA,CAAA;;AACA,MAAA,QAAA,GAAA,OAAA,CAAA,QAAA,CAAA;;AACA,MAAA,QAAA,GAAA,OAAA,CAAA,QAAA,CAAA;;AAEA,MAAA,oBAAA,GAAA,eAAA,CAAA,OAAA,CAAA,oBAAA,CAAA,CAAA;;AAEA,MAAA,aAAA,GAAA,eAAA,CAAA,OAAA,CAAA,eAAA,CAAA,CAAA;;AAEA,MAAM,KAAK,GAAG,OAAA,CAAA,OAAA,CAAY,cAAZ,CAAd;;AAEA,MAAM,YAAN,SAA2B,QAAA,CAAA,QAA3B,CAAmC;AAGlC,EAAA,WAAA,CAAY,IAAZ,EAA0B,GAA1B,EAAqC;AACpC;AACA,SAAK,IAAL,CAAU,GAAV;AACA,SAAK,IAAL,CAAU,IAAV;AACA,SAAK,IAAL,GAAY,IAAZ;AACA;;AARiC;AAenC;;AAEG;;;AACH,SAA8B,GAA9B,CACC;AAAE,EAAA,IAAI,EAAE;AAAR,CADD,EAEC;AAAE,EAAA;AAAF,CAFD,EAEuB;;AAEtB;AACA;AACA,UAAM,MAAM,GAAG,QAAA,CAAA,UAAA,CAAW,MAAX,CAAf;AACA,IAAA,MAAM,CAAC,MAAP,CAAc,GAAd;AACA,UAAM,IAAI,GAAG,MAAM,CAAC,MAAP,CAAc,KAAd,CAAb;AACA,IAAA,KAAK,CAAC,yCAAD,EAA4C,IAA5C,CAAL,C,CAEA;;AACA,QAAI,KAAK,IAAI,KAAK,CAAC,IAAN,KAAe,IAA5B,EAAkC;AACjC,MAAA,KAAK,CAAC,kCAAD,EAAqC,IAArC,CAAL;AACA,YAAM,IAAI,aAAA,CAAA,OAAJ,EAAN;AACA,KAHD,MAGO;AACN,MAAA,KAAK,CAAC,kDAAD,CAAL;AACA,YAAM,GAAG,GAAG,oBAAA,CAAA,OAAA,CAAgB,GAAhB,CAAZ;AACA,aAAO,IAAI,YAAJ,CAAiB,IAAjB,EAAuB,GAAvB,CAAP;AACA;AACD,G;AAAA;;AApBD,OAAA,CAAA,OAAA,GAAA,GAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst debug_1 = __importDefault(require(\"debug\"));\nconst stream_1 = require(\"stream\");\nconst crypto_1 = require(\"crypto\");\nconst data_uri_to_buffer_1 = __importDefault(require(\"data-uri-to-buffer\"));\nconst notmodified_1 = __importDefault(require(\"./notmodified\"));\nconst debug = debug_1.default('get-uri:data');\nclass DataReadable extends stream_1.Readable {\n    constructor(hash, buf) {\n        super();\n        this.push(buf);\n        this.push(null);\n        this.hash = hash;\n    }\n}\n/**\n * Returns a Readable stream from a \"data:\" URI.\n */\nfunction get({ href: uri }, { cache }) {\n    return __awaiter(this, void 0, void 0, function* () {\n        // need to create a SHA1 hash of the URI string, for cacheability checks\n        // in future `getUri()` calls with the same data URI passed in.\n        const shasum = crypto_1.createHash('sha1');\n        shasum.update(uri);\n        const hash = shasum.digest('hex');\n        debug('generated SHA1 hash for \"data:\" URI: %o', hash);\n        // check if the cache is the same \"data:\" URI that was previously passed in.\n        if (cache && cache.hash === hash) {\n            debug('got matching cache SHA1 hash: %o', hash);\n            throw new notmodified_1.default();\n        }\n        else {\n            debug('creating Readable stream from \"data:\" URI buffer');\n            const buf = data_uri_to_buffer_1.default(uri);\n            return new DataReadable(hash, buf);\n        }\n    });\n}\nexports.default = get;\n//# sourceMappingURL=data.js.map"]},"metadata":{},"sourceType":"script"}