{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst net_1 = __importDefault(require(\"net\"));\n\nconst tls_1 = __importDefault(require(\"tls\"));\n\nconst once_1 = __importDefault(require(\"@tootallnate/once\"));\n\nconst crypto_1 = __importDefault(require(\"crypto\"));\n\nconst get_uri_1 = __importDefault(require(\"get-uri\"));\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst raw_body_1 = __importDefault(require(\"raw-body\"));\n\nconst url_1 = require(\"url\");\n\nconst http_proxy_agent_1 = require(\"http-proxy-agent\");\n\nconst https_proxy_agent_1 = require(\"https-proxy-agent\");\n\nconst socks_proxy_agent_1 = require(\"socks-proxy-agent\");\n\nconst pac_resolver_1 = __importDefault(require(\"pac-resolver\"));\n\nconst agent_base_1 = require(\"agent-base\");\n\nconst debug = debug_1.default('pac-proxy-agent');\n/**\n * The `PacProxyAgent` class.\n *\n * A few different \"protocol\" modes are supported (supported protocols are\n * backed by the `get-uri` module):\n *\n *   - \"pac+data\", \"data\" - refers to an embedded \"data:\" URI\n *   - \"pac+file\", \"file\" - refers to a local file\n *   - \"pac+ftp\", \"ftp\" - refers to a file located on an FTP server\n *   - \"pac+http\", \"http\" - refers to an HTTP endpoint\n *   - \"pac+https\", \"https\" - refers to an HTTPS endpoint\n *\n * @api public\n */\n\nclass PacProxyAgent extends agent_base_1.Agent {\n  constructor(uri, opts = {}) {\n    super(opts);\n\n    this.clearResolverPromise = () => {\n      this.resolverPromise = undefined;\n    };\n\n    debug('Creating PacProxyAgent with URI %o and options %o', uri, opts); // Strip the \"pac+\" prefix\n\n    this.uri = uri.replace(/^pac\\+/i, '');\n    this.opts = Object.assign({}, opts);\n    this.cache = undefined;\n    this.resolver = undefined;\n    this.resolverHash = '';\n    this.resolverPromise = undefined; // For `PacResolver`\n\n    if (!this.opts.filename) {\n      this.opts.filename = uri;\n    }\n  }\n  /**\n   * Loads the PAC proxy file from the source if necessary, and returns\n   * a generated `FindProxyForURL()` resolver function to use.\n   *\n   * @api private\n   */\n\n\n  getResolver() {\n    if (!this.resolverPromise) {\n      this.resolverPromise = this.loadResolver();\n      this.resolverPromise.then(this.clearResolverPromise, this.clearResolverPromise);\n    }\n\n    return this.resolverPromise;\n  }\n\n  loadResolver() {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        // (Re)load the contents of the PAC file URI\n        const code = yield this.loadPacFile(); // Create a sha1 hash of the JS code\n\n        const hash = crypto_1.default.createHash('sha1').update(code).digest('hex');\n\n        if (this.resolver && this.resolverHash === hash) {\n          debug('Same sha1 hash for code - contents have not changed, reusing previous proxy resolver');\n          return this.resolver;\n        } // Cache the resolver\n\n\n        debug('Creating new proxy resolver instance');\n        this.resolver = pac_resolver_1.default(code, this.opts); // Store that sha1 hash for future comparison purposes\n\n        this.resolverHash = hash;\n        return this.resolver;\n      } catch (err) {\n        if (this.resolver && err.code === 'ENOTMODIFIED') {\n          debug('Got ENOTMODIFIED response, reusing previous proxy resolver');\n          return this.resolver;\n        }\n\n        throw err;\n      }\n    });\n  }\n  /**\n   * Loads the contents of the PAC proxy file.\n   *\n   * @api private\n   */\n\n\n  loadPacFile() {\n    return __awaiter(this, void 0, void 0, function* () {\n      debug('Loading PAC file: %o', this.uri);\n      const rs = yield get_uri_1.default(this.uri, {\n        cache: this.cache\n      });\n      debug('Got `Readable` instance for URI');\n      this.cache = rs;\n      const buf = yield raw_body_1.default(rs);\n      debug('Read %o byte PAC file from URI', buf.length);\n      return buf.toString('utf8');\n    });\n  }\n  /**\n   * Called when the node-core HTTP client library is creating a new HTTP request.\n   *\n   * @api protected\n   */\n\n\n  callback(req, opts) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        secureEndpoint\n      } = opts; // First, get a generated `FindProxyForURL()` function,\n      // either cached or retrieved from the source\n\n      const resolver = yield this.getResolver(); // Calculate the `url` parameter\n\n      const defaultPort = secureEndpoint ? 443 : 80;\n      let path = req.path;\n      let search = null;\n      const firstQuestion = path.indexOf('?');\n\n      if (firstQuestion !== -1) {\n        search = path.substring(firstQuestion);\n        path = path.substring(0, firstQuestion);\n      }\n\n      const urlOpts = Object.assign(Object.assign({}, opts), {\n        protocol: secureEndpoint ? 'https:' : 'http:',\n        pathname: path,\n        search,\n        // need to use `hostname` instead of `host` otherwise `port` is ignored\n        hostname: opts.host,\n        host: null,\n        href: null,\n        // set `port` to null when it is the protocol default port (80 / 443)\n        port: defaultPort === opts.port ? null : opts.port\n      });\n      const url = url_1.format(urlOpts);\n      debug('url: %o', url);\n      let result = yield resolver(url); // Default to \"DIRECT\" if a falsey value was returned (or nothing)\n\n      if (!result) {\n        result = 'DIRECT';\n      }\n\n      const proxies = String(result).trim().split(/\\s*;\\s*/g).filter(Boolean);\n\n      if (this.opts.fallbackToDirect && !proxies.includes('DIRECT')) {\n        proxies.push('DIRECT');\n      }\n\n      for (const proxy of proxies) {\n        let agent = null;\n        let socket = null;\n        const [type, target] = proxy.split(/\\s+/);\n        debug('Attempting to use proxy: %o', proxy);\n\n        if (type === 'DIRECT') {\n          // Direct connection to the destination endpoint\n          socket = secureEndpoint ? tls_1.default.connect(opts) : net_1.default.connect(opts);\n        } else if (type === 'SOCKS' || type === 'SOCKS5') {\n          // Use a SOCKSv5h proxy\n          agent = new socks_proxy_agent_1.SocksProxyAgent(`socks://${target}`);\n        } else if (type === 'SOCKS4') {\n          // Use a SOCKSv4a proxy\n          agent = new socks_proxy_agent_1.SocksProxyAgent(`socks4a://${target}`);\n        } else if (type === 'PROXY' || type === 'HTTP' || type === 'HTTPS') {\n          // Use an HTTP or HTTPS proxy\n          // http://dev.chromium.org/developers/design-documents/secure-web-proxy\n          const proxyURL = `${type === 'HTTPS' ? 'https' : 'http'}://${target}`;\n          const proxyOpts = Object.assign(Object.assign({}, this.opts), url_1.parse(proxyURL));\n\n          if (secureEndpoint) {\n            agent = new https_proxy_agent_1.HttpsProxyAgent(proxyOpts);\n          } else {\n            agent = new http_proxy_agent_1.HttpProxyAgent(proxyOpts);\n          }\n        }\n\n        try {\n          if (socket) {\n            // \"DIRECT\" connection, wait for connection confirmation\n            yield once_1.default(socket, 'connect');\n            req.emit('proxy', {\n              proxy,\n              socket\n            });\n            return socket;\n          }\n\n          if (agent) {\n            const s = yield agent.callback(req, opts);\n            req.emit('proxy', {\n              proxy,\n              socket: s\n            });\n            return s;\n          }\n\n          throw new Error(`Could not determine proxy type for: ${proxy}`);\n        } catch (err) {\n          debug('Got error for proxy %o: %o', proxy, err);\n          req.emit('proxy', {\n            proxy,\n            error: err\n          });\n        }\n      }\n\n      throw new Error(`Failed to establish a socket connection to proxies: ${JSON.stringify(proxies)}`);\n    });\n  }\n\n}\n\nexports.default = PacProxyAgent;","map":{"version":3,"sources":["../src/agent.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst net_1 = __importDefault(require(\"net\"));\nconst tls_1 = __importDefault(require(\"tls\"));\nconst once_1 = __importDefault(require(\"@tootallnate/once\"));\nconst crypto_1 = __importDefault(require(\"crypto\"));\nconst get_uri_1 = __importDefault(require(\"get-uri\"));\nconst debug_1 = __importDefault(require(\"debug\"));\nconst raw_body_1 = __importDefault(require(\"raw-body\"));\nconst url_1 = require(\"url\");\nconst http_proxy_agent_1 = require(\"http-proxy-agent\");\nconst https_proxy_agent_1 = require(\"https-proxy-agent\");\nconst socks_proxy_agent_1 = require(\"socks-proxy-agent\");\nconst pac_resolver_1 = __importDefault(require(\"pac-resolver\"));\nconst agent_base_1 = require(\"agent-base\");\nconst debug = debug_1.default('pac-proxy-agent');\n/**\n * The `PacProxyAgent` class.\n *\n * A few different \"protocol\" modes are supported (supported protocols are\n * backed by the `get-uri` module):\n *\n *   - \"pac+data\", \"data\" - refers to an embedded \"data:\" URI\n *   - \"pac+file\", \"file\" - refers to a local file\n *   - \"pac+ftp\", \"ftp\" - refers to a file located on an FTP server\n *   - \"pac+http\", \"http\" - refers to an HTTP endpoint\n *   - \"pac+https\", \"https\" - refers to an HTTPS endpoint\n *\n * @api public\n */\nclass PacProxyAgent extends agent_base_1.Agent {\n    constructor(uri, opts = {}) {\n        super(opts);\n        this.clearResolverPromise = () => {\n            this.resolverPromise = undefined;\n        };\n        debug('Creating PacProxyAgent with URI %o and options %o', uri, opts);\n        // Strip the \"pac+\" prefix\n        this.uri = uri.replace(/^pac\\+/i, '');\n        this.opts = Object.assign({}, opts);\n        this.cache = undefined;\n        this.resolver = undefined;\n        this.resolverHash = '';\n        this.resolverPromise = undefined;\n        // For `PacResolver`\n        if (!this.opts.filename) {\n            this.opts.filename = uri;\n        }\n    }\n    /**\n     * Loads the PAC proxy file from the source if necessary, and returns\n     * a generated `FindProxyForURL()` resolver function to use.\n     *\n     * @api private\n     */\n    getResolver() {\n        if (!this.resolverPromise) {\n            this.resolverPromise = this.loadResolver();\n            this.resolverPromise.then(this.clearResolverPromise, this.clearResolverPromise);\n        }\n        return this.resolverPromise;\n    }\n    loadResolver() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                // (Re)load the contents of the PAC file URI\n                const code = yield this.loadPacFile();\n                // Create a sha1 hash of the JS code\n                const hash = crypto_1.default\n                    .createHash('sha1')\n                    .update(code)\n                    .digest('hex');\n                if (this.resolver && this.resolverHash === hash) {\n                    debug('Same sha1 hash for code - contents have not changed, reusing previous proxy resolver');\n                    return this.resolver;\n                }\n                // Cache the resolver\n                debug('Creating new proxy resolver instance');\n                this.resolver = pac_resolver_1.default(code, this.opts);\n                // Store that sha1 hash for future comparison purposes\n                this.resolverHash = hash;\n                return this.resolver;\n            }\n            catch (err) {\n                if (this.resolver && err.code === 'ENOTMODIFIED') {\n                    debug('Got ENOTMODIFIED response, reusing previous proxy resolver');\n                    return this.resolver;\n                }\n                throw err;\n            }\n        });\n    }\n    /**\n     * Loads the contents of the PAC proxy file.\n     *\n     * @api private\n     */\n    loadPacFile() {\n        return __awaiter(this, void 0, void 0, function* () {\n            debug('Loading PAC file: %o', this.uri);\n            const rs = yield get_uri_1.default(this.uri, { cache: this.cache });\n            debug('Got `Readable` instance for URI');\n            this.cache = rs;\n            const buf = yield raw_body_1.default(rs);\n            debug('Read %o byte PAC file from URI', buf.length);\n            return buf.toString('utf8');\n        });\n    }\n    /**\n     * Called when the node-core HTTP client library is creating a new HTTP request.\n     *\n     * @api protected\n     */\n    callback(req, opts) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { secureEndpoint } = opts;\n            // First, get a generated `FindProxyForURL()` function,\n            // either cached or retrieved from the source\n            const resolver = yield this.getResolver();\n            // Calculate the `url` parameter\n            const defaultPort = secureEndpoint ? 443 : 80;\n            let path = req.path;\n            let search = null;\n            const firstQuestion = path.indexOf('?');\n            if (firstQuestion !== -1) {\n                search = path.substring(firstQuestion);\n                path = path.substring(0, firstQuestion);\n            }\n            const urlOpts = Object.assign(Object.assign({}, opts), { protocol: secureEndpoint ? 'https:' : 'http:', pathname: path, search, \n                // need to use `hostname` instead of `host` otherwise `port` is ignored\n                hostname: opts.host, host: null, href: null, \n                // set `port` to null when it is the protocol default port (80 / 443)\n                port: defaultPort === opts.port ? null : opts.port });\n            const url = url_1.format(urlOpts);\n            debug('url: %o', url);\n            let result = yield resolver(url);\n            // Default to \"DIRECT\" if a falsey value was returned (or nothing)\n            if (!result) {\n                result = 'DIRECT';\n            }\n            const proxies = String(result)\n                .trim()\n                .split(/\\s*;\\s*/g)\n                .filter(Boolean);\n            if (this.opts.fallbackToDirect && !proxies.includes('DIRECT')) {\n                proxies.push('DIRECT');\n            }\n            for (const proxy of proxies) {\n                let agent = null;\n                let socket = null;\n                const [type, target] = proxy.split(/\\s+/);\n                debug('Attempting to use proxy: %o', proxy);\n                if (type === 'DIRECT') {\n                    // Direct connection to the destination endpoint\n                    socket = secureEndpoint ? tls_1.default.connect(opts) : net_1.default.connect(opts);\n                }\n                else if (type === 'SOCKS' || type === 'SOCKS5') {\n                    // Use a SOCKSv5h proxy\n                    agent = new socks_proxy_agent_1.SocksProxyAgent(`socks://${target}`);\n                }\n                else if (type === 'SOCKS4') {\n                    // Use a SOCKSv4a proxy\n                    agent = new socks_proxy_agent_1.SocksProxyAgent(`socks4a://${target}`);\n                }\n                else if (type === 'PROXY' ||\n                    type === 'HTTP' ||\n                    type === 'HTTPS') {\n                    // Use an HTTP or HTTPS proxy\n                    // http://dev.chromium.org/developers/design-documents/secure-web-proxy\n                    const proxyURL = `${type === 'HTTPS' ? 'https' : 'http'}://${target}`;\n                    const proxyOpts = Object.assign(Object.assign({}, this.opts), url_1.parse(proxyURL));\n                    if (secureEndpoint) {\n                        agent = new https_proxy_agent_1.HttpsProxyAgent(proxyOpts);\n                    }\n                    else {\n                        agent = new http_proxy_agent_1.HttpProxyAgent(proxyOpts);\n                    }\n                }\n                try {\n                    if (socket) {\n                        // \"DIRECT\" connection, wait for connection confirmation\n                        yield once_1.default(socket, 'connect');\n                        req.emit('proxy', { proxy, socket });\n                        return socket;\n                    }\n                    if (agent) {\n                        const s = yield agent.callback(req, opts);\n                        req.emit('proxy', { proxy, socket: s });\n                        return s;\n                    }\n                    throw new Error(`Could not determine proxy type for: ${proxy}`);\n                }\n                catch (err) {\n                    debug('Got error for proxy %o: %o', proxy, err);\n                    req.emit('proxy', { proxy, error: err });\n                }\n            }\n            throw new Error(`Failed to establish a socket connection to proxies: ${JSON.stringify(proxies)}`);\n        });\n    }\n}\nexports.default = PacProxyAgent;\n//# sourceMappingURL=agent.js.map"]},"metadata":{},"sourceType":"script"}