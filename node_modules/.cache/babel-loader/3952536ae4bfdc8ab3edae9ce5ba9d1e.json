{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nconst util_1 = require(\"util\");\n\nconst escodegen_1 = require(\"escodegen\");\n\nconst esprima_1 = require(\"esprima\");\n\nconst ast_types_1 = require(\"ast-types\");\n\nconst vm_1 = require(\"vm\");\n\nconst supports_async_1 = __importDefault(require(\"./supports-async\"));\n\nconst generator_to_promise_1 = __importDefault(require(\"./generator-to-promise\"));\n/**\n * Compiles sync JavaScript code into JavaScript with async Functions.\n *\n * @param {String} code JavaScript string to convert\n * @param {Array} names Array of function names to add `await` operators to\n * @return {String} Converted JavaScript string with async/await injected\n * @api public\n */\n\n\nfunction degenerator(code, _names, {\n  output = 'async'\n} = {}) {\n  if (!Array.isArray(_names)) {\n    throw new TypeError('an array of async function \"names\" is required');\n  } // Duplicate the `names` array since it's rude to augment the user args\n\n\n  const names = _names.slice(0);\n\n  const ast = esprima_1.parseScript(code); // First pass is to find the `function` nodes and turn them into async or\n  // generator functions only if their body includes `CallExpressions` to\n  // function in `names`. We also add the names of the functions to the `names`\n  // array. We'll iterate several time, as every iteration might add new items\n  // to the `names` array, until no new names were added in the iteration.\n\n  let lastNamesLength = 0;\n\n  do {\n    lastNamesLength = names.length;\n    ast_types_1.visit(ast, {\n      visitVariableDeclaration(path) {\n        if (path.node.declarations) {\n          for (let i = 0; i < path.node.declarations.length; i++) {\n            const declaration = path.node.declarations[i];\n\n            if (ast_types_1.namedTypes.VariableDeclarator.check(declaration) && ast_types_1.namedTypes.Identifier.check(declaration.init) && ast_types_1.namedTypes.Identifier.check(declaration.id) && checkName(declaration.init.name, names) && !checkName(declaration.id.name, names)) {\n              names.push(declaration.id.name);\n            }\n          }\n        }\n\n        return false;\n      },\n\n      visitAssignmentExpression(path) {\n        if (ast_types_1.namedTypes.Identifier.check(path.node.left) && ast_types_1.namedTypes.Identifier.check(path.node.right) && checkName(path.node.right.name, names) && !checkName(path.node.left.name, names)) {\n          names.push(path.node.left.name);\n        }\n\n        return false;\n      },\n\n      visitFunction(path) {\n        if (path.node.id) {\n          let shouldDegenerate = false;\n          ast_types_1.visit(path.node, {\n            visitCallExpression(path) {\n              if (checkNames(path.node, names)) {\n                shouldDegenerate = true;\n              }\n\n              return false;\n            }\n\n          });\n\n          if (!shouldDegenerate) {\n            return false;\n          } // Got a \"function\" expression/statement,\n          // convert it into an async or generator function\n\n\n          if (output === 'async') {\n            path.node.async = true;\n          } else if (output === 'generator') {\n            path.node.generator = true;\n          } // Add function name to `names` array\n\n\n          if (!checkName(path.node.id.name, names)) {\n            names.push(path.node.id.name);\n          }\n        }\n\n        this.traverse(path);\n      }\n\n    });\n  } while (lastNamesLength !== names.length); // Second pass is for adding `await`/`yield` statements to any function\n  // invocations that match the given `names` array.\n\n\n  ast_types_1.visit(ast, {\n    visitCallExpression(path) {\n      if (checkNames(path.node, names)) {\n        // A \"function invocation\" expression,\n        // we need to inject a `AwaitExpression`/`YieldExpression`\n        const delegate = false;\n        const {\n          name,\n          parent: {\n            node: pNode\n          }\n        } = path;\n        let expr;\n\n        if (output === 'async') {\n          expr = ast_types_1.builders.awaitExpression(path.node, delegate);\n        } else if (output === 'generator') {\n          expr = ast_types_1.builders.yieldExpression(path.node, delegate);\n        } else {\n          throw new Error('Only \"async\" and \"generator\" are allowd `output` values');\n        }\n\n        if (ast_types_1.namedTypes.CallExpression.check(pNode)) {\n          pNode.arguments[name] = expr;\n        } else {\n          pNode[name] = expr;\n        }\n      }\n\n      this.traverse(path);\n    }\n\n  });\n  return escodegen_1.generate(ast);\n}\n\n(function (degenerator) {\n  degenerator.supportsAsync = supports_async_1.default;\n\n  function compile(code, returnName, names, options = {}) {\n    const output = supports_async_1.default ? 'async' : 'generator';\n    const compiled = degenerator(code, names, Object.assign(Object.assign({}, options), {\n      output\n    }));\n    const fn = vm_1.runInNewContext(`${compiled};${returnName}`, options.sandbox, options);\n\n    if (typeof fn !== 'function') {\n      throw new Error(`Expected a \"function\" to be returned for \\`${returnName}\\`, but got \"${typeof fn}\"`);\n    }\n\n    if (isAsyncFunction(fn)) {\n      return fn;\n    } else {\n      const rtn = generator_to_promise_1.default(fn);\n      Object.defineProperty(rtn, 'toString', {\n        value: fn.toString.bind(fn),\n        enumerable: false\n      });\n      return rtn;\n    }\n  }\n\n  degenerator.compile = compile;\n})(degenerator || (degenerator = {}));\n\nfunction isAsyncFunction(fn) {\n  return typeof fn === 'function' && fn.constructor.name === 'AsyncFunction';\n}\n/**\n * Returns `true` if `node` has a matching name to one of the entries in the\n * `names` array.\n *\n * @param {types.Node} node\n * @param {Array} names Array of function names to return true for\n * @return {Boolean}\n * @api private\n */\n\n\nfunction checkNames({\n  callee\n}, names) {\n  let name;\n\n  if (ast_types_1.namedTypes.Identifier.check(callee)) {\n    name = callee.name;\n  } else if (ast_types_1.namedTypes.MemberExpression.check(callee)) {\n    if (ast_types_1.namedTypes.Identifier.check(callee.object) && ast_types_1.namedTypes.Identifier.check(callee.property)) {\n      name = `${callee.object.name}.${callee.property.name}`;\n    } else {\n      return false;\n    }\n  } else if (ast_types_1.namedTypes.FunctionExpression.check(callee)) {\n    if (callee.id) {\n      name = callee.id.name;\n    } else {\n      return false;\n    }\n  } else {\n    throw new Error(`Don't know how to get name for: ${callee.type}`);\n  }\n\n  return checkName(name, names);\n}\n\nfunction checkName(name, names) {\n  // now that we have the `name`, check if any entries match in the `names` array\n  for (let i = 0; i < names.length; i++) {\n    const n = names[i];\n\n    if (util_1.isRegExp(n)) {\n      if (n.test(name)) {\n        return true;\n      }\n    } else if (name === n) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nmodule.exports = degenerator;","map":{"version":3,"sources":["../../src/index.ts"],"names":[],"mappings":";;;;;;;;AAAA,MAAA,MAAA,GAAA,OAAA,CAAA,MAAA,CAAA;;AACA,MAAA,WAAA,GAAA,OAAA,CAAA,WAAA,CAAA;;AACA,MAAA,SAAA,GAAA,OAAA,CAAA,SAAA,CAAA;;AACA,MAAA,WAAA,GAAA,OAAA,CAAA,WAAA,CAAA;;AACA,MAAA,IAAA,GAAA,OAAA,CAAA,IAAA,CAAA;;AAEA,MAAA,gBAAA,GAAA,eAAA,CAAA,OAAA,CAAA,kBAAA,CAAA,CAAA;;AACA,MAAA,sBAAA,GAAA,eAAA,CAAA,OAAA,CAAA,wBAAA,CAAA,CAAA;AAEA;;;;;;;AAOG;;;AAEH,SAAS,WAAT,CACC,IADD,EAEC,MAFD,EAGC;AAAE,EAAA,MAAM,GAAG;AAAX,IAAuD,EAHxD,EAG0D;AAEzD,MAAI,CAAC,KAAK,CAAC,OAAN,CAAc,MAAd,CAAL,EAA4B;AAC3B,UAAM,IAAI,SAAJ,CAAc,gDAAd,CAAN;AACA,GAJwD,CAMzD;;;AACA,QAAM,KAAK,GAAG,MAAM,CAAC,KAAP,CAAa,CAAb,CAAd;;AAEA,QAAM,GAAG,GAAG,SAAA,CAAA,WAAA,CAAY,IAAZ,CAAZ,CATyD,CAWzD;AACA;AACA;AACA;AACA;;AACA,MAAI,eAAe,GAAG,CAAtB;;AACA,KAAG;AACF,IAAA,eAAe,GAAG,KAAK,CAAC,MAAxB;AACA,IAAA,WAAA,CAAA,KAAA,CAAM,GAAN,EAAW;AACV,MAAA,wBAAwB,CAAC,IAAD,EAAK;AAC5B,YAAI,IAAI,CAAC,IAAL,CAAU,YAAd,EAA4B;AAC3B,eAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,IAAI,CAAC,IAAL,CAAU,YAAV,CAAuB,MAA3C,EAAmD,CAAC,EAApD,EAAwD;AACvD,kBAAM,WAAW,GAAG,IAAI,CAAC,IAAL,CAAU,YAAV,CAAuB,CAAvB,CAApB;;AACA,gBACC,WAAA,CAAA,UAAA,CAAE,kBAAF,CAAqB,KAArB,CAA2B,WAA3B,KACA,WAAA,CAAA,UAAA,CAAE,UAAF,CAAa,KAAb,CAAmB,WAAW,CAAC,IAA/B,CADA,IAEA,WAAA,CAAA,UAAA,CAAE,UAAF,CAAa,KAAb,CAAmB,WAAW,CAAC,EAA/B,CAFA,IAGA,SAAS,CAAC,WAAW,CAAC,IAAZ,CAAiB,IAAlB,EAAwB,KAAxB,CAHT,IAIA,CAAC,SAAS,CAAC,WAAW,CAAC,EAAZ,CAAe,IAAhB,EAAsB,KAAtB,CALX,EAME;AACD,cAAA,KAAK,CAAC,IAAN,CAAW,WAAW,CAAC,EAAZ,CAAe,IAA1B;AACA;AACD;AACD;;AACD,eAAO,KAAP;AACA,OAjBS;;AAkBV,MAAA,yBAAyB,CAAC,IAAD,EAAK;AAC7B,YACC,WAAA,CAAA,UAAA,CAAE,UAAF,CAAa,KAAb,CAAmB,IAAI,CAAC,IAAL,CAAU,IAA7B,KACA,WAAA,CAAA,UAAA,CAAE,UAAF,CAAa,KAAb,CAAmB,IAAI,CAAC,IAAL,CAAU,KAA7B,CADA,IAEA,SAAS,CAAC,IAAI,CAAC,IAAL,CAAU,KAAV,CAAgB,IAAjB,EAAuB,KAAvB,CAFT,IAGA,CAAC,SAAS,CAAC,IAAI,CAAC,IAAL,CAAU,IAAV,CAAe,IAAhB,EAAsB,KAAtB,CAJX,EAKE;AACD,UAAA,KAAK,CAAC,IAAN,CAAW,IAAI,CAAC,IAAL,CAAU,IAAV,CAAe,IAA1B;AACA;;AACD,eAAO,KAAP;AACA,OA5BS;;AA6BV,MAAA,aAAa,CAAC,IAAD,EAAK;AACjB,YAAI,IAAI,CAAC,IAAL,CAAU,EAAd,EAAkB;AACjB,cAAI,gBAAgB,GAAG,KAAvB;AACA,UAAA,WAAA,CAAA,KAAA,CAAM,IAAI,CAAC,IAAX,EAAiB;AAChB,YAAA,mBAAmB,CAAC,IAAD,EAAK;AACvB,kBAAI,UAAU,CAAC,IAAI,CAAC,IAAN,EAAY,KAAZ,CAAd,EAAkC;AACjC,gBAAA,gBAAgB,GAAG,IAAnB;AACA;;AACD,qBAAO,KAAP;AACA;;AANe,WAAjB;;AASA,cAAI,CAAC,gBAAL,EAAuB;AACtB,mBAAO,KAAP;AACA,WAbgB,CAejB;AACA;;;AACA,cAAI,MAAM,KAAK,OAAf,EAAwB;AACvB,YAAA,IAAI,CAAC,IAAL,CAAU,KAAV,GAAkB,IAAlB;AACA,WAFD,MAEO,IAAI,MAAM,KAAK,WAAf,EAA4B;AAClC,YAAA,IAAI,CAAC,IAAL,CAAU,SAAV,GAAsB,IAAtB;AACA,WArBgB,CAuBjB;;;AACA,cAAI,CAAC,SAAS,CAAC,IAAI,CAAC,IAAL,CAAU,EAAV,CAAa,IAAd,EAAoB,KAApB,CAAd,EAA0C;AACzC,YAAA,KAAK,CAAC,IAAN,CAAW,IAAI,CAAC,IAAL,CAAU,EAAV,CAAa,IAAxB;AACA;AACD;;AAED,aAAK,QAAL,CAAc,IAAd;AACA;;AA5DS,KAAX;AA8DA,GAhED,QAgES,eAAe,KAAK,KAAK,CAAC,MAhEnC,EAjByD,CAmFzD;AACA;;;AACA,EAAA,WAAA,CAAA,KAAA,CAAM,GAAN,EAAW;AACV,IAAA,mBAAmB,CAAC,IAAD,EAAK;AACvB,UAAI,UAAU,CAAC,IAAI,CAAC,IAAN,EAAY,KAAZ,CAAd,EAAkC;AACjC;AACA;AACA,cAAM,QAAQ,GAAG,KAAjB;AACA,cAAM;AACL,UAAA,IADK;AAEL,UAAA,MAAM,EAAE;AAAE,YAAA,IAAI,EAAE;AAAR;AAFH,YAGF,IAHJ;AAKA,YAAI,IAAJ;;AACA,YAAI,MAAM,KAAK,OAAf,EAAwB;AACvB,UAAA,IAAI,GAAG,WAAA,CAAA,QAAA,CAAE,eAAF,CAAkB,IAAI,CAAC,IAAvB,EAA6B,QAA7B,CAAP;AACA,SAFD,MAEO,IAAI,MAAM,KAAK,WAAf,EAA4B;AAClC,UAAA,IAAI,GAAG,WAAA,CAAA,QAAA,CAAE,eAAF,CAAkB,IAAI,CAAC,IAAvB,EAA6B,QAA7B,CAAP;AACA,SAFM,MAEA;AACN,gBAAM,IAAI,KAAJ,CACL,yDADK,CAAN;AAGA;;AAED,YAAI,WAAA,CAAA,UAAA,CAAE,cAAF,CAAiB,KAAjB,CAAuB,KAAvB,CAAJ,EAAmC;AAClC,UAAA,KAAK,CAAC,SAAN,CAAgB,IAAhB,IAAwB,IAAxB;AACA,SAFD,MAEO;AACN,UAAA,KAAK,CAAC,IAAD,CAAL,GAAc,IAAd;AACA;AACD;;AAED,WAAK,QAAL,CAAc,IAAd;AACA;;AA9BS,GAAX;AAiCA,SAAO,WAAA,CAAA,QAAA,CAAS,GAAT,CAAP;AACA;;AAED,CAAA,UAAU,WAAV,EAAqB;AAYP,EAAA,WAAA,CAAA,aAAA,GAAgB,gBAAA,CAAA,OAAhB;;AACb,WAAgB,OAAhB,CACC,IADD,EAEC,UAFD,EAGC,KAHD,EAIC,OAAA,GAA0B,EAJ3B,EAI6B;AAE5B,UAAM,MAAM,GAAG,gBAAA,CAAA,OAAA,GAAiB,OAAjB,GAA2B,WAA1C;AACA,UAAM,QAAQ,GAAG,WAAW,CAAC,IAAD,EAAO,KAAP,EAAY,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EAAO,OAAP,CAAA,EAAc;AAAE,MAAA;AAAF,KAAd,CAAZ,CAA5B;AACA,UAAM,EAAE,GAAG,IAAA,CAAA,eAAA,CACV,GAAG,QAAQ,IAAI,UAAU,EADf,EAEV,OAAO,CAAC,OAFE,EAGV,OAHU,CAAX;;AAKA,QAAI,OAAO,EAAP,KAAc,UAAlB,EAA8B;AAC7B,YAAM,IAAI,KAAJ,CACL,8CAA8C,UAAU,gBAAgB,OAAO,EAAE,GAD5E,CAAN;AAGA;;AACD,QAAI,eAAe,CAAC,EAAD,CAAnB,EAAyB;AACxB,aAAO,EAAP;AACA,KAFD,MAEO;AACN,YAAM,GAAG,GAAI,sBAAA,CAAA,OAAA,CAAqB,EAArB,CAAb;AACA,MAAA,MAAM,CAAC,cAAP,CAAsB,GAAtB,EAA2B,UAA3B,EAAuC;AACtC,QAAA,KAAK,EAAE,EAAE,CAAC,QAAH,CAAY,IAAZ,CAAiB,EAAjB,CAD+B;AAEtC,QAAA,UAAU,EAAE;AAF0B,OAAvC;AAIA,aAAO,GAAP;AACA;AACD;;AA5Be,EAAA,WAAA,CAAA,OAAA,GAAO,OAAP;AA6BhB,CA1CD,EAAU,WAAW,KAAX,WAAW,GAAA,EAAA,CAArB;;AA4CA,SAAS,eAAT,CAAyB,EAAzB,EAAgC;AAC/B,SAAO,OAAO,EAAP,KAAc,UAAd,IAA4B,EAAE,CAAC,WAAH,CAAe,IAAf,KAAwB,eAA3D;AACA;AAED;;;;;;;;AAQG;;;AAEH,SAAS,UAAT,CACC;AAAE,EAAA;AAAF,CADD,EAEC,KAFD,EAEoC;AAEnC,MAAI,IAAJ;;AACA,MAAI,WAAA,CAAA,UAAA,CAAE,UAAF,CAAa,KAAb,CAAmB,MAAnB,CAAJ,EAAgC;AAC/B,IAAA,IAAI,GAAG,MAAM,CAAC,IAAd;AACA,GAFD,MAEO,IAAI,WAAA,CAAA,UAAA,CAAE,gBAAF,CAAmB,KAAnB,CAAyB,MAAzB,CAAJ,EAAsC;AAC5C,QACC,WAAA,CAAA,UAAA,CAAE,UAAF,CAAa,KAAb,CAAmB,MAAM,CAAC,MAA1B,KACA,WAAA,CAAA,UAAA,CAAE,UAAF,CAAa,KAAb,CAAmB,MAAM,CAAC,QAA1B,CAFD,EAGE;AACD,MAAA,IAAI,GAAG,GAAG,MAAM,CAAC,MAAP,CAAc,IAAI,IAAI,MAAM,CAAC,QAAP,CAAgB,IAAI,EAApD;AACA,KALD,MAKO;AACN,aAAO,KAAP;AACA;AACD,GATM,MASA,IAAI,WAAA,CAAA,UAAA,CAAE,kBAAF,CAAqB,KAArB,CAA2B,MAA3B,CAAJ,EAAwC;AAC9C,QAAI,MAAM,CAAC,EAAX,EAAe;AACd,MAAA,IAAI,GAAG,MAAM,CAAC,EAAP,CAAU,IAAjB;AACA,KAFD,MAEO;AACN,aAAO,KAAP;AACA;AACD,GANM,MAMA;AACN,UAAM,IAAI,KAAJ,CAAU,mCAAmC,MAAM,CAAC,IAAI,EAAxD,CAAN;AACA;;AACD,SAAO,SAAS,CAAC,IAAD,EAAO,KAAP,CAAhB;AACA;;AAED,SAAS,SAAT,CAAmB,IAAnB,EAAiC,KAAjC,EAAoE;AACnE;AACA,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAAK,CAAC,MAA1B,EAAkC,CAAC,EAAnC,EAAuC;AACtC,UAAM,CAAC,GAAG,KAAK,CAAC,CAAD,CAAf;;AACA,QAAI,MAAA,CAAA,QAAA,CAAS,CAAT,CAAJ,EAAiB;AAChB,UAAI,CAAC,CAAC,IAAF,CAAO,IAAP,CAAJ,EAAkB;AACjB,eAAO,IAAP;AACA;AACD,KAJD,MAIO,IAAI,IAAI,KAAK,CAAb,EAAgB;AACtB,aAAO,IAAP;AACA;AACD;;AACD,SAAO,KAAP;AACA;;AAED,MAAA,CAAA,OAAA,GAAS,WAAT","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nconst util_1 = require(\"util\");\nconst escodegen_1 = require(\"escodegen\");\nconst esprima_1 = require(\"esprima\");\nconst ast_types_1 = require(\"ast-types\");\nconst vm_1 = require(\"vm\");\nconst supports_async_1 = __importDefault(require(\"./supports-async\"));\nconst generator_to_promise_1 = __importDefault(require(\"./generator-to-promise\"));\n/**\n * Compiles sync JavaScript code into JavaScript with async Functions.\n *\n * @param {String} code JavaScript string to convert\n * @param {Array} names Array of function names to add `await` operators to\n * @return {String} Converted JavaScript string with async/await injected\n * @api public\n */\nfunction degenerator(code, _names, { output = 'async' } = {}) {\n    if (!Array.isArray(_names)) {\n        throw new TypeError('an array of async function \"names\" is required');\n    }\n    // Duplicate the `names` array since it's rude to augment the user args\n    const names = _names.slice(0);\n    const ast = esprima_1.parseScript(code);\n    // First pass is to find the `function` nodes and turn them into async or\n    // generator functions only if their body includes `CallExpressions` to\n    // function in `names`. We also add the names of the functions to the `names`\n    // array. We'll iterate several time, as every iteration might add new items\n    // to the `names` array, until no new names were added in the iteration.\n    let lastNamesLength = 0;\n    do {\n        lastNamesLength = names.length;\n        ast_types_1.visit(ast, {\n            visitVariableDeclaration(path) {\n                if (path.node.declarations) {\n                    for (let i = 0; i < path.node.declarations.length; i++) {\n                        const declaration = path.node.declarations[i];\n                        if (ast_types_1.namedTypes.VariableDeclarator.check(declaration) &&\n                            ast_types_1.namedTypes.Identifier.check(declaration.init) &&\n                            ast_types_1.namedTypes.Identifier.check(declaration.id) &&\n                            checkName(declaration.init.name, names) &&\n                            !checkName(declaration.id.name, names)) {\n                            names.push(declaration.id.name);\n                        }\n                    }\n                }\n                return false;\n            },\n            visitAssignmentExpression(path) {\n                if (ast_types_1.namedTypes.Identifier.check(path.node.left) &&\n                    ast_types_1.namedTypes.Identifier.check(path.node.right) &&\n                    checkName(path.node.right.name, names) &&\n                    !checkName(path.node.left.name, names)) {\n                    names.push(path.node.left.name);\n                }\n                return false;\n            },\n            visitFunction(path) {\n                if (path.node.id) {\n                    let shouldDegenerate = false;\n                    ast_types_1.visit(path.node, {\n                        visitCallExpression(path) {\n                            if (checkNames(path.node, names)) {\n                                shouldDegenerate = true;\n                            }\n                            return false;\n                        }\n                    });\n                    if (!shouldDegenerate) {\n                        return false;\n                    }\n                    // Got a \"function\" expression/statement,\n                    // convert it into an async or generator function\n                    if (output === 'async') {\n                        path.node.async = true;\n                    }\n                    else if (output === 'generator') {\n                        path.node.generator = true;\n                    }\n                    // Add function name to `names` array\n                    if (!checkName(path.node.id.name, names)) {\n                        names.push(path.node.id.name);\n                    }\n                }\n                this.traverse(path);\n            }\n        });\n    } while (lastNamesLength !== names.length);\n    // Second pass is for adding `await`/`yield` statements to any function\n    // invocations that match the given `names` array.\n    ast_types_1.visit(ast, {\n        visitCallExpression(path) {\n            if (checkNames(path.node, names)) {\n                // A \"function invocation\" expression,\n                // we need to inject a `AwaitExpression`/`YieldExpression`\n                const delegate = false;\n                const { name, parent: { node: pNode } } = path;\n                let expr;\n                if (output === 'async') {\n                    expr = ast_types_1.builders.awaitExpression(path.node, delegate);\n                }\n                else if (output === 'generator') {\n                    expr = ast_types_1.builders.yieldExpression(path.node, delegate);\n                }\n                else {\n                    throw new Error('Only \"async\" and \"generator\" are allowd `output` values');\n                }\n                if (ast_types_1.namedTypes.CallExpression.check(pNode)) {\n                    pNode.arguments[name] = expr;\n                }\n                else {\n                    pNode[name] = expr;\n                }\n            }\n            this.traverse(path);\n        }\n    });\n    return escodegen_1.generate(ast);\n}\n(function (degenerator) {\n    degenerator.supportsAsync = supports_async_1.default;\n    function compile(code, returnName, names, options = {}) {\n        const output = supports_async_1.default ? 'async' : 'generator';\n        const compiled = degenerator(code, names, Object.assign(Object.assign({}, options), { output }));\n        const fn = vm_1.runInNewContext(`${compiled};${returnName}`, options.sandbox, options);\n        if (typeof fn !== 'function') {\n            throw new Error(`Expected a \"function\" to be returned for \\`${returnName}\\`, but got \"${typeof fn}\"`);\n        }\n        if (isAsyncFunction(fn)) {\n            return fn;\n        }\n        else {\n            const rtn = generator_to_promise_1.default(fn);\n            Object.defineProperty(rtn, 'toString', {\n                value: fn.toString.bind(fn),\n                enumerable: false\n            });\n            return rtn;\n        }\n    }\n    degenerator.compile = compile;\n})(degenerator || (degenerator = {}));\nfunction isAsyncFunction(fn) {\n    return typeof fn === 'function' && fn.constructor.name === 'AsyncFunction';\n}\n/**\n * Returns `true` if `node` has a matching name to one of the entries in the\n * `names` array.\n *\n * @param {types.Node} node\n * @param {Array} names Array of function names to return true for\n * @return {Boolean}\n * @api private\n */\nfunction checkNames({ callee }, names) {\n    let name;\n    if (ast_types_1.namedTypes.Identifier.check(callee)) {\n        name = callee.name;\n    }\n    else if (ast_types_1.namedTypes.MemberExpression.check(callee)) {\n        if (ast_types_1.namedTypes.Identifier.check(callee.object) &&\n            ast_types_1.namedTypes.Identifier.check(callee.property)) {\n            name = `${callee.object.name}.${callee.property.name}`;\n        }\n        else {\n            return false;\n        }\n    }\n    else if (ast_types_1.namedTypes.FunctionExpression.check(callee)) {\n        if (callee.id) {\n            name = callee.id.name;\n        }\n        else {\n            return false;\n        }\n    }\n    else {\n        throw new Error(`Don't know how to get name for: ${callee.type}`);\n    }\n    return checkName(name, names);\n}\nfunction checkName(name, names) {\n    // now that we have the `name`, check if any entries match in the `names` array\n    for (let i = 0; i < names.length; i++) {\n        const n = names[i];\n        if (util_1.isRegExp(n)) {\n            if (n.test(name)) {\n                return true;\n            }\n        }\n        else if (name === n) {\n            return true;\n        }\n    }\n    return false;\n}\nmodule.exports = degenerator;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}