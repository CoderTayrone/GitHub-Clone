{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FirestoreIndexes = void 0;\n\nconst clc = require(\"cli-color\");\n\nconst api = require(\"../api\");\n\nconst logger_1 = require(\"../logger\");\n\nconst utils = require(\"../utils\");\n\nconst validator = require(\"./validator\");\n\nconst API = require(\"./indexes-api\");\n\nconst sort = require(\"./indexes-sort\");\n\nconst util = require(\"./util\");\n\nconst prompt_1 = require(\"../prompt\");\n\nclass FirestoreIndexes {\n  async deploy(options, indexes, fieldOverrides) {\n    const spec = this.upgradeOldSpec({\n      indexes,\n      fieldOverrides\n    });\n    this.validateSpec(spec);\n    const indexesToDeploy = spec.indexes;\n    const fieldOverridesToDeploy = spec.fieldOverrides;\n    const existingIndexes = await this.listIndexes(options.project);\n    const existingFieldOverrides = await this.listFieldOverrides(options.project);\n    const indexesToDelete = existingIndexes.filter(index => {\n      return !indexesToDeploy.some(spec => this.indexMatchesSpec(index, spec));\n    });\n    const fieldOverridesToDelete = existingFieldOverrides.filter(field => {\n      return !fieldOverridesToDeploy.some(spec => {\n        const parsedName = util.parseFieldName(field.name);\n\n        if (parsedName.collectionGroupId !== spec.collectionGroup) {\n          return false;\n        }\n\n        if (parsedName.fieldPath !== spec.fieldPath) {\n          return false;\n        }\n\n        return true;\n      });\n    });\n    let shouldDeleteIndexes = options.force;\n\n    if (indexesToDelete.length > 0) {\n      if (options.nonInteractive && !options.force) {\n        utils.logLabeledBullet(\"firestore\", `there are ${indexesToDelete.length} indexes defined in your project that are not present in your ` + \"firestore indexes file. To delete them, run this command with the --force flag.\");\n      } else if (!options.force) {\n        const indexesString = indexesToDelete.map(x => this.prettyIndexString(x, false)).join(\"\\n\\t\");\n        utils.logLabeledBullet(\"firestore\", `The following indexes are defined in your project but are not present in your firestore indexes file:\\n\\t${indexesString}`);\n      }\n\n      if (!shouldDeleteIndexes) {\n        shouldDeleteIndexes = await prompt_1.promptOnce({\n          type: \"confirm\",\n          name: \"confirm\",\n          default: false,\n          message: \"Would you like to delete these indexes? Selecting no will continue the rest of the deployment.\"\n        });\n      }\n    }\n\n    for (const index of indexesToDeploy) {\n      const exists = existingIndexes.some(x => this.indexMatchesSpec(x, index));\n\n      if (exists) {\n        logger_1.logger.debug(`Skipping existing index: ${JSON.stringify(index)}`);\n      } else {\n        logger_1.logger.debug(`Creating new index: ${JSON.stringify(index)}`);\n        await this.createIndex(options.project, index);\n      }\n    }\n\n    if (shouldDeleteIndexes && indexesToDelete.length > 0) {\n      utils.logLabeledBullet(\"firestore\", `Deleting ${indexesToDelete.length} indexes...`);\n\n      for (const index of indexesToDelete) {\n        await this.deleteIndex(index);\n      }\n    }\n\n    let shouldDeleteFields = options.force;\n\n    if (fieldOverridesToDelete.length > 0) {\n      if (options.nonInteractive && !options.force) {\n        utils.logLabeledBullet(\"firestore\", `there are ${fieldOverridesToDelete.length} field overrides defined in your project that are not present in your ` + \"firestore indexes file. To delete them, run this command with the --force flag.\");\n      } else if (!options.force) {\n        const indexesString = fieldOverridesToDelete.map(x => this.prettyFieldString(x)).join(\"\\n\\t\");\n        utils.logLabeledBullet(\"firestore\", `The following field overrides are defined in your project but are not present in your firestore indexes file:\\n\\t${indexesString}`);\n      }\n\n      if (!shouldDeleteFields) {\n        shouldDeleteFields = await prompt_1.promptOnce({\n          type: \"confirm\",\n          name: \"confirm\",\n          default: false,\n          message: \"Would you like to delete these field overrides? Selecting no will continue the rest of the deployment.\"\n        });\n      }\n    }\n\n    for (const field of fieldOverridesToDeploy) {\n      const exists = existingFieldOverrides.some(x => this.fieldMatchesSpec(x, field));\n\n      if (exists) {\n        logger_1.logger.debug(`Skipping existing field override: ${JSON.stringify(field)}`);\n      } else {\n        logger_1.logger.debug(`Updating field override: ${JSON.stringify(field)}`);\n        await this.patchField(options.project, field);\n      }\n    }\n\n    if (shouldDeleteFields && fieldOverridesToDelete.length > 0) {\n      utils.logLabeledBullet(\"firestore\", `Deleting ${fieldOverridesToDelete.length} field overrides...`);\n\n      for (const field of fieldOverridesToDelete) {\n        await this.deleteField(field);\n      }\n    }\n  }\n\n  async listIndexes(project) {\n    const url = `projects/${project}/databases/(default)/collectionGroups/-/indexes`;\n    const res = await api.request(\"GET\", `/v1/${url}`, {\n      auth: true,\n      origin: api.firestoreOrigin\n    });\n    const indexes = res.body.indexes;\n\n    if (!indexes) {\n      return [];\n    }\n\n    return indexes.map(index => {\n      const fields = index.fields.filter(field => {\n        return field.fieldPath !== \"__name__\";\n      });\n      return {\n        name: index.name,\n        state: index.state,\n        queryScope: index.queryScope,\n        fields\n      };\n    });\n  }\n\n  async listFieldOverrides(project) {\n    const parent = `projects/${project}/databases/(default)/collectionGroups/-`;\n    const url = `${parent}/fields?filter=indexConfig.usesAncestorConfig=false`;\n    const res = await api.request(\"GET\", `/v1/${url}`, {\n      auth: true,\n      origin: api.firestoreOrigin\n    });\n    const fields = res.body.fields;\n\n    if (!fields) {\n      return [];\n    }\n\n    return fields.filter(field => {\n      return field.name.indexOf(\"__default__\") < 0;\n    });\n  }\n\n  makeIndexSpec(indexes, fields) {\n    const indexesJson = indexes.map(index => {\n      return {\n        collectionGroup: util.parseIndexName(index.name).collectionGroupId,\n        queryScope: index.queryScope,\n        fields: index.fields\n      };\n    });\n\n    if (!fields) {\n      logger_1.logger.debug(\"No field overrides specified, using [].\");\n      fields = [];\n    }\n\n    const fieldsJson = fields.map(field => {\n      const parsedName = util.parseFieldName(field.name);\n      const fieldIndexes = field.indexConfig.indexes || [];\n      return {\n        collectionGroup: parsedName.collectionGroupId,\n        fieldPath: parsedName.fieldPath,\n        indexes: fieldIndexes.map(index => {\n          const firstField = index.fields[0];\n          return {\n            order: firstField.order,\n            arrayConfig: firstField.arrayConfig,\n            queryScope: index.queryScope\n          };\n        })\n      };\n    });\n    const sortedIndexes = indexesJson.sort(sort.compareSpecIndex);\n    const sortedFields = fieldsJson.sort(sort.compareFieldOverride);\n    return {\n      indexes: sortedIndexes,\n      fieldOverrides: sortedFields\n    };\n  }\n\n  prettyPrintIndexes(indexes) {\n    if (indexes.length === 0) {\n      logger_1.logger.info(\"None\");\n      return;\n    }\n\n    const sortedIndexes = indexes.sort(sort.compareApiIndex);\n    sortedIndexes.forEach(index => {\n      logger_1.logger.info(this.prettyIndexString(index));\n    });\n  }\n\n  printFieldOverrides(fields) {\n    if (fields.length === 0) {\n      logger_1.logger.info(\"None\");\n      return;\n    }\n\n    const sortedFields = fields.sort(sort.compareApiField);\n    sortedFields.forEach(field => {\n      logger_1.logger.info(this.prettyFieldString(field));\n    });\n  }\n\n  validateSpec(spec) {\n    validator.assertHas(spec, \"indexes\");\n    spec.indexes.forEach(index => {\n      this.validateIndex(index);\n    });\n\n    if (spec.fieldOverrides) {\n      spec.fieldOverrides.forEach(field => {\n        this.validateField(field);\n      });\n    }\n  }\n\n  validateIndex(index) {\n    validator.assertHas(index, \"collectionGroup\");\n    validator.assertHas(index, \"queryScope\");\n    validator.assertEnum(index, \"queryScope\", Object.keys(API.QueryScope));\n    validator.assertHas(index, \"fields\");\n    index.fields.forEach(field => {\n      validator.assertHas(field, \"fieldPath\");\n      validator.assertHasOneOf(field, [\"order\", \"arrayConfig\"]);\n\n      if (field.order) {\n        validator.assertEnum(field, \"order\", Object.keys(API.Order));\n      }\n\n      if (field.arrayConfig) {\n        validator.assertEnum(field, \"arrayConfig\", Object.keys(API.ArrayConfig));\n      }\n    });\n  }\n\n  validateField(field) {\n    validator.assertHas(field, \"collectionGroup\");\n    validator.assertHas(field, \"fieldPath\");\n    validator.assertHas(field, \"indexes\");\n    field.indexes.forEach(index => {\n      validator.assertHasOneOf(index, [\"arrayConfig\", \"order\"]);\n\n      if (index.arrayConfig) {\n        validator.assertEnum(index, \"arrayConfig\", Object.keys(API.ArrayConfig));\n      }\n\n      if (index.order) {\n        validator.assertEnum(index, \"order\", Object.keys(API.Order));\n      }\n\n      if (index.queryScope) {\n        validator.assertEnum(index, \"queryScope\", Object.keys(API.QueryScope));\n      }\n    });\n  }\n\n  async patchField(project, spec) {\n    const url = `projects/${project}/databases/(default)/collectionGroups/${spec.collectionGroup}/fields/${spec.fieldPath}`;\n    const indexes = spec.indexes.map(index => {\n      return {\n        queryScope: index.queryScope,\n        fields: [{\n          fieldPath: spec.fieldPath,\n          arrayConfig: index.arrayConfig,\n          order: index.order\n        }]\n      };\n    });\n    const data = {\n      indexConfig: {\n        indexes\n      }\n    };\n    await api.request(\"PATCH\", `/v1/${url}`, {\n      auth: true,\n      origin: api.firestoreOrigin,\n      data\n    });\n  }\n\n  deleteField(field) {\n    const url = field.name;\n    const data = {};\n    return api.request(\"PATCH\", \"/v1/\" + url + \"?updateMask=indexConfig\", {\n      auth: true,\n      origin: api.firestoreOrigin,\n      data\n    });\n  }\n\n  createIndex(project, index) {\n    const url = `projects/${project}/databases/(default)/collectionGroups/${index.collectionGroup}/indexes`;\n    return api.request(\"POST\", \"/v1/\" + url, {\n      auth: true,\n      data: {\n        fields: index.fields,\n        queryScope: index.queryScope\n      },\n      origin: api.firestoreOrigin\n    });\n  }\n\n  deleteIndex(index) {\n    const url = index.name;\n    return api.request(\"DELETE\", \"/v1/\" + url, {\n      auth: true,\n      origin: api.firestoreOrigin\n    });\n  }\n\n  indexMatchesSpec(index, spec) {\n    const collection = util.parseIndexName(index.name).collectionGroupId;\n\n    if (collection !== spec.collectionGroup) {\n      return false;\n    }\n\n    if (index.queryScope !== spec.queryScope) {\n      return false;\n    }\n\n    if (index.fields.length !== spec.fields.length) {\n      return false;\n    }\n\n    let i = 0;\n\n    while (i < index.fields.length) {\n      const iField = index.fields[i];\n      const sField = spec.fields[i];\n\n      if (iField.fieldPath !== sField.fieldPath) {\n        return false;\n      }\n\n      if (iField.order !== sField.order) {\n        return false;\n      }\n\n      if (iField.arrayConfig !== sField.arrayConfig) {\n        return false;\n      }\n\n      i++;\n    }\n\n    return true;\n  }\n\n  fieldMatchesSpec(field, spec) {\n    const parsedName = util.parseFieldName(field.name);\n\n    if (parsedName.collectionGroupId !== spec.collectionGroup) {\n      return false;\n    }\n\n    if (parsedName.fieldPath !== spec.fieldPath) {\n      return false;\n    }\n\n    const fieldIndexes = field.indexConfig.indexes || [];\n\n    if (fieldIndexes.length !== spec.indexes.length) {\n      return false;\n    }\n\n    const fieldModes = fieldIndexes.map(index => {\n      const firstField = index.fields[0];\n      return firstField.order || firstField.arrayConfig;\n    });\n    const specModes = spec.indexes.map(index => {\n      return index.order || index.arrayConfig;\n    });\n\n    for (const mode of fieldModes) {\n      if (specModes.indexOf(mode) < 0) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  upgradeOldSpec(spec) {\n    const result = {\n      indexes: [],\n      fieldOverrides: spec.fieldOverrides || []\n    };\n\n    if (!(spec.indexes && spec.indexes.length > 0)) {\n      return result;\n    }\n\n    if (spec.indexes[0].collectionId) {\n      utils.logBullet(clc.bold.cyan(\"firestore:\") + \" your indexes indexes are specified in the v1beta1 API format. \" + \"Please upgrade to the new index API format by running \" + clc.bold(\"firebase firestore:indexes\") + \" again and saving the result.\");\n    }\n\n    result.indexes = spec.indexes.map(index => {\n      const i = {\n        collectionGroup: index.collectionGroup || index.collectionId,\n        queryScope: index.queryScope || API.QueryScope.COLLECTION,\n        fields: []\n      };\n\n      if (index.fields) {\n        i.fields = index.fields.map(field => {\n          const f = {\n            fieldPath: field.fieldPath\n          };\n\n          if (field.order) {\n            f.order = field.order;\n          } else if (field.arrayConfig) {\n            f.arrayConfig = field.arrayConfig;\n          } else if (field.mode === API.Mode.ARRAY_CONTAINS) {\n            f.arrayConfig = API.ArrayConfig.CONTAINS;\n          } else {\n            f.order = field.mode;\n          }\n\n          return f;\n        });\n      }\n\n      return i;\n    });\n    return result;\n  }\n\n  prettyIndexString(index, includeState = true) {\n    let result = \"\";\n\n    if (index.state && includeState) {\n      const stateMsg = `[${index.state}] `;\n\n      if (index.state === API.State.READY) {\n        result += clc.green(stateMsg);\n      } else if (index.state === API.State.CREATING) {\n        result += clc.yellow(stateMsg);\n      } else {\n        result += clc.red(stateMsg);\n      }\n    }\n\n    const nameInfo = util.parseIndexName(index.name);\n    result += clc.cyan(`(${nameInfo.collectionGroupId})`);\n    result += \" -- \";\n    index.fields.forEach(field => {\n      if (field.fieldPath === \"__name__\") {\n        return;\n      }\n\n      const orderOrArrayConfig = field.order ? field.order : field.arrayConfig;\n      result += `(${field.fieldPath},${orderOrArrayConfig}) `;\n    });\n    return result;\n  }\n\n  prettyFieldString(field) {\n    let result = \"\";\n    const parsedName = util.parseFieldName(field.name);\n    result += \"[\" + clc.cyan(parsedName.collectionGroupId) + \".\" + clc.yellow(parsedName.fieldPath) + \"] --\";\n    const fieldIndexes = field.indexConfig.indexes || [];\n\n    if (fieldIndexes.length > 0) {\n      fieldIndexes.forEach(index => {\n        const firstField = index.fields[0];\n        const mode = firstField.order || firstField.arrayConfig;\n        result += ` (${mode})`;\n      });\n    } else {\n      result += \" (no indexes)\";\n    }\n\n    return result;\n  }\n\n}\n\nexports.FirestoreIndexes = FirestoreIndexes;","map":{"version":3,"sources":["/home/dev/Documentos/Projects/github-clone/node_modules/firebase-tools/lib/firestore/indexes.js"],"names":["Object","defineProperty","exports","value","FirestoreIndexes","clc","require","api","logger_1","utils","validator","API","sort","util","prompt_1","deploy","options","indexes","fieldOverrides","spec","upgradeOldSpec","validateSpec","indexesToDeploy","fieldOverridesToDeploy","existingIndexes","listIndexes","project","existingFieldOverrides","listFieldOverrides","indexesToDelete","filter","index","some","indexMatchesSpec","fieldOverridesToDelete","field","parsedName","parseFieldName","name","collectionGroupId","collectionGroup","fieldPath","shouldDeleteIndexes","force","length","nonInteractive","logLabeledBullet","indexesString","map","x","prettyIndexString","join","promptOnce","type","default","message","exists","logger","debug","JSON","stringify","createIndex","deleteIndex","shouldDeleteFields","prettyFieldString","fieldMatchesSpec","patchField","deleteField","url","res","request","auth","origin","firestoreOrigin","body","fields","state","queryScope","parent","indexOf","makeIndexSpec","indexesJson","parseIndexName","fieldsJson","fieldIndexes","indexConfig","firstField","order","arrayConfig","sortedIndexes","compareSpecIndex","sortedFields","compareFieldOverride","prettyPrintIndexes","info","compareApiIndex","forEach","printFieldOverrides","compareApiField","assertHas","validateIndex","validateField","assertEnum","keys","QueryScope","assertHasOneOf","Order","ArrayConfig","data","collection","i","iField","sField","fieldModes","specModes","mode","result","collectionId","logBullet","bold","cyan","COLLECTION","f","Mode","ARRAY_CONTAINS","CONTAINS","includeState","stateMsg","State","READY","green","CREATING","yellow","red","nameInfo","orderOrArrayConfig"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FirestoreIndexes = void 0;\nconst clc = require(\"cli-color\");\nconst api = require(\"../api\");\nconst logger_1 = require(\"../logger\");\nconst utils = require(\"../utils\");\nconst validator = require(\"./validator\");\nconst API = require(\"./indexes-api\");\nconst sort = require(\"./indexes-sort\");\nconst util = require(\"./util\");\nconst prompt_1 = require(\"../prompt\");\nclass FirestoreIndexes {\n    async deploy(options, indexes, fieldOverrides) {\n        const spec = this.upgradeOldSpec({\n            indexes,\n            fieldOverrides,\n        });\n        this.validateSpec(spec);\n        const indexesToDeploy = spec.indexes;\n        const fieldOverridesToDeploy = spec.fieldOverrides;\n        const existingIndexes = await this.listIndexes(options.project);\n        const existingFieldOverrides = await this.listFieldOverrides(options.project);\n        const indexesToDelete = existingIndexes.filter((index) => {\n            return !indexesToDeploy.some((spec) => this.indexMatchesSpec(index, spec));\n        });\n        const fieldOverridesToDelete = existingFieldOverrides.filter((field) => {\n            return !fieldOverridesToDeploy.some((spec) => {\n                const parsedName = util.parseFieldName(field.name);\n                if (parsedName.collectionGroupId !== spec.collectionGroup) {\n                    return false;\n                }\n                if (parsedName.fieldPath !== spec.fieldPath) {\n                    return false;\n                }\n                return true;\n            });\n        });\n        let shouldDeleteIndexes = options.force;\n        if (indexesToDelete.length > 0) {\n            if (options.nonInteractive && !options.force) {\n                utils.logLabeledBullet(\"firestore\", `there are ${indexesToDelete.length} indexes defined in your project that are not present in your ` +\n                    \"firestore indexes file. To delete them, run this command with the --force flag.\");\n            }\n            else if (!options.force) {\n                const indexesString = indexesToDelete\n                    .map((x) => this.prettyIndexString(x, false))\n                    .join(\"\\n\\t\");\n                utils.logLabeledBullet(\"firestore\", `The following indexes are defined in your project but are not present in your firestore indexes file:\\n\\t${indexesString}`);\n            }\n            if (!shouldDeleteIndexes) {\n                shouldDeleteIndexes = await prompt_1.promptOnce({\n                    type: \"confirm\",\n                    name: \"confirm\",\n                    default: false,\n                    message: \"Would you like to delete these indexes? Selecting no will continue the rest of the deployment.\",\n                });\n            }\n        }\n        for (const index of indexesToDeploy) {\n            const exists = existingIndexes.some((x) => this.indexMatchesSpec(x, index));\n            if (exists) {\n                logger_1.logger.debug(`Skipping existing index: ${JSON.stringify(index)}`);\n            }\n            else {\n                logger_1.logger.debug(`Creating new index: ${JSON.stringify(index)}`);\n                await this.createIndex(options.project, index);\n            }\n        }\n        if (shouldDeleteIndexes && indexesToDelete.length > 0) {\n            utils.logLabeledBullet(\"firestore\", `Deleting ${indexesToDelete.length} indexes...`);\n            for (const index of indexesToDelete) {\n                await this.deleteIndex(index);\n            }\n        }\n        let shouldDeleteFields = options.force;\n        if (fieldOverridesToDelete.length > 0) {\n            if (options.nonInteractive && !options.force) {\n                utils.logLabeledBullet(\"firestore\", `there are ${fieldOverridesToDelete.length} field overrides defined in your project that are not present in your ` +\n                    \"firestore indexes file. To delete them, run this command with the --force flag.\");\n            }\n            else if (!options.force) {\n                const indexesString = fieldOverridesToDelete\n                    .map((x) => this.prettyFieldString(x))\n                    .join(\"\\n\\t\");\n                utils.logLabeledBullet(\"firestore\", `The following field overrides are defined in your project but are not present in your firestore indexes file:\\n\\t${indexesString}`);\n            }\n            if (!shouldDeleteFields) {\n                shouldDeleteFields = await prompt_1.promptOnce({\n                    type: \"confirm\",\n                    name: \"confirm\",\n                    default: false,\n                    message: \"Would you like to delete these field overrides? Selecting no will continue the rest of the deployment.\",\n                });\n            }\n        }\n        for (const field of fieldOverridesToDeploy) {\n            const exists = existingFieldOverrides.some((x) => this.fieldMatchesSpec(x, field));\n            if (exists) {\n                logger_1.logger.debug(`Skipping existing field override: ${JSON.stringify(field)}`);\n            }\n            else {\n                logger_1.logger.debug(`Updating field override: ${JSON.stringify(field)}`);\n                await this.patchField(options.project, field);\n            }\n        }\n        if (shouldDeleteFields && fieldOverridesToDelete.length > 0) {\n            utils.logLabeledBullet(\"firestore\", `Deleting ${fieldOverridesToDelete.length} field overrides...`);\n            for (const field of fieldOverridesToDelete) {\n                await this.deleteField(field);\n            }\n        }\n    }\n    async listIndexes(project) {\n        const url = `projects/${project}/databases/(default)/collectionGroups/-/indexes`;\n        const res = await api.request(\"GET\", `/v1/${url}`, {\n            auth: true,\n            origin: api.firestoreOrigin,\n        });\n        const indexes = res.body.indexes;\n        if (!indexes) {\n            return [];\n        }\n        return indexes.map((index) => {\n            const fields = index.fields.filter((field) => {\n                return field.fieldPath !== \"__name__\";\n            });\n            return {\n                name: index.name,\n                state: index.state,\n                queryScope: index.queryScope,\n                fields,\n            };\n        });\n    }\n    async listFieldOverrides(project) {\n        const parent = `projects/${project}/databases/(default)/collectionGroups/-`;\n        const url = `${parent}/fields?filter=indexConfig.usesAncestorConfig=false`;\n        const res = await api.request(\"GET\", `/v1/${url}`, {\n            auth: true,\n            origin: api.firestoreOrigin,\n        });\n        const fields = res.body.fields;\n        if (!fields) {\n            return [];\n        }\n        return fields.filter((field) => {\n            return field.name.indexOf(\"__default__\") < 0;\n        });\n    }\n    makeIndexSpec(indexes, fields) {\n        const indexesJson = indexes.map((index) => {\n            return {\n                collectionGroup: util.parseIndexName(index.name).collectionGroupId,\n                queryScope: index.queryScope,\n                fields: index.fields,\n            };\n        });\n        if (!fields) {\n            logger_1.logger.debug(\"No field overrides specified, using [].\");\n            fields = [];\n        }\n        const fieldsJson = fields.map((field) => {\n            const parsedName = util.parseFieldName(field.name);\n            const fieldIndexes = field.indexConfig.indexes || [];\n            return {\n                collectionGroup: parsedName.collectionGroupId,\n                fieldPath: parsedName.fieldPath,\n                indexes: fieldIndexes.map((index) => {\n                    const firstField = index.fields[0];\n                    return {\n                        order: firstField.order,\n                        arrayConfig: firstField.arrayConfig,\n                        queryScope: index.queryScope,\n                    };\n                }),\n            };\n        });\n        const sortedIndexes = indexesJson.sort(sort.compareSpecIndex);\n        const sortedFields = fieldsJson.sort(sort.compareFieldOverride);\n        return {\n            indexes: sortedIndexes,\n            fieldOverrides: sortedFields,\n        };\n    }\n    prettyPrintIndexes(indexes) {\n        if (indexes.length === 0) {\n            logger_1.logger.info(\"None\");\n            return;\n        }\n        const sortedIndexes = indexes.sort(sort.compareApiIndex);\n        sortedIndexes.forEach((index) => {\n            logger_1.logger.info(this.prettyIndexString(index));\n        });\n    }\n    printFieldOverrides(fields) {\n        if (fields.length === 0) {\n            logger_1.logger.info(\"None\");\n            return;\n        }\n        const sortedFields = fields.sort(sort.compareApiField);\n        sortedFields.forEach((field) => {\n            logger_1.logger.info(this.prettyFieldString(field));\n        });\n    }\n    validateSpec(spec) {\n        validator.assertHas(spec, \"indexes\");\n        spec.indexes.forEach((index) => {\n            this.validateIndex(index);\n        });\n        if (spec.fieldOverrides) {\n            spec.fieldOverrides.forEach((field) => {\n                this.validateField(field);\n            });\n        }\n    }\n    validateIndex(index) {\n        validator.assertHas(index, \"collectionGroup\");\n        validator.assertHas(index, \"queryScope\");\n        validator.assertEnum(index, \"queryScope\", Object.keys(API.QueryScope));\n        validator.assertHas(index, \"fields\");\n        index.fields.forEach((field) => {\n            validator.assertHas(field, \"fieldPath\");\n            validator.assertHasOneOf(field, [\"order\", \"arrayConfig\"]);\n            if (field.order) {\n                validator.assertEnum(field, \"order\", Object.keys(API.Order));\n            }\n            if (field.arrayConfig) {\n                validator.assertEnum(field, \"arrayConfig\", Object.keys(API.ArrayConfig));\n            }\n        });\n    }\n    validateField(field) {\n        validator.assertHas(field, \"collectionGroup\");\n        validator.assertHas(field, \"fieldPath\");\n        validator.assertHas(field, \"indexes\");\n        field.indexes.forEach((index) => {\n            validator.assertHasOneOf(index, [\"arrayConfig\", \"order\"]);\n            if (index.arrayConfig) {\n                validator.assertEnum(index, \"arrayConfig\", Object.keys(API.ArrayConfig));\n            }\n            if (index.order) {\n                validator.assertEnum(index, \"order\", Object.keys(API.Order));\n            }\n            if (index.queryScope) {\n                validator.assertEnum(index, \"queryScope\", Object.keys(API.QueryScope));\n            }\n        });\n    }\n    async patchField(project, spec) {\n        const url = `projects/${project}/databases/(default)/collectionGroups/${spec.collectionGroup}/fields/${spec.fieldPath}`;\n        const indexes = spec.indexes.map((index) => {\n            return {\n                queryScope: index.queryScope,\n                fields: [\n                    {\n                        fieldPath: spec.fieldPath,\n                        arrayConfig: index.arrayConfig,\n                        order: index.order,\n                    },\n                ],\n            };\n        });\n        const data = {\n            indexConfig: {\n                indexes,\n            },\n        };\n        await api.request(\"PATCH\", `/v1/${url}`, {\n            auth: true,\n            origin: api.firestoreOrigin,\n            data,\n        });\n    }\n    deleteField(field) {\n        const url = field.name;\n        const data = {};\n        return api.request(\"PATCH\", \"/v1/\" + url + \"?updateMask=indexConfig\", {\n            auth: true,\n            origin: api.firestoreOrigin,\n            data,\n        });\n    }\n    createIndex(project, index) {\n        const url = `projects/${project}/databases/(default)/collectionGroups/${index.collectionGroup}/indexes`;\n        return api.request(\"POST\", \"/v1/\" + url, {\n            auth: true,\n            data: {\n                fields: index.fields,\n                queryScope: index.queryScope,\n            },\n            origin: api.firestoreOrigin,\n        });\n    }\n    deleteIndex(index) {\n        const url = index.name;\n        return api.request(\"DELETE\", \"/v1/\" + url, {\n            auth: true,\n            origin: api.firestoreOrigin,\n        });\n    }\n    indexMatchesSpec(index, spec) {\n        const collection = util.parseIndexName(index.name).collectionGroupId;\n        if (collection !== spec.collectionGroup) {\n            return false;\n        }\n        if (index.queryScope !== spec.queryScope) {\n            return false;\n        }\n        if (index.fields.length !== spec.fields.length) {\n            return false;\n        }\n        let i = 0;\n        while (i < index.fields.length) {\n            const iField = index.fields[i];\n            const sField = spec.fields[i];\n            if (iField.fieldPath !== sField.fieldPath) {\n                return false;\n            }\n            if (iField.order !== sField.order) {\n                return false;\n            }\n            if (iField.arrayConfig !== sField.arrayConfig) {\n                return false;\n            }\n            i++;\n        }\n        return true;\n    }\n    fieldMatchesSpec(field, spec) {\n        const parsedName = util.parseFieldName(field.name);\n        if (parsedName.collectionGroupId !== spec.collectionGroup) {\n            return false;\n        }\n        if (parsedName.fieldPath !== spec.fieldPath) {\n            return false;\n        }\n        const fieldIndexes = field.indexConfig.indexes || [];\n        if (fieldIndexes.length !== spec.indexes.length) {\n            return false;\n        }\n        const fieldModes = fieldIndexes.map((index) => {\n            const firstField = index.fields[0];\n            return firstField.order || firstField.arrayConfig;\n        });\n        const specModes = spec.indexes.map((index) => {\n            return index.order || index.arrayConfig;\n        });\n        for (const mode of fieldModes) {\n            if (specModes.indexOf(mode) < 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    upgradeOldSpec(spec) {\n        const result = {\n            indexes: [],\n            fieldOverrides: spec.fieldOverrides || [],\n        };\n        if (!(spec.indexes && spec.indexes.length > 0)) {\n            return result;\n        }\n        if (spec.indexes[0].collectionId) {\n            utils.logBullet(clc.bold.cyan(\"firestore:\") +\n                \" your indexes indexes are specified in the v1beta1 API format. \" +\n                \"Please upgrade to the new index API format by running \" +\n                clc.bold(\"firebase firestore:indexes\") +\n                \" again and saving the result.\");\n        }\n        result.indexes = spec.indexes.map((index) => {\n            const i = {\n                collectionGroup: index.collectionGroup || index.collectionId,\n                queryScope: index.queryScope || API.QueryScope.COLLECTION,\n                fields: [],\n            };\n            if (index.fields) {\n                i.fields = index.fields.map((field) => {\n                    const f = {\n                        fieldPath: field.fieldPath,\n                    };\n                    if (field.order) {\n                        f.order = field.order;\n                    }\n                    else if (field.arrayConfig) {\n                        f.arrayConfig = field.arrayConfig;\n                    }\n                    else if (field.mode === API.Mode.ARRAY_CONTAINS) {\n                        f.arrayConfig = API.ArrayConfig.CONTAINS;\n                    }\n                    else {\n                        f.order = field.mode;\n                    }\n                    return f;\n                });\n            }\n            return i;\n        });\n        return result;\n    }\n    prettyIndexString(index, includeState = true) {\n        let result = \"\";\n        if (index.state && includeState) {\n            const stateMsg = `[${index.state}] `;\n            if (index.state === API.State.READY) {\n                result += clc.green(stateMsg);\n            }\n            else if (index.state === API.State.CREATING) {\n                result += clc.yellow(stateMsg);\n            }\n            else {\n                result += clc.red(stateMsg);\n            }\n        }\n        const nameInfo = util.parseIndexName(index.name);\n        result += clc.cyan(`(${nameInfo.collectionGroupId})`);\n        result += \" -- \";\n        index.fields.forEach((field) => {\n            if (field.fieldPath === \"__name__\") {\n                return;\n            }\n            const orderOrArrayConfig = field.order ? field.order : field.arrayConfig;\n            result += `(${field.fieldPath},${orderOrArrayConfig}) `;\n        });\n        return result;\n    }\n    prettyFieldString(field) {\n        let result = \"\";\n        const parsedName = util.parseFieldName(field.name);\n        result +=\n            \"[\" +\n                clc.cyan(parsedName.collectionGroupId) +\n                \".\" +\n                clc.yellow(parsedName.fieldPath) +\n                \"] --\";\n        const fieldIndexes = field.indexConfig.indexes || [];\n        if (fieldIndexes.length > 0) {\n            fieldIndexes.forEach((index) => {\n                const firstField = index.fields[0];\n                const mode = firstField.order || firstField.arrayConfig;\n                result += ` (${mode})`;\n            });\n        }\n        else {\n            result += \" (no indexes)\";\n        }\n        return result;\n    }\n}\nexports.FirestoreIndexes = FirestoreIndexes;\n"]},"metadata":{},"sourceType":"script"}