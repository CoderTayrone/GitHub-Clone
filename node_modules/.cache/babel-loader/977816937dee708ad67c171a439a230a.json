{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst once_1 = __importDefault(require(\"@tootallnate/once\"));\n\nconst ftp_1 = __importDefault(require(\"ftp\"));\n\nconst path_1 = require(\"path\");\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst notfound_1 = __importDefault(require(\"./notfound\"));\n\nconst notmodified_1 = __importDefault(require(\"./notmodified\"));\n\nconst debug = debug_1.default('get-uri:ftp');\n/**\n * Returns a Readable stream from an \"ftp:\" URI.\n */\n\nfunction get(parsed, opts) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const {\n      cache\n    } = opts;\n    const filepath = parsed.pathname;\n    let lastModified = null;\n\n    if (!filepath) {\n      throw new TypeError('No \"pathname\"!');\n    }\n\n    const client = new ftp_1.default();\n    client.once('greeting', greeting => {\n      debug('FTP greeting: %o', greeting);\n    });\n\n    function onend() {\n      // close the FTP client socket connection\n      client.end();\n    }\n\n    try {\n      opts.host = parsed.hostname || parsed.host || 'localhost';\n      opts.port = parseInt(parsed.port || '0', 10) || 21;\n      opts.debug = debug;\n\n      if (parsed.auth) {\n        const [user, password] = parsed.auth.split(':');\n        opts.user = user;\n        opts.password = password;\n      } // await cb(_ => client.connect(opts, _));\n\n\n      const readyPromise = once_1.default(client, 'ready');\n      client.connect(opts);\n      yield readyPromise; // first we have to figure out the Last Modified date.\n      // try the MDTM command first, which is an optional extension command.\n\n      try {\n        lastModified = yield new Promise((resolve, reject) => {\n          client.lastMod(filepath, (err, res) => {\n            return err ? reject(err) : resolve(res);\n          });\n        });\n      } catch (err) {\n        // handle the \"file not found\" error code\n        if (err.code === 550) {\n          throw new notfound_1.default();\n        }\n      }\n\n      if (!lastModified) {\n        // Try to get the last modified date via the LIST command (uses\n        // more bandwidth, but is more compatible with older FTP servers\n        const list = yield new Promise((resolve, reject) => {\n          client.list(path_1.dirname(filepath), (err, res) => {\n            return err ? reject(err) : resolve(res);\n          });\n        }); // attempt to find the \"entry\" with a matching \"name\"\n\n        const name = path_1.basename(filepath);\n        const entry = list.find(e => e.name === name);\n\n        if (entry) {\n          lastModified = entry.date;\n        }\n      }\n\n      if (lastModified) {\n        if (isNotModified()) {\n          throw new notmodified_1.default();\n        }\n      } else {\n        throw new notfound_1.default();\n      } // XXX: a small timeout seemed necessary otherwise FTP servers\n      // were returning empty sockets for the file occasionally\n      // setTimeout(client.get.bind(client, filepath, onfile), 10);\n\n\n      const rs = yield new Promise((resolve, reject) => {\n        client.get(filepath, (err, res) => {\n          return err ? reject(err) : resolve(res);\n        });\n      });\n      rs.once('end', onend);\n      rs.lastModified = lastModified;\n      return rs;\n    } catch (err) {\n      client.destroy();\n      throw err;\n    } // called when `lastModified` is set, and a \"cache\" stream was provided\n\n\n    function isNotModified() {\n      if (cache && cache.lastModified && lastModified) {\n        return +cache.lastModified === +lastModified;\n      }\n\n      return false;\n    }\n  });\n}\n\nexports.default = get;","map":{"version":3,"sources":["../src/ftp.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst once_1 = __importDefault(require(\"@tootallnate/once\"));\nconst ftp_1 = __importDefault(require(\"ftp\"));\nconst path_1 = require(\"path\");\nconst debug_1 = __importDefault(require(\"debug\"));\nconst notfound_1 = __importDefault(require(\"./notfound\"));\nconst notmodified_1 = __importDefault(require(\"./notmodified\"));\nconst debug = debug_1.default('get-uri:ftp');\n/**\n * Returns a Readable stream from an \"ftp:\" URI.\n */\nfunction get(parsed, opts) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const { cache } = opts;\n        const filepath = parsed.pathname;\n        let lastModified = null;\n        if (!filepath) {\n            throw new TypeError('No \"pathname\"!');\n        }\n        const client = new ftp_1.default();\n        client.once('greeting', (greeting) => {\n            debug('FTP greeting: %o', greeting);\n        });\n        function onend() {\n            // close the FTP client socket connection\n            client.end();\n        }\n        try {\n            opts.host = parsed.hostname || parsed.host || 'localhost';\n            opts.port = parseInt(parsed.port || '0', 10) || 21;\n            opts.debug = debug;\n            if (parsed.auth) {\n                const [user, password] = parsed.auth.split(':');\n                opts.user = user;\n                opts.password = password;\n            }\n            // await cb(_ => client.connect(opts, _));\n            const readyPromise = once_1.default(client, 'ready');\n            client.connect(opts);\n            yield readyPromise;\n            // first we have to figure out the Last Modified date.\n            // try the MDTM command first, which is an optional extension command.\n            try {\n                lastModified = yield new Promise((resolve, reject) => {\n                    client.lastMod(filepath, (err, res) => {\n                        return err ? reject(err) : resolve(res);\n                    });\n                });\n            }\n            catch (err) {\n                // handle the \"file not found\" error code\n                if (err.code === 550) {\n                    throw new notfound_1.default();\n                }\n            }\n            if (!lastModified) {\n                // Try to get the last modified date via the LIST command (uses\n                // more bandwidth, but is more compatible with older FTP servers\n                const list = yield new Promise((resolve, reject) => {\n                    client.list(path_1.dirname(filepath), (err, res) => {\n                        return err ? reject(err) : resolve(res);\n                    });\n                });\n                // attempt to find the \"entry\" with a matching \"name\"\n                const name = path_1.basename(filepath);\n                const entry = list.find(e => e.name === name);\n                if (entry) {\n                    lastModified = entry.date;\n                }\n            }\n            if (lastModified) {\n                if (isNotModified()) {\n                    throw new notmodified_1.default();\n                }\n            }\n            else {\n                throw new notfound_1.default();\n            }\n            // XXX: a small timeout seemed necessary otherwise FTP servers\n            // were returning empty sockets for the file occasionally\n            // setTimeout(client.get.bind(client, filepath, onfile), 10);\n            const rs = (yield new Promise((resolve, reject) => {\n                client.get(filepath, (err, res) => {\n                    return err ? reject(err) : resolve(res);\n                });\n            }));\n            rs.once('end', onend);\n            rs.lastModified = lastModified;\n            return rs;\n        }\n        catch (err) {\n            client.destroy();\n            throw err;\n        }\n        // called when `lastModified` is set, and a \"cache\" stream was provided\n        function isNotModified() {\n            if (cache && cache.lastModified && lastModified) {\n                return +cache.lastModified === +lastModified;\n            }\n            return false;\n        }\n    });\n}\nexports.default = get;\n//# sourceMappingURL=ftp.js.map"]},"metadata":{},"sourceType":"script"}