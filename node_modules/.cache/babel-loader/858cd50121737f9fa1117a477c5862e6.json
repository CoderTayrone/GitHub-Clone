{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.addResourcesToBackend = exports.discoverBackend = exports.useStrategy = void 0;\n\nconst path = require(\"path\");\n\nconst _ = require(\"lodash\");\n\nconst child_process_1 = require(\"child_process\");\n\nconst error_1 = require(\"../../../../error\");\n\nconst logger_1 = require(\"../../../../logger\");\n\nconst backend = require(\"../../backend\");\n\nconst api = require(\"../../../../api\");\n\nconst proto = require(\"../../../../gcp/proto\");\n\nconst TRIGGER_PARSER = path.resolve(__dirname, \"./triggerParser.js\");\n\nfunction removeInspectOptions(options) {\n  return options.filter(opt => !opt.startsWith(\"--inspect\"));\n}\n\nfunction parseTriggers(projectId, sourceDir, configValues, envs) {\n  return new Promise((resolve, reject) => {\n    const env = Object.assign({}, envs);\n    env.GCLOUD_PROJECT = projectId;\n\n    if (!_.isEmpty(configValues)) {\n      env.CLOUD_RUNTIME_CONFIG = JSON.stringify(configValues);\n    }\n\n    const execArgv = removeInspectOptions(process.execArgv);\n\n    if (env.NODE_OPTIONS) {\n      env.NODE_OPTIONS = removeInspectOptions(env.NODE_OPTIONS.split(\" \")).join(\" \");\n    }\n\n    const parser = child_process_1.fork(TRIGGER_PARSER, [sourceDir], {\n      silent: true,\n      env: env,\n      execArgv: execArgv\n    });\n    parser.on(\"message\", message => {\n      if (message.triggers) {\n        resolve(message.triggers);\n      } else if (message.error) {\n        reject(new error_1.FirebaseError(message.error, {\n          exit: 1\n        }));\n      }\n    });\n    parser.on(\"exit\", code => {\n      if (code !== 0) {\n        reject(new error_1.FirebaseError(\"There was an unknown problem while trying to parse function triggers.\", {\n          exit: 2\n        }));\n      }\n    });\n  });\n}\n\nfunction useStrategy(context) {\n  return Promise.resolve(true);\n}\n\nexports.useStrategy = useStrategy;\n\nasync function discoverBackend(projectId, sourceDir, runtime, configValues, envs) {\n  const triggerAnnotations = await parseTriggers(projectId, sourceDir, configValues, envs);\n  const want = Object.assign(Object.assign({}, backend.empty()), {\n    environmentVariables: envs\n  });\n\n  for (const annotation of triggerAnnotations) {\n    addResourcesToBackend(projectId, runtime, annotation, want);\n  }\n\n  return want;\n}\n\nexports.discoverBackend = discoverBackend;\n\nfunction addResourcesToBackend(projectId, runtime, annotation, want) {\n  Object.freeze(annotation);\n\n  for (const region of annotation.regions || [api.functionsDefaultRegion]) {\n    let trigger;\n\n    if (!!annotation.httpsTrigger == !!annotation.eventTrigger) {\n      throw new error_1.FirebaseError(\"Unexpected annotation generated by the Firebase Functions SDK. This should never happen.\");\n    }\n\n    if (annotation.httpsTrigger) {\n      let allowInsecure;\n\n      if (\"allowInsecure\" in annotation.httpsTrigger) {\n        allowInsecure = !!annotation.httpsTrigger.allowInsecure;\n      } else {\n        allowInsecure = !annotation.platform || annotation.platform === \"gcfv1\";\n      }\n\n      trigger = {\n        allowInsecure\n      };\n\n      if (annotation.failurePolicy) {\n        logger_1.logger.warn(`Ignoring retry policy for HTTPS function ${annotation.name}`);\n      }\n\n      proto.copyIfPresent(trigger, annotation.httpsTrigger, \"invoker\", \"invoker\");\n    } else {\n      trigger = {\n        eventType: annotation.eventTrigger.eventType,\n        eventFilters: {\n          resource: annotation.eventTrigger.resource\n        },\n        retry: !!annotation.failurePolicy\n      };\n    }\n\n    const cloudFunctionName = {\n      id: annotation.name,\n      region: region,\n      project: projectId\n    };\n    const cloudFunction = Object.assign(Object.assign({\n      platform: annotation.platform || \"gcfv1\"\n    }, cloudFunctionName), {\n      entryPoint: annotation.entryPoint,\n      runtime: runtime,\n      trigger: trigger\n    });\n\n    if (annotation.vpcConnector) {\n      let maybeId = annotation.vpcConnector;\n\n      if (!maybeId.includes(\"/\")) {\n        maybeId = `projects/${projectId}/locations/${region}/connectors/${maybeId}`;\n      }\n\n      cloudFunction.vpcConnector = maybeId;\n    }\n\n    proto.copyIfPresent(cloudFunction, annotation, \"concurrency\", \"serviceAccountEmail\", \"labels\", \"vpcConnectorEgressSettings\", \"ingressSettings\", \"timeout\", \"maxInstances\", \"minInstances\", \"availableMemoryMb\");\n\n    if (annotation.schedule) {\n      want.requiredAPIs[\"pubsub\"] = \"pubsub.googleapis.com\";\n      want.requiredAPIs[\"scheduler\"] = \"cloudscheduler.googleapis.com\";\n      const id = backend.scheduleIdForFunction(cloudFunctionName);\n      const schedule = {\n        id,\n        project: projectId,\n        schedule: annotation.schedule.schedule,\n        transport: \"pubsub\",\n        targetService: cloudFunctionName\n      };\n      proto.copyIfPresent(schedule, annotation.schedule, \"timeZone\", \"retryConfig\");\n      want.schedules.push(schedule);\n      const topic = {\n        id,\n        project: projectId,\n        labels: backend.SCHEDULED_FUNCTION_LABEL,\n        targetService: cloudFunctionName\n      };\n      want.topics.push(topic);\n\n      if (backend.isEventTrigger(cloudFunction.trigger)) {\n        cloudFunction.trigger.eventFilters.resource = `${cloudFunction.trigger.eventFilters.resource}/${id}`;\n      }\n\n      cloudFunction.labels = Object.assign(Object.assign({}, cloudFunction.labels), {\n        \"deployment-scheduled\": \"true\"\n      });\n    }\n\n    want.cloudFunctions.push(cloudFunction);\n  }\n}\n\nexports.addResourcesToBackend = addResourcesToBackend;","map":{"version":3,"sources":["/home/dev/Documentos/Projects/github-clone/node_modules/firebase-tools/lib/deploy/functions/runtimes/node/parseTriggers.js"],"names":["Object","defineProperty","exports","value","addResourcesToBackend","discoverBackend","useStrategy","path","require","_","child_process_1","error_1","logger_1","backend","api","proto","TRIGGER_PARSER","resolve","__dirname","removeInspectOptions","options","filter","opt","startsWith","parseTriggers","projectId","sourceDir","configValues","envs","Promise","reject","env","assign","GCLOUD_PROJECT","isEmpty","CLOUD_RUNTIME_CONFIG","JSON","stringify","execArgv","process","NODE_OPTIONS","split","join","parser","fork","silent","on","message","triggers","error","FirebaseError","exit","code","context","runtime","triggerAnnotations","want","empty","environmentVariables","annotation","freeze","region","regions","functionsDefaultRegion","trigger","httpsTrigger","eventTrigger","allowInsecure","platform","failurePolicy","logger","warn","name","copyIfPresent","eventType","eventFilters","resource","retry","cloudFunctionName","id","project","cloudFunction","entryPoint","vpcConnector","maybeId","includes","schedule","requiredAPIs","scheduleIdForFunction","transport","targetService","schedules","push","topic","labels","SCHEDULED_FUNCTION_LABEL","topics","isEventTrigger","cloudFunctions"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.addResourcesToBackend = exports.discoverBackend = exports.useStrategy = void 0;\nconst path = require(\"path\");\nconst _ = require(\"lodash\");\nconst child_process_1 = require(\"child_process\");\nconst error_1 = require(\"../../../../error\");\nconst logger_1 = require(\"../../../../logger\");\nconst backend = require(\"../../backend\");\nconst api = require(\"../../../../api\");\nconst proto = require(\"../../../../gcp/proto\");\nconst TRIGGER_PARSER = path.resolve(__dirname, \"./triggerParser.js\");\nfunction removeInspectOptions(options) {\n    return options.filter((opt) => !opt.startsWith(\"--inspect\"));\n}\nfunction parseTriggers(projectId, sourceDir, configValues, envs) {\n    return new Promise((resolve, reject) => {\n        const env = Object.assign({}, envs);\n        env.GCLOUD_PROJECT = projectId;\n        if (!_.isEmpty(configValues)) {\n            env.CLOUD_RUNTIME_CONFIG = JSON.stringify(configValues);\n        }\n        const execArgv = removeInspectOptions(process.execArgv);\n        if (env.NODE_OPTIONS) {\n            env.NODE_OPTIONS = removeInspectOptions(env.NODE_OPTIONS.split(\" \")).join(\" \");\n        }\n        const parser = child_process_1.fork(TRIGGER_PARSER, [sourceDir], {\n            silent: true,\n            env: env,\n            execArgv: execArgv,\n        });\n        parser.on(\"message\", (message) => {\n            if (message.triggers) {\n                resolve(message.triggers);\n            }\n            else if (message.error) {\n                reject(new error_1.FirebaseError(message.error, { exit: 1 }));\n            }\n        });\n        parser.on(\"exit\", (code) => {\n            if (code !== 0) {\n                reject(new error_1.FirebaseError(\"There was an unknown problem while trying to parse function triggers.\", { exit: 2 }));\n            }\n        });\n    });\n}\nfunction useStrategy(context) {\n    return Promise.resolve(true);\n}\nexports.useStrategy = useStrategy;\nasync function discoverBackend(projectId, sourceDir, runtime, configValues, envs) {\n    const triggerAnnotations = await parseTriggers(projectId, sourceDir, configValues, envs);\n    const want = Object.assign(Object.assign({}, backend.empty()), { environmentVariables: envs });\n    for (const annotation of triggerAnnotations) {\n        addResourcesToBackend(projectId, runtime, annotation, want);\n    }\n    return want;\n}\nexports.discoverBackend = discoverBackend;\nfunction addResourcesToBackend(projectId, runtime, annotation, want) {\n    Object.freeze(annotation);\n    for (const region of annotation.regions || [api.functionsDefaultRegion]) {\n        let trigger;\n        if (!!annotation.httpsTrigger == !!annotation.eventTrigger) {\n            throw new error_1.FirebaseError(\"Unexpected annotation generated by the Firebase Functions SDK. This should never happen.\");\n        }\n        if (annotation.httpsTrigger) {\n            let allowInsecure;\n            if (\"allowInsecure\" in annotation.httpsTrigger) {\n                allowInsecure = !!annotation.httpsTrigger.allowInsecure;\n            }\n            else {\n                allowInsecure = !annotation.platform || annotation.platform === \"gcfv1\";\n            }\n            trigger = { allowInsecure };\n            if (annotation.failurePolicy) {\n                logger_1.logger.warn(`Ignoring retry policy for HTTPS function ${annotation.name}`);\n            }\n            proto.copyIfPresent(trigger, annotation.httpsTrigger, \"invoker\", \"invoker\");\n        }\n        else {\n            trigger = {\n                eventType: annotation.eventTrigger.eventType,\n                eventFilters: {\n                    resource: annotation.eventTrigger.resource,\n                },\n                retry: !!annotation.failurePolicy,\n            };\n        }\n        const cloudFunctionName = {\n            id: annotation.name,\n            region: region,\n            project: projectId,\n        };\n        const cloudFunction = Object.assign(Object.assign({ platform: annotation.platform || \"gcfv1\" }, cloudFunctionName), { entryPoint: annotation.entryPoint, runtime: runtime, trigger: trigger });\n        if (annotation.vpcConnector) {\n            let maybeId = annotation.vpcConnector;\n            if (!maybeId.includes(\"/\")) {\n                maybeId = `projects/${projectId}/locations/${region}/connectors/${maybeId}`;\n            }\n            cloudFunction.vpcConnector = maybeId;\n        }\n        proto.copyIfPresent(cloudFunction, annotation, \"concurrency\", \"serviceAccountEmail\", \"labels\", \"vpcConnectorEgressSettings\", \"ingressSettings\", \"timeout\", \"maxInstances\", \"minInstances\", \"availableMemoryMb\");\n        if (annotation.schedule) {\n            want.requiredAPIs[\"pubsub\"] = \"pubsub.googleapis.com\";\n            want.requiredAPIs[\"scheduler\"] = \"cloudscheduler.googleapis.com\";\n            const id = backend.scheduleIdForFunction(cloudFunctionName);\n            const schedule = {\n                id,\n                project: projectId,\n                schedule: annotation.schedule.schedule,\n                transport: \"pubsub\",\n                targetService: cloudFunctionName,\n            };\n            proto.copyIfPresent(schedule, annotation.schedule, \"timeZone\", \"retryConfig\");\n            want.schedules.push(schedule);\n            const topic = {\n                id,\n                project: projectId,\n                labels: backend.SCHEDULED_FUNCTION_LABEL,\n                targetService: cloudFunctionName,\n            };\n            want.topics.push(topic);\n            if (backend.isEventTrigger(cloudFunction.trigger)) {\n                cloudFunction.trigger.eventFilters.resource = `${cloudFunction.trigger.eventFilters.resource}/${id}`;\n            }\n            cloudFunction.labels = Object.assign(Object.assign({}, cloudFunction.labels), { \"deployment-scheduled\": \"true\" });\n        }\n        want.cloudFunctions.push(cloudFunction);\n    }\n}\nexports.addResourcesToBackend = addResourcesToBackend;\n"]},"metadata":{},"sourceType":"script"}