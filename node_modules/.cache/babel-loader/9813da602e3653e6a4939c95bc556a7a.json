{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.confirmUpdate = exports.inferUpdateSource = exports.updateFromPublisherSource = exports.updateToVersionFromPublisherSource = exports.updateFromUrlSource = exports.updateFromLocalSource = exports.update = exports.retryUpdate = exports.displayChanges = exports.warningUpdateToOtherSource = exports.getExistingSourceOrigin = void 0;\n\nconst clc = require(\"cli-color\");\n\nconst semver = require(\"semver\");\n\nconst error_1 = require(\"../error\");\n\nconst logger_1 = require(\"../logger\");\n\nconst resolveSource = require(\"./resolveSource\");\n\nconst extensionsApi = require(\"./extensionsApi\");\n\nconst prompt_1 = require(\"../prompt\");\n\nconst marked = require(\"marked\");\n\nconst extensionsHelper_1 = require(\"./extensionsHelper\");\n\nconst utils = require(\"../utils\");\n\nconst displayExtensionInfo_1 = require(\"./displayExtensionInfo\");\n\nconst changelog = require(\"./changelog\");\n\nfunction invalidSourceErrMsgTemplate(instanceId, source) {\n  return `Unable to update from the source \\`${clc.bold(source)}\\`. To update this instance, you can either:\\n\n  - Run \\`${clc.bold(\"firebase ext:update \" + instanceId)}\\` to update from the published source.\\n\n  - Check your directory path or URL, then run \\`${clc.bold(\"firebase ext:update \" + instanceId + \" <otherSource>\")}\\` to update from a local directory or URL source.`;\n}\n\nasync function getExistingSourceOrigin(projectId, instanceId, extensionName, existingSource) {\n  const instance = await extensionsApi.getInstance(projectId, instanceId);\n  return instance && instance.config.extensionRef ? extensionsHelper_1.SourceOrigin.PUBLISHED_EXTENSION : extensionsHelper_1.SourceOrigin.LOCAL;\n}\n\nexports.getExistingSourceOrigin = getExistingSourceOrigin;\n\nasync function showUpdateVersionInfo(instanceId, from, to, source) {\n  if (source) {\n    source = clc.bold(source);\n  } else {\n    source = \"version\";\n  }\n\n  utils.logLabeledBullet(extensionsHelper_1.logPrefix, `Updating ${clc.bold(instanceId)} from version ${clc.bold(from)} to ${source} (${clc.bold(to)})`);\n\n  if (semver.lt(to, from)) {\n    utils.logLabeledBullet(extensionsHelper_1.logPrefix, \"The version you are updating to is less than the current version for this extension. This extension may not be backwards compatible.\");\n    return await displayExtensionInfo_1.getConsent(\"version\", \"Do you wish to continue?\");\n  }\n\n  return;\n}\n\nfunction warningUpdateToOtherSource(sourceOrigin) {\n  let targetText;\n\n  if ([extensionsHelper_1.SourceOrigin.PUBLISHED_EXTENSION, extensionsHelper_1.SourceOrigin.PUBLISHED_EXTENSION_VERSION].includes(sourceOrigin)) {\n    targetText = \"published extension\";\n  } else if (sourceOrigin === extensionsHelper_1.SourceOrigin.LOCAL) {\n    targetText = \"local directory\";\n  } else if (sourceOrigin === extensionsHelper_1.SourceOrigin.URL) {\n    targetText = \"URL\";\n  }\n\n  const warning = `All the instance's resources and logic will be overwritten to use the source code and files from the ${targetText}.\\n`;\n  logger_1.logger.info(marked(warning));\n}\n\nexports.warningUpdateToOtherSource = warningUpdateToOtherSource;\n\nasync function displayChanges(spec, newSpec) {\n  logger_1.logger.info(\"This update contains the following changes (in green and red). \" + \"If at any point you choose not to continue, the extension will not be updated and the changes will be discarded:\\n\");\n  displayExtensionInfo_1.displayUpdateChangesNoInput(spec, newSpec);\n  await displayExtensionInfo_1.displayUpdateChangesRequiringConfirmation(spec, newSpec);\n}\n\nexports.displayChanges = displayChanges;\n\nasync function retryUpdate() {\n  return prompt_1.promptOnce({\n    type: \"confirm\",\n    message: \"Are you sure you wish to continue with updating anyways?\",\n    default: false\n  });\n}\n\nexports.retryUpdate = retryUpdate;\n\nasync function update(updateOptions) {\n  const {\n    projectId,\n    instanceId,\n    source,\n    extRef,\n    params\n  } = updateOptions;\n\n  if (extRef) {\n    return await extensionsApi.updateInstanceFromRegistry(projectId, instanceId, extRef, params);\n  } else if (source) {\n    return await extensionsApi.updateInstance(projectId, instanceId, source, params);\n  }\n\n  throw new error_1.FirebaseError(`Neither a source nor a version of the extension was supplied for ${instanceId}. Please make sure this is a valid extension and try again.`);\n}\n\nexports.update = update;\n\nasync function updateFromLocalSource(projectId, instanceId, localSource, existingSpec, existingSource) {\n  displayExtensionInfo_1.displayExtInfo(instanceId, \"\", existingSpec, false);\n  let source;\n\n  try {\n    source = await extensionsHelper_1.createSourceFromLocation(projectId, localSource);\n  } catch (err) {\n    throw new error_1.FirebaseError(invalidSourceErrMsgTemplate(instanceId, localSource));\n  }\n\n  utils.logLabeledBullet(extensionsHelper_1.logPrefix, `${clc.bold(\"You are updating this extension instance to a local source.\")}`);\n  await showUpdateVersionInfo(instanceId, existingSpec.version, source.spec.version, localSource);\n  warningUpdateToOtherSource(extensionsHelper_1.SourceOrigin.LOCAL);\n  await confirmUpdate();\n  return source.name;\n}\n\nexports.updateFromLocalSource = updateFromLocalSource;\n\nasync function updateFromUrlSource(projectId, instanceId, urlSource, existingSpec, existingSource) {\n  displayExtensionInfo_1.displayExtInfo(instanceId, \"\", existingSpec, false);\n  let source;\n\n  try {\n    source = await extensionsHelper_1.createSourceFromLocation(projectId, urlSource);\n  } catch (err) {\n    throw new error_1.FirebaseError(invalidSourceErrMsgTemplate(instanceId, urlSource));\n  }\n\n  utils.logLabeledBullet(extensionsHelper_1.logPrefix, `${clc.bold(\"You are updating this extension instance to a URL source.\")}`);\n  await showUpdateVersionInfo(instanceId, existingSpec.version, source.spec.version, urlSource);\n  warningUpdateToOtherSource(extensionsHelper_1.SourceOrigin.URL);\n  await confirmUpdate();\n  return source.name;\n}\n\nexports.updateFromUrlSource = updateFromUrlSource;\n\nasync function updateToVersionFromPublisherSource(projectId, instanceId, extVersionRef, existingSpec, existingSource) {\n  let source;\n  const refObj = extensionsApi.parseRef(extVersionRef);\n  const version = refObj.version;\n  const extensionRef = `${refObj.publisherId}/${refObj.extensionId}`;\n  displayExtensionInfo_1.displayExtInfo(instanceId, refObj.publisherId, existingSpec, true);\n  const extension = await extensionsApi.getExtension(extensionRef);\n\n  try {\n    source = await extensionsApi.getExtensionVersion(extVersionRef);\n  } catch (err) {\n    throw new error_1.FirebaseError(`Could not find source '${clc.bold(extVersionRef)}' because (${clc.bold(version)}) is not a published version. To update, use the latest version of this extension (${clc.bold(extension.latestVersion)}).`);\n  }\n\n  let registryEntry;\n\n  try {\n    registryEntry = await resolveSource.resolveRegistryEntry(existingSpec.name);\n  } catch (err) {\n    logger_1.logger.debug(`Unable to fetch registry.json entry for ${existingSpec.name}`);\n  }\n\n  if (registryEntry) {\n    const minVer = resolveSource.getMinRequiredVersion(registryEntry);\n\n    if (minVer && semver.gt(minVer, source.spec.version)) {\n      throw new error_1.FirebaseError(`The version you are trying to update to (${clc.bold(source.spec.version)}) is less than the minimum version required (${clc.bold(minVer)}) to use this extension.`);\n    }\n  }\n\n  await showUpdateVersionInfo(instanceId, existingSpec.version, source.spec.version, extVersionRef);\n  warningUpdateToOtherSource(extensionsHelper_1.SourceOrigin.PUBLISHED_EXTENSION);\n  const releaseNotes = await changelog.getReleaseNotesForUpdate({\n    extensionRef,\n    fromVersion: existingSpec.version,\n    toVersion: source.spec.version\n  });\n\n  if (Object.keys(releaseNotes).length) {\n    changelog.displayReleaseNotes(releaseNotes, existingSpec.version);\n  }\n\n  await confirmUpdate();\n  return source.name;\n}\n\nexports.updateToVersionFromPublisherSource = updateToVersionFromPublisherSource;\n\nasync function updateFromPublisherSource(projectId, instanceId, extRef, existingSpec, existingSource) {\n  return updateToVersionFromPublisherSource(projectId, instanceId, `${extRef}@latest`, existingSpec, existingSource);\n}\n\nexports.updateFromPublisherSource = updateFromPublisherSource;\n\nfunction inferUpdateSource(updateSource, existingRef) {\n  if (!updateSource) {\n    return `${existingRef}@latest`;\n  }\n\n  if (semver.valid(updateSource)) {\n    return `${existingRef}@${updateSource}`;\n  }\n\n  if (!extensionsHelper_1.isLocalOrURLPath(updateSource) && updateSource.split(\"/\").length < 2) {\n    return updateSource.includes(\"@\") ? `firebase/${updateSource}` : `firebase/${updateSource}@latest`;\n  }\n\n  if (!extensionsHelper_1.isLocalOrURLPath(updateSource) && !updateSource.includes(\"@\")) {\n    return `${updateSource}@latest`;\n  }\n\n  return updateSource;\n}\n\nexports.inferUpdateSource = inferUpdateSource;\n\nasync function confirmUpdate() {\n  const continueUpdate = await prompt_1.promptOnce({\n    type: \"confirm\",\n    message: \"Do you wish to continue with this update?\",\n    default: false\n  });\n\n  if (!continueUpdate) {\n    throw new error_1.FirebaseError(`Update cancelled.`);\n  }\n}\n\nexports.confirmUpdate = confirmUpdate;","map":{"version":3,"sources":["/home/dev/Documentos/Projects/github-clone/node_modules/firebase-tools/lib/extensions/updateHelper.js"],"names":["Object","defineProperty","exports","value","confirmUpdate","inferUpdateSource","updateFromPublisherSource","updateToVersionFromPublisherSource","updateFromUrlSource","updateFromLocalSource","update","retryUpdate","displayChanges","warningUpdateToOtherSource","getExistingSourceOrigin","clc","require","semver","error_1","logger_1","resolveSource","extensionsApi","prompt_1","marked","extensionsHelper_1","utils","displayExtensionInfo_1","changelog","invalidSourceErrMsgTemplate","instanceId","source","bold","projectId","extensionName","existingSource","instance","getInstance","config","extensionRef","SourceOrigin","PUBLISHED_EXTENSION","LOCAL","showUpdateVersionInfo","from","to","logLabeledBullet","logPrefix","lt","getConsent","sourceOrigin","targetText","PUBLISHED_EXTENSION_VERSION","includes","URL","warning","logger","info","spec","newSpec","displayUpdateChangesNoInput","displayUpdateChangesRequiringConfirmation","promptOnce","type","message","default","updateOptions","extRef","params","updateInstanceFromRegistry","updateInstance","FirebaseError","localSource","existingSpec","displayExtInfo","createSourceFromLocation","err","version","name","urlSource","extVersionRef","refObj","parseRef","publisherId","extensionId","extension","getExtension","getExtensionVersion","latestVersion","registryEntry","resolveRegistryEntry","debug","minVer","getMinRequiredVersion","gt","releaseNotes","getReleaseNotesForUpdate","fromVersion","toVersion","keys","length","displayReleaseNotes","updateSource","existingRef","valid","isLocalOrURLPath","split","continueUpdate"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.confirmUpdate = exports.inferUpdateSource = exports.updateFromPublisherSource = exports.updateToVersionFromPublisherSource = exports.updateFromUrlSource = exports.updateFromLocalSource = exports.update = exports.retryUpdate = exports.displayChanges = exports.warningUpdateToOtherSource = exports.getExistingSourceOrigin = void 0;\nconst clc = require(\"cli-color\");\nconst semver = require(\"semver\");\nconst error_1 = require(\"../error\");\nconst logger_1 = require(\"../logger\");\nconst resolveSource = require(\"./resolveSource\");\nconst extensionsApi = require(\"./extensionsApi\");\nconst prompt_1 = require(\"../prompt\");\nconst marked = require(\"marked\");\nconst extensionsHelper_1 = require(\"./extensionsHelper\");\nconst utils = require(\"../utils\");\nconst displayExtensionInfo_1 = require(\"./displayExtensionInfo\");\nconst changelog = require(\"./changelog\");\nfunction invalidSourceErrMsgTemplate(instanceId, source) {\n    return `Unable to update from the source \\`${clc.bold(source)}\\`. To update this instance, you can either:\\n\n  - Run \\`${clc.bold(\"firebase ext:update \" + instanceId)}\\` to update from the published source.\\n\n  - Check your directory path or URL, then run \\`${clc.bold(\"firebase ext:update \" + instanceId + \" <otherSource>\")}\\` to update from a local directory or URL source.`;\n}\nasync function getExistingSourceOrigin(projectId, instanceId, extensionName, existingSource) {\n    const instance = await extensionsApi.getInstance(projectId, instanceId);\n    return instance && instance.config.extensionRef\n        ? extensionsHelper_1.SourceOrigin.PUBLISHED_EXTENSION\n        : extensionsHelper_1.SourceOrigin.LOCAL;\n}\nexports.getExistingSourceOrigin = getExistingSourceOrigin;\nasync function showUpdateVersionInfo(instanceId, from, to, source) {\n    if (source) {\n        source = clc.bold(source);\n    }\n    else {\n        source = \"version\";\n    }\n    utils.logLabeledBullet(extensionsHelper_1.logPrefix, `Updating ${clc.bold(instanceId)} from version ${clc.bold(from)} to ${source} (${clc.bold(to)})`);\n    if (semver.lt(to, from)) {\n        utils.logLabeledBullet(extensionsHelper_1.logPrefix, \"The version you are updating to is less than the current version for this extension. This extension may not be backwards compatible.\");\n        return await displayExtensionInfo_1.getConsent(\"version\", \"Do you wish to continue?\");\n    }\n    return;\n}\nfunction warningUpdateToOtherSource(sourceOrigin) {\n    let targetText;\n    if ([extensionsHelper_1.SourceOrigin.PUBLISHED_EXTENSION, extensionsHelper_1.SourceOrigin.PUBLISHED_EXTENSION_VERSION].includes(sourceOrigin)) {\n        targetText = \"published extension\";\n    }\n    else if (sourceOrigin === extensionsHelper_1.SourceOrigin.LOCAL) {\n        targetText = \"local directory\";\n    }\n    else if (sourceOrigin === extensionsHelper_1.SourceOrigin.URL) {\n        targetText = \"URL\";\n    }\n    const warning = `All the instance's resources and logic will be overwritten to use the source code and files from the ${targetText}.\\n`;\n    logger_1.logger.info(marked(warning));\n}\nexports.warningUpdateToOtherSource = warningUpdateToOtherSource;\nasync function displayChanges(spec, newSpec) {\n    logger_1.logger.info(\"This update contains the following changes (in green and red). \" +\n        \"If at any point you choose not to continue, the extension will not be updated and the changes will be discarded:\\n\");\n    displayExtensionInfo_1.displayUpdateChangesNoInput(spec, newSpec);\n    await displayExtensionInfo_1.displayUpdateChangesRequiringConfirmation(spec, newSpec);\n}\nexports.displayChanges = displayChanges;\nasync function retryUpdate() {\n    return prompt_1.promptOnce({\n        type: \"confirm\",\n        message: \"Are you sure you wish to continue with updating anyways?\",\n        default: false,\n    });\n}\nexports.retryUpdate = retryUpdate;\nasync function update(updateOptions) {\n    const { projectId, instanceId, source, extRef, params } = updateOptions;\n    if (extRef) {\n        return await extensionsApi.updateInstanceFromRegistry(projectId, instanceId, extRef, params);\n    }\n    else if (source) {\n        return await extensionsApi.updateInstance(projectId, instanceId, source, params);\n    }\n    throw new error_1.FirebaseError(`Neither a source nor a version of the extension was supplied for ${instanceId}. Please make sure this is a valid extension and try again.`);\n}\nexports.update = update;\nasync function updateFromLocalSource(projectId, instanceId, localSource, existingSpec, existingSource) {\n    displayExtensionInfo_1.displayExtInfo(instanceId, \"\", existingSpec, false);\n    let source;\n    try {\n        source = await extensionsHelper_1.createSourceFromLocation(projectId, localSource);\n    }\n    catch (err) {\n        throw new error_1.FirebaseError(invalidSourceErrMsgTemplate(instanceId, localSource));\n    }\n    utils.logLabeledBullet(extensionsHelper_1.logPrefix, `${clc.bold(\"You are updating this extension instance to a local source.\")}`);\n    await showUpdateVersionInfo(instanceId, existingSpec.version, source.spec.version, localSource);\n    warningUpdateToOtherSource(extensionsHelper_1.SourceOrigin.LOCAL);\n    await confirmUpdate();\n    return source.name;\n}\nexports.updateFromLocalSource = updateFromLocalSource;\nasync function updateFromUrlSource(projectId, instanceId, urlSource, existingSpec, existingSource) {\n    displayExtensionInfo_1.displayExtInfo(instanceId, \"\", existingSpec, false);\n    let source;\n    try {\n        source = await extensionsHelper_1.createSourceFromLocation(projectId, urlSource);\n    }\n    catch (err) {\n        throw new error_1.FirebaseError(invalidSourceErrMsgTemplate(instanceId, urlSource));\n    }\n    utils.logLabeledBullet(extensionsHelper_1.logPrefix, `${clc.bold(\"You are updating this extension instance to a URL source.\")}`);\n    await showUpdateVersionInfo(instanceId, existingSpec.version, source.spec.version, urlSource);\n    warningUpdateToOtherSource(extensionsHelper_1.SourceOrigin.URL);\n    await confirmUpdate();\n    return source.name;\n}\nexports.updateFromUrlSource = updateFromUrlSource;\nasync function updateToVersionFromPublisherSource(projectId, instanceId, extVersionRef, existingSpec, existingSource) {\n    let source;\n    const refObj = extensionsApi.parseRef(extVersionRef);\n    const version = refObj.version;\n    const extensionRef = `${refObj.publisherId}/${refObj.extensionId}`;\n    displayExtensionInfo_1.displayExtInfo(instanceId, refObj.publisherId, existingSpec, true);\n    const extension = await extensionsApi.getExtension(extensionRef);\n    try {\n        source = await extensionsApi.getExtensionVersion(extVersionRef);\n    }\n    catch (err) {\n        throw new error_1.FirebaseError(`Could not find source '${clc.bold(extVersionRef)}' because (${clc.bold(version)}) is not a published version. To update, use the latest version of this extension (${clc.bold(extension.latestVersion)}).`);\n    }\n    let registryEntry;\n    try {\n        registryEntry = await resolveSource.resolveRegistryEntry(existingSpec.name);\n    }\n    catch (err) {\n        logger_1.logger.debug(`Unable to fetch registry.json entry for ${existingSpec.name}`);\n    }\n    if (registryEntry) {\n        const minVer = resolveSource.getMinRequiredVersion(registryEntry);\n        if (minVer && semver.gt(minVer, source.spec.version)) {\n            throw new error_1.FirebaseError(`The version you are trying to update to (${clc.bold(source.spec.version)}) is less than the minimum version required (${clc.bold(minVer)}) to use this extension.`);\n        }\n    }\n    await showUpdateVersionInfo(instanceId, existingSpec.version, source.spec.version, extVersionRef);\n    warningUpdateToOtherSource(extensionsHelper_1.SourceOrigin.PUBLISHED_EXTENSION);\n    const releaseNotes = await changelog.getReleaseNotesForUpdate({\n        extensionRef,\n        fromVersion: existingSpec.version,\n        toVersion: source.spec.version,\n    });\n    if (Object.keys(releaseNotes).length) {\n        changelog.displayReleaseNotes(releaseNotes, existingSpec.version);\n    }\n    await confirmUpdate();\n    return source.name;\n}\nexports.updateToVersionFromPublisherSource = updateToVersionFromPublisherSource;\nasync function updateFromPublisherSource(projectId, instanceId, extRef, existingSpec, existingSource) {\n    return updateToVersionFromPublisherSource(projectId, instanceId, `${extRef}@latest`, existingSpec, existingSource);\n}\nexports.updateFromPublisherSource = updateFromPublisherSource;\nfunction inferUpdateSource(updateSource, existingRef) {\n    if (!updateSource) {\n        return `${existingRef}@latest`;\n    }\n    if (semver.valid(updateSource)) {\n        return `${existingRef}@${updateSource}`;\n    }\n    if (!extensionsHelper_1.isLocalOrURLPath(updateSource) && updateSource.split(\"/\").length < 2) {\n        return updateSource.includes(\"@\")\n            ? `firebase/${updateSource}`\n            : `firebase/${updateSource}@latest`;\n    }\n    if (!extensionsHelper_1.isLocalOrURLPath(updateSource) && !updateSource.includes(\"@\")) {\n        return `${updateSource}@latest`;\n    }\n    return updateSource;\n}\nexports.inferUpdateSource = inferUpdateSource;\nasync function confirmUpdate() {\n    const continueUpdate = await prompt_1.promptOnce({\n        type: \"confirm\",\n        message: \"Do you wish to continue with this update?\",\n        default: false,\n    });\n    if (!continueUpdate) {\n        throw new error_1.FirebaseError(`Update cancelled.`);\n    }\n}\nexports.confirmUpdate = confirmUpdate;\n"]},"metadata":{},"sourceType":"script"}