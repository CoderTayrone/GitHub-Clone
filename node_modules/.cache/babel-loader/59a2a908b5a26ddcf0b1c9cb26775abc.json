{"ast":null,"code":"\"use strict\";\n\nvar __asyncValues = this && this.__asyncValues || function (o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator],\n      i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () {\n    return this;\n  }, i);\n\n  function verb(n) {\n    i[n] = o[n] && function (v) {\n      return new Promise(function (resolve, reject) {\n        v = o[n](v), settle(resolve, reject, v.done, v.value);\n      });\n    };\n  }\n\n  function settle(resolve, reject, d, v) {\n    Promise.resolve(v).then(function (v) {\n      resolve({\n        value: v,\n        done: d\n      });\n    }, reject);\n  }\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Persistence = exports.StorageLayer = exports.UploadStatus = exports.ResumableUpload = exports.StoredFile = void 0;\n\nconst fs_1 = require(\"fs\");\n\nconst os_1 = require(\"os\");\n\nconst uuid_1 = require(\"uuid\");\n\nconst list_1 = require(\"./list\");\n\nconst metadata_1 = require(\"./metadata\");\n\nconst path = require(\"path\");\n\nconst fs = require(\"fs\");\n\nconst fse = require(\"fs-extra\");\n\nconst rimraf = require(\"rimraf\");\n\nconst cloudFunctions_1 = require(\"./cloudFunctions\");\n\nconst logger_1 = require(\"../../logger\");\n\nclass StoredFile {\n  constructor(metadata, path) {\n    this.metadata = metadata;\n    this._path = path;\n  }\n\n  get metadata() {\n    return this._metadata;\n  }\n\n  set metadata(value) {\n    this._metadata = value;\n  }\n\n  get path() {\n    return this._path;\n  }\n\n  set path(value) {\n    this._path = value;\n  }\n\n}\n\nexports.StoredFile = StoredFile;\n\nclass ResumableUpload {\n  constructor(bucketId, objectId, uploadId, contentType, metadata) {\n    this._currentBytesUploaded = 0;\n    this._status = UploadStatus.ACTIVE;\n    this._bucketId = bucketId;\n    this._objectId = objectId;\n    this._uploadId = uploadId;\n    this._contentType = contentType;\n    this._metadata = metadata;\n    this._fileLocation = encodeURIComponent(`${uploadId}_b_${bucketId}_o_${objectId}`);\n    this._currentBytesUploaded = 0;\n  }\n\n  get uploadId() {\n    return this._uploadId;\n  }\n\n  get metadata() {\n    return this._metadata;\n  }\n\n  get bucketId() {\n    return this._bucketId;\n  }\n\n  get objectId() {\n    return this._objectId;\n  }\n\n  get contentType() {\n    return this._contentType;\n  }\n\n  set contentType(contentType) {\n    this._contentType = contentType;\n  }\n\n  get currentBytesUploaded() {\n    return this._currentBytesUploaded;\n  }\n\n  set currentBytesUploaded(value) {\n    this._currentBytesUploaded = value;\n  }\n\n  set status(status) {\n    this._status = status;\n  }\n\n  get status() {\n    return this._status;\n  }\n\n  get fileLocation() {\n    return this._fileLocation;\n  }\n\n}\n\nexports.ResumableUpload = ResumableUpload;\nvar UploadStatus;\n\n(function (UploadStatus) {\n  UploadStatus[UploadStatus[\"ACTIVE\"] = 0] = \"ACTIVE\";\n  UploadStatus[UploadStatus[\"CANCELLED\"] = 1] = \"CANCELLED\";\n  UploadStatus[UploadStatus[\"FINISHED\"] = 2] = \"FINISHED\";\n})(UploadStatus = exports.UploadStatus || (exports.UploadStatus = {}));\n\nclass StorageLayer {\n  constructor(_projectId) {\n    this._projectId = _projectId;\n    this.reset();\n    this._cloudFunctions = new cloudFunctions_1.StorageCloudFunctions(this._projectId);\n  }\n\n  reset() {\n    this._files = new Map();\n    this._persistence = new Persistence(`${os_1.tmpdir()}/firebase/storage/blobs`);\n    this._uploads = new Map();\n    this._buckets = new Map();\n  }\n\n  createBucket(id) {\n    if (!this._buckets.has(id)) {\n      this._buckets.set(id, new metadata_1.CloudStorageBucketMetadata(id));\n    }\n  }\n\n  listBuckets() {\n    if (this._buckets.size == 0) {\n      this.createBucket(\"default-bucket\");\n    }\n\n    return [...this._buckets.values()];\n  }\n\n  getMetadata(bucket, object) {\n    const key = this.path(bucket, object);\n\n    const val = this._files.get(key);\n\n    if (val) {\n      return val.metadata;\n    }\n\n    return;\n  }\n\n  getBytes(bucket, object, size, offset) {\n    const key = this.path(bucket, object);\n\n    const val = this._files.get(key);\n\n    if (val) {\n      const len = size ? size : Number(val.metadata.size);\n      return this._persistence.readBytes(this.path(bucket, object), len, offset);\n    }\n\n    return undefined;\n  }\n\n  public(value) {\n    this._files = value;\n  }\n\n  startUpload(bucket, object, contentType, metadata) {\n    const uploadId = uuid_1.v4();\n    const upload = new ResumableUpload(bucket, object, uploadId, contentType, metadata);\n\n    this._uploads.set(uploadId, upload);\n\n    return upload;\n  }\n\n  queryUpload(uploadId) {\n    return this._uploads.get(uploadId);\n  }\n\n  cancelUpload(uploadId) {\n    const upload = this._uploads.get(uploadId);\n\n    if (!upload) {\n      return undefined;\n    }\n\n    upload.status = UploadStatus.CANCELLED;\n\n    this._persistence.deleteFile(upload.fileLocation);\n  }\n\n  uploadBytes(uploadId, bytes) {\n    const upload = this._uploads.get(uploadId);\n\n    if (!upload) {\n      return undefined;\n    }\n\n    this._persistence.appendBytes(upload.fileLocation, bytes, upload.currentBytesUploaded);\n\n    upload.currentBytesUploaded += bytes.byteLength;\n    return upload;\n  }\n\n  deleteFile(bucketId, objectId) {\n    const isFolder = objectId.toLowerCase().endsWith(\"%2f\");\n\n    if (isFolder) {\n      objectId = objectId.slice(0, -3);\n    }\n\n    let filePath = this.path(bucketId, objectId);\n\n    if (isFolder) {\n      filePath += \"%2F\";\n    }\n\n    const file = this._files.get(filePath);\n\n    if (file == undefined) {\n      return false;\n    } else {\n      this._files.delete(filePath);\n\n      this._persistence.deleteFile(filePath);\n\n      this._cloudFunctions.dispatch(\"delete\", new metadata_1.CloudStorageObjectMetadata(file.metadata));\n\n      return true;\n    }\n  }\n\n  async deleteAll() {\n    return this._persistence.deleteAll();\n  }\n\n  finalizeUpload(uploadId) {\n    const upload = this._uploads.get(uploadId);\n\n    if (!upload) {\n      return undefined;\n    }\n\n    upload.status = UploadStatus.FINISHED;\n    const filePath = this.path(upload.bucketId, upload.objectId);\n\n    const bytes = this._persistence.readBytes(upload.fileLocation, upload.currentBytesUploaded);\n\n    const finalMetadata = new metadata_1.StoredFileMetadata({\n      name: upload.objectId,\n      bucket: upload.bucketId,\n      contentType: \"\",\n      contentEncoding: upload.metadata.contentEncoding,\n      customMetadata: upload.metadata.metadata\n    }, this._cloudFunctions, bytes, upload.metadata);\n    const file = new StoredFile(finalMetadata, filePath);\n\n    this._files.set(filePath, file);\n\n    this._persistence.deleteFile(filePath, true);\n\n    this._persistence.renameFile(upload.fileLocation, filePath);\n\n    this._cloudFunctions.dispatch(\"finalize\", new metadata_1.CloudStorageObjectMetadata(file.metadata));\n\n    return {\n      upload: upload,\n      file: file\n    };\n  }\n\n  oneShotUpload(bucket, object, contentType, incomingMetadata, bytes) {\n    const filePath = this.path(bucket, object);\n\n    this._persistence.deleteFile(filePath, true);\n\n    this._persistence.appendBytes(filePath, bytes);\n\n    const md = new metadata_1.StoredFileMetadata({\n      name: object,\n      bucket: bucket,\n      contentType: incomingMetadata.contentType || \"application/octet-stream\",\n      contentEncoding: incomingMetadata.contentEncoding,\n      customMetadata: incomingMetadata.metadata\n    }, this._cloudFunctions, bytes, incomingMetadata);\n    const file = new StoredFile(md, this._persistence.getDiskPath(filePath));\n\n    this._files.set(filePath, file);\n\n    this._cloudFunctions.dispatch(\"finalize\", new metadata_1.CloudStorageObjectMetadata(file.metadata));\n\n    return file.metadata;\n  }\n\n  listItemsAndPrefixes(bucket, prefix, delimiter, pageToken, maxResults) {\n    if (!delimiter) {\n      delimiter = \"/\";\n    }\n\n    if (!prefix) {\n      prefix = \"\";\n    }\n\n    if (!prefix.endsWith(delimiter)) {\n      prefix += delimiter;\n    }\n\n    if (!prefix.startsWith(delimiter)) {\n      prefix = delimiter + prefix;\n    }\n\n    let items = [];\n    const prefixes = new Set();\n\n    for (const [, file] of this._files) {\n      if (file.metadata.bucket != bucket) {\n        continue;\n      }\n\n      let name = `${delimiter}${file.metadata.name}`;\n\n      if (!name.startsWith(prefix)) {\n        continue;\n      }\n\n      name = name.substring(prefix.length);\n\n      if (name.startsWith(delimiter)) {\n        name = name.substring(prefix.length);\n      }\n\n      const startAtIndex = name.indexOf(delimiter);\n\n      if (startAtIndex == -1) {\n        if (!file.metadata.name.endsWith(\"/\")) {\n          items.push(file.metadata.name);\n        }\n      } else {\n        const prefixPath = prefix + name.substring(0, startAtIndex + 1);\n        prefixes.add(prefixPath);\n      }\n    }\n\n    items.sort();\n\n    if (pageToken) {\n      const idx = items.findIndex(v => v == pageToken);\n\n      if (idx != -1) {\n        items = items.slice(idx);\n      }\n    }\n\n    if (!maxResults) {\n      maxResults = 1000;\n    }\n\n    let nextPageToken = undefined;\n\n    if (items.length > maxResults) {\n      nextPageToken = items[maxResults];\n      items = items.slice(0, maxResults);\n    }\n\n    return new list_1.ListResponse([...prefixes].sort(), items.map(i => new list_1.ListItem(i, bucket)), nextPageToken);\n  }\n\n  listItems(bucket, prefix, delimiter, pageToken, maxResults) {\n    if (!delimiter) {\n      delimiter = \"/\";\n    }\n\n    if (!prefix) {\n      prefix = \"\";\n    }\n\n    if (!prefix.endsWith(delimiter)) {\n      prefix += delimiter;\n    }\n\n    let items = [];\n\n    for (const [, file] of this._files) {\n      if (file.metadata.bucket != bucket) {\n        continue;\n      }\n\n      let name = file.metadata.name;\n\n      if (!name.startsWith(prefix)) {\n        continue;\n      }\n\n      name = name.substring(prefix.length);\n\n      if (name.startsWith(delimiter)) {\n        name = name.substring(prefix.length);\n      }\n\n      items.push(this.path(file.metadata.bucket, file.metadata.name));\n    }\n\n    items.sort();\n\n    if (pageToken) {\n      const idx = items.findIndex(v => v == pageToken);\n\n      if (idx != -1) {\n        items = items.slice(idx);\n      }\n    }\n\n    if (!maxResults) {\n      maxResults = 1000;\n    }\n\n    return {\n      kind: \"#storage/objects\",\n      items: items.map(item => {\n        const storedFile = this._files.get(item);\n\n        if (!storedFile) {\n          return console.warn(`No file ${item}`);\n        }\n\n        return new metadata_1.CloudStorageObjectMetadata(storedFile.metadata);\n      })\n    };\n  }\n\n  addDownloadToken(bucket, object) {\n    const key = this.path(bucket, object);\n\n    const val = this._files.get(key);\n\n    if (!val) {\n      return undefined;\n    }\n\n    const md = val.metadata;\n    md.addDownloadToken();\n    return md;\n  }\n\n  deleteDownloadToken(bucket, object, token) {\n    const key = this.path(bucket, object);\n\n    const val = this._files.get(key);\n\n    if (!val) {\n      return undefined;\n    }\n\n    const md = val.metadata;\n    md.deleteDownloadToken(token);\n    return md;\n  }\n\n  path(bucket, object) {\n    const directory = path.dirname(object);\n    const filename = path.basename(object) + (object.endsWith(\"/\") ? \"/\" : \"\");\n    return path.join(bucket, directory, encodeURIComponent(filename));\n  }\n\n  get dirPath() {\n    return this._persistence.dirPath;\n  }\n\n  async export(storageExportPath) {\n    var e_1, _a;\n\n    const bucketsList = {\n      buckets: []\n    };\n\n    for (const b of this.listBuckets()) {\n      bucketsList.buckets.push({\n        id: b.id\n      });\n    }\n\n    const bucketsFilePath = path.join(storageExportPath, \"buckets.json\");\n    await fse.writeFile(bucketsFilePath, JSON.stringify(bucketsList, undefined, 2));\n    const blobsDirPath = path.join(storageExportPath, \"blobs\");\n    await fse.ensureDir(blobsDirPath);\n    await fse.copy(this.dirPath, blobsDirPath, {\n      recursive: true\n    });\n    const metadataDirPath = path.join(storageExportPath, \"metadata\");\n    await fse.ensureDir(metadataDirPath);\n\n    try {\n      for (var _b = __asyncValues(this._files.entries()), _c; _c = await _b.next(), !_c.done;) {\n        const [p, file] = _c.value;\n        const metadataExportPath = path.join(metadataDirPath, p) + \".json\";\n        const metadataExportDirPath = path.dirname(metadataExportPath);\n        await fse.ensureDir(metadataExportDirPath);\n        await fse.writeFile(metadataExportPath, metadata_1.StoredFileMetadata.toJSON(file.metadata));\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) await _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  }\n\n  import(storageExportPath) {\n    const bucketsFile = path.join(storageExportPath, \"buckets.json\");\n    const bucketsList = JSON.parse(fs.readFileSync(bucketsFile, \"utf-8\"));\n\n    for (const b of bucketsList.buckets) {\n      const bucketMetadata = new metadata_1.CloudStorageBucketMetadata(b.id);\n\n      this._buckets.set(b.id, bucketMetadata);\n    }\n\n    const metadataDir = path.join(storageExportPath, \"metadata\");\n    const blobsDir = path.join(storageExportPath, \"blobs\");\n    const metadataList = this.walkDirSync(metadataDir);\n    const dotJson = \".json\";\n\n    for (const f of metadataList) {\n      if (path.extname(f) !== dotJson) {\n        logger_1.logger.debug(`Skipping unexpected storage metadata file: ${f}`);\n        continue;\n      }\n\n      const metadata = metadata_1.StoredFileMetadata.fromJSON(fs.readFileSync(f, \"utf-8\"), this._cloudFunctions);\n      const metadataRelPath = path.relative(metadataDir, f);\n      const blobPath = metadataRelPath.substring(0, metadataRelPath.length - dotJson.length);\n      const blobAbsPath = path.join(blobsDir, blobPath);\n\n      if (!fs.existsSync(blobAbsPath)) {\n        logger_1.logger.warn(`Could not find file \"${blobPath}\" in storage export.`);\n        continue;\n      }\n\n      const file = new StoredFile(metadata, blobPath);\n\n      this._files.set(blobPath, file);\n    }\n\n    fse.copySync(blobsDir, this.dirPath);\n  }\n\n  *walkDirSync(dir) {\n    const files = fs.readdirSync(dir);\n\n    for (const file of files) {\n      const p = path.join(dir, file);\n\n      if (fs.statSync(p).isDirectory()) {\n        yield* this.walkDirSync(p);\n      } else {\n        yield p;\n      }\n    }\n  }\n\n}\n\nexports.StorageLayer = StorageLayer;\n\nclass Persistence {\n  constructor(dirPath) {\n    this._dirPath = dirPath;\n\n    if (!fs_1.existsSync(dirPath)) {\n      fs_1.mkdirSync(dirPath, {\n        recursive: true\n      });\n    }\n  }\n\n  get dirPath() {\n    return this._dirPath;\n  }\n\n  appendBytes(fileName, bytes, fileOffset) {\n    const filepath = this.getDiskPath(fileName);\n    const encodedSlashIndex = filepath.toLowerCase().lastIndexOf(\"%2f\");\n    const dirPath = encodedSlashIndex >= 0 ? filepath.substring(0, encodedSlashIndex) : path.dirname(filepath);\n\n    if (!fs_1.existsSync(dirPath)) {\n      fs_1.mkdirSync(dirPath, {\n        recursive: true\n      });\n    }\n\n    let fd;\n\n    try {\n      fs.appendFileSync(filepath, bytes);\n      return filepath;\n    } finally {\n      if (fd) {\n        fs_1.closeSync(fd);\n      }\n    }\n  }\n\n  readBytes(fileName, size, fileOffset) {\n    const path = this.getDiskPath(fileName);\n    let fd;\n\n    try {\n      fd = fs_1.openSync(path, \"r\");\n      const buf = Buffer.alloc(size);\n      const offset = fileOffset && fileOffset > 0 ? fileOffset : 0;\n      fs_1.readSync(fd, buf, 0, size, offset);\n      return buf;\n    } finally {\n      if (fd) {\n        fs_1.closeSync(fd);\n      }\n    }\n  }\n\n  deleteFile(fileName, failSilently = false) {\n    try {\n      fs_1.unlinkSync(this.getDiskPath(fileName));\n    } catch (err) {\n      if (!failSilently) {\n        throw err;\n      }\n    }\n  }\n\n  deleteAll() {\n    return new Promise((resolve, reject) => {\n      rimraf(this._dirPath, err => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve();\n        }\n      });\n    });\n  }\n\n  renameFile(oldName, newName) {\n    const dirPath = this.getDiskPath(path.dirname(newName));\n\n    if (!fs_1.existsSync(dirPath)) {\n      fs_1.mkdirSync(dirPath, {\n        recursive: true\n      });\n    }\n\n    fs_1.renameSync(this.getDiskPath(oldName), this.getDiskPath(newName));\n  }\n\n  getDiskPath(fileName) {\n    return path.join(this._dirPath, fileName);\n  }\n\n}\n\nexports.Persistence = Persistence;","map":{"version":3,"sources":["/home/dev/Documentos/Projects/github-clone/node_modules/firebase-tools/lib/emulator/storage/files.js"],"names":["__asyncValues","o","Symbol","asyncIterator","TypeError","m","i","call","__values","iterator","verb","n","v","Promise","resolve","reject","settle","done","value","d","then","Object","defineProperty","exports","Persistence","StorageLayer","UploadStatus","ResumableUpload","StoredFile","fs_1","require","os_1","uuid_1","list_1","metadata_1","path","fs","fse","rimraf","cloudFunctions_1","logger_1","constructor","metadata","_path","_metadata","bucketId","objectId","uploadId","contentType","_currentBytesUploaded","_status","ACTIVE","_bucketId","_objectId","_uploadId","_contentType","_fileLocation","encodeURIComponent","currentBytesUploaded","status","fileLocation","_projectId","reset","_cloudFunctions","StorageCloudFunctions","_files","Map","_persistence","tmpdir","_uploads","_buckets","createBucket","id","has","set","CloudStorageBucketMetadata","listBuckets","size","values","getMetadata","bucket","object","key","val","get","getBytes","offset","len","Number","readBytes","undefined","public","startUpload","v4","upload","queryUpload","cancelUpload","CANCELLED","deleteFile","uploadBytes","bytes","appendBytes","byteLength","isFolder","toLowerCase","endsWith","slice","filePath","file","delete","dispatch","CloudStorageObjectMetadata","deleteAll","finalizeUpload","FINISHED","finalMetadata","StoredFileMetadata","name","contentEncoding","customMetadata","renameFile","oneShotUpload","incomingMetadata","md","getDiskPath","listItemsAndPrefixes","prefix","delimiter","pageToken","maxResults","startsWith","items","prefixes","Set","substring","length","startAtIndex","indexOf","push","prefixPath","add","sort","idx","findIndex","nextPageToken","ListResponse","map","ListItem","listItems","kind","item","storedFile","console","warn","addDownloadToken","deleteDownloadToken","token","directory","dirname","filename","basename","join","dirPath","export","storageExportPath","e_1","_a","bucketsList","buckets","b","bucketsFilePath","writeFile","JSON","stringify","blobsDirPath","ensureDir","copy","recursive","metadataDirPath","_b","entries","_c","next","p","metadataExportPath","metadataExportDirPath","toJSON","e_1_1","error","return","import","bucketsFile","parse","readFileSync","bucketMetadata","metadataDir","blobsDir","metadataList","walkDirSync","dotJson","f","extname","logger","debug","fromJSON","metadataRelPath","relative","blobPath","blobAbsPath","existsSync","copySync","dir","files","readdirSync","statSync","isDirectory","_dirPath","mkdirSync","fileName","fileOffset","filepath","encodedSlashIndex","lastIndexOf","fd","appendFileSync","closeSync","openSync","buf","Buffer","alloc","readSync","failSilently","unlinkSync","err","oldName","newName","renameSync"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __asyncValues = (this && this.__asyncValues) || function (o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Persistence = exports.StorageLayer = exports.UploadStatus = exports.ResumableUpload = exports.StoredFile = void 0;\nconst fs_1 = require(\"fs\");\nconst os_1 = require(\"os\");\nconst uuid_1 = require(\"uuid\");\nconst list_1 = require(\"./list\");\nconst metadata_1 = require(\"./metadata\");\nconst path = require(\"path\");\nconst fs = require(\"fs\");\nconst fse = require(\"fs-extra\");\nconst rimraf = require(\"rimraf\");\nconst cloudFunctions_1 = require(\"./cloudFunctions\");\nconst logger_1 = require(\"../../logger\");\nclass StoredFile {\n    constructor(metadata, path) {\n        this.metadata = metadata;\n        this._path = path;\n    }\n    get metadata() {\n        return this._metadata;\n    }\n    set metadata(value) {\n        this._metadata = value;\n    }\n    get path() {\n        return this._path;\n    }\n    set path(value) {\n        this._path = value;\n    }\n}\nexports.StoredFile = StoredFile;\nclass ResumableUpload {\n    constructor(bucketId, objectId, uploadId, contentType, metadata) {\n        this._currentBytesUploaded = 0;\n        this._status = UploadStatus.ACTIVE;\n        this._bucketId = bucketId;\n        this._objectId = objectId;\n        this._uploadId = uploadId;\n        this._contentType = contentType;\n        this._metadata = metadata;\n        this._fileLocation = encodeURIComponent(`${uploadId}_b_${bucketId}_o_${objectId}`);\n        this._currentBytesUploaded = 0;\n    }\n    get uploadId() {\n        return this._uploadId;\n    }\n    get metadata() {\n        return this._metadata;\n    }\n    get bucketId() {\n        return this._bucketId;\n    }\n    get objectId() {\n        return this._objectId;\n    }\n    get contentType() {\n        return this._contentType;\n    }\n    set contentType(contentType) {\n        this._contentType = contentType;\n    }\n    get currentBytesUploaded() {\n        return this._currentBytesUploaded;\n    }\n    set currentBytesUploaded(value) {\n        this._currentBytesUploaded = value;\n    }\n    set status(status) {\n        this._status = status;\n    }\n    get status() {\n        return this._status;\n    }\n    get fileLocation() {\n        return this._fileLocation;\n    }\n}\nexports.ResumableUpload = ResumableUpload;\nvar UploadStatus;\n(function (UploadStatus) {\n    UploadStatus[UploadStatus[\"ACTIVE\"] = 0] = \"ACTIVE\";\n    UploadStatus[UploadStatus[\"CANCELLED\"] = 1] = \"CANCELLED\";\n    UploadStatus[UploadStatus[\"FINISHED\"] = 2] = \"FINISHED\";\n})(UploadStatus = exports.UploadStatus || (exports.UploadStatus = {}));\nclass StorageLayer {\n    constructor(_projectId) {\n        this._projectId = _projectId;\n        this.reset();\n        this._cloudFunctions = new cloudFunctions_1.StorageCloudFunctions(this._projectId);\n    }\n    reset() {\n        this._files = new Map();\n        this._persistence = new Persistence(`${os_1.tmpdir()}/firebase/storage/blobs`);\n        this._uploads = new Map();\n        this._buckets = new Map();\n    }\n    createBucket(id) {\n        if (!this._buckets.has(id)) {\n            this._buckets.set(id, new metadata_1.CloudStorageBucketMetadata(id));\n        }\n    }\n    listBuckets() {\n        if (this._buckets.size == 0) {\n            this.createBucket(\"default-bucket\");\n        }\n        return [...this._buckets.values()];\n    }\n    getMetadata(bucket, object) {\n        const key = this.path(bucket, object);\n        const val = this._files.get(key);\n        if (val) {\n            return val.metadata;\n        }\n        return;\n    }\n    getBytes(bucket, object, size, offset) {\n        const key = this.path(bucket, object);\n        const val = this._files.get(key);\n        if (val) {\n            const len = size ? size : Number(val.metadata.size);\n            return this._persistence.readBytes(this.path(bucket, object), len, offset);\n        }\n        return undefined;\n    }\n    public(value) {\n        this._files = value;\n    }\n    startUpload(bucket, object, contentType, metadata) {\n        const uploadId = uuid_1.v4();\n        const upload = new ResumableUpload(bucket, object, uploadId, contentType, metadata);\n        this._uploads.set(uploadId, upload);\n        return upload;\n    }\n    queryUpload(uploadId) {\n        return this._uploads.get(uploadId);\n    }\n    cancelUpload(uploadId) {\n        const upload = this._uploads.get(uploadId);\n        if (!upload) {\n            return undefined;\n        }\n        upload.status = UploadStatus.CANCELLED;\n        this._persistence.deleteFile(upload.fileLocation);\n    }\n    uploadBytes(uploadId, bytes) {\n        const upload = this._uploads.get(uploadId);\n        if (!upload) {\n            return undefined;\n        }\n        this._persistence.appendBytes(upload.fileLocation, bytes, upload.currentBytesUploaded);\n        upload.currentBytesUploaded += bytes.byteLength;\n        return upload;\n    }\n    deleteFile(bucketId, objectId) {\n        const isFolder = objectId.toLowerCase().endsWith(\"%2f\");\n        if (isFolder) {\n            objectId = objectId.slice(0, -3);\n        }\n        let filePath = this.path(bucketId, objectId);\n        if (isFolder) {\n            filePath += \"%2F\";\n        }\n        const file = this._files.get(filePath);\n        if (file == undefined) {\n            return false;\n        }\n        else {\n            this._files.delete(filePath);\n            this._persistence.deleteFile(filePath);\n            this._cloudFunctions.dispatch(\"delete\", new metadata_1.CloudStorageObjectMetadata(file.metadata));\n            return true;\n        }\n    }\n    async deleteAll() {\n        return this._persistence.deleteAll();\n    }\n    finalizeUpload(uploadId) {\n        const upload = this._uploads.get(uploadId);\n        if (!upload) {\n            return undefined;\n        }\n        upload.status = UploadStatus.FINISHED;\n        const filePath = this.path(upload.bucketId, upload.objectId);\n        const bytes = this._persistence.readBytes(upload.fileLocation, upload.currentBytesUploaded);\n        const finalMetadata = new metadata_1.StoredFileMetadata({\n            name: upload.objectId,\n            bucket: upload.bucketId,\n            contentType: \"\",\n            contentEncoding: upload.metadata.contentEncoding,\n            customMetadata: upload.metadata.metadata,\n        }, this._cloudFunctions, bytes, upload.metadata);\n        const file = new StoredFile(finalMetadata, filePath);\n        this._files.set(filePath, file);\n        this._persistence.deleteFile(filePath, true);\n        this._persistence.renameFile(upload.fileLocation, filePath);\n        this._cloudFunctions.dispatch(\"finalize\", new metadata_1.CloudStorageObjectMetadata(file.metadata));\n        return { upload: upload, file: file };\n    }\n    oneShotUpload(bucket, object, contentType, incomingMetadata, bytes) {\n        const filePath = this.path(bucket, object);\n        this._persistence.deleteFile(filePath, true);\n        this._persistence.appendBytes(filePath, bytes);\n        const md = new metadata_1.StoredFileMetadata({\n            name: object,\n            bucket: bucket,\n            contentType: incomingMetadata.contentType || \"application/octet-stream\",\n            contentEncoding: incomingMetadata.contentEncoding,\n            customMetadata: incomingMetadata.metadata,\n        }, this._cloudFunctions, bytes, incomingMetadata);\n        const file = new StoredFile(md, this._persistence.getDiskPath(filePath));\n        this._files.set(filePath, file);\n        this._cloudFunctions.dispatch(\"finalize\", new metadata_1.CloudStorageObjectMetadata(file.metadata));\n        return file.metadata;\n    }\n    listItemsAndPrefixes(bucket, prefix, delimiter, pageToken, maxResults) {\n        if (!delimiter) {\n            delimiter = \"/\";\n        }\n        if (!prefix) {\n            prefix = \"\";\n        }\n        if (!prefix.endsWith(delimiter)) {\n            prefix += delimiter;\n        }\n        if (!prefix.startsWith(delimiter)) {\n            prefix = delimiter + prefix;\n        }\n        let items = [];\n        const prefixes = new Set();\n        for (const [, file] of this._files) {\n            if (file.metadata.bucket != bucket) {\n                continue;\n            }\n            let name = `${delimiter}${file.metadata.name}`;\n            if (!name.startsWith(prefix)) {\n                continue;\n            }\n            name = name.substring(prefix.length);\n            if (name.startsWith(delimiter)) {\n                name = name.substring(prefix.length);\n            }\n            const startAtIndex = name.indexOf(delimiter);\n            if (startAtIndex == -1) {\n                if (!file.metadata.name.endsWith(\"/\")) {\n                    items.push(file.metadata.name);\n                }\n            }\n            else {\n                const prefixPath = prefix + name.substring(0, startAtIndex + 1);\n                prefixes.add(prefixPath);\n            }\n        }\n        items.sort();\n        if (pageToken) {\n            const idx = items.findIndex((v) => v == pageToken);\n            if (idx != -1) {\n                items = items.slice(idx);\n            }\n        }\n        if (!maxResults) {\n            maxResults = 1000;\n        }\n        let nextPageToken = undefined;\n        if (items.length > maxResults) {\n            nextPageToken = items[maxResults];\n            items = items.slice(0, maxResults);\n        }\n        return new list_1.ListResponse([...prefixes].sort(), items.map((i) => new list_1.ListItem(i, bucket)), nextPageToken);\n    }\n    listItems(bucket, prefix, delimiter, pageToken, maxResults) {\n        if (!delimiter) {\n            delimiter = \"/\";\n        }\n        if (!prefix) {\n            prefix = \"\";\n        }\n        if (!prefix.endsWith(delimiter)) {\n            prefix += delimiter;\n        }\n        let items = [];\n        for (const [, file] of this._files) {\n            if (file.metadata.bucket != bucket) {\n                continue;\n            }\n            let name = file.metadata.name;\n            if (!name.startsWith(prefix)) {\n                continue;\n            }\n            name = name.substring(prefix.length);\n            if (name.startsWith(delimiter)) {\n                name = name.substring(prefix.length);\n            }\n            items.push(this.path(file.metadata.bucket, file.metadata.name));\n        }\n        items.sort();\n        if (pageToken) {\n            const idx = items.findIndex((v) => v == pageToken);\n            if (idx != -1) {\n                items = items.slice(idx);\n            }\n        }\n        if (!maxResults) {\n            maxResults = 1000;\n        }\n        return {\n            kind: \"#storage/objects\",\n            items: items.map((item) => {\n                const storedFile = this._files.get(item);\n                if (!storedFile) {\n                    return console.warn(`No file ${item}`);\n                }\n                return new metadata_1.CloudStorageObjectMetadata(storedFile.metadata);\n            }),\n        };\n    }\n    addDownloadToken(bucket, object) {\n        const key = this.path(bucket, object);\n        const val = this._files.get(key);\n        if (!val) {\n            return undefined;\n        }\n        const md = val.metadata;\n        md.addDownloadToken();\n        return md;\n    }\n    deleteDownloadToken(bucket, object, token) {\n        const key = this.path(bucket, object);\n        const val = this._files.get(key);\n        if (!val) {\n            return undefined;\n        }\n        const md = val.metadata;\n        md.deleteDownloadToken(token);\n        return md;\n    }\n    path(bucket, object) {\n        const directory = path.dirname(object);\n        const filename = path.basename(object) + (object.endsWith(\"/\") ? \"/\" : \"\");\n        return path.join(bucket, directory, encodeURIComponent(filename));\n    }\n    get dirPath() {\n        return this._persistence.dirPath;\n    }\n    async export(storageExportPath) {\n        var e_1, _a;\n        const bucketsList = {\n            buckets: [],\n        };\n        for (const b of this.listBuckets()) {\n            bucketsList.buckets.push({ id: b.id });\n        }\n        const bucketsFilePath = path.join(storageExportPath, \"buckets.json\");\n        await fse.writeFile(bucketsFilePath, JSON.stringify(bucketsList, undefined, 2));\n        const blobsDirPath = path.join(storageExportPath, \"blobs\");\n        await fse.ensureDir(blobsDirPath);\n        await fse.copy(this.dirPath, blobsDirPath, { recursive: true });\n        const metadataDirPath = path.join(storageExportPath, \"metadata\");\n        await fse.ensureDir(metadataDirPath);\n        try {\n            for (var _b = __asyncValues(this._files.entries()), _c; _c = await _b.next(), !_c.done;) {\n                const [p, file] = _c.value;\n                const metadataExportPath = path.join(metadataDirPath, p) + \".json\";\n                const metadataExportDirPath = path.dirname(metadataExportPath);\n                await fse.ensureDir(metadataExportDirPath);\n                await fse.writeFile(metadataExportPath, metadata_1.StoredFileMetadata.toJSON(file.metadata));\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) await _a.call(_b);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n    }\n    import(storageExportPath) {\n        const bucketsFile = path.join(storageExportPath, \"buckets.json\");\n        const bucketsList = JSON.parse(fs.readFileSync(bucketsFile, \"utf-8\"));\n        for (const b of bucketsList.buckets) {\n            const bucketMetadata = new metadata_1.CloudStorageBucketMetadata(b.id);\n            this._buckets.set(b.id, bucketMetadata);\n        }\n        const metadataDir = path.join(storageExportPath, \"metadata\");\n        const blobsDir = path.join(storageExportPath, \"blobs\");\n        const metadataList = this.walkDirSync(metadataDir);\n        const dotJson = \".json\";\n        for (const f of metadataList) {\n            if (path.extname(f) !== dotJson) {\n                logger_1.logger.debug(`Skipping unexpected storage metadata file: ${f}`);\n                continue;\n            }\n            const metadata = metadata_1.StoredFileMetadata.fromJSON(fs.readFileSync(f, \"utf-8\"), this._cloudFunctions);\n            const metadataRelPath = path.relative(metadataDir, f);\n            const blobPath = metadataRelPath.substring(0, metadataRelPath.length - dotJson.length);\n            const blobAbsPath = path.join(blobsDir, blobPath);\n            if (!fs.existsSync(blobAbsPath)) {\n                logger_1.logger.warn(`Could not find file \"${blobPath}\" in storage export.`);\n                continue;\n            }\n            const file = new StoredFile(metadata, blobPath);\n            this._files.set(blobPath, file);\n        }\n        fse.copySync(blobsDir, this.dirPath);\n    }\n    *walkDirSync(dir) {\n        const files = fs.readdirSync(dir);\n        for (const file of files) {\n            const p = path.join(dir, file);\n            if (fs.statSync(p).isDirectory()) {\n                yield* this.walkDirSync(p);\n            }\n            else {\n                yield p;\n            }\n        }\n    }\n}\nexports.StorageLayer = StorageLayer;\nclass Persistence {\n    constructor(dirPath) {\n        this._dirPath = dirPath;\n        if (!fs_1.existsSync(dirPath)) {\n            fs_1.mkdirSync(dirPath, {\n                recursive: true,\n            });\n        }\n    }\n    get dirPath() {\n        return this._dirPath;\n    }\n    appendBytes(fileName, bytes, fileOffset) {\n        const filepath = this.getDiskPath(fileName);\n        const encodedSlashIndex = filepath.toLowerCase().lastIndexOf(\"%2f\");\n        const dirPath = encodedSlashIndex >= 0 ? filepath.substring(0, encodedSlashIndex) : path.dirname(filepath);\n        if (!fs_1.existsSync(dirPath)) {\n            fs_1.mkdirSync(dirPath, {\n                recursive: true,\n            });\n        }\n        let fd;\n        try {\n            fs.appendFileSync(filepath, bytes);\n            return filepath;\n        }\n        finally {\n            if (fd) {\n                fs_1.closeSync(fd);\n            }\n        }\n    }\n    readBytes(fileName, size, fileOffset) {\n        const path = this.getDiskPath(fileName);\n        let fd;\n        try {\n            fd = fs_1.openSync(path, \"r\");\n            const buf = Buffer.alloc(size);\n            const offset = fileOffset && fileOffset > 0 ? fileOffset : 0;\n            fs_1.readSync(fd, buf, 0, size, offset);\n            return buf;\n        }\n        finally {\n            if (fd) {\n                fs_1.closeSync(fd);\n            }\n        }\n    }\n    deleteFile(fileName, failSilently = false) {\n        try {\n            fs_1.unlinkSync(this.getDiskPath(fileName));\n        }\n        catch (err) {\n            if (!failSilently) {\n                throw err;\n            }\n        }\n    }\n    deleteAll() {\n        return new Promise((resolve, reject) => {\n            rimraf(this._dirPath, (err) => {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve();\n                }\n            });\n        });\n    }\n    renameFile(oldName, newName) {\n        const dirPath = this.getDiskPath(path.dirname(newName));\n        if (!fs_1.existsSync(dirPath)) {\n            fs_1.mkdirSync(dirPath, {\n                recursive: true,\n            });\n        }\n        fs_1.renameSync(this.getDiskPath(oldName), this.getDiskPath(newName));\n    }\n    getDiskPath(fileName) {\n        return path.join(this._dirPath, fileName);\n    }\n}\nexports.Persistence = Persistence;\n"]},"metadata":{},"sourceType":"script"}