{"ast":null,"code":"\"use strict\";\n\nconst $Ref = require(\"./ref\");\n\nconst Pointer = require(\"./pointer\");\n\nconst {\n  ono\n} = require(\"@jsdevtools/ono\");\n\nconst url = require(\"./util/url\");\n\nmodule.exports = dereference;\n/**\n * Crawls the JSON schema, finds all JSON references, and dereferences them.\n * This method mutates the JSON schema object, replacing JSON references with their resolved value.\n *\n * @param {$RefParser} parser\n * @param {$RefParserOptions} options\n */\n\nfunction dereference(parser, options) {\n  // console.log('Dereferencing $ref pointers in %s', parser.$refs._root$Ref.path);\n  let dereferenced = crawl(parser.schema, parser.$refs._root$Ref.path, \"#\", new Set(), new Set(), new Map(), parser.$refs, options);\n  parser.$refs.circular = dereferenced.circular;\n  parser.schema = dereferenced.value;\n}\n/**\n * Recursively crawls the given value, and dereferences any JSON references.\n *\n * @param {*} obj - The value to crawl. If it's not an object or array, it will be ignored.\n * @param {string} path - The full path of `obj`, possibly with a JSON Pointer in the hash\n * @param {string} pathFromRoot - The path of `obj` from the schema root\n * @param {Set<object>} parents - An array of the parent objects that have already been dereferenced\n * @param {Set<object>} processedObjects - An array of all the objects that have already been processed\n * @param {Map<string,object>} dereferencedCache - An map of all the dereferenced objects\n * @param {$Refs} $refs\n * @param {$RefParserOptions} options\n * @returns {{value: object, circular: boolean}}\n */\n\n\nfunction crawl(obj, path, pathFromRoot, parents, processedObjects, dereferencedCache, $refs, options) {\n  let dereferenced;\n  let result = {\n    value: obj,\n    circular: false\n  };\n\n  if (options.dereference.circular === \"ignore\" || !processedObjects.has(obj)) {\n    if (obj && typeof obj === \"object\" && !ArrayBuffer.isView(obj)) {\n      parents.add(obj);\n      processedObjects.add(obj);\n\n      if ($Ref.isAllowed$Ref(obj, options)) {\n        dereferenced = dereference$Ref(obj, path, pathFromRoot, parents, processedObjects, dereferencedCache, $refs, options);\n        result.circular = dereferenced.circular;\n        result.value = dereferenced.value;\n      } else {\n        for (const key of Object.keys(obj)) {\n          let keyPath = Pointer.join(path, key);\n          let keyPathFromRoot = Pointer.join(pathFromRoot, key);\n          let value = obj[key];\n          let circular = false;\n\n          if ($Ref.isAllowed$Ref(value, options)) {\n            dereferenced = dereference$Ref(value, keyPath, keyPathFromRoot, parents, processedObjects, dereferencedCache, $refs, options);\n            circular = dereferenced.circular; // Avoid pointless mutations; breaks frozen objects to no profit\n\n            if (obj[key] !== dereferenced.value) {\n              obj[key] = dereferenced.value;\n            }\n          } else {\n            if (!parents.has(value)) {\n              dereferenced = crawl(value, keyPath, keyPathFromRoot, parents, processedObjects, dereferencedCache, $refs, options);\n              circular = dereferenced.circular; // Avoid pointless mutations; breaks frozen objects to no profit\n\n              if (obj[key] !== dereferenced.value) {\n                obj[key] = dereferenced.value;\n              }\n            } else {\n              circular = foundCircularReference(keyPath, $refs, options);\n            }\n          } // Set the \"isCircular\" flag if this or any other property is circular\n\n\n          result.circular = result.circular || circular;\n        }\n      }\n\n      parents.delete(obj);\n    }\n  }\n\n  return result;\n}\n/**\n * Dereferences the given JSON Reference, and then crawls the resulting value.\n *\n * @param {{$ref: string}} $ref - The JSON Reference to resolve\n * @param {string} path - The full path of `$ref`, possibly with a JSON Pointer in the hash\n * @param {string} pathFromRoot - The path of `$ref` from the schema root\n * @param {Set<object>} parents - An array of the parent objects that have already been dereferenced\n * @param {Set<object>} processedObjects - An array of all the objects that have already been dereferenced\n * @param {Map<string,object>} dereferencedCache - An map of all the dereferenced objects\n * @param {$Refs} $refs\n * @param {$RefParserOptions} options\n * @returns {{value: object, circular: boolean}}\n */\n\n\nfunction dereference$Ref($ref, path, pathFromRoot, parents, processedObjects, dereferencedCache, $refs, options) {\n  // console.log('Dereferencing $ref pointer \"%s\" at %s', $ref.$ref, path);\n  let $refPath = url.resolve(path, $ref.$ref);\n  const cache = dereferencedCache.get($refPath);\n\n  if (cache) {\n    const refKeys = Object.keys($ref);\n\n    if (refKeys.length > 1) {\n      const extraKeys = {};\n\n      for (let key of refKeys) {\n        if (key !== \"$ref\" && !(key in cache.value)) {\n          extraKeys[key] = $ref[key];\n        }\n      }\n\n      return {\n        circular: cache.circular,\n        value: Object.assign({}, cache.value, extraKeys)\n      };\n    }\n\n    return cache;\n  }\n\n  let pointer = $refs._resolve($refPath, path, options);\n\n  if (pointer === null) {\n    return {\n      circular: false,\n      value: null\n    };\n  } // Check for circular references\n\n\n  let directCircular = pointer.circular;\n  let circular = directCircular || parents.has(pointer.value);\n  circular && foundCircularReference(path, $refs, options); // Dereference the JSON reference\n\n  let dereferencedValue = $Ref.dereference($ref, pointer.value); // Crawl the dereferenced value (unless it's circular)\n\n  if (!circular) {\n    // Determine if the dereferenced value is circular\n    let dereferenced = crawl(dereferencedValue, pointer.path, pathFromRoot, parents, processedObjects, dereferencedCache, $refs, options);\n    circular = dereferenced.circular;\n    dereferencedValue = dereferenced.value;\n  }\n\n  if (circular && !directCircular && options.dereference.circular === \"ignore\") {\n    // The user has chosen to \"ignore\" circular references, so don't change the value\n    dereferencedValue = $ref;\n  }\n\n  if (directCircular) {\n    // The pointer is a DIRECT circular reference (i.e. it references itself).\n    // So replace the $ref path with the absolute path from the JSON Schema root\n    dereferencedValue.$ref = pathFromRoot;\n  }\n\n  const dereferencedObject = {\n    circular,\n    value: dereferencedValue\n  }; // only cache if no extra properties than $ref\n\n  if (Object.keys($ref).length === 1) {\n    dereferencedCache.set($refPath, dereferencedObject);\n  }\n\n  return dereferencedObject;\n}\n/**\n * Called when a circular reference is found.\n * It sets the {@link $Refs#circular} flag, and throws an error if options.dereference.circular is false.\n *\n * @param {string} keyPath - The JSON Reference path of the circular reference\n * @param {$Refs} $refs\n * @param {$RefParserOptions} options\n * @returns {boolean} - always returns true, to indicate that a circular reference was found\n */\n\n\nfunction foundCircularReference(keyPath, $refs, options) {\n  $refs.circular = true;\n\n  if (!options.dereference.circular) {\n    throw ono.reference(`Circular $ref pointer found at ${keyPath}`);\n  }\n\n  return true;\n}","map":{"version":3,"sources":["/home/dev/Documentos/Projects/github-clone/node_modules/@apidevtools/json-schema-ref-parser/lib/dereference.js"],"names":["$Ref","require","Pointer","ono","url","module","exports","dereference","parser","options","dereferenced","crawl","schema","$refs","_root$Ref","path","Set","Map","circular","value","obj","pathFromRoot","parents","processedObjects","dereferencedCache","result","has","ArrayBuffer","isView","add","isAllowed$Ref","dereference$Ref","key","Object","keys","keyPath","join","keyPathFromRoot","foundCircularReference","delete","$ref","$refPath","resolve","cache","get","refKeys","length","extraKeys","assign","pointer","_resolve","directCircular","dereferencedValue","dereferencedObject","set","reference"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst $Ref = require(\"./ref\");\nconst Pointer = require(\"./pointer\");\nconst { ono } = require(\"@jsdevtools/ono\");\nconst url = require(\"./util/url\");\n\nmodule.exports = dereference;\n\n/**\n * Crawls the JSON schema, finds all JSON references, and dereferences them.\n * This method mutates the JSON schema object, replacing JSON references with their resolved value.\n *\n * @param {$RefParser} parser\n * @param {$RefParserOptions} options\n */\nfunction dereference (parser, options) {\n  // console.log('Dereferencing $ref pointers in %s', parser.$refs._root$Ref.path);\n  let dereferenced = crawl(parser.schema, parser.$refs._root$Ref.path, \"#\", new Set(), new Set(), new Map(), parser.$refs, options);\n  parser.$refs.circular = dereferenced.circular;\n  parser.schema = dereferenced.value;\n}\n\n/**\n * Recursively crawls the given value, and dereferences any JSON references.\n *\n * @param {*} obj - The value to crawl. If it's not an object or array, it will be ignored.\n * @param {string} path - The full path of `obj`, possibly with a JSON Pointer in the hash\n * @param {string} pathFromRoot - The path of `obj` from the schema root\n * @param {Set<object>} parents - An array of the parent objects that have already been dereferenced\n * @param {Set<object>} processedObjects - An array of all the objects that have already been processed\n * @param {Map<string,object>} dereferencedCache - An map of all the dereferenced objects\n * @param {$Refs} $refs\n * @param {$RefParserOptions} options\n * @returns {{value: object, circular: boolean}}\n */\nfunction crawl (obj, path, pathFromRoot, parents, processedObjects, dereferencedCache, $refs, options) {\n  let dereferenced;\n  let result = {\n    value: obj,\n    circular: false\n  };\n\n  if (options.dereference.circular === \"ignore\" || !processedObjects.has(obj)) {\n    if (obj && typeof obj === \"object\" && !ArrayBuffer.isView(obj)) {\n      parents.add(obj);\n      processedObjects.add(obj);\n\n      if ($Ref.isAllowed$Ref(obj, options)) {\n        dereferenced = dereference$Ref(obj, path, pathFromRoot, parents, processedObjects, dereferencedCache, $refs, options);\n        result.circular = dereferenced.circular;\n        result.value = dereferenced.value;\n      }\n      else {\n        for (const key of Object.keys(obj)) {\n          let keyPath = Pointer.join(path, key);\n          let keyPathFromRoot = Pointer.join(pathFromRoot, key);\n          let value = obj[key];\n          let circular = false;\n\n          if ($Ref.isAllowed$Ref(value, options)) {\n            dereferenced = dereference$Ref(value, keyPath, keyPathFromRoot, parents, processedObjects, dereferencedCache, $refs, options);\n            circular = dereferenced.circular;\n            // Avoid pointless mutations; breaks frozen objects to no profit\n            if (obj[key] !== dereferenced.value) {\n              obj[key] = dereferenced.value;\n            }\n          }\n          else {\n            if (!parents.has(value)) {\n              dereferenced = crawl(value, keyPath, keyPathFromRoot, parents, processedObjects, dereferencedCache, $refs, options);\n              circular = dereferenced.circular;\n              // Avoid pointless mutations; breaks frozen objects to no profit\n              if (obj[key] !== dereferenced.value) {\n                obj[key] = dereferenced.value;\n              }\n            }\n            else {\n              circular = foundCircularReference(keyPath, $refs, options);\n            }\n          }\n\n          // Set the \"isCircular\" flag if this or any other property is circular\n          result.circular = result.circular || circular;\n        }\n      }\n\n      parents.delete(obj);\n    }\n  }\n\n  return result;\n}\n\n/**\n * Dereferences the given JSON Reference, and then crawls the resulting value.\n *\n * @param {{$ref: string}} $ref - The JSON Reference to resolve\n * @param {string} path - The full path of `$ref`, possibly with a JSON Pointer in the hash\n * @param {string} pathFromRoot - The path of `$ref` from the schema root\n * @param {Set<object>} parents - An array of the parent objects that have already been dereferenced\n * @param {Set<object>} processedObjects - An array of all the objects that have already been dereferenced\n * @param {Map<string,object>} dereferencedCache - An map of all the dereferenced objects\n * @param {$Refs} $refs\n * @param {$RefParserOptions} options\n * @returns {{value: object, circular: boolean}}\n */\nfunction dereference$Ref ($ref, path, pathFromRoot, parents, processedObjects, dereferencedCache, $refs, options) {\n  // console.log('Dereferencing $ref pointer \"%s\" at %s', $ref.$ref, path);\n\n  let $refPath = url.resolve(path, $ref.$ref);\n\n  const cache = dereferencedCache.get($refPath);\n  if (cache) {\n    const refKeys = Object.keys($ref);\n    if (refKeys.length > 1) {\n      const extraKeys = {};\n      for (let key of refKeys) {\n        if (key !== \"$ref\" && !(key in cache.value)) {\n          extraKeys[key] = $ref[key];\n        }\n      }\n      return {\n        circular: cache.circular,\n        value: Object.assign({}, cache.value, extraKeys),\n      };\n    }\n\n    return cache;\n  }\n\n\n  let pointer = $refs._resolve($refPath, path, options);\n\n  if (pointer === null) {\n    return {\n      circular: false,\n      value: null,\n    };\n  }\n\n  // Check for circular references\n  let directCircular = pointer.circular;\n  let circular = directCircular || parents.has(pointer.value);\n  circular && foundCircularReference(path, $refs, options);\n\n  // Dereference the JSON reference\n  let dereferencedValue = $Ref.dereference($ref, pointer.value);\n\n  // Crawl the dereferenced value (unless it's circular)\n  if (!circular) {\n    // Determine if the dereferenced value is circular\n    let dereferenced = crawl(dereferencedValue, pointer.path, pathFromRoot, parents, processedObjects, dereferencedCache, $refs, options);\n    circular = dereferenced.circular;\n    dereferencedValue = dereferenced.value;\n  }\n\n  if (circular && !directCircular && options.dereference.circular === \"ignore\") {\n    // The user has chosen to \"ignore\" circular references, so don't change the value\n    dereferencedValue = $ref;\n  }\n\n  if (directCircular) {\n    // The pointer is a DIRECT circular reference (i.e. it references itself).\n    // So replace the $ref path with the absolute path from the JSON Schema root\n    dereferencedValue.$ref = pathFromRoot;\n  }\n\n\n  const dereferencedObject = {\n    circular,\n    value: dereferencedValue\n  };\n\n  // only cache if no extra properties than $ref\n  if (Object.keys($ref).length === 1) {\n    dereferencedCache.set($refPath, dereferencedObject);\n  }\n\n  return dereferencedObject;\n}\n\n/**\n * Called when a circular reference is found.\n * It sets the {@link $Refs#circular} flag, and throws an error if options.dereference.circular is false.\n *\n * @param {string} keyPath - The JSON Reference path of the circular reference\n * @param {$Refs} $refs\n * @param {$RefParserOptions} options\n * @returns {boolean} - always returns true, to indicate that a circular reference was found\n */\nfunction foundCircularReference (keyPath, $refs, options) {\n  $refs.circular = true;\n  if (!options.dereference.circular) {\n    throw ono.reference(`Circular $ref pointer found at ${keyPath}`);\n  }\n  return true;\n}\n"]},"metadata":{},"sourceType":"script"}