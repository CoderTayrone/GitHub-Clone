{"ast":null,"code":"'use strict';\n\nconst fs = require('graceful-fs');\n\nconst path = require('path');\n\nconst mkdirpSync = require('../mkdirs').mkdirsSync;\n\nconst utimesSync = require('../util/utimes.js').utimesMillisSync;\n\nconst notExist = Symbol('notExist');\nconst existsReg = Symbol('existsReg');\n\nfunction copySync(src, dest, opts) {\n  if (typeof opts === 'function') {\n    opts = {\n      filter: opts\n    };\n  }\n\n  opts = opts || {};\n  opts.clobber = 'clobber' in opts ? !!opts.clobber : true; // default to true for now\n\n  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber; // overwrite falls back to clobber\n  // Warn about using preserveTimestamps on 32-bit node\n\n  if (opts.preserveTimestamps && process.arch === 'ia32') {\n    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\\n\n    see https://github.com/jprichardson/node-fs-extra/issues/269`);\n  }\n\n  src = path.resolve(src);\n  dest = path.resolve(dest); // don't allow src and dest to be the same\n\n  if (src === dest) throw new Error('Source and destination must not be the same.');\n  if (opts.filter && !opts.filter(src, dest)) return;\n  const destParent = path.dirname(dest);\n  if (!fs.existsSync(destParent)) mkdirpSync(destParent);\n  return startCopy(src, dest, opts);\n}\n\nfunction startCopy(src, dest, opts) {\n  if (opts.filter && !opts.filter(src, dest)) return;\n  return getStats(src, dest, opts);\n}\n\nfunction getStats(src, dest, opts) {\n  const statSync = opts.dereference ? fs.statSync : fs.lstatSync;\n  const st = statSync(src);\n  if (st.isDirectory()) return onDir(st, src, dest, opts);else if (st.isFile() || st.isCharacterDevice() || st.isBlockDevice()) return onFile(st, src, dest, opts);else if (st.isSymbolicLink()) return onLink(src, dest, opts);\n}\n\nfunction onFile(srcStat, src, dest, opts) {\n  const resolvedPath = checkDest(dest);\n\n  if (resolvedPath === notExist) {\n    return copyFile(srcStat, src, dest, opts);\n  } else if (resolvedPath === existsReg) {\n    return mayCopyFile(srcStat, src, dest, opts);\n  } else {\n    if (src === resolvedPath) return;\n    return mayCopyFile(srcStat, src, dest, opts);\n  }\n}\n\nfunction mayCopyFile(srcStat, src, dest, opts) {\n  if (opts.overwrite) {\n    fs.unlinkSync(dest);\n    return copyFile(srcStat, src, dest, opts);\n  } else if (opts.errorOnExist) {\n    throw new Error(`'${dest}' already exists`);\n  }\n}\n\nfunction copyFile(srcStat, src, dest, opts) {\n  if (typeof fs.copyFileSync === 'function') {\n    fs.copyFileSync(src, dest);\n    fs.chmodSync(dest, srcStat.mode);\n\n    if (opts.preserveTimestamps) {\n      return utimesSync(dest, srcStat.atime, srcStat.mtime);\n    }\n\n    return;\n  }\n\n  return copyFileFallback(srcStat, src, dest, opts);\n}\n\nfunction copyFileFallback(srcStat, src, dest, opts) {\n  const BUF_LENGTH = 64 * 1024;\n\n  const _buff = require('../util/buffer')(BUF_LENGTH);\n\n  const fdr = fs.openSync(src, 'r');\n  const fdw = fs.openSync(dest, 'w', srcStat.mode);\n  let bytesRead = 1;\n  let pos = 0;\n\n  while (bytesRead > 0) {\n    bytesRead = fs.readSync(fdr, _buff, 0, BUF_LENGTH, pos);\n    fs.writeSync(fdw, _buff, 0, bytesRead);\n    pos += bytesRead;\n  }\n\n  if (opts.preserveTimestamps) fs.futimesSync(fdw, srcStat.atime, srcStat.mtime);\n  fs.closeSync(fdr);\n  fs.closeSync(fdw);\n}\n\nfunction onDir(srcStat, src, dest, opts) {\n  const resolvedPath = checkDest(dest);\n\n  if (resolvedPath === notExist) {\n    if (isSrcSubdir(src, dest)) {\n      throw new Error(`Cannot copy '${src}' to a subdirectory of itself, '${dest}'.`);\n    }\n\n    return mkDirAndCopy(srcStat, src, dest, opts);\n  } else if (resolvedPath === existsReg) {\n    if (isSrcSubdir(src, dest)) {\n      throw new Error(`Cannot copy '${src}' to a subdirectory of itself, '${dest}'.`);\n    }\n\n    return mayCopyDir(src, dest, opts);\n  } else {\n    if (src === resolvedPath) return;\n    return copyDir(src, dest, opts);\n  }\n}\n\nfunction mayCopyDir(src, dest, opts) {\n  if (!fs.statSync(dest).isDirectory()) {\n    throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);\n  }\n\n  return copyDir(src, dest, opts);\n}\n\nfunction mkDirAndCopy(srcStat, src, dest, opts) {\n  fs.mkdirSync(dest, srcStat.mode);\n  fs.chmodSync(dest, srcStat.mode);\n  return copyDir(src, dest, opts);\n}\n\nfunction copyDir(src, dest, opts) {\n  fs.readdirSync(src).forEach(item => {\n    startCopy(path.join(src, item), path.join(dest, item), opts);\n  });\n}\n\nfunction onLink(src, dest, opts) {\n  let resolvedSrcPath = fs.readlinkSync(src);\n\n  if (opts.dereference) {\n    resolvedSrcPath = path.resolve(process.cwd(), resolvedSrcPath);\n  }\n\n  let resolvedDestPath = checkDest(dest);\n\n  if (resolvedDestPath === notExist || resolvedDestPath === existsReg) {\n    // if dest already exists, fs throws error anyway,\n    // so no need to guard against it here.\n    return fs.symlinkSync(resolvedSrcPath, dest);\n  } else {\n    if (opts.dereference) {\n      resolvedDestPath = path.resolve(process.cwd(), resolvedDestPath);\n    }\n\n    if (resolvedDestPath === resolvedSrcPath) return; // prevent copy if src is a subdir of dest since unlinking\n    // dest in this case would result in removing src contents\n    // and therefore a broken symlink would be created.\n\n    if (fs.statSync(dest).isDirectory() && isSrcSubdir(resolvedDestPath, resolvedSrcPath)) {\n      throw new Error(`Cannot overwrite '${resolvedDestPath}' with '${resolvedSrcPath}'.`);\n    }\n\n    return copyLink(resolvedSrcPath, dest);\n  }\n}\n\nfunction copyLink(resolvedSrcPath, dest) {\n  fs.unlinkSync(dest);\n  return fs.symlinkSync(resolvedSrcPath, dest);\n} // check if dest exists and/or is a symlink\n\n\nfunction checkDest(dest) {\n  let resolvedPath;\n\n  try {\n    resolvedPath = fs.readlinkSync(dest);\n  } catch (err) {\n    if (err.code === 'ENOENT') return notExist; // dest exists and is a regular file or directory, Windows may throw UNKNOWN error\n\n    if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return existsReg;\n    throw err;\n  }\n\n  return resolvedPath; // dest exists and is a symlink\n} // return true if dest is a subdir of src, otherwise false.\n// extract dest base dir and check if that is the same as src basename\n\n\nfunction isSrcSubdir(src, dest) {\n  const baseDir = dest.split(path.dirname(src) + path.sep)[1];\n\n  if (baseDir) {\n    const destBasename = baseDir.split(path.sep)[0];\n\n    if (destBasename) {\n      return src !== dest && dest.indexOf(src) > -1 && destBasename === path.basename(src);\n    }\n\n    return false;\n  }\n\n  return false;\n}\n\nmodule.exports = copySync;","map":{"version":3,"sources":["/home/dev/Documentos/Projects/github-clone/node_modules/firebase-tools/node_modules/fs-extra/lib/copy-sync/copy-sync.js"],"names":["fs","require","path","mkdirpSync","mkdirsSync","utimesSync","utimesMillisSync","notExist","Symbol","existsReg","copySync","src","dest","opts","filter","clobber","overwrite","preserveTimestamps","process","arch","console","warn","resolve","Error","destParent","dirname","existsSync","startCopy","getStats","statSync","dereference","lstatSync","st","isDirectory","onDir","isFile","isCharacterDevice","isBlockDevice","onFile","isSymbolicLink","onLink","srcStat","resolvedPath","checkDest","copyFile","mayCopyFile","unlinkSync","errorOnExist","copyFileSync","chmodSync","mode","atime","mtime","copyFileFallback","BUF_LENGTH","_buff","fdr","openSync","fdw","bytesRead","pos","readSync","writeSync","futimesSync","closeSync","isSrcSubdir","mkDirAndCopy","mayCopyDir","copyDir","mkdirSync","readdirSync","forEach","item","join","resolvedSrcPath","readlinkSync","cwd","resolvedDestPath","symlinkSync","copyLink","err","code","baseDir","split","sep","destBasename","indexOf","basename","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst mkdirpSync = require('../mkdirs').mkdirsSync\nconst utimesSync = require('../util/utimes.js').utimesMillisSync\n\nconst notExist = Symbol('notExist')\nconst existsReg = Symbol('existsReg')\n\nfunction copySync (src, dest, opts) {\n  if (typeof opts === 'function') {\n    opts = {filter: opts}\n  }\n\n  opts = opts || {}\n  opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now\n  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber\n\n  // Warn about using preserveTimestamps on 32-bit node\n  if (opts.preserveTimestamps && process.arch === 'ia32') {\n    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\\n\n    see https://github.com/jprichardson/node-fs-extra/issues/269`)\n  }\n\n  src = path.resolve(src)\n  dest = path.resolve(dest)\n\n  // don't allow src and dest to be the same\n  if (src === dest) throw new Error('Source and destination must not be the same.')\n\n  if (opts.filter && !opts.filter(src, dest)) return\n\n  const destParent = path.dirname(dest)\n  if (!fs.existsSync(destParent)) mkdirpSync(destParent)\n  return startCopy(src, dest, opts)\n}\n\nfunction startCopy (src, dest, opts) {\n  if (opts.filter && !opts.filter(src, dest)) return\n  return getStats(src, dest, opts)\n}\n\nfunction getStats (src, dest, opts) {\n  const statSync = opts.dereference ? fs.statSync : fs.lstatSync\n  const st = statSync(src)\n\n  if (st.isDirectory()) return onDir(st, src, dest, opts)\n  else if (st.isFile() ||\n           st.isCharacterDevice() ||\n           st.isBlockDevice()) return onFile(st, src, dest, opts)\n  else if (st.isSymbolicLink()) return onLink(src, dest, opts)\n}\n\nfunction onFile (srcStat, src, dest, opts) {\n  const resolvedPath = checkDest(dest)\n  if (resolvedPath === notExist) {\n    return copyFile(srcStat, src, dest, opts)\n  } else if (resolvedPath === existsReg) {\n    return mayCopyFile(srcStat, src, dest, opts)\n  } else {\n    if (src === resolvedPath) return\n    return mayCopyFile(srcStat, src, dest, opts)\n  }\n}\n\nfunction mayCopyFile (srcStat, src, dest, opts) {\n  if (opts.overwrite) {\n    fs.unlinkSync(dest)\n    return copyFile(srcStat, src, dest, opts)\n  } else if (opts.errorOnExist) {\n    throw new Error(`'${dest}' already exists`)\n  }\n}\n\nfunction copyFile (srcStat, src, dest, opts) {\n  if (typeof fs.copyFileSync === 'function') {\n    fs.copyFileSync(src, dest)\n    fs.chmodSync(dest, srcStat.mode)\n    if (opts.preserveTimestamps) {\n      return utimesSync(dest, srcStat.atime, srcStat.mtime)\n    }\n    return\n  }\n  return copyFileFallback(srcStat, src, dest, opts)\n}\n\nfunction copyFileFallback (srcStat, src, dest, opts) {\n  const BUF_LENGTH = 64 * 1024\n  const _buff = require('../util/buffer')(BUF_LENGTH)\n\n  const fdr = fs.openSync(src, 'r')\n  const fdw = fs.openSync(dest, 'w', srcStat.mode)\n  let bytesRead = 1\n  let pos = 0\n\n  while (bytesRead > 0) {\n    bytesRead = fs.readSync(fdr, _buff, 0, BUF_LENGTH, pos)\n    fs.writeSync(fdw, _buff, 0, bytesRead)\n    pos += bytesRead\n  }\n\n  if (opts.preserveTimestamps) fs.futimesSync(fdw, srcStat.atime, srcStat.mtime)\n\n  fs.closeSync(fdr)\n  fs.closeSync(fdw)\n}\n\nfunction onDir (srcStat, src, dest, opts) {\n  const resolvedPath = checkDest(dest)\n  if (resolvedPath === notExist) {\n    if (isSrcSubdir(src, dest)) {\n      throw new Error(`Cannot copy '${src}' to a subdirectory of itself, '${dest}'.`)\n    }\n    return mkDirAndCopy(srcStat, src, dest, opts)\n  } else if (resolvedPath === existsReg) {\n    if (isSrcSubdir(src, dest)) {\n      throw new Error(`Cannot copy '${src}' to a subdirectory of itself, '${dest}'.`)\n    }\n    return mayCopyDir(src, dest, opts)\n  } else {\n    if (src === resolvedPath) return\n    return copyDir(src, dest, opts)\n  }\n}\n\nfunction mayCopyDir (src, dest, opts) {\n  if (!fs.statSync(dest).isDirectory()) {\n    throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`)\n  }\n  return copyDir(src, dest, opts)\n}\n\nfunction mkDirAndCopy (srcStat, src, dest, opts) {\n  fs.mkdirSync(dest, srcStat.mode)\n  fs.chmodSync(dest, srcStat.mode)\n  return copyDir(src, dest, opts)\n}\n\nfunction copyDir (src, dest, opts) {\n  fs.readdirSync(src).forEach(item => {\n    startCopy(path.join(src, item), path.join(dest, item), opts)\n  })\n}\n\nfunction onLink (src, dest, opts) {\n  let resolvedSrcPath = fs.readlinkSync(src)\n\n  if (opts.dereference) {\n    resolvedSrcPath = path.resolve(process.cwd(), resolvedSrcPath)\n  }\n\n  let resolvedDestPath = checkDest(dest)\n  if (resolvedDestPath === notExist || resolvedDestPath === existsReg) {\n    // if dest already exists, fs throws error anyway,\n    // so no need to guard against it here.\n    return fs.symlinkSync(resolvedSrcPath, dest)\n  } else {\n    if (opts.dereference) {\n      resolvedDestPath = path.resolve(process.cwd(), resolvedDestPath)\n    }\n    if (resolvedDestPath === resolvedSrcPath) return\n\n    // prevent copy if src is a subdir of dest since unlinking\n    // dest in this case would result in removing src contents\n    // and therefore a broken symlink would be created.\n    if (fs.statSync(dest).isDirectory() && isSrcSubdir(resolvedDestPath, resolvedSrcPath)) {\n      throw new Error(`Cannot overwrite '${resolvedDestPath}' with '${resolvedSrcPath}'.`)\n    }\n    return copyLink(resolvedSrcPath, dest)\n  }\n}\n\nfunction copyLink (resolvedSrcPath, dest) {\n  fs.unlinkSync(dest)\n  return fs.symlinkSync(resolvedSrcPath, dest)\n}\n\n// check if dest exists and/or is a symlink\nfunction checkDest (dest) {\n  let resolvedPath\n  try {\n    resolvedPath = fs.readlinkSync(dest)\n  } catch (err) {\n    if (err.code === 'ENOENT') return notExist\n\n    // dest exists and is a regular file or directory, Windows may throw UNKNOWN error\n    if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return existsReg\n\n    throw err\n  }\n  return resolvedPath // dest exists and is a symlink\n}\n\n// return true if dest is a subdir of src, otherwise false.\n// extract dest base dir and check if that is the same as src basename\nfunction isSrcSubdir (src, dest) {\n  const baseDir = dest.split(path.dirname(src) + path.sep)[1]\n  if (baseDir) {\n    const destBasename = baseDir.split(path.sep)[0]\n    if (destBasename) {\n      return src !== dest && dest.indexOf(src) > -1 && destBasename === path.basename(src)\n    }\n    return false\n  }\n  return false\n}\n\nmodule.exports = copySync\n"]},"metadata":{},"sourceType":"script"}