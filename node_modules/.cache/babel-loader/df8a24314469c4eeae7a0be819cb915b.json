{"ast":null,"code":"import { d as defaultTagPrefix, _ as _createForOfIteratorHelper, a as _typeof, b as _createClass, c as _classCallCheck, e as _defineProperty, Y as YAMLSyntaxError, T as Type, f as YAMLWarning, g as YAMLSemanticError, h as _slicedToArray, i as YAMLError, j as _inherits, k as _createSuper } from './PlainValue-b8036b75.js';\nimport { parse as parse$1 } from './parse-cst.js';\nimport { b as binaryOptions, a as boolOptions, i as intOptions, n as nullOptions, s as strOptions, N as Node, P as Pair, S as Scalar, c as stringifyString, A as Alias, Y as YAMLSeq, d as YAMLMap, M as Merge, C as Collection, r as resolveNode, e as isEmptyPath, t as toJSON, f as addComment } from './resolveSeq-492ab440.js';\nimport { S as Schema } from './Schema-e94716c8.js';\nimport { w as warn } from './warnings-df54cb69.js';\nvar defaultOptions = {\n  anchorPrefix: 'a',\n  customTags: null,\n  indent: 2,\n  indentSeq: true,\n  keepCstNodes: false,\n  keepNodeTypes: true,\n  keepBlobsInJSON: true,\n  mapAsMap: false,\n  maxAliasCount: 100,\n  prettyErrors: false,\n  // TODO Set true in v2\n  simpleKeys: false,\n  version: '1.2'\n};\nvar scalarOptions = {\n  get binary() {\n    return binaryOptions;\n  },\n\n  set binary(opt) {\n    Object.assign(binaryOptions, opt);\n  },\n\n  get bool() {\n    return boolOptions;\n  },\n\n  set bool(opt) {\n    Object.assign(boolOptions, opt);\n  },\n\n  get int() {\n    return intOptions;\n  },\n\n  set int(opt) {\n    Object.assign(intOptions, opt);\n  },\n\n  get null() {\n    return nullOptions;\n  },\n\n  set null(opt) {\n    Object.assign(nullOptions, opt);\n  },\n\n  get str() {\n    return strOptions;\n  },\n\n  set str(opt) {\n    Object.assign(strOptions, opt);\n  }\n\n};\nvar documentOptions = {\n  '1.0': {\n    schema: 'yaml-1.1',\n    merge: true,\n    tagPrefixes: [{\n      handle: '!',\n      prefix: defaultTagPrefix\n    }, {\n      handle: '!!',\n      prefix: 'tag:private.yaml.org,2002:'\n    }]\n  },\n  1.1: {\n    schema: 'yaml-1.1',\n    merge: true,\n    tagPrefixes: [{\n      handle: '!',\n      prefix: '!'\n    }, {\n      handle: '!!',\n      prefix: defaultTagPrefix\n    }]\n  },\n  1.2: {\n    schema: 'core',\n    merge: false,\n    tagPrefixes: [{\n      handle: '!',\n      prefix: '!'\n    }, {\n      handle: '!!',\n      prefix: defaultTagPrefix\n    }]\n  }\n};\n\nfunction stringifyTag(doc, tag) {\n  if ((doc.version || doc.options.version) === '1.0') {\n    var priv = tag.match(/^tag:private\\.yaml\\.org,2002:([^:/]+)$/);\n    if (priv) return '!' + priv[1];\n    var vocab = tag.match(/^tag:([a-zA-Z0-9-]+)\\.yaml\\.org,2002:(.*)/);\n    return vocab ? \"!\".concat(vocab[1], \"/\").concat(vocab[2]) : \"!\".concat(tag.replace(/^tag:/, ''));\n  }\n\n  var p = doc.tagPrefixes.find(function (p) {\n    return tag.indexOf(p.prefix) === 0;\n  });\n\n  if (!p) {\n    var dtp = doc.getDefaults().tagPrefixes;\n    p = dtp && dtp.find(function (p) {\n      return tag.indexOf(p.prefix) === 0;\n    });\n  }\n\n  if (!p) return tag[0] === '!' ? tag : \"!<\".concat(tag, \">\");\n  var suffix = tag.substr(p.prefix.length).replace(/[!,[\\]{}]/g, function (ch) {\n    return {\n      '!': '%21',\n      ',': '%2C',\n      '[': '%5B',\n      ']': '%5D',\n      '{': '%7B',\n      '}': '%7D'\n    }[ch];\n  });\n  return p.handle + suffix;\n}\n\nfunction getTagObject(tags, item) {\n  if (item instanceof Alias) return Alias;\n\n  if (item.tag) {\n    var match = tags.filter(function (t) {\n      return t.tag === item.tag;\n    });\n    if (match.length > 0) return match.find(function (t) {\n      return t.format === item.format;\n    }) || match[0];\n  }\n\n  var tagObj, obj;\n\n  if (item instanceof Scalar) {\n    obj = item.value; // TODO: deprecate/remove class check\n\n    var _match = tags.filter(function (t) {\n      return t.identify && t.identify(obj) || t.class && obj instanceof t.class;\n    });\n\n    tagObj = _match.find(function (t) {\n      return t.format === item.format;\n    }) || _match.find(function (t) {\n      return !t.format;\n    });\n  } else {\n    obj = item;\n    tagObj = tags.find(function (t) {\n      return t.nodeClass && obj instanceof t.nodeClass;\n    });\n  }\n\n  if (!tagObj) {\n    var name = obj && obj.constructor ? obj.constructor.name : _typeof(obj);\n    throw new Error(\"Tag not resolved for \".concat(name, \" value\"));\n  }\n\n  return tagObj;\n} // needs to be called before value stringifier to allow for circular anchor refs\n\n\nfunction stringifyProps(node, tagObj, _ref) {\n  var anchors = _ref.anchors,\n      doc = _ref.doc;\n  var props = [];\n  var anchor = doc.anchors.getName(node);\n\n  if (anchor) {\n    anchors[anchor] = node;\n    props.push(\"&\".concat(anchor));\n  }\n\n  if (node.tag) {\n    props.push(stringifyTag(doc, node.tag));\n  } else if (!tagObj.default) {\n    props.push(stringifyTag(doc, tagObj.tag));\n  }\n\n  return props.join(' ');\n}\n\nfunction stringify$1(item, ctx, onComment, onChompKeep) {\n  var _ctx$doc = ctx.doc,\n      anchors = _ctx$doc.anchors,\n      schema = _ctx$doc.schema;\n  var tagObj;\n\n  if (!(item instanceof Node)) {\n    var createCtx = {\n      aliasNodes: [],\n      onTagObj: function onTagObj(o) {\n        return tagObj = o;\n      },\n      prevObjects: new Map()\n    };\n    item = schema.createNode(item, true, null, createCtx);\n\n    var _iterator = _createForOfIteratorHelper(createCtx.aliasNodes),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var alias = _step.value;\n        alias.source = alias.source.node;\n        var name = anchors.getName(alias.source);\n\n        if (!name) {\n          name = anchors.newName();\n          anchors.map[name] = alias.source;\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n\n  if (item instanceof Pair) return item.toString(ctx, onComment, onChompKeep);\n  if (!tagObj) tagObj = getTagObject(schema.tags, item);\n  var props = stringifyProps(item, tagObj, ctx);\n  if (props.length > 0) ctx.indentAtStart = (ctx.indentAtStart || 0) + props.length + 1;\n  var str = typeof tagObj.stringify === 'function' ? tagObj.stringify(item, ctx, onComment, onChompKeep) : item instanceof Scalar ? stringifyString(item, ctx, onComment, onChompKeep) : item.toString(ctx, onComment, onChompKeep);\n  if (!props) return str;\n  return item instanceof Scalar || str[0] === '{' || str[0] === '[' ? \"\".concat(props, \" \").concat(str) : \"\".concat(props, \"\\n\").concat(ctx.indent).concat(str);\n}\n\nvar Anchors = /*#__PURE__*/function () {\n  function Anchors(prefix) {\n    _classCallCheck(this, Anchors);\n\n    _defineProperty(this, \"map\", Object.create(null));\n\n    this.prefix = prefix;\n  }\n\n  _createClass(Anchors, [{\n    key: \"createAlias\",\n    value: function createAlias(node, name) {\n      this.setAnchor(node, name);\n      return new Alias(node);\n    }\n  }, {\n    key: \"createMergePair\",\n    value: function createMergePair() {\n      var _this = this;\n\n      var merge = new Merge();\n\n      for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {\n        sources[_key] = arguments[_key];\n      }\n\n      merge.value.items = sources.map(function (s) {\n        if (s instanceof Alias) {\n          if (s.source instanceof YAMLMap) return s;\n        } else if (s instanceof YAMLMap) {\n          return _this.createAlias(s);\n        }\n\n        throw new Error('Merge sources must be Map nodes or their Aliases');\n      });\n      return merge;\n    }\n  }, {\n    key: \"getName\",\n    value: function getName(node) {\n      var map = this.map;\n      return Object.keys(map).find(function (a) {\n        return map[a] === node;\n      });\n    }\n  }, {\n    key: \"getNames\",\n    value: function getNames() {\n      return Object.keys(this.map);\n    }\n  }, {\n    key: \"getNode\",\n    value: function getNode(name) {\n      return this.map[name];\n    }\n  }, {\n    key: \"newName\",\n    value: function newName(prefix) {\n      if (!prefix) prefix = this.prefix;\n      var names = Object.keys(this.map);\n\n      for (var i = 1; true; ++i) {\n        var name = \"\".concat(prefix).concat(i);\n        if (!names.includes(name)) return name;\n      }\n    } // During parsing, map & aliases contain CST nodes\n\n  }, {\n    key: \"resolveNodes\",\n    value: function resolveNodes() {\n      var map = this.map,\n          _cstAliases = this._cstAliases;\n      Object.keys(map).forEach(function (a) {\n        map[a] = map[a].resolved;\n      });\n\n      _cstAliases.forEach(function (a) {\n        a.source = a.source.resolved;\n      });\n\n      delete this._cstAliases;\n    }\n  }, {\n    key: \"setAnchor\",\n    value: function setAnchor(node, name) {\n      if (node != null && !Anchors.validAnchorNode(node)) {\n        throw new Error('Anchors may only be set for Scalar, Seq and Map nodes');\n      }\n\n      if (name && /[\\x00-\\x19\\s,[\\]{}]/.test(name)) {\n        throw new Error('Anchor names must not contain whitespace or control characters');\n      }\n\n      var map = this.map;\n      var prev = node && Object.keys(map).find(function (a) {\n        return map[a] === node;\n      });\n\n      if (prev) {\n        if (!name) {\n          return prev;\n        } else if (prev !== name) {\n          delete map[prev];\n          map[name] = node;\n        }\n      } else {\n        if (!name) {\n          if (!node) return null;\n          name = this.newName();\n        }\n\n        map[name] = node;\n      }\n\n      return name;\n    }\n  }], [{\n    key: \"validAnchorNode\",\n    value: function validAnchorNode(node) {\n      return node instanceof Scalar || node instanceof YAMLSeq || node instanceof YAMLMap;\n    }\n  }]);\n\n  return Anchors;\n}();\n\nvar visit = function visit(node, tags) {\n  if (node && _typeof(node) === 'object') {\n    var tag = node.tag;\n\n    if (node instanceof Collection) {\n      if (tag) tags[tag] = true;\n      node.items.forEach(function (n) {\n        return visit(n, tags);\n      });\n    } else if (node instanceof Pair) {\n      visit(node.key, tags);\n      visit(node.value, tags);\n    } else if (node instanceof Scalar) {\n      if (tag) tags[tag] = true;\n    }\n  }\n\n  return tags;\n};\n\nvar listTagNames = function listTagNames(node) {\n  return Object.keys(visit(node, {}));\n};\n\nfunction parseContents(doc, contents) {\n  var comments = {\n    before: [],\n    after: []\n  };\n  var body = undefined;\n  var spaceBefore = false;\n\n  var _iterator = _createForOfIteratorHelper(contents),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var node = _step.value;\n\n      if (node.valueRange) {\n        if (body !== undefined) {\n          var msg = 'Document contains trailing content not separated by a ... or --- line';\n          doc.errors.push(new YAMLSyntaxError(node, msg));\n          break;\n        }\n\n        var res = resolveNode(doc, node);\n\n        if (spaceBefore) {\n          res.spaceBefore = true;\n          spaceBefore = false;\n        }\n\n        body = res;\n      } else if (node.comment !== null) {\n        var cc = body === undefined ? comments.before : comments.after;\n        cc.push(node.comment);\n      } else if (node.type === Type.BLANK_LINE) {\n        spaceBefore = true;\n\n        if (body === undefined && comments.before.length > 0 && !doc.commentBefore) {\n          // space-separated comments at start are parsed as document comments\n          doc.commentBefore = comments.before.join('\\n');\n          comments.before = [];\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  doc.contents = body || null;\n\n  if (!body) {\n    doc.comment = comments.before.concat(comments.after).join('\\n') || null;\n  } else {\n    var cb = comments.before.join('\\n');\n\n    if (cb) {\n      var cbNode = body instanceof Collection && body.items[0] ? body.items[0] : body;\n      cbNode.commentBefore = cbNode.commentBefore ? \"\".concat(cb, \"\\n\").concat(cbNode.commentBefore) : cb;\n    }\n\n    doc.comment = comments.after.join('\\n') || null;\n  }\n}\n\nfunction resolveTagDirective(_ref, directive) {\n  var tagPrefixes = _ref.tagPrefixes;\n\n  var _directive$parameters = _slicedToArray(directive.parameters, 2),\n      handle = _directive$parameters[0],\n      prefix = _directive$parameters[1];\n\n  if (!handle || !prefix) {\n    var msg = 'Insufficient parameters given for %TAG directive';\n    throw new YAMLSemanticError(directive, msg);\n  }\n\n  if (tagPrefixes.some(function (p) {\n    return p.handle === handle;\n  })) {\n    var _msg = 'The %TAG directive must only be given at most once per handle in the same document.';\n    throw new YAMLSemanticError(directive, _msg);\n  }\n\n  return {\n    handle: handle,\n    prefix: prefix\n  };\n}\n\nfunction resolveYamlDirective(doc, directive) {\n  var _directive$parameters2 = _slicedToArray(directive.parameters, 1),\n      version = _directive$parameters2[0];\n\n  if (directive.name === 'YAML:1.0') version = '1.0';\n\n  if (!version) {\n    var msg = 'Insufficient parameters given for %YAML directive';\n    throw new YAMLSemanticError(directive, msg);\n  }\n\n  if (!documentOptions[version]) {\n    var v0 = doc.version || doc.options.version;\n\n    var _msg2 = \"Document will be parsed as YAML \".concat(v0, \" rather than YAML \").concat(version);\n\n    doc.warnings.push(new YAMLWarning(directive, _msg2));\n  }\n\n  return version;\n}\n\nfunction parseDirectives(doc, directives, prevDoc) {\n  var directiveComments = [];\n  var hasDirectives = false;\n\n  var _iterator = _createForOfIteratorHelper(directives),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var directive = _step.value;\n      var comment = directive.comment,\n          name = directive.name;\n\n      switch (name) {\n        case 'TAG':\n          try {\n            doc.tagPrefixes.push(resolveTagDirective(doc, directive));\n          } catch (error) {\n            doc.errors.push(error);\n          }\n\n          hasDirectives = true;\n          break;\n\n        case 'YAML':\n        case 'YAML:1.0':\n          if (doc.version) {\n            var msg = 'The %YAML directive must only be given at most once per document.';\n            doc.errors.push(new YAMLSemanticError(directive, msg));\n          }\n\n          try {\n            doc.version = resolveYamlDirective(doc, directive);\n          } catch (error) {\n            doc.errors.push(error);\n          }\n\n          hasDirectives = true;\n          break;\n\n        default:\n          if (name) {\n            var _msg3 = \"YAML only supports %TAG and %YAML directives, and not %\".concat(name);\n\n            doc.warnings.push(new YAMLWarning(directive, _msg3));\n          }\n\n      }\n\n      if (comment) directiveComments.push(comment);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  if (prevDoc && !hasDirectives && '1.1' === (doc.version || prevDoc.version || doc.options.version)) {\n    var copyTagPrefix = function copyTagPrefix(_ref2) {\n      var handle = _ref2.handle,\n          prefix = _ref2.prefix;\n      return {\n        handle: handle,\n        prefix: prefix\n      };\n    };\n\n    doc.tagPrefixes = prevDoc.tagPrefixes.map(copyTagPrefix);\n    doc.version = prevDoc.version;\n  }\n\n  doc.commentBefore = directiveComments.join('\\n') || null;\n}\n\nfunction assertCollection(contents) {\n  if (contents instanceof Collection) return true;\n  throw new Error('Expected a YAML collection as document contents');\n}\n\nvar Document$1 = /*#__PURE__*/function () {\n  function Document(options) {\n    _classCallCheck(this, Document);\n\n    this.anchors = new Anchors(options.anchorPrefix);\n    this.commentBefore = null;\n    this.comment = null;\n    this.contents = null;\n    this.directivesEndMarker = null;\n    this.errors = [];\n    this.options = options;\n    this.schema = null;\n    this.tagPrefixes = [];\n    this.version = null;\n    this.warnings = [];\n  }\n\n  _createClass(Document, [{\n    key: \"add\",\n    value: function add(value) {\n      assertCollection(this.contents);\n      return this.contents.add(value);\n    }\n  }, {\n    key: \"addIn\",\n    value: function addIn(path, value) {\n      assertCollection(this.contents);\n      this.contents.addIn(path, value);\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(key) {\n      assertCollection(this.contents);\n      return this.contents.delete(key);\n    }\n  }, {\n    key: \"deleteIn\",\n    value: function deleteIn(path) {\n      if (isEmptyPath(path)) {\n        if (this.contents == null) return false;\n        this.contents = null;\n        return true;\n      }\n\n      assertCollection(this.contents);\n      return this.contents.deleteIn(path);\n    }\n  }, {\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Document.defaults[this.version] || Document.defaults[this.options.version] || {};\n    }\n  }, {\n    key: \"get\",\n    value: function get(key, keepScalar) {\n      return this.contents instanceof Collection ? this.contents.get(key, keepScalar) : undefined;\n    }\n  }, {\n    key: \"getIn\",\n    value: function getIn(path, keepScalar) {\n      if (isEmptyPath(path)) return !keepScalar && this.contents instanceof Scalar ? this.contents.value : this.contents;\n      return this.contents instanceof Collection ? this.contents.getIn(path, keepScalar) : undefined;\n    }\n  }, {\n    key: \"has\",\n    value: function has(key) {\n      return this.contents instanceof Collection ? this.contents.has(key) : false;\n    }\n  }, {\n    key: \"hasIn\",\n    value: function hasIn(path) {\n      if (isEmptyPath(path)) return this.contents !== undefined;\n      return this.contents instanceof Collection ? this.contents.hasIn(path) : false;\n    }\n  }, {\n    key: \"set\",\n    value: function set(key, value) {\n      assertCollection(this.contents);\n      this.contents.set(key, value);\n    }\n  }, {\n    key: \"setIn\",\n    value: function setIn(path, value) {\n      if (isEmptyPath(path)) this.contents = value;else {\n        assertCollection(this.contents);\n        this.contents.setIn(path, value);\n      }\n    }\n  }, {\n    key: \"setSchema\",\n    value: function setSchema(id, customTags) {\n      if (!id && !customTags && this.schema) return;\n      if (typeof id === 'number') id = id.toFixed(1);\n\n      if (id === '1.0' || id === '1.1' || id === '1.2') {\n        if (this.version) this.version = id;else this.options.version = id;\n        delete this.options.schema;\n      } else if (id && typeof id === 'string') {\n        this.options.schema = id;\n      }\n\n      if (Array.isArray(customTags)) this.options.customTags = customTags;\n      var opt = Object.assign({}, this.getDefaults(), this.options);\n      this.schema = new Schema(opt);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(node, prevDoc) {\n      if (this.options.keepCstNodes) this.cstNode = node;\n      if (this.options.keepNodeTypes) this.type = 'DOCUMENT';\n      var _node$directives = node.directives,\n          directives = _node$directives === void 0 ? [] : _node$directives,\n          _node$contents = node.contents,\n          contents = _node$contents === void 0 ? [] : _node$contents,\n          directivesEndMarker = node.directivesEndMarker,\n          error = node.error,\n          valueRange = node.valueRange;\n\n      if (error) {\n        if (!error.source) error.source = this;\n        this.errors.push(error);\n      }\n\n      parseDirectives(this, directives, prevDoc);\n      if (directivesEndMarker) this.directivesEndMarker = true;\n      this.range = valueRange ? [valueRange.start, valueRange.end] : null;\n      this.setSchema();\n      this.anchors._cstAliases = [];\n      parseContents(this, contents);\n      this.anchors.resolveNodes();\n\n      if (this.options.prettyErrors) {\n        var _iterator = _createForOfIteratorHelper(this.errors),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var _error = _step.value;\n            if (_error instanceof YAMLError) _error.makePretty();\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        var _iterator2 = _createForOfIteratorHelper(this.warnings),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var warn = _step2.value;\n            if (warn instanceof YAMLError) warn.makePretty();\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"listNonDefaultTags\",\n    value: function listNonDefaultTags() {\n      return listTagNames(this.contents).filter(function (t) {\n        return t.indexOf(Schema.defaultPrefix) !== 0;\n      });\n    }\n  }, {\n    key: \"setTagPrefix\",\n    value: function setTagPrefix(handle, prefix) {\n      if (handle[0] !== '!' || handle[handle.length - 1] !== '!') throw new Error('Handle must start and end with !');\n\n      if (prefix) {\n        var prev = this.tagPrefixes.find(function (p) {\n          return p.handle === handle;\n        });\n        if (prev) prev.prefix = prefix;else this.tagPrefixes.push({\n          handle: handle,\n          prefix: prefix\n        });\n      } else {\n        this.tagPrefixes = this.tagPrefixes.filter(function (p) {\n          return p.handle !== handle;\n        });\n      }\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON$1(arg, onAnchor) {\n      var _this = this;\n\n      var _this$options = this.options,\n          keepBlobsInJSON = _this$options.keepBlobsInJSON,\n          mapAsMap = _this$options.mapAsMap,\n          maxAliasCount = _this$options.maxAliasCount;\n      var keep = keepBlobsInJSON && (typeof arg !== 'string' || !(this.contents instanceof Scalar));\n      var ctx = {\n        doc: this,\n        indentStep: '  ',\n        keep: keep,\n        mapAsMap: keep && !!mapAsMap,\n        maxAliasCount: maxAliasCount,\n        stringify: stringify$1 // Requiring directly in Pair would create circular dependencies\n\n      };\n      var anchorNames = Object.keys(this.anchors.map);\n      if (anchorNames.length > 0) ctx.anchors = new Map(anchorNames.map(function (name) {\n        return [_this.anchors.map[name], {\n          alias: [],\n          aliasCount: 0,\n          count: 1\n        }];\n      }));\n      var res = toJSON(this.contents, arg, ctx);\n\n      if (typeof onAnchor === 'function' && ctx.anchors) {\n        var _iterator3 = _createForOfIteratorHelper(ctx.anchors.values()),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var _step3$value = _step3.value,\n                count = _step3$value.count,\n                _res = _step3$value.res;\n            onAnchor(_res, count);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      }\n\n      return res;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      if (this.errors.length > 0) throw new Error('Document with errors cannot be stringified');\n      var indentSize = this.options.indent;\n\n      if (!Number.isInteger(indentSize) || indentSize <= 0) {\n        var s = JSON.stringify(indentSize);\n        throw new Error(\"\\\"indent\\\" option must be a positive integer, not \".concat(s));\n      }\n\n      this.setSchema();\n      var lines = [];\n      var hasDirectives = false;\n\n      if (this.version) {\n        var vd = '%YAML 1.2';\n\n        if (this.schema.name === 'yaml-1.1') {\n          if (this.version === '1.0') vd = '%YAML:1.0';else if (this.version === '1.1') vd = '%YAML 1.1';\n        }\n\n        lines.push(vd);\n        hasDirectives = true;\n      }\n\n      var tagNames = this.listNonDefaultTags();\n      this.tagPrefixes.forEach(function (_ref) {\n        var handle = _ref.handle,\n            prefix = _ref.prefix;\n\n        if (tagNames.some(function (t) {\n          return t.indexOf(prefix) === 0;\n        })) {\n          lines.push(\"%TAG \".concat(handle, \" \").concat(prefix));\n          hasDirectives = true;\n        }\n      });\n      if (hasDirectives || this.directivesEndMarker) lines.push('---');\n\n      if (this.commentBefore) {\n        if (hasDirectives || !this.directivesEndMarker) lines.unshift('');\n        lines.unshift(this.commentBefore.replace(/^/gm, '#'));\n      }\n\n      var ctx = {\n        anchors: Object.create(null),\n        doc: this,\n        indent: '',\n        indentStep: ' '.repeat(indentSize),\n        stringify: stringify$1 // Requiring directly in nodes would create circular dependencies\n\n      };\n      var chompKeep = false;\n      var contentComment = null;\n\n      if (this.contents) {\n        if (this.contents instanceof Node) {\n          if (this.contents.spaceBefore && (hasDirectives || this.directivesEndMarker)) lines.push('');\n          if (this.contents.commentBefore) lines.push(this.contents.commentBefore.replace(/^/gm, '#')); // top-level block scalars need to be indented if followed by a comment\n\n          ctx.forceBlockIndent = !!this.comment;\n          contentComment = this.contents.comment;\n        }\n\n        var onChompKeep = contentComment ? null : function () {\n          return chompKeep = true;\n        };\n        var body = stringify$1(this.contents, ctx, function () {\n          return contentComment = null;\n        }, onChompKeep);\n        lines.push(addComment(body, '', contentComment));\n      } else if (this.contents !== undefined) {\n        lines.push(stringify$1(this.contents, ctx));\n      }\n\n      if (this.comment) {\n        if ((!chompKeep || contentComment) && lines[lines.length - 1] !== '') lines.push('');\n        lines.push(this.comment.replace(/^/gm, '#'));\n      }\n\n      return lines.join('\\n') + '\\n';\n    }\n  }]);\n\n  return Document;\n}();\n\n_defineProperty(Document$1, \"defaults\", documentOptions);\n\nfunction createNode(value) {\n  var wrapScalars = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var tag = arguments.length > 2 ? arguments[2] : undefined;\n\n  if (tag === undefined && typeof wrapScalars === 'string') {\n    tag = wrapScalars;\n    wrapScalars = true;\n  }\n\n  var options = Object.assign({}, Document$1.defaults[defaultOptions.version], defaultOptions);\n  var schema = new Schema(options);\n  return schema.createNode(value, wrapScalars, tag);\n}\n\nvar Document = /*#__PURE__*/function (_YAMLDocument) {\n  _inherits(Document, _YAMLDocument);\n\n  var _super = _createSuper(Document);\n\n  function Document(options) {\n    _classCallCheck(this, Document);\n\n    return _super.call(this, Object.assign({}, defaultOptions, options));\n  }\n\n  return Document;\n}(Document$1);\n\nfunction parseAllDocuments(src, options) {\n  var stream = [];\n  var prev;\n\n  var _iterator = _createForOfIteratorHelper(parse$1(src)),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var cstDoc = _step.value;\n      var doc = new Document(options);\n      doc.parse(cstDoc, prev);\n      stream.push(doc);\n      prev = doc;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return stream;\n}\n\nfunction parseDocument(src, options) {\n  var cst = parse$1(src);\n  var doc = new Document(options).parse(cst[0]);\n\n  if (cst.length > 1) {\n    var errMsg = 'Source contains multiple documents; please use YAML.parseAllDocuments()';\n    doc.errors.unshift(new YAMLSemanticError(cst[1], errMsg));\n  }\n\n  return doc;\n}\n\nfunction parse(src, options) {\n  var doc = parseDocument(src, options);\n  doc.warnings.forEach(function (warning) {\n    return warn(warning);\n  });\n  if (doc.errors.length > 0) throw doc.errors[0];\n  return doc.toJSON();\n}\n\nfunction stringify(value, options) {\n  var doc = new Document(options);\n  doc.contents = value;\n  return String(doc);\n}\n\nvar YAML = {\n  createNode: createNode,\n  defaultOptions: defaultOptions,\n  Document: Document,\n  parse: parse,\n  parseAllDocuments: parseAllDocuments,\n  parseCST: parse$1,\n  parseDocument: parseDocument,\n  scalarOptions: scalarOptions,\n  stringify: stringify\n};\nexport { YAML };","map":{"version":3,"sources":["/home/dev/Documentos/Projects/github-clone/node_modules/yaml/browser/dist/index.js"],"names":["d","defaultTagPrefix","_","_createForOfIteratorHelper","a","_typeof","b","_createClass","c","_classCallCheck","e","_defineProperty","Y","YAMLSyntaxError","T","Type","f","YAMLWarning","g","YAMLSemanticError","h","_slicedToArray","i","YAMLError","j","_inherits","k","_createSuper","parse","parse$1","binaryOptions","boolOptions","intOptions","n","nullOptions","s","strOptions","N","Node","P","Pair","S","Scalar","stringifyString","A","Alias","YAMLSeq","YAMLMap","M","Merge","C","Collection","r","resolveNode","isEmptyPath","t","toJSON","addComment","Schema","w","warn","defaultOptions","anchorPrefix","customTags","indent","indentSeq","keepCstNodes","keepNodeTypes","keepBlobsInJSON","mapAsMap","maxAliasCount","prettyErrors","simpleKeys","version","scalarOptions","binary","opt","Object","assign","bool","int","null","str","documentOptions","schema","merge","tagPrefixes","handle","prefix","stringifyTag","doc","tag","options","priv","match","vocab","concat","replace","p","find","indexOf","dtp","getDefaults","suffix","substr","length","ch","getTagObject","tags","item","filter","format","tagObj","obj","value","_match","identify","class","nodeClass","name","constructor","Error","stringifyProps","node","_ref","anchors","props","anchor","getName","push","default","join","stringify$1","ctx","onComment","onChompKeep","_ctx$doc","createCtx","aliasNodes","onTagObj","o","prevObjects","Map","createNode","_iterator","_step","done","alias","source","newName","map","err","toString","indentAtStart","stringify","Anchors","create","key","createAlias","setAnchor","createMergePair","_this","_len","arguments","sources","Array","_key","items","keys","getNames","getNode","names","includes","resolveNodes","_cstAliases","forEach","resolved","validAnchorNode","test","prev","visit","listTagNames","parseContents","contents","comments","before","after","body","undefined","spaceBefore","valueRange","msg","errors","res","comment","cc","type","BLANK_LINE","commentBefore","cb","cbNode","resolveTagDirective","directive","_directive$parameters","parameters","some","_msg","resolveYamlDirective","_directive$parameters2","v0","_msg2","warnings","parseDirectives","directives","prevDoc","directiveComments","hasDirectives","error","_msg3","copyTagPrefix","_ref2","assertCollection","Document$1","Document","directivesEndMarker","add","addIn","path","_delete","delete","deleteIn","defaults","get","keepScalar","getIn","has","hasIn","set","setIn","setSchema","id","toFixed","isArray","cstNode","_node$directives","_node$contents","range","start","end","_error","makePretty","_iterator2","_step2","listNonDefaultTags","defaultPrefix","setTagPrefix","toJSON$1","arg","onAnchor","_this$options","keep","indentStep","anchorNames","aliasCount","count","_iterator3","values","_step3","_step3$value","_res","indentSize","Number","isInteger","JSON","lines","vd","tagNames","unshift","repeat","chompKeep","contentComment","forceBlockIndent","wrapScalars","_YAMLDocument","_super","call","parseAllDocuments","src","stream","cstDoc","parseDocument","cst","errMsg","warning","String","YAML","parseCST"],"mappings":"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","sourcesContent":["import { d as defaultTagPrefix, _ as _createForOfIteratorHelper, a as _typeof, b as _createClass, c as _classCallCheck, e as _defineProperty, Y as YAMLSyntaxError, T as Type, f as YAMLWarning, g as YAMLSemanticError, h as _slicedToArray, i as YAMLError, j as _inherits, k as _createSuper } from './PlainValue-b8036b75.js';\nimport { parse as parse$1 } from './parse-cst.js';\nimport { b as binaryOptions, a as boolOptions, i as intOptions, n as nullOptions, s as strOptions, N as Node, P as Pair, S as Scalar, c as stringifyString, A as Alias, Y as YAMLSeq, d as YAMLMap, M as Merge, C as Collection, r as resolveNode, e as isEmptyPath, t as toJSON, f as addComment } from './resolveSeq-492ab440.js';\nimport { S as Schema } from './Schema-e94716c8.js';\nimport { w as warn } from './warnings-df54cb69.js';\n\nvar defaultOptions = {\n  anchorPrefix: 'a',\n  customTags: null,\n  indent: 2,\n  indentSeq: true,\n  keepCstNodes: false,\n  keepNodeTypes: true,\n  keepBlobsInJSON: true,\n  mapAsMap: false,\n  maxAliasCount: 100,\n  prettyErrors: false,\n  // TODO Set true in v2\n  simpleKeys: false,\n  version: '1.2'\n};\nvar scalarOptions = {\n  get binary() {\n    return binaryOptions;\n  },\n\n  set binary(opt) {\n    Object.assign(binaryOptions, opt);\n  },\n\n  get bool() {\n    return boolOptions;\n  },\n\n  set bool(opt) {\n    Object.assign(boolOptions, opt);\n  },\n\n  get int() {\n    return intOptions;\n  },\n\n  set int(opt) {\n    Object.assign(intOptions, opt);\n  },\n\n  get null() {\n    return nullOptions;\n  },\n\n  set null(opt) {\n    Object.assign(nullOptions, opt);\n  },\n\n  get str() {\n    return strOptions;\n  },\n\n  set str(opt) {\n    Object.assign(strOptions, opt);\n  }\n\n};\nvar documentOptions = {\n  '1.0': {\n    schema: 'yaml-1.1',\n    merge: true,\n    tagPrefixes: [{\n      handle: '!',\n      prefix: defaultTagPrefix\n    }, {\n      handle: '!!',\n      prefix: 'tag:private.yaml.org,2002:'\n    }]\n  },\n  1.1: {\n    schema: 'yaml-1.1',\n    merge: true,\n    tagPrefixes: [{\n      handle: '!',\n      prefix: '!'\n    }, {\n      handle: '!!',\n      prefix: defaultTagPrefix\n    }]\n  },\n  1.2: {\n    schema: 'core',\n    merge: false,\n    tagPrefixes: [{\n      handle: '!',\n      prefix: '!'\n    }, {\n      handle: '!!',\n      prefix: defaultTagPrefix\n    }]\n  }\n};\n\nfunction stringifyTag(doc, tag) {\n  if ((doc.version || doc.options.version) === '1.0') {\n    var priv = tag.match(/^tag:private\\.yaml\\.org,2002:([^:/]+)$/);\n    if (priv) return '!' + priv[1];\n    var vocab = tag.match(/^tag:([a-zA-Z0-9-]+)\\.yaml\\.org,2002:(.*)/);\n    return vocab ? \"!\".concat(vocab[1], \"/\").concat(vocab[2]) : \"!\".concat(tag.replace(/^tag:/, ''));\n  }\n\n  var p = doc.tagPrefixes.find(function (p) {\n    return tag.indexOf(p.prefix) === 0;\n  });\n\n  if (!p) {\n    var dtp = doc.getDefaults().tagPrefixes;\n    p = dtp && dtp.find(function (p) {\n      return tag.indexOf(p.prefix) === 0;\n    });\n  }\n\n  if (!p) return tag[0] === '!' ? tag : \"!<\".concat(tag, \">\");\n  var suffix = tag.substr(p.prefix.length).replace(/[!,[\\]{}]/g, function (ch) {\n    return {\n      '!': '%21',\n      ',': '%2C',\n      '[': '%5B',\n      ']': '%5D',\n      '{': '%7B',\n      '}': '%7D'\n    }[ch];\n  });\n  return p.handle + suffix;\n}\n\nfunction getTagObject(tags, item) {\n  if (item instanceof Alias) return Alias;\n\n  if (item.tag) {\n    var match = tags.filter(function (t) {\n      return t.tag === item.tag;\n    });\n    if (match.length > 0) return match.find(function (t) {\n      return t.format === item.format;\n    }) || match[0];\n  }\n\n  var tagObj, obj;\n\n  if (item instanceof Scalar) {\n    obj = item.value; // TODO: deprecate/remove class check\n\n    var _match = tags.filter(function (t) {\n      return t.identify && t.identify(obj) || t.class && obj instanceof t.class;\n    });\n\n    tagObj = _match.find(function (t) {\n      return t.format === item.format;\n    }) || _match.find(function (t) {\n      return !t.format;\n    });\n  } else {\n    obj = item;\n    tagObj = tags.find(function (t) {\n      return t.nodeClass && obj instanceof t.nodeClass;\n    });\n  }\n\n  if (!tagObj) {\n    var name = obj && obj.constructor ? obj.constructor.name : _typeof(obj);\n    throw new Error(\"Tag not resolved for \".concat(name, \" value\"));\n  }\n\n  return tagObj;\n} // needs to be called before value stringifier to allow for circular anchor refs\n\n\nfunction stringifyProps(node, tagObj, _ref) {\n  var anchors = _ref.anchors,\n      doc = _ref.doc;\n  var props = [];\n  var anchor = doc.anchors.getName(node);\n\n  if (anchor) {\n    anchors[anchor] = node;\n    props.push(\"&\".concat(anchor));\n  }\n\n  if (node.tag) {\n    props.push(stringifyTag(doc, node.tag));\n  } else if (!tagObj.default) {\n    props.push(stringifyTag(doc, tagObj.tag));\n  }\n\n  return props.join(' ');\n}\n\nfunction stringify$1(item, ctx, onComment, onChompKeep) {\n  var _ctx$doc = ctx.doc,\n      anchors = _ctx$doc.anchors,\n      schema = _ctx$doc.schema;\n  var tagObj;\n\n  if (!(item instanceof Node)) {\n    var createCtx = {\n      aliasNodes: [],\n      onTagObj: function onTagObj(o) {\n        return tagObj = o;\n      },\n      prevObjects: new Map()\n    };\n    item = schema.createNode(item, true, null, createCtx);\n\n    var _iterator = _createForOfIteratorHelper(createCtx.aliasNodes),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var alias = _step.value;\n        alias.source = alias.source.node;\n        var name = anchors.getName(alias.source);\n\n        if (!name) {\n          name = anchors.newName();\n          anchors.map[name] = alias.source;\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n\n  if (item instanceof Pair) return item.toString(ctx, onComment, onChompKeep);\n  if (!tagObj) tagObj = getTagObject(schema.tags, item);\n  var props = stringifyProps(item, tagObj, ctx);\n  if (props.length > 0) ctx.indentAtStart = (ctx.indentAtStart || 0) + props.length + 1;\n  var str = typeof tagObj.stringify === 'function' ? tagObj.stringify(item, ctx, onComment, onChompKeep) : item instanceof Scalar ? stringifyString(item, ctx, onComment, onChompKeep) : item.toString(ctx, onComment, onChompKeep);\n  if (!props) return str;\n  return item instanceof Scalar || str[0] === '{' || str[0] === '[' ? \"\".concat(props, \" \").concat(str) : \"\".concat(props, \"\\n\").concat(ctx.indent).concat(str);\n}\n\nvar Anchors = /*#__PURE__*/function () {\n  function Anchors(prefix) {\n    _classCallCheck(this, Anchors);\n\n    _defineProperty(this, \"map\", Object.create(null));\n\n    this.prefix = prefix;\n  }\n\n  _createClass(Anchors, [{\n    key: \"createAlias\",\n    value: function createAlias(node, name) {\n      this.setAnchor(node, name);\n      return new Alias(node);\n    }\n  }, {\n    key: \"createMergePair\",\n    value: function createMergePair() {\n      var _this = this;\n\n      var merge = new Merge();\n\n      for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {\n        sources[_key] = arguments[_key];\n      }\n\n      merge.value.items = sources.map(function (s) {\n        if (s instanceof Alias) {\n          if (s.source instanceof YAMLMap) return s;\n        } else if (s instanceof YAMLMap) {\n          return _this.createAlias(s);\n        }\n\n        throw new Error('Merge sources must be Map nodes or their Aliases');\n      });\n      return merge;\n    }\n  }, {\n    key: \"getName\",\n    value: function getName(node) {\n      var map = this.map;\n      return Object.keys(map).find(function (a) {\n        return map[a] === node;\n      });\n    }\n  }, {\n    key: \"getNames\",\n    value: function getNames() {\n      return Object.keys(this.map);\n    }\n  }, {\n    key: \"getNode\",\n    value: function getNode(name) {\n      return this.map[name];\n    }\n  }, {\n    key: \"newName\",\n    value: function newName(prefix) {\n      if (!prefix) prefix = this.prefix;\n      var names = Object.keys(this.map);\n\n      for (var i = 1; true; ++i) {\n        var name = \"\".concat(prefix).concat(i);\n        if (!names.includes(name)) return name;\n      }\n    } // During parsing, map & aliases contain CST nodes\n\n  }, {\n    key: \"resolveNodes\",\n    value: function resolveNodes() {\n      var map = this.map,\n          _cstAliases = this._cstAliases;\n      Object.keys(map).forEach(function (a) {\n        map[a] = map[a].resolved;\n      });\n\n      _cstAliases.forEach(function (a) {\n        a.source = a.source.resolved;\n      });\n\n      delete this._cstAliases;\n    }\n  }, {\n    key: \"setAnchor\",\n    value: function setAnchor(node, name) {\n      if (node != null && !Anchors.validAnchorNode(node)) {\n        throw new Error('Anchors may only be set for Scalar, Seq and Map nodes');\n      }\n\n      if (name && /[\\x00-\\x19\\s,[\\]{}]/.test(name)) {\n        throw new Error('Anchor names must not contain whitespace or control characters');\n      }\n\n      var map = this.map;\n      var prev = node && Object.keys(map).find(function (a) {\n        return map[a] === node;\n      });\n\n      if (prev) {\n        if (!name) {\n          return prev;\n        } else if (prev !== name) {\n          delete map[prev];\n          map[name] = node;\n        }\n      } else {\n        if (!name) {\n          if (!node) return null;\n          name = this.newName();\n        }\n\n        map[name] = node;\n      }\n\n      return name;\n    }\n  }], [{\n    key: \"validAnchorNode\",\n    value: function validAnchorNode(node) {\n      return node instanceof Scalar || node instanceof YAMLSeq || node instanceof YAMLMap;\n    }\n  }]);\n\n  return Anchors;\n}();\n\nvar visit = function visit(node, tags) {\n  if (node && _typeof(node) === 'object') {\n    var tag = node.tag;\n\n    if (node instanceof Collection) {\n      if (tag) tags[tag] = true;\n      node.items.forEach(function (n) {\n        return visit(n, tags);\n      });\n    } else if (node instanceof Pair) {\n      visit(node.key, tags);\n      visit(node.value, tags);\n    } else if (node instanceof Scalar) {\n      if (tag) tags[tag] = true;\n    }\n  }\n\n  return tags;\n};\n\nvar listTagNames = function listTagNames(node) {\n  return Object.keys(visit(node, {}));\n};\n\nfunction parseContents(doc, contents) {\n  var comments = {\n    before: [],\n    after: []\n  };\n  var body = undefined;\n  var spaceBefore = false;\n\n  var _iterator = _createForOfIteratorHelper(contents),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var node = _step.value;\n\n      if (node.valueRange) {\n        if (body !== undefined) {\n          var msg = 'Document contains trailing content not separated by a ... or --- line';\n          doc.errors.push(new YAMLSyntaxError(node, msg));\n          break;\n        }\n\n        var res = resolveNode(doc, node);\n\n        if (spaceBefore) {\n          res.spaceBefore = true;\n          spaceBefore = false;\n        }\n\n        body = res;\n      } else if (node.comment !== null) {\n        var cc = body === undefined ? comments.before : comments.after;\n        cc.push(node.comment);\n      } else if (node.type === Type.BLANK_LINE) {\n        spaceBefore = true;\n\n        if (body === undefined && comments.before.length > 0 && !doc.commentBefore) {\n          // space-separated comments at start are parsed as document comments\n          doc.commentBefore = comments.before.join('\\n');\n          comments.before = [];\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  doc.contents = body || null;\n\n  if (!body) {\n    doc.comment = comments.before.concat(comments.after).join('\\n') || null;\n  } else {\n    var cb = comments.before.join('\\n');\n\n    if (cb) {\n      var cbNode = body instanceof Collection && body.items[0] ? body.items[0] : body;\n      cbNode.commentBefore = cbNode.commentBefore ? \"\".concat(cb, \"\\n\").concat(cbNode.commentBefore) : cb;\n    }\n\n    doc.comment = comments.after.join('\\n') || null;\n  }\n}\n\nfunction resolveTagDirective(_ref, directive) {\n  var tagPrefixes = _ref.tagPrefixes;\n\n  var _directive$parameters = _slicedToArray(directive.parameters, 2),\n      handle = _directive$parameters[0],\n      prefix = _directive$parameters[1];\n\n  if (!handle || !prefix) {\n    var msg = 'Insufficient parameters given for %TAG directive';\n    throw new YAMLSemanticError(directive, msg);\n  }\n\n  if (tagPrefixes.some(function (p) {\n    return p.handle === handle;\n  })) {\n    var _msg = 'The %TAG directive must only be given at most once per handle in the same document.';\n    throw new YAMLSemanticError(directive, _msg);\n  }\n\n  return {\n    handle: handle,\n    prefix: prefix\n  };\n}\n\nfunction resolveYamlDirective(doc, directive) {\n  var _directive$parameters2 = _slicedToArray(directive.parameters, 1),\n      version = _directive$parameters2[0];\n\n  if (directive.name === 'YAML:1.0') version = '1.0';\n\n  if (!version) {\n    var msg = 'Insufficient parameters given for %YAML directive';\n    throw new YAMLSemanticError(directive, msg);\n  }\n\n  if (!documentOptions[version]) {\n    var v0 = doc.version || doc.options.version;\n\n    var _msg2 = \"Document will be parsed as YAML \".concat(v0, \" rather than YAML \").concat(version);\n\n    doc.warnings.push(new YAMLWarning(directive, _msg2));\n  }\n\n  return version;\n}\n\nfunction parseDirectives(doc, directives, prevDoc) {\n  var directiveComments = [];\n  var hasDirectives = false;\n\n  var _iterator = _createForOfIteratorHelper(directives),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var directive = _step.value;\n      var comment = directive.comment,\n          name = directive.name;\n\n      switch (name) {\n        case 'TAG':\n          try {\n            doc.tagPrefixes.push(resolveTagDirective(doc, directive));\n          } catch (error) {\n            doc.errors.push(error);\n          }\n\n          hasDirectives = true;\n          break;\n\n        case 'YAML':\n        case 'YAML:1.0':\n          if (doc.version) {\n            var msg = 'The %YAML directive must only be given at most once per document.';\n            doc.errors.push(new YAMLSemanticError(directive, msg));\n          }\n\n          try {\n            doc.version = resolveYamlDirective(doc, directive);\n          } catch (error) {\n            doc.errors.push(error);\n          }\n\n          hasDirectives = true;\n          break;\n\n        default:\n          if (name) {\n            var _msg3 = \"YAML only supports %TAG and %YAML directives, and not %\".concat(name);\n\n            doc.warnings.push(new YAMLWarning(directive, _msg3));\n          }\n\n      }\n\n      if (comment) directiveComments.push(comment);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  if (prevDoc && !hasDirectives && '1.1' === (doc.version || prevDoc.version || doc.options.version)) {\n    var copyTagPrefix = function copyTagPrefix(_ref2) {\n      var handle = _ref2.handle,\n          prefix = _ref2.prefix;\n      return {\n        handle: handle,\n        prefix: prefix\n      };\n    };\n\n    doc.tagPrefixes = prevDoc.tagPrefixes.map(copyTagPrefix);\n    doc.version = prevDoc.version;\n  }\n\n  doc.commentBefore = directiveComments.join('\\n') || null;\n}\n\nfunction assertCollection(contents) {\n  if (contents instanceof Collection) return true;\n  throw new Error('Expected a YAML collection as document contents');\n}\n\nvar Document$1 = /*#__PURE__*/function () {\n  function Document(options) {\n    _classCallCheck(this, Document);\n\n    this.anchors = new Anchors(options.anchorPrefix);\n    this.commentBefore = null;\n    this.comment = null;\n    this.contents = null;\n    this.directivesEndMarker = null;\n    this.errors = [];\n    this.options = options;\n    this.schema = null;\n    this.tagPrefixes = [];\n    this.version = null;\n    this.warnings = [];\n  }\n\n  _createClass(Document, [{\n    key: \"add\",\n    value: function add(value) {\n      assertCollection(this.contents);\n      return this.contents.add(value);\n    }\n  }, {\n    key: \"addIn\",\n    value: function addIn(path, value) {\n      assertCollection(this.contents);\n      this.contents.addIn(path, value);\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(key) {\n      assertCollection(this.contents);\n      return this.contents.delete(key);\n    }\n  }, {\n    key: \"deleteIn\",\n    value: function deleteIn(path) {\n      if (isEmptyPath(path)) {\n        if (this.contents == null) return false;\n        this.contents = null;\n        return true;\n      }\n\n      assertCollection(this.contents);\n      return this.contents.deleteIn(path);\n    }\n  }, {\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Document.defaults[this.version] || Document.defaults[this.options.version] || {};\n    }\n  }, {\n    key: \"get\",\n    value: function get(key, keepScalar) {\n      return this.contents instanceof Collection ? this.contents.get(key, keepScalar) : undefined;\n    }\n  }, {\n    key: \"getIn\",\n    value: function getIn(path, keepScalar) {\n      if (isEmptyPath(path)) return !keepScalar && this.contents instanceof Scalar ? this.contents.value : this.contents;\n      return this.contents instanceof Collection ? this.contents.getIn(path, keepScalar) : undefined;\n    }\n  }, {\n    key: \"has\",\n    value: function has(key) {\n      return this.contents instanceof Collection ? this.contents.has(key) : false;\n    }\n  }, {\n    key: \"hasIn\",\n    value: function hasIn(path) {\n      if (isEmptyPath(path)) return this.contents !== undefined;\n      return this.contents instanceof Collection ? this.contents.hasIn(path) : false;\n    }\n  }, {\n    key: \"set\",\n    value: function set(key, value) {\n      assertCollection(this.contents);\n      this.contents.set(key, value);\n    }\n  }, {\n    key: \"setIn\",\n    value: function setIn(path, value) {\n      if (isEmptyPath(path)) this.contents = value;else {\n        assertCollection(this.contents);\n        this.contents.setIn(path, value);\n      }\n    }\n  }, {\n    key: \"setSchema\",\n    value: function setSchema(id, customTags) {\n      if (!id && !customTags && this.schema) return;\n      if (typeof id === 'number') id = id.toFixed(1);\n\n      if (id === '1.0' || id === '1.1' || id === '1.2') {\n        if (this.version) this.version = id;else this.options.version = id;\n        delete this.options.schema;\n      } else if (id && typeof id === 'string') {\n        this.options.schema = id;\n      }\n\n      if (Array.isArray(customTags)) this.options.customTags = customTags;\n      var opt = Object.assign({}, this.getDefaults(), this.options);\n      this.schema = new Schema(opt);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(node, prevDoc) {\n      if (this.options.keepCstNodes) this.cstNode = node;\n      if (this.options.keepNodeTypes) this.type = 'DOCUMENT';\n      var _node$directives = node.directives,\n          directives = _node$directives === void 0 ? [] : _node$directives,\n          _node$contents = node.contents,\n          contents = _node$contents === void 0 ? [] : _node$contents,\n          directivesEndMarker = node.directivesEndMarker,\n          error = node.error,\n          valueRange = node.valueRange;\n\n      if (error) {\n        if (!error.source) error.source = this;\n        this.errors.push(error);\n      }\n\n      parseDirectives(this, directives, prevDoc);\n      if (directivesEndMarker) this.directivesEndMarker = true;\n      this.range = valueRange ? [valueRange.start, valueRange.end] : null;\n      this.setSchema();\n      this.anchors._cstAliases = [];\n      parseContents(this, contents);\n      this.anchors.resolveNodes();\n\n      if (this.options.prettyErrors) {\n        var _iterator = _createForOfIteratorHelper(this.errors),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var _error = _step.value;\n            if (_error instanceof YAMLError) _error.makePretty();\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        var _iterator2 = _createForOfIteratorHelper(this.warnings),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var warn = _step2.value;\n            if (warn instanceof YAMLError) warn.makePretty();\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"listNonDefaultTags\",\n    value: function listNonDefaultTags() {\n      return listTagNames(this.contents).filter(function (t) {\n        return t.indexOf(Schema.defaultPrefix) !== 0;\n      });\n    }\n  }, {\n    key: \"setTagPrefix\",\n    value: function setTagPrefix(handle, prefix) {\n      if (handle[0] !== '!' || handle[handle.length - 1] !== '!') throw new Error('Handle must start and end with !');\n\n      if (prefix) {\n        var prev = this.tagPrefixes.find(function (p) {\n          return p.handle === handle;\n        });\n        if (prev) prev.prefix = prefix;else this.tagPrefixes.push({\n          handle: handle,\n          prefix: prefix\n        });\n      } else {\n        this.tagPrefixes = this.tagPrefixes.filter(function (p) {\n          return p.handle !== handle;\n        });\n      }\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON$1(arg, onAnchor) {\n      var _this = this;\n\n      var _this$options = this.options,\n          keepBlobsInJSON = _this$options.keepBlobsInJSON,\n          mapAsMap = _this$options.mapAsMap,\n          maxAliasCount = _this$options.maxAliasCount;\n      var keep = keepBlobsInJSON && (typeof arg !== 'string' || !(this.contents instanceof Scalar));\n      var ctx = {\n        doc: this,\n        indentStep: '  ',\n        keep: keep,\n        mapAsMap: keep && !!mapAsMap,\n        maxAliasCount: maxAliasCount,\n        stringify: stringify$1 // Requiring directly in Pair would create circular dependencies\n\n      };\n      var anchorNames = Object.keys(this.anchors.map);\n      if (anchorNames.length > 0) ctx.anchors = new Map(anchorNames.map(function (name) {\n        return [_this.anchors.map[name], {\n          alias: [],\n          aliasCount: 0,\n          count: 1\n        }];\n      }));\n\n      var res = toJSON(this.contents, arg, ctx);\n\n      if (typeof onAnchor === 'function' && ctx.anchors) {\n        var _iterator3 = _createForOfIteratorHelper(ctx.anchors.values()),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var _step3$value = _step3.value,\n                count = _step3$value.count,\n                _res = _step3$value.res;\n            onAnchor(_res, count);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      }\n\n      return res;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      if (this.errors.length > 0) throw new Error('Document with errors cannot be stringified');\n      var indentSize = this.options.indent;\n\n      if (!Number.isInteger(indentSize) || indentSize <= 0) {\n        var s = JSON.stringify(indentSize);\n        throw new Error(\"\\\"indent\\\" option must be a positive integer, not \".concat(s));\n      }\n\n      this.setSchema();\n      var lines = [];\n      var hasDirectives = false;\n\n      if (this.version) {\n        var vd = '%YAML 1.2';\n\n        if (this.schema.name === 'yaml-1.1') {\n          if (this.version === '1.0') vd = '%YAML:1.0';else if (this.version === '1.1') vd = '%YAML 1.1';\n        }\n\n        lines.push(vd);\n        hasDirectives = true;\n      }\n\n      var tagNames = this.listNonDefaultTags();\n      this.tagPrefixes.forEach(function (_ref) {\n        var handle = _ref.handle,\n            prefix = _ref.prefix;\n\n        if (tagNames.some(function (t) {\n          return t.indexOf(prefix) === 0;\n        })) {\n          lines.push(\"%TAG \".concat(handle, \" \").concat(prefix));\n          hasDirectives = true;\n        }\n      });\n      if (hasDirectives || this.directivesEndMarker) lines.push('---');\n\n      if (this.commentBefore) {\n        if (hasDirectives || !this.directivesEndMarker) lines.unshift('');\n        lines.unshift(this.commentBefore.replace(/^/gm, '#'));\n      }\n\n      var ctx = {\n        anchors: Object.create(null),\n        doc: this,\n        indent: '',\n        indentStep: ' '.repeat(indentSize),\n        stringify: stringify$1 // Requiring directly in nodes would create circular dependencies\n\n      };\n      var chompKeep = false;\n      var contentComment = null;\n\n      if (this.contents) {\n        if (this.contents instanceof Node) {\n          if (this.contents.spaceBefore && (hasDirectives || this.directivesEndMarker)) lines.push('');\n          if (this.contents.commentBefore) lines.push(this.contents.commentBefore.replace(/^/gm, '#')); // top-level block scalars need to be indented if followed by a comment\n\n          ctx.forceBlockIndent = !!this.comment;\n          contentComment = this.contents.comment;\n        }\n\n        var onChompKeep = contentComment ? null : function () {\n          return chompKeep = true;\n        };\n        var body = stringify$1(this.contents, ctx, function () {\n          return contentComment = null;\n        }, onChompKeep);\n        lines.push(addComment(body, '', contentComment));\n      } else if (this.contents !== undefined) {\n        lines.push(stringify$1(this.contents, ctx));\n      }\n\n      if (this.comment) {\n        if ((!chompKeep || contentComment) && lines[lines.length - 1] !== '') lines.push('');\n        lines.push(this.comment.replace(/^/gm, '#'));\n      }\n\n      return lines.join('\\n') + '\\n';\n    }\n  }]);\n\n  return Document;\n}();\n\n_defineProperty(Document$1, \"defaults\", documentOptions);\n\nfunction createNode(value) {\n  var wrapScalars = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var tag = arguments.length > 2 ? arguments[2] : undefined;\n\n  if (tag === undefined && typeof wrapScalars === 'string') {\n    tag = wrapScalars;\n    wrapScalars = true;\n  }\n\n  var options = Object.assign({}, Document$1.defaults[defaultOptions.version], defaultOptions);\n  var schema = new Schema(options);\n  return schema.createNode(value, wrapScalars, tag);\n}\n\nvar Document = /*#__PURE__*/function (_YAMLDocument) {\n  _inherits(Document, _YAMLDocument);\n\n  var _super = _createSuper(Document);\n\n  function Document(options) {\n    _classCallCheck(this, Document);\n\n    return _super.call(this, Object.assign({}, defaultOptions, options));\n  }\n\n  return Document;\n}(Document$1);\n\nfunction parseAllDocuments(src, options) {\n  var stream = [];\n  var prev;\n\n  var _iterator = _createForOfIteratorHelper(parse$1(src)),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var cstDoc = _step.value;\n      var doc = new Document(options);\n      doc.parse(cstDoc, prev);\n      stream.push(doc);\n      prev = doc;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return stream;\n}\n\nfunction parseDocument(src, options) {\n  var cst = parse$1(src);\n  var doc = new Document(options).parse(cst[0]);\n\n  if (cst.length > 1) {\n    var errMsg = 'Source contains multiple documents; please use YAML.parseAllDocuments()';\n    doc.errors.unshift(new YAMLSemanticError(cst[1], errMsg));\n  }\n\n  return doc;\n}\n\nfunction parse(src, options) {\n  var doc = parseDocument(src, options);\n  doc.warnings.forEach(function (warning) {\n    return warn(warning);\n  });\n  if (doc.errors.length > 0) throw doc.errors[0];\n  return doc.toJSON();\n}\n\nfunction stringify(value, options) {\n  var doc = new Document(options);\n  doc.contents = value;\n  return String(doc);\n}\n\nvar YAML = {\n  createNode: createNode,\n  defaultOptions: defaultOptions,\n  Document: Document,\n  parse: parse,\n  parseAllDocuments: parseAllDocuments,\n  parseCST: parse$1,\n  parseDocument: parseDocument,\n  scalarOptions: scalarOptions,\n  stringify: stringify\n};\n\nexport { YAML };\n"]},"metadata":{},"sourceType":"module"}