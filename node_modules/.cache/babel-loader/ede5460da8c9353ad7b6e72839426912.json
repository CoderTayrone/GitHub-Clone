{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.generateResponseValidator = exports.generateRequestValidator = exports._filterRequiredProperties = exports._fixNullables = void 0;\n\nconst ajv_1 = __importDefault(require(\"ajv\"));\n\nconst json_schema_traverse_1 = __importDefault(require(\"json-schema-traverse\"));\n\nconst json_schema_resolve_ref_1 = require(\"../../utils/json-schema-resolve-ref\");\n\nconst jsonPaths = __importStar(require(\"../../utils/jsonPaths\"));\n\nconst jsonSchema = __importStar(require(\"../../utils/jsonSchema\"));\n\nconst mime_1 = require(\"../../utils/mime\"); // urlencoded and form-data requests do not contain any type information;\n// for example `?foo=9` doesn't tell us if `foo` is the number 9, or the string\n// \"9\", so we need to use type coercion to make sure the data passed in matches\n// our schema.\n\n\nconst REQUEST_TYPE_COERCION_ALLOWED = new mime_1.MimeTypeRegistry({\n  'application/x-www-form-urlencoded': true,\n  'multipart/form-data': true\n}); // TODO tests\n// * readOnly\n// * readOnly with additionalProperties and value supplied\n// * readOnly not supplied but required\n// * writeOnly (all cases as readOnly)\n// * Make sure validation errors are correct format.\n\nfunction assertNever(x) {\n  throw new Error('Unexpected object: ' + x);\n}\n\nfunction getParameterDescription(parameterLocation) {\n  let description = '';\n\n  switch (parameterLocation.in) {\n    case 'path':\n    case 'server':\n    case 'query':\n    case 'cookie':\n    case 'header':\n      description = `${parameterLocation.in} parameter \"${parameterLocation.name}\"`;\n      break;\n\n    case 'request':\n    case 'response':\n      description = `${parameterLocation.in} body`;\n      break;\n\n    default:\n      assertNever(parameterLocation.in);\n  }\n\n  return description;\n}\n\nfunction addCustomFormats(ajv, customFormats) {\n  return Object.keys(customFormats).reduce((result, key) => {\n    const customFormat = customFormats[key];\n\n    if (typeof customFormat === 'function' || customFormat instanceof RegExp) {\n      result[key] = {\n        type: 'string',\n        validate: customFormat\n      };\n    } else if (customFormat.type === 'string') {\n      result[key] = {\n        type: 'string',\n        validate: customFormat.validate\n      };\n    } else if (customFormat.type === 'number') {\n      result[key] = {\n        type: 'number',\n        validate: customFormat.validate\n      };\n    }\n\n    ajv.addFormat(key, result[key]);\n    return result;\n  }, {});\n}\n\nfunction removeExamples(schema) {\n  // ajv will print \"schema id ignored\" to stdout if an example contains a filed\n  // named \"id\", so just axe all the examples.\n  json_schema_traverse_1.default(schema, childSchema => {\n    if (childSchema.example) {\n      delete childSchema.example;\n    }\n  });\n}\n\nfunction _fixNullables(schema) {\n  json_schema_traverse_1.default(schema, {\n    cb: {\n      post: (childSchema, _jsonPtr, rootSchema, _parentJsonPtr, parentKeyword, _parentSchema, keyIndex) => {\n        if (childSchema.nullable) {\n          let ref = rootSchema;\n          let key = parentKeyword;\n\n          if (key && keyIndex) {\n            ref = ref[key];\n            key = `${keyIndex}`;\n          }\n\n          if (ref && key) {\n            ref[key] = {\n              anyOf: [{\n                type: 'null'\n              }, childSchema]\n            };\n          } else if (childSchema === schema) {\n            schema = {\n              anyOf: [{\n                type: 'null'\n              }, schema]\n            };\n          }\n        }\n      }\n    }\n  });\n  return schema;\n}\n\nexports._fixNullables = _fixNullables;\n\nfunction _filterRequiredProperties(schema, propNameToFilter) {\n  json_schema_traverse_1.default(schema, childSchema => {\n    if (childSchema.properties && childSchema.required) {\n      for (const propName of Object.keys(childSchema.properties)) {\n        const prop = childSchema.properties[propName]; // Resolve the prop, in case it's a `{$ref: ....}`.\n\n        const resolvedProp = json_schema_resolve_ref_1.resolveRef(schema, prop);\n\n        if (resolvedProp && resolvedProp[propNameToFilter]) {\n          childSchema.required = childSchema.required.filter(r => r !== propName);\n        }\n      }\n    }\n  });\n}\n\nexports._filterRequiredProperties = _filterRequiredProperties;\n\nfunction doValidate(schemaPtr, parameterLocation, parameterRequired, ajvValidate, json) {\n  const value = {\n    value: json\n  };\n  let errors = null;\n\n  if (json === null || json === undefined) {\n    if (parameterRequired) {\n      errors = [{\n        message: `Missing required ${getParameterDescription(parameterLocation)}`,\n        location: {\n          in: parameterLocation.in,\n          name: parameterLocation.name,\n          // docPath comes from parameter here, not schema, since the parameter\n          // is the one that defines it is required.\n          docPath: parameterLocation.docPath,\n          path: ''\n        }\n      }];\n    }\n  }\n\n  if (!errors) {\n    ajvValidate(value);\n\n    if (ajvValidate.errors) {\n      errors = ajvValidate.errors.map(err => {\n        let pathPtr = err.dataPath || '';\n\n        if (pathPtr.startsWith('/value')) {\n          pathPtr = pathPtr.slice(6);\n        }\n\n        return {\n          message: err.message || 'Unspecified error',\n          location: {\n            in: parameterLocation.in,\n            name: parameterLocation.name,\n            docPath: schemaPtr,\n            path: pathPtr\n          },\n          ajvError: err\n        };\n      });\n    }\n  }\n\n  return {\n    errors,\n    value: value.value\n  };\n}\n\nfunction generateValidator(schemaContext, parameterLocation, parameterRequired, propNameToFilter, allowTypeCoercion) {\n  const {\n    openApiDoc,\n    jsonPointer: schemaPtr\n  } = schemaContext;\n  const customFormats = schemaContext.options.customFormats;\n  let schema = jsonSchema.extractSchema(openApiDoc, schemaPtr);\n\n  _filterRequiredProperties(schema, propNameToFilter);\n\n  removeExamples(schema); // TODO: Should we do this?  Or should we rely on the schema being correct in the first place?\n  // schema = _fixNullables(schema);\n  // So that we can replace the \"root\" value of the schema using ajv's type coercion...\n\n  json_schema_traverse_1.default(schema, node => {\n    if (node.$ref) {\n      if (node.$ref.startsWith('#')) {\n        node.$ref = `#/properties/value/${node.$ref.slice(2)}`;\n      } else {\n        node.$ref = jsonPaths.toUriFragment(`/properties/value/${node.$ref.slice(1)}`);\n      }\n    }\n  });\n  schema = {\n    type: 'object',\n    properties: {\n      value: schema\n    }\n  };\n  const ajv = new ajv_1.default({\n    useDefaults: true,\n    coerceTypes: allowTypeCoercion ? 'array' : false,\n    removeAdditional: allowTypeCoercion ? 'failing' : false,\n    jsonPointers: true,\n    nullable: true,\n    allErrors: schemaContext.options.allErrors\n  });\n  addCustomFormats(ajv, customFormats);\n  const validate = ajv.compile(schema);\n  return function (json) {\n    return doValidate(schemaPtr, parameterLocation, parameterRequired, validate, json);\n  };\n}\n\nfunction generateRequestValidator(schemaContext, parameterLocation, parameterRequired, mediaType) {\n  const allowTypeCoercion = mediaType ? REQUEST_TYPE_COERCION_ALLOWED.get(mediaType) || false : false;\n  return generateValidator(schemaContext, parameterLocation, parameterRequired, 'readOnly', allowTypeCoercion);\n}\n\nexports.generateRequestValidator = generateRequestValidator;\n\nfunction generateResponseValidator(schemaContext, parameterLocation, parameterRequired) {\n  return generateValidator(schemaContext, parameterLocation, parameterRequired, 'writeOnly', false);\n}\n\nexports.generateResponseValidator = generateResponseValidator;","map":{"version":3,"sources":["../../../src/oas3/Schema/validators.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.generateResponseValidator = exports.generateRequestValidator = exports._filterRequiredProperties = exports._fixNullables = void 0;\nconst ajv_1 = __importDefault(require(\"ajv\"));\nconst json_schema_traverse_1 = __importDefault(require(\"json-schema-traverse\"));\nconst json_schema_resolve_ref_1 = require(\"../../utils/json-schema-resolve-ref\");\nconst jsonPaths = __importStar(require(\"../../utils/jsonPaths\"));\nconst jsonSchema = __importStar(require(\"../../utils/jsonSchema\"));\nconst mime_1 = require(\"../../utils/mime\");\n// urlencoded and form-data requests do not contain any type information;\n// for example `?foo=9` doesn't tell us if `foo` is the number 9, or the string\n// \"9\", so we need to use type coercion to make sure the data passed in matches\n// our schema.\nconst REQUEST_TYPE_COERCION_ALLOWED = new mime_1.MimeTypeRegistry({\n    'application/x-www-form-urlencoded': true,\n    'multipart/form-data': true,\n});\n// TODO tests\n// * readOnly\n// * readOnly with additionalProperties and value supplied\n// * readOnly not supplied but required\n// * writeOnly (all cases as readOnly)\n// * Make sure validation errors are correct format.\nfunction assertNever(x) {\n    throw new Error('Unexpected object: ' + x);\n}\nfunction getParameterDescription(parameterLocation) {\n    let description = '';\n    switch (parameterLocation.in) {\n        case 'path':\n        case 'server':\n        case 'query':\n        case 'cookie':\n        case 'header':\n            description = `${parameterLocation.in} parameter \"${parameterLocation.name}\"`;\n            break;\n        case 'request':\n        case 'response':\n            description = `${parameterLocation.in} body`;\n            break;\n        default:\n            assertNever(parameterLocation.in);\n    }\n    return description;\n}\nfunction addCustomFormats(ajv, customFormats) {\n    return Object.keys(customFormats).reduce((result, key) => {\n        const customFormat = customFormats[key];\n        if (typeof customFormat === 'function' || customFormat instanceof RegExp) {\n            result[key] = { type: 'string', validate: customFormat };\n        }\n        else if (customFormat.type === 'string') {\n            result[key] = { type: 'string', validate: customFormat.validate };\n        }\n        else if (customFormat.type === 'number') {\n            result[key] = { type: 'number', validate: customFormat.validate };\n        }\n        ajv.addFormat(key, result[key]);\n        return result;\n    }, {});\n}\nfunction removeExamples(schema) {\n    // ajv will print \"schema id ignored\" to stdout if an example contains a filed\n    // named \"id\", so just axe all the examples.\n    json_schema_traverse_1.default(schema, (childSchema) => {\n        if (childSchema.example) {\n            delete childSchema.example;\n        }\n    });\n}\nfunction _fixNullables(schema) {\n    json_schema_traverse_1.default(schema, {\n        cb: {\n            post: (childSchema, _jsonPtr, rootSchema, _parentJsonPtr, parentKeyword, _parentSchema, keyIndex) => {\n                if (childSchema.nullable) {\n                    let ref = rootSchema;\n                    let key = parentKeyword;\n                    if (key && keyIndex) {\n                        ref = ref[key];\n                        key = `${keyIndex}`;\n                    }\n                    if (ref && key) {\n                        ref[key] = {\n                            anyOf: [{ type: 'null' }, childSchema],\n                        };\n                    }\n                    else if (childSchema === schema) {\n                        schema = {\n                            anyOf: [{ type: 'null' }, schema],\n                        };\n                    }\n                }\n            },\n        },\n    });\n    return schema;\n}\nexports._fixNullables = _fixNullables;\nfunction _filterRequiredProperties(schema, propNameToFilter) {\n    json_schema_traverse_1.default(schema, (childSchema) => {\n        if (childSchema.properties && childSchema.required) {\n            for (const propName of Object.keys(childSchema.properties)) {\n                const prop = childSchema.properties[propName];\n                // Resolve the prop, in case it's a `{$ref: ....}`.\n                const resolvedProp = json_schema_resolve_ref_1.resolveRef(schema, prop);\n                if (resolvedProp && resolvedProp[propNameToFilter]) {\n                    childSchema.required = childSchema.required.filter((r) => r !== propName);\n                }\n            }\n        }\n    });\n}\nexports._filterRequiredProperties = _filterRequiredProperties;\nfunction doValidate(schemaPtr, parameterLocation, parameterRequired, ajvValidate, json) {\n    const value = { value: json };\n    let errors = null;\n    if (json === null || json === undefined) {\n        if (parameterRequired) {\n            errors = [\n                {\n                    message: `Missing required ${getParameterDescription(parameterLocation)}`,\n                    location: {\n                        in: parameterLocation.in,\n                        name: parameterLocation.name,\n                        // docPath comes from parameter here, not schema, since the parameter\n                        // is the one that defines it is required.\n                        docPath: parameterLocation.docPath,\n                        path: '',\n                    },\n                },\n            ];\n        }\n    }\n    if (!errors) {\n        ajvValidate(value);\n        if (ajvValidate.errors) {\n            errors = ajvValidate.errors.map((err) => {\n                let pathPtr = err.dataPath || '';\n                if (pathPtr.startsWith('/value')) {\n                    pathPtr = pathPtr.slice(6);\n                }\n                return {\n                    message: err.message || 'Unspecified error',\n                    location: {\n                        in: parameterLocation.in,\n                        name: parameterLocation.name,\n                        docPath: schemaPtr,\n                        path: pathPtr,\n                    },\n                    ajvError: err,\n                };\n            });\n        }\n    }\n    return { errors, value: value.value };\n}\nfunction generateValidator(schemaContext, parameterLocation, parameterRequired, propNameToFilter, allowTypeCoercion) {\n    const { openApiDoc, jsonPointer: schemaPtr } = schemaContext;\n    const customFormats = schemaContext.options.customFormats;\n    let schema = jsonSchema.extractSchema(openApiDoc, schemaPtr);\n    _filterRequiredProperties(schema, propNameToFilter);\n    removeExamples(schema);\n    // TODO: Should we do this?  Or should we rely on the schema being correct in the first place?\n    // schema = _fixNullables(schema);\n    // So that we can replace the \"root\" value of the schema using ajv's type coercion...\n    json_schema_traverse_1.default(schema, (node) => {\n        if (node.$ref) {\n            if (node.$ref.startsWith('#')) {\n                node.$ref = `#/properties/value/${node.$ref.slice(2)}`;\n            }\n            else {\n                node.$ref = jsonPaths.toUriFragment(`/properties/value/${node.$ref.slice(1)}`);\n            }\n        }\n    });\n    schema = {\n        type: 'object',\n        properties: {\n            value: schema,\n        },\n    };\n    const ajv = new ajv_1.default({\n        useDefaults: true,\n        coerceTypes: allowTypeCoercion ? 'array' : false,\n        removeAdditional: allowTypeCoercion ? 'failing' : false,\n        jsonPointers: true,\n        nullable: true,\n        allErrors: schemaContext.options.allErrors,\n    });\n    addCustomFormats(ajv, customFormats);\n    const validate = ajv.compile(schema);\n    return function (json) {\n        return doValidate(schemaPtr, parameterLocation, parameterRequired, validate, json);\n    };\n}\nfunction generateRequestValidator(schemaContext, parameterLocation, parameterRequired, mediaType) {\n    const allowTypeCoercion = mediaType\n        ? REQUEST_TYPE_COERCION_ALLOWED.get(mediaType) || false\n        : false;\n    return generateValidator(schemaContext, parameterLocation, parameterRequired, 'readOnly', allowTypeCoercion);\n}\nexports.generateRequestValidator = generateRequestValidator;\nfunction generateResponseValidator(schemaContext, parameterLocation, parameterRequired) {\n    return generateValidator(schemaContext, parameterLocation, parameterRequired, 'writeOnly', false);\n}\nexports.generateResponseValidator = generateResponseValidator;\n//# sourceMappingURL=validators.js.map"]},"metadata":{},"sourceType":"script"}