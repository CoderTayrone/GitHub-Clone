{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst invoke_1 = require(\"../controllers/invoke\");\n\nconst stringToStream_1 = __importDefault(require(\"../utils/stringToStream\"));\n\nconst errors_1 = require(\"../errors\");\n\nconst bufferToStream_1 = __importDefault(require(\"../utils/bufferToStream\"));\n\nconst typeUtils_1 = require(\"../utils/typeUtils\");\n\nconst ExegesisContextImpl_1 = __importDefault(require(\"./ExegesisContextImpl\"));\n\nfunction handleSecurity(operation, context) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const authenticated = yield operation.authenticate(context);\n    context.security = authenticated;\n\n    if (authenticated) {\n      const matchedSchemes = Object.keys(authenticated);\n\n      if (matchedSchemes.length === 1) {\n        context.user = authenticated[matchedSchemes[0]].user;\n      }\n    }\n  });\n}\n\nfunction setDefaultContentType(res) {\n  const body = res.body;\n\n  if (res.headers['content-type']) {// Nothing to do!\n  } else if (body === undefined || body === null) {// Do nothing\n  } else if (body instanceof Buffer) {\n    res.headers['content-type'] = 'text/plain';\n  } else if (typeof body === 'string') {\n    res.headers['content-type'] = 'text/plain';\n  } else if (typeUtils_1.isReadable(body)) {\n    res.headers['content-type'] = 'text/plain';\n  } else {\n    res.headers['content-type'] = 'application/json';\n  }\n}\n\nfunction resultToHttpResponse(context, result) {\n  let output;\n  const headers = context.res.headers;\n\n  if (result) {\n    if (result instanceof Buffer) {\n      output = bufferToStream_1.default(result);\n    } else if (typeof result === 'string') {\n      output = stringToStream_1.default(result);\n    } else if (typeUtils_1.isReadable(result)) {\n      output = result;\n    } else {\n      if (!headers['content-type']) {\n        headers['content-type'] = 'application/json';\n      }\n\n      output = stringToStream_1.default(JSON.stringify(result), 'utf-8');\n    }\n  }\n\n  return {\n    status: context.res.statusCode,\n    headers,\n    body: output\n  };\n}\n\nfunction handleError(err) {\n  if (err instanceof errors_1.ValidationError) {\n    // TODO: Allow customization of validation error?  Or even\n    // just throw the error instead of turning it into a message?\n    const jsonError = {\n      message: 'Validation errors',\n      errors: err.errors.map(error => {\n        return {\n          message: error.message,\n          location: error.location\n        };\n      })\n    };\n    return {\n      status: err.status,\n      headers: {\n        'content-type': 'application/json'\n      },\n      body: stringToStream_1.default(JSON.stringify(jsonError), 'utf-8')\n    };\n  } else if (Number.isInteger(err.status)) {\n    return {\n      status: err.status,\n      headers: {\n        'content-type': 'application/json'\n      },\n      body: stringToStream_1.default(JSON.stringify({\n        message: err.message\n      }), 'utf-8')\n    };\n  } else {\n    throw err;\n  }\n}\n/**\n * Returns a `(req, res) => Promise<boolean>` function, which handles incoming\n * HTTP requests.  The returned function will return true if the request was\n * handled, and false otherwise.\n *\n * @returns runner function.\n */\n\n\nfunction generateExegesisRunner(api, options) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const plugins = options.plugins;\n    return function exegesisRunner(req, res) {\n      return __awaiter(this, void 0, void 0, function* () {\n        const method = req.method || 'get';\n        const url = req.url || '/';\n        let result;\n\n        try {\n          yield plugins.preRouting({\n            req,\n            res\n          });\n          const resolved = api.resolve(method, url, req.headers);\n\n          if (!resolved) {\n            return result;\n          }\n\n          const context = new ExegesisContextImpl_1.default(req, res, resolved.api, options.originalOptions);\n\n          if (!context.isResponseFinished()) {\n            yield plugins.postRouting(context);\n          }\n\n          if (resolved.operation) {\n            const {\n              operation\n            } = resolved;\n\n            context._setOperation(resolved.baseUrl, resolved.path, operation);\n\n            if (!operation.controller) {\n              throw new Error(`No controller found for ${method} ${url}`);\n            }\n\n            yield handleSecurity(operation, context);\n\n            if (!context.isResponseFinished()) {\n              yield plugins.postSecurity(context);\n            }\n\n            if (!context.isResponseFinished()) {\n              // Fill in context.params and context.requestBody.\n              yield context.getParams();\n              yield context.getRequestBody();\n            }\n\n            if (!context.isResponseFinished()) {\n              yield invoke_1.invokeController(operation.controllerModule, operation.controller, context);\n            }\n\n            if (!context.origRes.headersSent) {\n              // Set _afterController to allow postController() plugins to\n              // modify the response.\n              context.res._afterController = true;\n              yield plugins.postController(context);\n            }\n\n            if (!context.origRes.headersSent) {\n              // Before response validation, if there is a body and no\n              // content-type has been set, set a reasonable default.\n              setDefaultContentType(context.res);\n\n              if (options.onResponseValidationError) {\n                const responseValidationResult = resolved.operation.validateResponse(context.res, options.validateDefaultResponses);\n\n                try {\n                  if (responseValidationResult.errors && responseValidationResult.errors.length) {\n                    options.onResponseValidationError({\n                      errors: responseValidationResult.errors,\n                      isDefault: responseValidationResult.isDefault,\n                      context\n                    });\n                  }\n                } catch (err) {\n                  err.status = err.status || 500;\n                  throw err;\n                }\n              }\n\n              yield plugins.postResponseValidation(context);\n            }\n\n            if (!context.origRes.headersSent) {\n              result = resultToHttpResponse(context, context.res.body);\n            }\n          }\n\n          return result;\n        } catch (err) {\n          if (options.autoHandleHttpErrors) {\n            if (options.autoHandleHttpErrors instanceof Function) {\n              return options.autoHandleHttpErrors(err, {\n                req\n              });\n            }\n\n            return handleError(err);\n          } else {\n            throw err;\n          }\n        }\n      });\n    };\n  });\n}\n\nexports.default = generateExegesisRunner;","map":{"version":3,"sources":["../../src/core/exegesisRunner.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst invoke_1 = require(\"../controllers/invoke\");\nconst stringToStream_1 = __importDefault(require(\"../utils/stringToStream\"));\nconst errors_1 = require(\"../errors\");\nconst bufferToStream_1 = __importDefault(require(\"../utils/bufferToStream\"));\nconst typeUtils_1 = require(\"../utils/typeUtils\");\nconst ExegesisContextImpl_1 = __importDefault(require(\"./ExegesisContextImpl\"));\nfunction handleSecurity(operation, context) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const authenticated = yield operation.authenticate(context);\n        context.security = authenticated;\n        if (authenticated) {\n            const matchedSchemes = Object.keys(authenticated);\n            if (matchedSchemes.length === 1) {\n                context.user = authenticated[matchedSchemes[0]].user;\n            }\n        }\n    });\n}\nfunction setDefaultContentType(res) {\n    const body = res.body;\n    if (res.headers['content-type']) {\n        // Nothing to do!\n    }\n    else if (body === undefined || body === null) {\n        // Do nothing\n    }\n    else if (body instanceof Buffer) {\n        res.headers['content-type'] = 'text/plain';\n    }\n    else if (typeof body === 'string') {\n        res.headers['content-type'] = 'text/plain';\n    }\n    else if (typeUtils_1.isReadable(body)) {\n        res.headers['content-type'] = 'text/plain';\n    }\n    else {\n        res.headers['content-type'] = 'application/json';\n    }\n}\nfunction resultToHttpResponse(context, result) {\n    let output;\n    const headers = context.res.headers;\n    if (result) {\n        if (result instanceof Buffer) {\n            output = bufferToStream_1.default(result);\n        }\n        else if (typeof result === 'string') {\n            output = stringToStream_1.default(result);\n        }\n        else if (typeUtils_1.isReadable(result)) {\n            output = result;\n        }\n        else {\n            if (!headers['content-type']) {\n                headers['content-type'] = 'application/json';\n            }\n            output = stringToStream_1.default(JSON.stringify(result), 'utf-8');\n        }\n    }\n    return {\n        status: context.res.statusCode,\n        headers,\n        body: output,\n    };\n}\nfunction handleError(err) {\n    if (err instanceof errors_1.ValidationError) {\n        // TODO: Allow customization of validation error?  Or even\n        // just throw the error instead of turning it into a message?\n        const jsonError = {\n            message: 'Validation errors',\n            errors: err.errors.map((error) => {\n                return {\n                    message: error.message,\n                    location: error.location,\n                };\n            }),\n        };\n        return {\n            status: err.status,\n            headers: { 'content-type': 'application/json' },\n            body: stringToStream_1.default(JSON.stringify(jsonError), 'utf-8'),\n        };\n    }\n    else if (Number.isInteger(err.status)) {\n        return {\n            status: err.status,\n            headers: { 'content-type': 'application/json' },\n            body: stringToStream_1.default(JSON.stringify({ message: err.message }), 'utf-8'),\n        };\n    }\n    else {\n        throw err;\n    }\n}\n/**\n * Returns a `(req, res) => Promise<boolean>` function, which handles incoming\n * HTTP requests.  The returned function will return true if the request was\n * handled, and false otherwise.\n *\n * @returns runner function.\n */\nfunction generateExegesisRunner(api, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const plugins = options.plugins;\n        return function exegesisRunner(req, res) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const method = req.method || 'get';\n                const url = req.url || '/';\n                let result;\n                try {\n                    yield plugins.preRouting({ req, res });\n                    const resolved = api.resolve(method, url, req.headers);\n                    if (!resolved) {\n                        return result;\n                    }\n                    const context = new ExegesisContextImpl_1.default(req, res, resolved.api, options.originalOptions);\n                    if (!context.isResponseFinished()) {\n                        yield plugins.postRouting(context);\n                    }\n                    if (resolved.operation) {\n                        const { operation } = resolved;\n                        context._setOperation(resolved.baseUrl, resolved.path, operation);\n                        if (!operation.controller) {\n                            throw new Error(`No controller found for ${method} ${url}`);\n                        }\n                        yield handleSecurity(operation, context);\n                        if (!context.isResponseFinished()) {\n                            yield plugins.postSecurity(context);\n                        }\n                        if (!context.isResponseFinished()) {\n                            // Fill in context.params and context.requestBody.\n                            yield context.getParams();\n                            yield context.getRequestBody();\n                        }\n                        if (!context.isResponseFinished()) {\n                            yield invoke_1.invokeController(operation.controllerModule, operation.controller, context);\n                        }\n                        if (!context.origRes.headersSent) {\n                            // Set _afterController to allow postController() plugins to\n                            // modify the response.\n                            context.res._afterController = true;\n                            yield plugins.postController(context);\n                        }\n                        if (!context.origRes.headersSent) {\n                            // Before response validation, if there is a body and no\n                            // content-type has been set, set a reasonable default.\n                            setDefaultContentType(context.res);\n                            if (options.onResponseValidationError) {\n                                const responseValidationResult = resolved.operation.validateResponse(context.res, options.validateDefaultResponses);\n                                try {\n                                    if (responseValidationResult.errors &&\n                                        responseValidationResult.errors.length) {\n                                        options.onResponseValidationError({\n                                            errors: responseValidationResult.errors,\n                                            isDefault: responseValidationResult.isDefault,\n                                            context,\n                                        });\n                                    }\n                                }\n                                catch (err) {\n                                    err.status = err.status || 500;\n                                    throw err;\n                                }\n                            }\n                            yield plugins.postResponseValidation(context);\n                        }\n                        if (!context.origRes.headersSent) {\n                            result = resultToHttpResponse(context, context.res.body);\n                        }\n                    }\n                    return result;\n                }\n                catch (err) {\n                    if (options.autoHandleHttpErrors) {\n                        if (options.autoHandleHttpErrors instanceof Function) {\n                            return options.autoHandleHttpErrors(err, { req });\n                        }\n                        return handleError(err);\n                    }\n                    else {\n                        throw err;\n                    }\n                }\n            });\n        };\n    });\n}\nexports.default = generateExegesisRunner;\n//# sourceMappingURL=exegesisRunner.js.map"]},"metadata":{},"sourceType":"script"}