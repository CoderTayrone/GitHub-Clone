{"ast":null,"code":"'use strict'; // the PEND/UNPEND stuff tracks whether we're ready to emit end/close yet.\n// but the path reservations are required to avoid race conditions where\n// parallelized unpack ops may mess with one another, due to dependencies\n// (like a Link depending on its target) or destructive operations (like\n// clobbering an fs object to create one of a different type.)\n\nconst assert = require('assert');\n\nconst EE = require('events').EventEmitter;\n\nconst Parser = require('./parse.js');\n\nconst fs = require('fs');\n\nconst fsm = require('fs-minipass');\n\nconst path = require('path');\n\nconst mkdir = require('./mkdir.js');\n\nconst mkdirSync = mkdir.sync;\n\nconst wc = require('./winchars.js');\n\nconst stripAbsolutePath = require('./strip-absolute-path.js');\n\nconst pathReservations = require('./path-reservations.js');\n\nconst normPath = require('./normalize-windows-path.js');\n\nconst stripSlash = require('./strip-trailing-slashes.js');\n\nconst ONENTRY = Symbol('onEntry');\nconst CHECKFS = Symbol('checkFs');\nconst CHECKFS2 = Symbol('checkFs2');\nconst PRUNECACHE = Symbol('pruneCache');\nconst ISREUSABLE = Symbol('isReusable');\nconst MAKEFS = Symbol('makeFs');\nconst FILE = Symbol('file');\nconst DIRECTORY = Symbol('directory');\nconst LINK = Symbol('link');\nconst SYMLINK = Symbol('symlink');\nconst HARDLINK = Symbol('hardlink');\nconst UNSUPPORTED = Symbol('unsupported');\nconst UNKNOWN = Symbol('unknown');\nconst CHECKPATH = Symbol('checkPath');\nconst MKDIR = Symbol('mkdir');\nconst ONERROR = Symbol('onError');\nconst PENDING = Symbol('pending');\nconst PEND = Symbol('pend');\nconst UNPEND = Symbol('unpend');\nconst ENDED = Symbol('ended');\nconst MAYBECLOSE = Symbol('maybeClose');\nconst SKIP = Symbol('skip');\nconst DOCHOWN = Symbol('doChown');\nconst UID = Symbol('uid');\nconst GID = Symbol('gid');\nconst CHECKED_CWD = Symbol('checkedCwd');\n\nconst crypto = require('crypto');\n\nconst platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;\nconst isWindows = platform === 'win32'; // Unlinks on Windows are not atomic.\n//\n// This means that if you have a file entry, followed by another\n// file entry with an identical name, and you cannot re-use the file\n// (because it's a hardlink, or because unlink:true is set, or it's\n// Windows, which does not have useful nlink values), then the unlink\n// will be committed to the disk AFTER the new file has been written\n// over the old one, deleting the new file.\n//\n// To work around this, on Windows systems, we rename the file and then\n// delete the renamed file.  It's a sloppy kludge, but frankly, I do not\n// know of a better way to do this, given windows' non-atomic unlink\n// semantics.\n//\n// See: https://github.com/npm/node-tar/issues/183\n\n/* istanbul ignore next */\n\nconst unlinkFile = (path, cb) => {\n  if (!isWindows) return fs.unlink(path, cb);\n  const name = path + '.DELETE.' + crypto.randomBytes(16).toString('hex');\n  fs.rename(path, name, er => {\n    if (er) return cb(er);\n    fs.unlink(name, cb);\n  });\n};\n/* istanbul ignore next */\n\n\nconst unlinkFileSync = path => {\n  if (!isWindows) return fs.unlinkSync(path);\n  const name = path + '.DELETE.' + crypto.randomBytes(16).toString('hex');\n  fs.renameSync(path, name);\n  fs.unlinkSync(name);\n}; // this.gid, entry.gid, this.processUid\n\n\nconst uint32 = (a, b, c) => a === a >>> 0 ? a : b === b >>> 0 ? b : c; // clear the cache if it's a case-insensitive unicode-squashing match.\n// we can't know if the current file system is case-sensitive or supports\n// unicode fully, so we check for similarity on the maximally compatible\n// representation.  Err on the side of pruning, since all it's doing is\n// preventing lstats, and it's not the end of the world if we get a false\n// positive.\n// Note that on windows, we always drop the entire cache whenever a\n// symbolic link is encountered, because 8.3 filenames are impossible\n// to reason about, and collisions are hazards rather than just failures.\n\n\nconst cacheKeyNormalize = path => stripSlash(normPath(path)).normalize('NFKD').toLowerCase();\n\nconst pruneCache = (cache, abs) => {\n  abs = cacheKeyNormalize(abs);\n\n  for (const path of cache.keys()) {\n    const pnorm = cacheKeyNormalize(path);\n    if (pnorm === abs || pnorm.indexOf(abs + '/') === 0) cache.delete(path);\n  }\n};\n\nconst dropCache = cache => {\n  for (const key of cache.keys()) cache.delete(key);\n};\n\nclass Unpack extends Parser {\n  constructor(opt) {\n    if (!opt) opt = {};\n\n    opt.ondone = _ => {\n      this[ENDED] = true;\n      this[MAYBECLOSE]();\n    };\n\n    super(opt);\n    this[CHECKED_CWD] = false;\n    this.reservations = pathReservations();\n    this.transform = typeof opt.transform === 'function' ? opt.transform : null;\n    this.writable = true;\n    this.readable = false;\n    this[PENDING] = 0;\n    this[ENDED] = false;\n    this.dirCache = opt.dirCache || new Map();\n\n    if (typeof opt.uid === 'number' || typeof opt.gid === 'number') {\n      // need both or neither\n      if (typeof opt.uid !== 'number' || typeof opt.gid !== 'number') throw new TypeError('cannot set owner without number uid and gid');\n      if (opt.preserveOwner) throw new TypeError('cannot preserve owner in archive and also set owner explicitly');\n      this.uid = opt.uid;\n      this.gid = opt.gid;\n      this.setOwner = true;\n    } else {\n      this.uid = null;\n      this.gid = null;\n      this.setOwner = false;\n    } // default true for root\n\n\n    if (opt.preserveOwner === undefined && typeof opt.uid !== 'number') this.preserveOwner = process.getuid && process.getuid() === 0;else this.preserveOwner = !!opt.preserveOwner;\n    this.processUid = (this.preserveOwner || this.setOwner) && process.getuid ? process.getuid() : null;\n    this.processGid = (this.preserveOwner || this.setOwner) && process.getgid ? process.getgid() : null; // mostly just for testing, but useful in some cases.\n    // Forcibly trigger a chown on every entry, no matter what\n\n    this.forceChown = opt.forceChown === true; // turn ><?| in filenames into 0xf000-higher encoded forms\n\n    this.win32 = !!opt.win32 || isWindows; // do not unpack over files that are newer than what's in the archive\n\n    this.newer = !!opt.newer; // do not unpack over ANY files\n\n    this.keep = !!opt.keep; // do not set mtime/atime of extracted entries\n\n    this.noMtime = !!opt.noMtime; // allow .., absolute path entries, and unpacking through symlinks\n    // without this, warn and skip .., relativize absolutes, and error\n    // on symlinks in extraction path\n\n    this.preservePaths = !!opt.preservePaths; // unlink files and links before writing. This breaks existing hard\n    // links, and removes symlink directories rather than erroring\n\n    this.unlink = !!opt.unlink;\n    this.cwd = normPath(path.resolve(opt.cwd || process.cwd()));\n    this.strip = +opt.strip || 0;\n    this.processUmask = process.umask();\n    this.umask = typeof opt.umask === 'number' ? opt.umask : this.processUmask; // default mode for dirs created as parents\n\n    this.dmode = opt.dmode || 0o0777 & ~this.umask;\n    this.fmode = opt.fmode || 0o0666 & ~this.umask;\n    this.on('entry', entry => this[ONENTRY](entry));\n  }\n\n  [MAYBECLOSE]() {\n    if (this[ENDED] && this[PENDING] === 0) {\n      this.emit('prefinish');\n      this.emit('finish');\n      this.emit('end');\n      this.emit('close');\n    }\n  }\n\n  [CHECKPATH](entry) {\n    if (this.strip) {\n      const parts = normPath(entry.path).split('/');\n      if (parts.length < this.strip) return false;\n      entry.path = parts.slice(this.strip).join('/');\n\n      if (entry.type === 'Link') {\n        const linkparts = normPath(entry.linkpath).split('/');\n        if (linkparts.length >= this.strip) entry.linkpath = linkparts.slice(this.strip).join('/');else return false;\n      }\n    }\n\n    if (!this.preservePaths) {\n      const p = normPath(entry.path);\n      const parts = p.split('/');\n\n      if (parts.includes('..') || isWindows && /^[a-z]:\\.\\.$/i.test(parts[0])) {\n        this.warn(`path contains '..'`, p);\n        return false;\n      } // strip off the root\n\n\n      const s = stripAbsolutePath(p);\n\n      if (s[0]) {\n        entry.path = s[1];\n        this.warn(`stripping ${s[0]} from absolute path`, p);\n      }\n    }\n\n    if (path.isAbsolute(entry.path)) entry.absolute = normPath(path.resolve(entry.path));else entry.absolute = normPath(path.resolve(this.cwd, entry.path)); // if we somehow ended up with a path that escapes the cwd, and we are\n    // not in preservePaths mode, then something is fishy!  This should have\n    // been prevented above, so ignore this for coverage.\n\n    /* istanbul ignore if - defense in depth */\n\n    if (!this.preservePaths && entry.absolute.indexOf(this.cwd + '/') !== 0 && entry.absolute !== this.cwd) {\n      this.warn('TAR_ENTRY_ERROR', 'path escaped extraction target', {\n        entry,\n        path: normPath(entry.path),\n        resolvedPath: entry.absolute,\n        cwd: this.cwd\n      });\n      return false;\n    } // an archive can set properties on the extraction directory, but it\n    // may not replace the cwd with a different kind of thing entirely.\n\n\n    if (entry.absolute === this.cwd && entry.type !== 'Directory' && entry.type !== 'GNUDumpDir') return false; // only encode : chars that aren't drive letter indicators\n\n    if (this.win32) {\n      const {\n        root: aRoot\n      } = path.win32.parse(entry.absolute);\n      entry.absolute = aRoot + wc.encode(entry.absolute.substr(aRoot.length));\n      const {\n        root: pRoot\n      } = path.win32.parse(entry.path);\n      entry.path = pRoot + wc.encode(entry.path.substr(pRoot.length));\n    }\n\n    return true;\n  }\n\n  [ONENTRY](entry) {\n    if (!this[CHECKPATH](entry)) return entry.resume();\n    assert.equal(typeof entry.absolute, 'string');\n\n    switch (entry.type) {\n      case 'Directory':\n      case 'GNUDumpDir':\n        if (entry.mode) entry.mode = entry.mode | 0o700;\n\n      case 'File':\n      case 'OldFile':\n      case 'ContiguousFile':\n      case 'Link':\n      case 'SymbolicLink':\n        return this[CHECKFS](entry);\n\n      case 'CharacterDevice':\n      case 'BlockDevice':\n      case 'FIFO':\n        return this[UNSUPPORTED](entry);\n    }\n  }\n\n  [ONERROR](er, entry) {\n    // Cwd has to exist, or else nothing works. That's serious.\n    // Other errors are warnings, which raise the error in strict\n    // mode, but otherwise continue on.\n    if (er.name === 'CwdError') this.emit('error', er);else {\n      this.warn(er.message, er);\n      this[UNPEND]();\n      entry.resume();\n    }\n  }\n\n  [MKDIR](dir, mode, cb) {\n    mkdir(normPath(dir), {\n      uid: this.uid,\n      gid: this.gid,\n      processUid: this.processUid,\n      processGid: this.processGid,\n      umask: this.processUmask,\n      preserve: this.preservePaths,\n      unlink: this.unlink,\n      cache: this.dirCache,\n      cwd: this.cwd,\n      mode: mode\n    }, cb);\n  }\n\n  [DOCHOWN](entry) {\n    // in preserve owner mode, chown if the entry doesn't match process\n    // in set owner mode, chown if setting doesn't match process\n    return this.forceChown || this.preserveOwner && (typeof entry.uid === 'number' && entry.uid !== this.processUid || typeof entry.gid === 'number' && entry.gid !== this.processGid) || typeof this.uid === 'number' && this.uid !== this.processUid || typeof this.gid === 'number' && this.gid !== this.processGid;\n  }\n\n  [UID](entry) {\n    return uint32(this.uid, entry.uid, this.processUid);\n  }\n\n  [GID](entry) {\n    return uint32(this.gid, entry.gid, this.processGid);\n  }\n\n  [FILE](entry, fullyDone) {\n    const mode = entry.mode & 0o7777 || this.fmode;\n    const stream = new fsm.WriteStream(entry.absolute, {\n      mode: mode,\n      autoClose: false\n    });\n    stream.on('error', er => {\n      if (stream.fd) fs.close(stream.fd, () => {}); // flush all the data out so that we aren't left hanging\n      // if the error wasn't actually fatal.  otherwise the parse\n      // is blocked, and we never proceed.\n\n      /* istanbul ignore next */\n\n      stream.write = () => true;\n\n      this[ONERROR](er, entry);\n      fullyDone();\n    });\n    let actions = 1;\n\n    const done = er => {\n      if (er) {\n        /* istanbul ignore else - we should always have a fd by now */\n        if (stream.fd) fs.close(stream.fd, () => {});\n        this[ONERROR](er, entry);\n        fullyDone();\n        return;\n      }\n\n      if (--actions === 0) {\n        fs.close(stream.fd, er => {\n          fullyDone();\n          /* istanbul ignore next */\n\n          er ? this[ONERROR](er, entry) : this[UNPEND]();\n        });\n      }\n    };\n\n    stream.on('finish', _ => {\n      // if futimes fails, try utimes\n      // if utimes fails, fail with the original error\n      // same for fchown/chown\n      const abs = entry.absolute;\n      const fd = stream.fd;\n\n      if (entry.mtime && !this.noMtime) {\n        actions++;\n        const atime = entry.atime || new Date();\n        const mtime = entry.mtime;\n        fs.futimes(fd, atime, mtime, er => er ? fs.utimes(abs, atime, mtime, er2 => done(er2 && er)) : done());\n      }\n\n      if (this[DOCHOWN](entry)) {\n        actions++;\n        const uid = this[UID](entry);\n        const gid = this[GID](entry);\n        fs.fchown(fd, uid, gid, er => er ? fs.chown(abs, uid, gid, er2 => done(er2 && er)) : done());\n      }\n\n      done();\n    });\n    const tx = this.transform ? this.transform(entry) || entry : entry;\n\n    if (tx !== entry) {\n      tx.on('error', er => this[ONERROR](er, entry));\n      entry.pipe(tx);\n    }\n\n    tx.pipe(stream);\n  }\n\n  [DIRECTORY](entry, fullyDone) {\n    const mode = entry.mode & 0o7777 || this.dmode;\n    this[MKDIR](entry.absolute, mode, er => {\n      if (er) {\n        fullyDone();\n        return this[ONERROR](er, entry);\n      }\n\n      let actions = 1;\n\n      const done = _ => {\n        if (--actions === 0) {\n          fullyDone();\n          this[UNPEND]();\n          entry.resume();\n        }\n      };\n\n      if (entry.mtime && !this.noMtime) {\n        actions++;\n        fs.utimes(entry.absolute, entry.atime || new Date(), entry.mtime, done);\n      }\n\n      if (this[DOCHOWN](entry)) {\n        actions++;\n        fs.chown(entry.absolute, this[UID](entry), this[GID](entry), done);\n      }\n\n      done();\n    });\n  }\n\n  [UNSUPPORTED](entry) {\n    this.warn('unsupported entry type: ' + entry.type, entry);\n    entry.resume();\n  }\n\n  [SYMLINK](entry, done) {\n    this[LINK](entry, entry.linkpath, 'symlink', done);\n  }\n\n  [HARDLINK](entry, done) {\n    const linkpath = normPath(path.resolve(this.cwd, entry.linkpath));\n    this[LINK](entry, linkpath, 'link', done);\n  }\n\n  [PEND]() {\n    this[PENDING]++;\n  }\n\n  [UNPEND]() {\n    this[PENDING]--;\n    this[MAYBECLOSE]();\n  }\n\n  [SKIP](entry) {\n    this[UNPEND]();\n    entry.resume();\n  } // Check if we can reuse an existing filesystem entry safely and\n  // overwrite it, rather than unlinking and recreating\n  // Windows doesn't report a useful nlink, so we just never reuse entries\n\n\n  [ISREUSABLE](entry, st) {\n    return entry.type === 'File' && !this.unlink && st.isFile() && st.nlink <= 1 && !isWindows;\n  } // check if a thing is there, and if so, try to clobber it\n\n\n  [CHECKFS](entry) {\n    this[PEND]();\n    const paths = [entry.path];\n    if (entry.linkpath) paths.push(entry.linkpath);\n    this.reservations.reserve(paths, done => this[CHECKFS2](entry, done));\n  }\n\n  [PRUNECACHE](entry) {\n    // if we are not creating a directory, and the path is in the dirCache,\n    // then that means we are about to delete the directory we created\n    // previously, and it is no longer going to be a directory, and neither\n    // is any of its children.\n    // If a symbolic link is encountered, all bets are off.  There is no\n    // reasonable way to sanitize the cache in such a way we will be able to\n    // avoid having filesystem collisions.  If this happens with a non-symlink\n    // entry, it'll just fail to unpack, but a symlink to a directory, using an\n    // 8.3 shortname or certain unicode attacks, can evade detection and lead\n    // to arbitrary writes to anywhere on the system.\n    if (entry.type === 'SymbolicLink') dropCache(this.dirCache);else if (entry.type !== 'Directory') pruneCache(this.dirCache, entry.absolute);\n  }\n\n  [CHECKFS2](entry, fullyDone) {\n    this[PRUNECACHE](entry);\n\n    const done = er => {\n      this[PRUNECACHE](entry);\n      fullyDone(er);\n    };\n\n    const checkCwd = () => {\n      this[MKDIR](this.cwd, this.dmode, er => {\n        if (er) {\n          this[ONERROR](er, entry);\n          done();\n          return;\n        }\n\n        this[CHECKED_CWD] = true;\n        start();\n      });\n    };\n\n    const start = () => {\n      if (entry.absolute !== this.cwd) {\n        const parent = normPath(path.dirname(entry.absolute));\n\n        if (parent !== this.cwd) {\n          return this[MKDIR](parent, this.dmode, er => {\n            if (er) {\n              this[ONERROR](er, entry);\n              done();\n              return;\n            }\n\n            afterMakeParent();\n          });\n        }\n      }\n\n      afterMakeParent();\n    };\n\n    const afterMakeParent = () => {\n      fs.lstat(entry.absolute, (lstatEr, st) => {\n        if (st && (this.keep || this.newer && st.mtime > entry.mtime)) {\n          this[SKIP](entry);\n          done();\n          return;\n        }\n\n        if (lstatEr || this[ISREUSABLE](entry, st)) return this[MAKEFS](null, entry, done);\n\n        if (st.isDirectory()) {\n          if (entry.type === 'Directory') {\n            const needChmod = !this.noChmod && entry.mode && (st.mode & 0o7777) !== entry.mode;\n\n            const afterChmod = er => this[MAKEFS](er, entry, done);\n\n            if (!needChmod) return afterChmod();\n            return fs.chmod(entry.absolute, entry.mode, afterChmod);\n          } // Not a dir entry, have to remove it.\n          // NB: the only way to end up with an entry that is the cwd\n          // itself, in such a way that == does not detect, is a\n          // tricky windows absolute path with UNC or 8.3 parts (and\n          // preservePaths:true, or else it will have been stripped).\n          // In that case, the user has opted out of path protections\n          // explicitly, so if they blow away the cwd, c'est la vie.\n\n\n          if (entry.absolute !== this.cwd) {\n            return fs.rmdir(entry.absolute, er => this[MAKEFS](er, entry, done));\n          }\n        } // not a dir, and not reusable\n        // don't remove if the cwd, we want that error\n\n\n        if (entry.absolute === this.cwd) return this[MAKEFS](null, entry, done);\n        unlinkFile(entry.absolute, er => this[MAKEFS](er, entry, done));\n      });\n    };\n\n    if (this[CHECKED_CWD]) start();else checkCwd();\n  }\n\n  [MAKEFS](er, entry, done) {\n    if (er) return this[ONERROR](er, entry);\n\n    switch (entry.type) {\n      case 'File':\n      case 'OldFile':\n      case 'ContiguousFile':\n        return this[FILE](entry, done);\n\n      case 'Link':\n        return this[HARDLINK](entry, done);\n\n      case 'SymbolicLink':\n        return this[SYMLINK](entry, done);\n\n      case 'Directory':\n      case 'GNUDumpDir':\n        return this[DIRECTORY](entry, done);\n    }\n  }\n\n  [LINK](entry, linkpath, link, done) {\n    // XXX: get the type ('symlink' or 'junction') for windows\n    fs[link](linkpath, entry.absolute, er => {\n      if (er) return this[ONERROR](er, entry);\n      done();\n      this[UNPEND]();\n      entry.resume();\n    });\n  }\n\n}\n\nconst callSync = fn => {\n  try {\n    return [null, fn()];\n  } catch (er) {\n    return [er, null];\n  }\n};\n\nclass UnpackSync extends Unpack {\n  [MAKEFS](er, entry) {\n    return super[MAKEFS](er, entry,\n    /* istanbul ignore next */\n    () => {});\n  }\n\n  [CHECKFS](entry) {\n    this[PRUNECACHE](entry);\n\n    if (!this[CHECKED_CWD]) {\n      const er = this[MKDIR](this.cwd, this.dmode);\n      if (er) return this[ONERROR](er, entry);\n      this[CHECKED_CWD] = true;\n    } // don't bother to make the parent if the current entry is the cwd,\n    // we've already checked it.\n\n\n    if (entry.absolute !== this.cwd) {\n      const parent = normPath(path.dirname(entry.absolute));\n\n      if (parent !== this.cwd) {\n        const mkParent = this[MKDIR](parent, this.dmode);\n        if (mkParent) return this[ONERROR](mkParent, entry);\n      }\n    }\n\n    const [lstatEr, st] = callSync(() => fs.lstatSync(entry.absolute));\n    if (st && (this.keep || this.newer && st.mtime > entry.mtime)) return this[SKIP](entry);\n    if (lstatEr || this[ISREUSABLE](entry, st)) return this[MAKEFS](null, entry);\n\n    if (st.isDirectory()) {\n      if (entry.type === 'Directory') {\n        const needChmod = !this.noChmod && entry.mode && (st.mode & 0o7777) !== entry.mode;\n        const [er] = needChmod ? callSync(() => {\n          fs.chmodSync(entry.absolute, entry.mode);\n        }) : [];\n        return this[MAKEFS](er, entry);\n      } // not a dir entry, have to remove it\n\n\n      const [er] = callSync(() => fs.rmdirSync(entry.absolute));\n      this[MAKEFS](er, entry);\n    } // not a dir, and not reusable.\n    // don't remove if it's the cwd, since we want that error.\n\n\n    const [er] = entry.absolute === this.cwd ? [] : callSync(() => unlinkFileSync(entry.absolute));\n    this[MAKEFS](er, entry);\n  }\n\n  [FILE](entry, done) {\n    const mode = entry.mode & 0o7777 || this.fmode;\n\n    const oner = er => {\n      let closeError;\n\n      try {\n        fs.closeSync(fd);\n      } catch (e) {\n        closeError = e;\n      }\n\n      if (er || closeError) this[ONERROR](er || closeError, entry);\n      done();\n    };\n\n    let stream;\n    let fd;\n\n    try {\n      fd = fs.openSync(entry.absolute, 'w', mode);\n    } catch (er) {\n      return oner(er);\n    }\n\n    const tx = this.transform ? this.transform(entry) || entry : entry;\n\n    if (tx !== entry) {\n      tx.on('error', er => this[ONERROR](er, entry));\n      entry.pipe(tx);\n    }\n\n    tx.on('data', chunk => {\n      try {\n        fs.writeSync(fd, chunk, 0, chunk.length);\n      } catch (er) {\n        oner(er);\n      }\n    });\n    tx.on('end', _ => {\n      let er = null; // try both, falling futimes back to utimes\n      // if either fails, handle the first error\n\n      if (entry.mtime && !this.noMtime) {\n        const atime = entry.atime || new Date();\n        const mtime = entry.mtime;\n\n        try {\n          fs.futimesSync(fd, atime, mtime);\n        } catch (futimeser) {\n          try {\n            fs.utimesSync(entry.absolute, atime, mtime);\n          } catch (utimeser) {\n            er = futimeser;\n          }\n        }\n      }\n\n      if (this[DOCHOWN](entry)) {\n        const uid = this[UID](entry);\n        const gid = this[GID](entry);\n\n        try {\n          fs.fchownSync(fd, uid, gid);\n        } catch (fchowner) {\n          try {\n            fs.chownSync(entry.absolute, uid, gid);\n          } catch (chowner) {\n            er = er || fchowner;\n          }\n        }\n      }\n\n      oner(er);\n    });\n  }\n\n  [DIRECTORY](entry, done) {\n    const mode = entry.mode & 0o7777 || this.dmode;\n    const er = this[MKDIR](entry.absolute, mode);\n\n    if (er) {\n      this[ONERROR](er, entry);\n      done();\n      return;\n    }\n\n    if (entry.mtime && !this.noMtime) {\n      try {\n        fs.utimesSync(entry.absolute, entry.atime || new Date(), entry.mtime);\n      } catch (er) {}\n    }\n\n    if (this[DOCHOWN](entry)) {\n      try {\n        fs.chownSync(entry.absolute, this[UID](entry), this[GID](entry));\n      } catch (er) {}\n    }\n\n    done();\n    entry.resume();\n  }\n\n  [MKDIR](dir, mode) {\n    try {\n      return mkdir.sync(normPath(dir), {\n        uid: this.uid,\n        gid: this.gid,\n        processUid: this.processUid,\n        processGid: this.processGid,\n        umask: this.processUmask,\n        preserve: this.preservePaths,\n        unlink: this.unlink,\n        cache: this.dirCache,\n        cwd: this.cwd,\n        mode: mode\n      });\n    } catch (er) {\n      return er;\n    }\n  }\n\n  [LINK](entry, linkpath, link, done) {\n    try {\n      fs[link + 'Sync'](linkpath, entry.absolute);\n      done();\n      entry.resume();\n    } catch (er) {\n      return this[ONERROR](er, entry);\n    }\n  }\n\n}\n\nUnpack.Sync = UnpackSync;\nmodule.exports = Unpack;","map":{"version":3,"sources":["/home/dev/Documentos/Projects/github-clone/node_modules/firebase-tools/node_modules/tar/lib/unpack.js"],"names":["assert","require","EE","EventEmitter","Parser","fs","fsm","path","mkdir","mkdirSync","sync","wc","stripAbsolutePath","pathReservations","normPath","stripSlash","ONENTRY","Symbol","CHECKFS","CHECKFS2","PRUNECACHE","ISREUSABLE","MAKEFS","FILE","DIRECTORY","LINK","SYMLINK","HARDLINK","UNSUPPORTED","UNKNOWN","CHECKPATH","MKDIR","ONERROR","PENDING","PEND","UNPEND","ENDED","MAYBECLOSE","SKIP","DOCHOWN","UID","GID","CHECKED_CWD","crypto","platform","process","env","TESTING_TAR_FAKE_PLATFORM","isWindows","unlinkFile","cb","unlink","name","randomBytes","toString","rename","er","unlinkFileSync","unlinkSync","renameSync","uint32","a","b","c","cacheKeyNormalize","normalize","toLowerCase","pruneCache","cache","abs","keys","pnorm","indexOf","delete","dropCache","key","Unpack","constructor","opt","ondone","_","reservations","transform","writable","readable","dirCache","Map","uid","gid","TypeError","preserveOwner","setOwner","undefined","getuid","processUid","processGid","getgid","forceChown","win32","newer","keep","noMtime","preservePaths","cwd","resolve","strip","processUmask","umask","dmode","fmode","on","entry","emit","parts","split","length","slice","join","type","linkparts","linkpath","p","includes","test","warn","s","isAbsolute","absolute","resolvedPath","root","aRoot","parse","encode","substr","pRoot","resume","equal","mode","message","dir","preserve","fullyDone","stream","WriteStream","autoClose","fd","close","write","actions","done","mtime","atime","Date","futimes","utimes","er2","fchown","chown","tx","pipe","st","isFile","nlink","paths","push","reserve","checkCwd","start","parent","dirname","afterMakeParent","lstat","lstatEr","isDirectory","needChmod","noChmod","afterChmod","chmod","rmdir","link","callSync","fn","UnpackSync","mkParent","lstatSync","chmodSync","rmdirSync","oner","closeError","closeSync","e","openSync","chunk","writeSync","futimesSync","futimeser","utimesSync","utimeser","fchownSync","fchowner","chownSync","chowner","Sync","module","exports"],"mappings":"AAAA,a,CAEA;AACA;AACA;AACA;AACA;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,QAAD,CAAtB;;AACA,MAAMC,EAAE,GAAGD,OAAO,CAAC,QAAD,CAAP,CAAkBE,YAA7B;;AACA,MAAMC,MAAM,GAAGH,OAAO,CAAC,YAAD,CAAtB;;AACA,MAAMI,EAAE,GAAGJ,OAAO,CAAC,IAAD,CAAlB;;AACA,MAAMK,GAAG,GAAGL,OAAO,CAAC,aAAD,CAAnB;;AACA,MAAMM,IAAI,GAAGN,OAAO,CAAC,MAAD,CAApB;;AACA,MAAMO,KAAK,GAAGP,OAAO,CAAC,YAAD,CAArB;;AACA,MAAMQ,SAAS,GAAGD,KAAK,CAACE,IAAxB;;AACA,MAAMC,EAAE,GAAGV,OAAO,CAAC,eAAD,CAAlB;;AACA,MAAMW,iBAAiB,GAAGX,OAAO,CAAC,0BAAD,CAAjC;;AACA,MAAMY,gBAAgB,GAAGZ,OAAO,CAAC,wBAAD,CAAhC;;AACA,MAAMa,QAAQ,GAAGb,OAAO,CAAC,6BAAD,CAAxB;;AACA,MAAMc,UAAU,GAAGd,OAAO,CAAC,6BAAD,CAA1B;;AAEA,MAAMe,OAAO,GAAGC,MAAM,CAAC,SAAD,CAAtB;AACA,MAAMC,OAAO,GAAGD,MAAM,CAAC,SAAD,CAAtB;AACA,MAAME,QAAQ,GAAGF,MAAM,CAAC,UAAD,CAAvB;AACA,MAAMG,UAAU,GAAGH,MAAM,CAAC,YAAD,CAAzB;AACA,MAAMI,UAAU,GAAGJ,MAAM,CAAC,YAAD,CAAzB;AACA,MAAMK,MAAM,GAAGL,MAAM,CAAC,QAAD,CAArB;AACA,MAAMM,IAAI,GAAGN,MAAM,CAAC,MAAD,CAAnB;AACA,MAAMO,SAAS,GAAGP,MAAM,CAAC,WAAD,CAAxB;AACA,MAAMQ,IAAI,GAAGR,MAAM,CAAC,MAAD,CAAnB;AACA,MAAMS,OAAO,GAAGT,MAAM,CAAC,SAAD,CAAtB;AACA,MAAMU,QAAQ,GAAGV,MAAM,CAAC,UAAD,CAAvB;AACA,MAAMW,WAAW,GAAGX,MAAM,CAAC,aAAD,CAA1B;AACA,MAAMY,OAAO,GAAGZ,MAAM,CAAC,SAAD,CAAtB;AACA,MAAMa,SAAS,GAAGb,MAAM,CAAC,WAAD,CAAxB;AACA,MAAMc,KAAK,GAAGd,MAAM,CAAC,OAAD,CAApB;AACA,MAAMe,OAAO,GAAGf,MAAM,CAAC,SAAD,CAAtB;AACA,MAAMgB,OAAO,GAAGhB,MAAM,CAAC,SAAD,CAAtB;AACA,MAAMiB,IAAI,GAAGjB,MAAM,CAAC,MAAD,CAAnB;AACA,MAAMkB,MAAM,GAAGlB,MAAM,CAAC,QAAD,CAArB;AACA,MAAMmB,KAAK,GAAGnB,MAAM,CAAC,OAAD,CAApB;AACA,MAAMoB,UAAU,GAAGpB,MAAM,CAAC,YAAD,CAAzB;AACA,MAAMqB,IAAI,GAAGrB,MAAM,CAAC,MAAD,CAAnB;AACA,MAAMsB,OAAO,GAAGtB,MAAM,CAAC,SAAD,CAAtB;AACA,MAAMuB,GAAG,GAAGvB,MAAM,CAAC,KAAD,CAAlB;AACA,MAAMwB,GAAG,GAAGxB,MAAM,CAAC,KAAD,CAAlB;AACA,MAAMyB,WAAW,GAAGzB,MAAM,CAAC,YAAD,CAA1B;;AACA,MAAM0B,MAAM,GAAG1C,OAAO,CAAC,QAAD,CAAtB;;AACA,MAAM2C,QAAQ,GAAGC,OAAO,CAACC,GAAR,CAAYC,yBAAZ,IAAyCF,OAAO,CAACD,QAAlE;AACA,MAAMI,SAAS,GAAGJ,QAAQ,KAAK,OAA/B,C,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;;AACA,MAAMK,UAAU,GAAG,CAAC1C,IAAD,EAAO2C,EAAP,KAAc;AAC/B,MAAI,CAACF,SAAL,EACE,OAAO3C,EAAE,CAAC8C,MAAH,CAAU5C,IAAV,EAAgB2C,EAAhB,CAAP;AAEF,QAAME,IAAI,GAAG7C,IAAI,GAAG,UAAP,GAAoBoC,MAAM,CAACU,WAAP,CAAmB,EAAnB,EAAuBC,QAAvB,CAAgC,KAAhC,CAAjC;AACAjD,EAAAA,EAAE,CAACkD,MAAH,CAAUhD,IAAV,EAAgB6C,IAAhB,EAAsBI,EAAE,IAAI;AAC1B,QAAIA,EAAJ,EACE,OAAON,EAAE,CAACM,EAAD,CAAT;AACFnD,IAAAA,EAAE,CAAC8C,MAAH,CAAUC,IAAV,EAAgBF,EAAhB;AACD,GAJD;AAKD,CAVD;AAYA;;;AACA,MAAMO,cAAc,GAAGlD,IAAI,IAAI;AAC7B,MAAI,CAACyC,SAAL,EACE,OAAO3C,EAAE,CAACqD,UAAH,CAAcnD,IAAd,CAAP;AAEF,QAAM6C,IAAI,GAAG7C,IAAI,GAAG,UAAP,GAAoBoC,MAAM,CAACU,WAAP,CAAmB,EAAnB,EAAuBC,QAAvB,CAAgC,KAAhC,CAAjC;AACAjD,EAAAA,EAAE,CAACsD,UAAH,CAAcpD,IAAd,EAAoB6C,IAApB;AACA/C,EAAAA,EAAE,CAACqD,UAAH,CAAcN,IAAd;AACD,CAPD,C,CASA;;;AACA,MAAMQ,MAAM,GAAG,CAACC,CAAD,EAAIC,CAAJ,EAAOC,CAAP,KACbF,CAAC,KAAKA,CAAC,KAAK,CAAZ,GAAgBA,CAAhB,GACEC,CAAC,KAAKA,CAAC,KAAK,CAAZ,GAAgBA,CAAhB,GACAC,CAHJ,C,CAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMC,iBAAiB,GAAGzD,IAAI,IAAIQ,UAAU,CAACD,QAAQ,CAACP,IAAD,CAAT,CAAV,CAC/B0D,SAD+B,CACrB,MADqB,EAE/BC,WAF+B,EAAlC;;AAIA,MAAMC,UAAU,GAAG,CAACC,KAAD,EAAQC,GAAR,KAAgB;AACjCA,EAAAA,GAAG,GAAGL,iBAAiB,CAACK,GAAD,CAAvB;;AACA,OAAK,MAAM9D,IAAX,IAAmB6D,KAAK,CAACE,IAAN,EAAnB,EAAiC;AAC/B,UAAMC,KAAK,GAAGP,iBAAiB,CAACzD,IAAD,CAA/B;AACA,QAAIgE,KAAK,KAAKF,GAAV,IAAiBE,KAAK,CAACC,OAAN,CAAcH,GAAG,GAAG,GAApB,MAA6B,CAAlD,EACED,KAAK,CAACK,MAAN,CAAalE,IAAb;AACH;AACF,CAPD;;AASA,MAAMmE,SAAS,GAAGN,KAAK,IAAI;AACzB,OAAK,MAAMO,GAAX,IAAkBP,KAAK,CAACE,IAAN,EAAlB,EACEF,KAAK,CAACK,MAAN,CAAaE,GAAb;AACH,CAHD;;AAKA,MAAMC,MAAN,SAAqBxE,MAArB,CAA4B;AAC1ByE,EAAAA,WAAW,CAAEC,GAAF,EAAO;AAChB,QAAI,CAACA,GAAL,EACEA,GAAG,GAAG,EAAN;;AAEFA,IAAAA,GAAG,CAACC,MAAJ,GAAaC,CAAC,IAAI;AAChB,WAAK5C,KAAL,IAAc,IAAd;AACA,WAAKC,UAAL;AACD,KAHD;;AAKA,UAAMyC,GAAN;AAEA,SAAKpC,WAAL,IAAoB,KAApB;AAEA,SAAKuC,YAAL,GAAoBpE,gBAAgB,EAApC;AAEA,SAAKqE,SAAL,GAAiB,OAAOJ,GAAG,CAACI,SAAX,KAAyB,UAAzB,GAAsCJ,GAAG,CAACI,SAA1C,GAAsD,IAAvE;AAEA,SAAKC,QAAL,GAAgB,IAAhB;AACA,SAAKC,QAAL,GAAgB,KAAhB;AAEA,SAAKnD,OAAL,IAAgB,CAAhB;AACA,SAAKG,KAAL,IAAc,KAAd;AAEA,SAAKiD,QAAL,GAAgBP,GAAG,CAACO,QAAJ,IAAgB,IAAIC,GAAJ,EAAhC;;AAEA,QAAI,OAAOR,GAAG,CAACS,GAAX,KAAmB,QAAnB,IAA+B,OAAOT,GAAG,CAACU,GAAX,KAAmB,QAAtD,EAAgE;AAC9D;AACA,UAAI,OAAOV,GAAG,CAACS,GAAX,KAAmB,QAAnB,IAA+B,OAAOT,GAAG,CAACU,GAAX,KAAmB,QAAtD,EACE,MAAM,IAAIC,SAAJ,CAAc,6CAAd,CAAN;AACF,UAAIX,GAAG,CAACY,aAAR,EACE,MAAM,IAAID,SAAJ,CACJ,gEADI,CAAN;AAEF,WAAKF,GAAL,GAAWT,GAAG,CAACS,GAAf;AACA,WAAKC,GAAL,GAAWV,GAAG,CAACU,GAAf;AACA,WAAKG,QAAL,GAAgB,IAAhB;AACD,KAVD,MAUO;AACL,WAAKJ,GAAL,GAAW,IAAX;AACA,WAAKC,GAAL,GAAW,IAAX;AACA,WAAKG,QAAL,GAAgB,KAAhB;AACD,KAvCe,CAyChB;;;AACA,QAAIb,GAAG,CAACY,aAAJ,KAAsBE,SAAtB,IAAmC,OAAOd,GAAG,CAACS,GAAX,KAAmB,QAA1D,EACE,KAAKG,aAAL,GAAqB7C,OAAO,CAACgD,MAAR,IAAkBhD,OAAO,CAACgD,MAAR,OAAqB,CAA5D,CADF,KAGE,KAAKH,aAAL,GAAqB,CAAC,CAACZ,GAAG,CAACY,aAA3B;AAEF,SAAKI,UAAL,GAAkB,CAAC,KAAKJ,aAAL,IAAsB,KAAKC,QAA5B,KAAyC9C,OAAO,CAACgD,MAAjD,GAChBhD,OAAO,CAACgD,MAAR,EADgB,GACG,IADrB;AAEA,SAAKE,UAAL,GAAkB,CAAC,KAAKL,aAAL,IAAsB,KAAKC,QAA5B,KAAyC9C,OAAO,CAACmD,MAAjD,GAChBnD,OAAO,CAACmD,MAAR,EADgB,GACG,IADrB,CAjDgB,CAoDhB;AACA;;AACA,SAAKC,UAAL,GAAkBnB,GAAG,CAACmB,UAAJ,KAAmB,IAArC,CAtDgB,CAwDhB;;AACA,SAAKC,KAAL,GAAa,CAAC,CAACpB,GAAG,CAACoB,KAAN,IAAelD,SAA5B,CAzDgB,CA2DhB;;AACA,SAAKmD,KAAL,GAAa,CAAC,CAACrB,GAAG,CAACqB,KAAnB,CA5DgB,CA8DhB;;AACA,SAAKC,IAAL,GAAY,CAAC,CAACtB,GAAG,CAACsB,IAAlB,CA/DgB,CAiEhB;;AACA,SAAKC,OAAL,GAAe,CAAC,CAACvB,GAAG,CAACuB,OAArB,CAlEgB,CAoEhB;AACA;AACA;;AACA,SAAKC,aAAL,GAAqB,CAAC,CAACxB,GAAG,CAACwB,aAA3B,CAvEgB,CAyEhB;AACA;;AACA,SAAKnD,MAAL,GAAc,CAAC,CAAC2B,GAAG,CAAC3B,MAApB;AAEA,SAAKoD,GAAL,GAAWzF,QAAQ,CAACP,IAAI,CAACiG,OAAL,CAAa1B,GAAG,CAACyB,GAAJ,IAAW1D,OAAO,CAAC0D,GAAR,EAAxB,CAAD,CAAnB;AACA,SAAKE,KAAL,GAAa,CAAC3B,GAAG,CAAC2B,KAAL,IAAc,CAA3B;AACA,SAAKC,YAAL,GAAoB7D,OAAO,CAAC8D,KAAR,EAApB;AACA,SAAKA,KAAL,GAAa,OAAO7B,GAAG,CAAC6B,KAAX,KAAqB,QAArB,GAAgC7B,GAAG,CAAC6B,KAApC,GAA4C,KAAKD,YAA9D,CAhFgB,CAiFhB;;AACA,SAAKE,KAAL,GAAa9B,GAAG,CAAC8B,KAAJ,IAAc,SAAU,CAAC,KAAKD,KAA3C;AACA,SAAKE,KAAL,GAAa/B,GAAG,CAAC+B,KAAJ,IAAc,SAAU,CAAC,KAAKF,KAA3C;AACA,SAAKG,EAAL,CAAQ,OAAR,EAAiBC,KAAK,IAAI,KAAK/F,OAAL,EAAc+F,KAAd,CAA1B;AACD;;AAEU,GAAV1E,UAAU,IAAK;AACd,QAAI,KAAKD,KAAL,KAAe,KAAKH,OAAL,MAAkB,CAArC,EAAwC;AACtC,WAAK+E,IAAL,CAAU,WAAV;AACA,WAAKA,IAAL,CAAU,QAAV;AACA,WAAKA,IAAL,CAAU,KAAV;AACA,WAAKA,IAAL,CAAU,OAAV;AACD;AACF;;AAES,GAATlF,SAAS,EAAGiF,KAAH,EAAU;AAClB,QAAI,KAAKN,KAAT,EAAgB;AACd,YAAMQ,KAAK,GAAGnG,QAAQ,CAACiG,KAAK,CAACxG,IAAP,CAAR,CAAqB2G,KAArB,CAA2B,GAA3B,CAAd;AACA,UAAID,KAAK,CAACE,MAAN,GAAe,KAAKV,KAAxB,EACE,OAAO,KAAP;AACFM,MAAAA,KAAK,CAACxG,IAAN,GAAa0G,KAAK,CAACG,KAAN,CAAY,KAAKX,KAAjB,EAAwBY,IAAxB,CAA6B,GAA7B,CAAb;;AAEA,UAAIN,KAAK,CAACO,IAAN,KAAe,MAAnB,EAA2B;AACzB,cAAMC,SAAS,GAAGzG,QAAQ,CAACiG,KAAK,CAACS,QAAP,CAAR,CAAyBN,KAAzB,CAA+B,GAA/B,CAAlB;AACA,YAAIK,SAAS,CAACJ,MAAV,IAAoB,KAAKV,KAA7B,EACEM,KAAK,CAACS,QAAN,GAAiBD,SAAS,CAACH,KAAV,CAAgB,KAAKX,KAArB,EAA4BY,IAA5B,CAAiC,GAAjC,CAAjB,CADF,KAGE,OAAO,KAAP;AACH;AACF;;AAED,QAAI,CAAC,KAAKf,aAAV,EAAyB;AACvB,YAAMmB,CAAC,GAAG3G,QAAQ,CAACiG,KAAK,CAACxG,IAAP,CAAlB;AACA,YAAM0G,KAAK,GAAGQ,CAAC,CAACP,KAAF,CAAQ,GAAR,CAAd;;AACA,UAAID,KAAK,CAACS,QAAN,CAAe,IAAf,KAAwB1E,SAAS,IAAI,gBAAgB2E,IAAhB,CAAqBV,KAAK,CAAC,CAAD,CAA1B,CAAzC,EAAyE;AACvE,aAAKW,IAAL,CAAW,oBAAX,EAAgCH,CAAhC;AACA,eAAO,KAAP;AACD,OANsB,CAQvB;;;AACA,YAAMI,CAAC,GAAGjH,iBAAiB,CAAC6G,CAAD,CAA3B;;AACA,UAAII,CAAC,CAAC,CAAD,CAAL,EAAU;AACRd,QAAAA,KAAK,CAACxG,IAAN,GAAasH,CAAC,CAAC,CAAD,CAAd;AACA,aAAKD,IAAL,CAAW,aAAYC,CAAC,CAAC,CAAD,CAAI,qBAA5B,EAAkDJ,CAAlD;AACD;AACF;;AAED,QAAIlH,IAAI,CAACuH,UAAL,CAAgBf,KAAK,CAACxG,IAAtB,CAAJ,EACEwG,KAAK,CAACgB,QAAN,GAAiBjH,QAAQ,CAACP,IAAI,CAACiG,OAAL,CAAaO,KAAK,CAACxG,IAAnB,CAAD,CAAzB,CADF,KAGEwG,KAAK,CAACgB,QAAN,GAAiBjH,QAAQ,CAACP,IAAI,CAACiG,OAAL,CAAa,KAAKD,GAAlB,EAAuBQ,KAAK,CAACxG,IAA7B,CAAD,CAAzB,CAnCgB,CAqClB;AACA;AACA;;AACA;;AACA,QAAI,CAAC,KAAK+F,aAAN,IACAS,KAAK,CAACgB,QAAN,CAAevD,OAAf,CAAuB,KAAK+B,GAAL,GAAW,GAAlC,MAA2C,CAD3C,IAEAQ,KAAK,CAACgB,QAAN,KAAmB,KAAKxB,GAF5B,EAEiC;AAC/B,WAAKqB,IAAL,CAAU,iBAAV,EAA6B,gCAA7B,EAA+D;AAC7Db,QAAAA,KAD6D;AAE7DxG,QAAAA,IAAI,EAAEO,QAAQ,CAACiG,KAAK,CAACxG,IAAP,CAF+C;AAG7DyH,QAAAA,YAAY,EAAEjB,KAAK,CAACgB,QAHyC;AAI7DxB,QAAAA,GAAG,EAAE,KAAKA;AAJmD,OAA/D;AAMA,aAAO,KAAP;AACD,KAnDiB,CAqDlB;AACA;;;AACA,QAAIQ,KAAK,CAACgB,QAAN,KAAmB,KAAKxB,GAAxB,IACAQ,KAAK,CAACO,IAAN,KAAe,WADf,IAEAP,KAAK,CAACO,IAAN,KAAe,YAFnB,EAGE,OAAO,KAAP,CA1DgB,CA4DlB;;AACA,QAAI,KAAKpB,KAAT,EAAgB;AACd,YAAM;AAAE+B,QAAAA,IAAI,EAAEC;AAAR,UAAkB3H,IAAI,CAAC2F,KAAL,CAAWiC,KAAX,CAAiBpB,KAAK,CAACgB,QAAvB,CAAxB;AACAhB,MAAAA,KAAK,CAACgB,QAAN,GAAiBG,KAAK,GAAGvH,EAAE,CAACyH,MAAH,CAAUrB,KAAK,CAACgB,QAAN,CAAeM,MAAf,CAAsBH,KAAK,CAACf,MAA5B,CAAV,CAAzB;AACA,YAAM;AAAEc,QAAAA,IAAI,EAAEK;AAAR,UAAkB/H,IAAI,CAAC2F,KAAL,CAAWiC,KAAX,CAAiBpB,KAAK,CAACxG,IAAvB,CAAxB;AACAwG,MAAAA,KAAK,CAACxG,IAAN,GAAa+H,KAAK,GAAG3H,EAAE,CAACyH,MAAH,CAAUrB,KAAK,CAACxG,IAAN,CAAW8H,MAAX,CAAkBC,KAAK,CAACnB,MAAxB,CAAV,CAArB;AACD;;AAED,WAAO,IAAP;AACD;;AAEO,GAAPnG,OAAO,EAAG+F,KAAH,EAAU;AAChB,QAAI,CAAC,KAAKjF,SAAL,EAAgBiF,KAAhB,CAAL,EACE,OAAOA,KAAK,CAACwB,MAAN,EAAP;AAEFvI,IAAAA,MAAM,CAACwI,KAAP,CAAa,OAAOzB,KAAK,CAACgB,QAA1B,EAAoC,QAApC;;AAEA,YAAQhB,KAAK,CAACO,IAAd;AACE,WAAK,WAAL;AACA,WAAK,YAAL;AACE,YAAIP,KAAK,CAAC0B,IAAV,EACE1B,KAAK,CAAC0B,IAAN,GAAa1B,KAAK,CAAC0B,IAAN,GAAa,KAA1B;;AAEJ,WAAK,MAAL;AACA,WAAK,SAAL;AACA,WAAK,gBAAL;AACA,WAAK,MAAL;AACA,WAAK,cAAL;AACE,eAAO,KAAKvH,OAAL,EAAc6F,KAAd,CAAP;;AAEF,WAAK,iBAAL;AACA,WAAK,aAAL;AACA,WAAK,MAAL;AACE,eAAO,KAAKnF,WAAL,EAAkBmF,KAAlB,CAAP;AAhBJ;AAkBD;;AAEO,GAAP/E,OAAO,EAAGwB,EAAH,EAAOuD,KAAP,EAAc;AACpB;AACA;AACA;AACA,QAAIvD,EAAE,CAACJ,IAAH,KAAY,UAAhB,EACE,KAAK4D,IAAL,CAAU,OAAV,EAAmBxD,EAAnB,EADF,KAEK;AACH,WAAKoE,IAAL,CAAUpE,EAAE,CAACkF,OAAb,EAAsBlF,EAAtB;AACA,WAAKrB,MAAL;AACA4E,MAAAA,KAAK,CAACwB,MAAN;AACD;AACF;;AAEK,GAALxG,KAAK,EAAG4G,GAAH,EAAQF,IAAR,EAAcvF,EAAd,EAAkB;AACtB1C,IAAAA,KAAK,CAACM,QAAQ,CAAC6H,GAAD,CAAT,EAAgB;AACnBpD,MAAAA,GAAG,EAAE,KAAKA,GADS;AAEnBC,MAAAA,GAAG,EAAE,KAAKA,GAFS;AAGnBM,MAAAA,UAAU,EAAE,KAAKA,UAHE;AAInBC,MAAAA,UAAU,EAAE,KAAKA,UAJE;AAKnBY,MAAAA,KAAK,EAAE,KAAKD,YALO;AAMnBkC,MAAAA,QAAQ,EAAE,KAAKtC,aANI;AAOnBnD,MAAAA,MAAM,EAAE,KAAKA,MAPM;AAQnBiB,MAAAA,KAAK,EAAE,KAAKiB,QARO;AASnBkB,MAAAA,GAAG,EAAE,KAAKA,GATS;AAUnBkC,MAAAA,IAAI,EAAEA;AAVa,KAAhB,EAWFvF,EAXE,CAAL;AAYD;;AAEO,GAAPX,OAAO,EAAGwE,KAAH,EAAU;AAChB;AACA;AACA,WAAO,KAAKd,UAAL,IACL,KAAKP,aAAL,KACE,OAAOqB,KAAK,CAACxB,GAAb,KAAqB,QAArB,IAAiCwB,KAAK,CAACxB,GAAN,KAAc,KAAKO,UAApD,IACA,OAAOiB,KAAK,CAACvB,GAAb,KAAqB,QAArB,IAAiCuB,KAAK,CAACvB,GAAN,KAAc,KAAKO,UAFtD,CADK,IAKH,OAAO,KAAKR,GAAZ,KAAoB,QAApB,IAAgC,KAAKA,GAAL,KAAa,KAAKO,UAAlD,IACA,OAAO,KAAKN,GAAZ,KAAoB,QAApB,IAAgC,KAAKA,GAAL,KAAa,KAAKO,UANtD;AAOD;;AAEG,GAAHvD,GAAG,EAAGuE,KAAH,EAAU;AACZ,WAAOnD,MAAM,CAAC,KAAK2B,GAAN,EAAWwB,KAAK,CAACxB,GAAjB,EAAsB,KAAKO,UAA3B,CAAb;AACD;;AAEG,GAAHrD,GAAG,EAAGsE,KAAH,EAAU;AACZ,WAAOnD,MAAM,CAAC,KAAK4B,GAAN,EAAWuB,KAAK,CAACvB,GAAjB,EAAsB,KAAKO,UAA3B,CAAb;AACD;;AAEI,GAAJxE,IAAI,EAAGwF,KAAH,EAAU8B,SAAV,EAAqB;AACxB,UAAMJ,IAAI,GAAG1B,KAAK,CAAC0B,IAAN,GAAa,MAAb,IAAuB,KAAK5B,KAAzC;AACA,UAAMiC,MAAM,GAAG,IAAIxI,GAAG,CAACyI,WAAR,CAAoBhC,KAAK,CAACgB,QAA1B,EAAoC;AACjDU,MAAAA,IAAI,EAAEA,IAD2C;AAEjDO,MAAAA,SAAS,EAAE;AAFsC,KAApC,CAAf;AAIAF,IAAAA,MAAM,CAAChC,EAAP,CAAU,OAAV,EAAmBtD,EAAE,IAAI;AACvB,UAAIsF,MAAM,CAACG,EAAX,EACE5I,EAAE,CAAC6I,KAAH,CAASJ,MAAM,CAACG,EAAhB,EAAoB,MAAM,CAAE,CAA5B,EAFqB,CAIvB;AACA;AACA;;AACA;;AACAH,MAAAA,MAAM,CAACK,KAAP,GAAe,MAAM,IAArB;;AACA,WAAKnH,OAAL,EAAcwB,EAAd,EAAkBuD,KAAlB;AACA8B,MAAAA,SAAS;AACV,KAXD;AAaA,QAAIO,OAAO,GAAG,CAAd;;AACA,UAAMC,IAAI,GAAG7F,EAAE,IAAI;AACjB,UAAIA,EAAJ,EAAQ;AACN;AACA,YAAIsF,MAAM,CAACG,EAAX,EACE5I,EAAE,CAAC6I,KAAH,CAASJ,MAAM,CAACG,EAAhB,EAAoB,MAAM,CAAE,CAA5B;AAEF,aAAKjH,OAAL,EAAcwB,EAAd,EAAkBuD,KAAlB;AACA8B,QAAAA,SAAS;AACT;AACD;;AAED,UAAI,EAAEO,OAAF,KAAc,CAAlB,EAAqB;AACnB/I,QAAAA,EAAE,CAAC6I,KAAH,CAASJ,MAAM,CAACG,EAAhB,EAAoBzF,EAAE,IAAI;AACxBqF,UAAAA,SAAS;AACT;;AACArF,UAAAA,EAAE,GAAG,KAAKxB,OAAL,EAAcwB,EAAd,EAAkBuD,KAAlB,CAAH,GAA8B,KAAK5E,MAAL,GAAhC;AACD,SAJD;AAKD;AACF,KAlBD;;AAoBA2G,IAAAA,MAAM,CAAChC,EAAP,CAAU,QAAV,EAAoB9B,CAAC,IAAI;AACvB;AACA;AACA;AACA,YAAMX,GAAG,GAAG0C,KAAK,CAACgB,QAAlB;AACA,YAAMkB,EAAE,GAAGH,MAAM,CAACG,EAAlB;;AAEA,UAAIlC,KAAK,CAACuC,KAAN,IAAe,CAAC,KAAKjD,OAAzB,EAAkC;AAChC+C,QAAAA,OAAO;AACP,cAAMG,KAAK,GAAGxC,KAAK,CAACwC,KAAN,IAAe,IAAIC,IAAJ,EAA7B;AACA,cAAMF,KAAK,GAAGvC,KAAK,CAACuC,KAApB;AACAjJ,QAAAA,EAAE,CAACoJ,OAAH,CAAWR,EAAX,EAAeM,KAAf,EAAsBD,KAAtB,EAA6B9F,EAAE,IAC7BA,EAAE,GAAGnD,EAAE,CAACqJ,MAAH,CAAUrF,GAAV,EAAekF,KAAf,EAAsBD,KAAtB,EAA6BK,GAAG,IAAIN,IAAI,CAACM,GAAG,IAAInG,EAAR,CAAxC,CAAH,GACA6F,IAAI,EAFR;AAGD;;AAED,UAAI,KAAK9G,OAAL,EAAcwE,KAAd,CAAJ,EAA0B;AACxBqC,QAAAA,OAAO;AACP,cAAM7D,GAAG,GAAG,KAAK/C,GAAL,EAAUuE,KAAV,CAAZ;AACA,cAAMvB,GAAG,GAAG,KAAK/C,GAAL,EAAUsE,KAAV,CAAZ;AACA1G,QAAAA,EAAE,CAACuJ,MAAH,CAAUX,EAAV,EAAc1D,GAAd,EAAmBC,GAAnB,EAAwBhC,EAAE,IACxBA,EAAE,GAAGnD,EAAE,CAACwJ,KAAH,CAASxF,GAAT,EAAckB,GAAd,EAAmBC,GAAnB,EAAwBmE,GAAG,IAAIN,IAAI,CAACM,GAAG,IAAInG,EAAR,CAAnC,CAAH,GACA6F,IAAI,EAFR;AAGD;;AAEDA,MAAAA,IAAI;AACL,KA1BD;AA4BA,UAAMS,EAAE,GAAG,KAAK5E,SAAL,GAAiB,KAAKA,SAAL,CAAe6B,KAAf,KAAyBA,KAA1C,GAAkDA,KAA7D;;AACA,QAAI+C,EAAE,KAAK/C,KAAX,EAAkB;AAChB+C,MAAAA,EAAE,CAAChD,EAAH,CAAM,OAAN,EAAetD,EAAE,IAAI,KAAKxB,OAAL,EAAcwB,EAAd,EAAkBuD,KAAlB,CAArB;AACAA,MAAAA,KAAK,CAACgD,IAAN,CAAWD,EAAX;AACD;;AACDA,IAAAA,EAAE,CAACC,IAAH,CAAQjB,MAAR;AACD;;AAES,GAATtH,SAAS,EAAGuF,KAAH,EAAU8B,SAAV,EAAqB;AAC7B,UAAMJ,IAAI,GAAG1B,KAAK,CAAC0B,IAAN,GAAa,MAAb,IAAuB,KAAK7B,KAAzC;AACA,SAAK7E,KAAL,EAAYgF,KAAK,CAACgB,QAAlB,EAA4BU,IAA5B,EAAkCjF,EAAE,IAAI;AACtC,UAAIA,EAAJ,EAAQ;AACNqF,QAAAA,SAAS;AACT,eAAO,KAAK7G,OAAL,EAAcwB,EAAd,EAAkBuD,KAAlB,CAAP;AACD;;AAED,UAAIqC,OAAO,GAAG,CAAd;;AACA,YAAMC,IAAI,GAAGrE,CAAC,IAAI;AAChB,YAAI,EAAEoE,OAAF,KAAc,CAAlB,EAAqB;AACnBP,UAAAA,SAAS;AACT,eAAK1G,MAAL;AACA4E,UAAAA,KAAK,CAACwB,MAAN;AACD;AACF,OAND;;AAQA,UAAIxB,KAAK,CAACuC,KAAN,IAAe,CAAC,KAAKjD,OAAzB,EAAkC;AAChC+C,QAAAA,OAAO;AACP/I,QAAAA,EAAE,CAACqJ,MAAH,CAAU3C,KAAK,CAACgB,QAAhB,EAA0BhB,KAAK,CAACwC,KAAN,IAAe,IAAIC,IAAJ,EAAzC,EAAqDzC,KAAK,CAACuC,KAA3D,EAAkED,IAAlE;AACD;;AAED,UAAI,KAAK9G,OAAL,EAAcwE,KAAd,CAAJ,EAA0B;AACxBqC,QAAAA,OAAO;AACP/I,QAAAA,EAAE,CAACwJ,KAAH,CAAS9C,KAAK,CAACgB,QAAf,EAAyB,KAAKvF,GAAL,EAAUuE,KAAV,CAAzB,EAA2C,KAAKtE,GAAL,EAAUsE,KAAV,CAA3C,EAA6DsC,IAA7D;AACD;;AAEDA,MAAAA,IAAI;AACL,KA1BD;AA2BD;;AAEW,GAAXzH,WAAW,EAAGmF,KAAH,EAAU;AACpB,SAAKa,IAAL,CAAU,6BAA6Bb,KAAK,CAACO,IAA7C,EAAmDP,KAAnD;AACAA,IAAAA,KAAK,CAACwB,MAAN;AACD;;AAEO,GAAP7G,OAAO,EAAGqF,KAAH,EAAUsC,IAAV,EAAgB;AACtB,SAAK5H,IAAL,EAAWsF,KAAX,EAAkBA,KAAK,CAACS,QAAxB,EAAkC,SAAlC,EAA6C6B,IAA7C;AACD;;AAEQ,GAAR1H,QAAQ,EAAGoF,KAAH,EAAUsC,IAAV,EAAgB;AACvB,UAAM7B,QAAQ,GAAG1G,QAAQ,CAACP,IAAI,CAACiG,OAAL,CAAa,KAAKD,GAAlB,EAAuBQ,KAAK,CAACS,QAA7B,CAAD,CAAzB;AACA,SAAK/F,IAAL,EAAWsF,KAAX,EAAkBS,QAAlB,EAA4B,MAA5B,EAAoC6B,IAApC;AACD;;AAEI,GAAJnH,IAAI,IAAK;AACR,SAAKD,OAAL;AACD;;AAEM,GAANE,MAAM,IAAK;AACV,SAAKF,OAAL;AACA,SAAKI,UAAL;AACD;;AAEI,GAAJC,IAAI,EAAGyE,KAAH,EAAU;AACb,SAAK5E,MAAL;AACA4E,IAAAA,KAAK,CAACwB,MAAN;AACD,GAvXyB,CAyX1B;AACA;AACA;;;AACW,GAAVlH,UAAU,EAAG0F,KAAH,EAAUiD,EAAV,EAAc;AACvB,WAAOjD,KAAK,CAACO,IAAN,KAAe,MAAf,IACL,CAAC,KAAKnE,MADD,IAEL6G,EAAE,CAACC,MAAH,EAFK,IAGLD,EAAE,CAACE,KAAH,IAAY,CAHP,IAIL,CAAClH,SAJH;AAKD,GAlYyB,CAoY1B;;;AACQ,GAAP9B,OAAO,EAAG6F,KAAH,EAAU;AAChB,SAAK7E,IAAL;AACA,UAAMiI,KAAK,GAAG,CAACpD,KAAK,CAACxG,IAAP,CAAd;AACA,QAAIwG,KAAK,CAACS,QAAV,EACE2C,KAAK,CAACC,IAAN,CAAWrD,KAAK,CAACS,QAAjB;AACF,SAAKvC,YAAL,CAAkBoF,OAAlB,CAA0BF,KAA1B,EAAiCd,IAAI,IAAI,KAAKlI,QAAL,EAAe4F,KAAf,EAAsBsC,IAAtB,CAAzC;AACD;;AAEU,GAAVjI,UAAU,EAAG2F,KAAH,EAAU;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAIA,KAAK,CAACO,IAAN,KAAe,cAAnB,EACE5C,SAAS,CAAC,KAAKW,QAAN,CAAT,CADF,KAEK,IAAI0B,KAAK,CAACO,IAAN,KAAe,WAAnB,EACHnD,UAAU,CAAC,KAAKkB,QAAN,EAAgB0B,KAAK,CAACgB,QAAtB,CAAV;AACH;;AAEQ,GAAR5G,QAAQ,EAAG4F,KAAH,EAAU8B,SAAV,EAAqB;AAC5B,SAAKzH,UAAL,EAAiB2F,KAAjB;;AAEA,UAAMsC,IAAI,GAAG7F,EAAE,IAAI;AACjB,WAAKpC,UAAL,EAAiB2F,KAAjB;AACA8B,MAAAA,SAAS,CAACrF,EAAD,CAAT;AACD,KAHD;;AAKA,UAAM8G,QAAQ,GAAG,MAAM;AACrB,WAAKvI,KAAL,EAAY,KAAKwE,GAAjB,EAAsB,KAAKK,KAA3B,EAAkCpD,EAAE,IAAI;AACtC,YAAIA,EAAJ,EAAQ;AACN,eAAKxB,OAAL,EAAcwB,EAAd,EAAkBuD,KAAlB;AACAsC,UAAAA,IAAI;AACJ;AACD;;AACD,aAAK3G,WAAL,IAAoB,IAApB;AACA6H,QAAAA,KAAK;AACN,OARD;AASD,KAVD;;AAYA,UAAMA,KAAK,GAAG,MAAM;AAClB,UAAIxD,KAAK,CAACgB,QAAN,KAAmB,KAAKxB,GAA5B,EAAiC;AAC/B,cAAMiE,MAAM,GAAG1J,QAAQ,CAACP,IAAI,CAACkK,OAAL,CAAa1D,KAAK,CAACgB,QAAnB,CAAD,CAAvB;;AACA,YAAIyC,MAAM,KAAK,KAAKjE,GAApB,EAAyB;AACvB,iBAAO,KAAKxE,KAAL,EAAYyI,MAAZ,EAAoB,KAAK5D,KAAzB,EAAgCpD,EAAE,IAAI;AAC3C,gBAAIA,EAAJ,EAAQ;AACN,mBAAKxB,OAAL,EAAcwB,EAAd,EAAkBuD,KAAlB;AACAsC,cAAAA,IAAI;AACJ;AACD;;AACDqB,YAAAA,eAAe;AAChB,WAPM,CAAP;AAQD;AACF;;AACDA,MAAAA,eAAe;AAChB,KAfD;;AAiBA,UAAMA,eAAe,GAAG,MAAM;AAC5BrK,MAAAA,EAAE,CAACsK,KAAH,CAAS5D,KAAK,CAACgB,QAAf,EAAyB,CAAC6C,OAAD,EAAUZ,EAAV,KAAiB;AACxC,YAAIA,EAAE,KAAK,KAAK5D,IAAL,IAAa,KAAKD,KAAL,IAAc6D,EAAE,CAACV,KAAH,GAAWvC,KAAK,CAACuC,KAAjD,CAAN,EAA+D;AAC7D,eAAKhH,IAAL,EAAWyE,KAAX;AACAsC,UAAAA,IAAI;AACJ;AACD;;AACD,YAAIuB,OAAO,IAAI,KAAKvJ,UAAL,EAAiB0F,KAAjB,EAAwBiD,EAAxB,CAAf,EACE,OAAO,KAAK1I,MAAL,EAAa,IAAb,EAAmByF,KAAnB,EAA0BsC,IAA1B,CAAP;;AAEF,YAAIW,EAAE,CAACa,WAAH,EAAJ,EAAsB;AACpB,cAAI9D,KAAK,CAACO,IAAN,KAAe,WAAnB,EAAgC;AAC9B,kBAAMwD,SAAS,GAAG,CAAC,KAAKC,OAAN,IAChBhE,KAAK,CAAC0B,IADU,IAEhB,CAACuB,EAAE,CAACvB,IAAH,GAAU,MAAX,MAAuB1B,KAAK,CAAC0B,IAF/B;;AAGA,kBAAMuC,UAAU,GAAGxH,EAAE,IAAI,KAAKlC,MAAL,EAAakC,EAAb,EAAiBuD,KAAjB,EAAwBsC,IAAxB,CAAzB;;AACA,gBAAI,CAACyB,SAAL,EACE,OAAOE,UAAU,EAAjB;AACF,mBAAO3K,EAAE,CAAC4K,KAAH,CAASlE,KAAK,CAACgB,QAAf,EAAyBhB,KAAK,CAAC0B,IAA/B,EAAqCuC,UAArC,CAAP;AACD,WATmB,CAUpB;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,cAAIjE,KAAK,CAACgB,QAAN,KAAmB,KAAKxB,GAA5B,EAAiC;AAC/B,mBAAOlG,EAAE,CAAC6K,KAAH,CAASnE,KAAK,CAACgB,QAAf,EAAyBvE,EAAE,IAChC,KAAKlC,MAAL,EAAakC,EAAb,EAAiBuD,KAAjB,EAAwBsC,IAAxB,CADK,CAAP;AAED;AACF,SA9BuC,CAgCxC;AACA;;;AACA,YAAItC,KAAK,CAACgB,QAAN,KAAmB,KAAKxB,GAA5B,EACE,OAAO,KAAKjF,MAAL,EAAa,IAAb,EAAmByF,KAAnB,EAA0BsC,IAA1B,CAAP;AAEFpG,QAAAA,UAAU,CAAC8D,KAAK,CAACgB,QAAP,EAAiBvE,EAAE,IAC3B,KAAKlC,MAAL,EAAakC,EAAb,EAAiBuD,KAAjB,EAAwBsC,IAAxB,CADQ,CAAV;AAED,OAvCD;AAwCD,KAzCD;;AA2CA,QAAI,KAAK3G,WAAL,CAAJ,EACE6H,KAAK,GADP,KAGED,QAAQ;AACX;;AAEM,GAANhJ,MAAM,EAAGkC,EAAH,EAAOuD,KAAP,EAAcsC,IAAd,EAAoB;AACzB,QAAI7F,EAAJ,EACE,OAAO,KAAKxB,OAAL,EAAcwB,EAAd,EAAkBuD,KAAlB,CAAP;;AAEF,YAAQA,KAAK,CAACO,IAAd;AACE,WAAK,MAAL;AACA,WAAK,SAAL;AACA,WAAK,gBAAL;AACE,eAAO,KAAK/F,IAAL,EAAWwF,KAAX,EAAkBsC,IAAlB,CAAP;;AAEF,WAAK,MAAL;AACE,eAAO,KAAK1H,QAAL,EAAeoF,KAAf,EAAsBsC,IAAtB,CAAP;;AAEF,WAAK,cAAL;AACE,eAAO,KAAK3H,OAAL,EAAcqF,KAAd,EAAqBsC,IAArB,CAAP;;AAEF,WAAK,WAAL;AACA,WAAK,YAAL;AACE,eAAO,KAAK7H,SAAL,EAAgBuF,KAAhB,EAAuBsC,IAAvB,CAAP;AAdJ;AAgBD;;AAEI,GAAJ5H,IAAI,EAAGsF,KAAH,EAAUS,QAAV,EAAoB2D,IAApB,EAA0B9B,IAA1B,EAAgC;AACnC;AACAhJ,IAAAA,EAAE,CAAC8K,IAAD,CAAF,CAAS3D,QAAT,EAAmBT,KAAK,CAACgB,QAAzB,EAAmCvE,EAAE,IAAI;AACvC,UAAIA,EAAJ,EACE,OAAO,KAAKxB,OAAL,EAAcwB,EAAd,EAAkBuD,KAAlB,CAAP;AACFsC,MAAAA,IAAI;AACJ,WAAKlH,MAAL;AACA4E,MAAAA,KAAK,CAACwB,MAAN;AACD,KAND;AAOD;;AAnhByB;;AAshB5B,MAAM6C,QAAQ,GAAGC,EAAE,IAAI;AACrB,MAAI;AACF,WAAO,CAAC,IAAD,EAAOA,EAAE,EAAT,CAAP;AACD,GAFD,CAEE,OAAO7H,EAAP,EAAW;AACX,WAAO,CAACA,EAAD,EAAK,IAAL,CAAP;AACD;AACF,CAND;;AAOA,MAAM8H,UAAN,SAAyB1G,MAAzB,CAAgC;AACvB,GAANtD,MAAM,EAAGkC,EAAH,EAAOuD,KAAP,EAAc;AACnB,WAAO,MAAMzF,MAAN,EAAckC,EAAd,EAAkBuD,KAAlB;AAAyB;AAA2B,UAAM,CAAE,CAA5D,CAAP;AACD;;AAEO,GAAP7F,OAAO,EAAG6F,KAAH,EAAU;AAChB,SAAK3F,UAAL,EAAiB2F,KAAjB;;AAEA,QAAI,CAAC,KAAKrE,WAAL,CAAL,EAAwB;AACtB,YAAMc,EAAE,GAAG,KAAKzB,KAAL,EAAY,KAAKwE,GAAjB,EAAsB,KAAKK,KAA3B,CAAX;AACA,UAAIpD,EAAJ,EACE,OAAO,KAAKxB,OAAL,EAAcwB,EAAd,EAAkBuD,KAAlB,CAAP;AACF,WAAKrE,WAAL,IAAoB,IAApB;AACD,KARe,CAUhB;AACA;;;AACA,QAAIqE,KAAK,CAACgB,QAAN,KAAmB,KAAKxB,GAA5B,EAAiC;AAC/B,YAAMiE,MAAM,GAAG1J,QAAQ,CAACP,IAAI,CAACkK,OAAL,CAAa1D,KAAK,CAACgB,QAAnB,CAAD,CAAvB;;AACA,UAAIyC,MAAM,KAAK,KAAKjE,GAApB,EAAyB;AACvB,cAAMgF,QAAQ,GAAG,KAAKxJ,KAAL,EAAYyI,MAAZ,EAAoB,KAAK5D,KAAzB,CAAjB;AACA,YAAI2E,QAAJ,EACE,OAAO,KAAKvJ,OAAL,EAAcuJ,QAAd,EAAwBxE,KAAxB,CAAP;AACH;AACF;;AAED,UAAM,CAAC6D,OAAD,EAAUZ,EAAV,IAAgBoB,QAAQ,CAAC,MAAM/K,EAAE,CAACmL,SAAH,CAAazE,KAAK,CAACgB,QAAnB,CAAP,CAA9B;AACA,QAAIiC,EAAE,KAAK,KAAK5D,IAAL,IAAa,KAAKD,KAAL,IAAc6D,EAAE,CAACV,KAAH,GAAWvC,KAAK,CAACuC,KAAjD,CAAN,EACE,OAAO,KAAKhH,IAAL,EAAWyE,KAAX,CAAP;AAEF,QAAI6D,OAAO,IAAI,KAAKvJ,UAAL,EAAiB0F,KAAjB,EAAwBiD,EAAxB,CAAf,EACE,OAAO,KAAK1I,MAAL,EAAa,IAAb,EAAmByF,KAAnB,CAAP;;AAEF,QAAIiD,EAAE,CAACa,WAAH,EAAJ,EAAsB;AACpB,UAAI9D,KAAK,CAACO,IAAN,KAAe,WAAnB,EAAgC;AAC9B,cAAMwD,SAAS,GAAG,CAAC,KAAKC,OAAN,IAChBhE,KAAK,CAAC0B,IADU,IAEhB,CAACuB,EAAE,CAACvB,IAAH,GAAU,MAAX,MAAuB1B,KAAK,CAAC0B,IAF/B;AAGA,cAAM,CAACjF,EAAD,IAAOsH,SAAS,GAAGM,QAAQ,CAAC,MAAM;AACtC/K,UAAAA,EAAE,CAACoL,SAAH,CAAa1E,KAAK,CAACgB,QAAnB,EAA6BhB,KAAK,CAAC0B,IAAnC;AACD,SAFgC,CAAX,GAEjB,EAFL;AAGA,eAAO,KAAKnH,MAAL,EAAakC,EAAb,EAAiBuD,KAAjB,CAAP;AACD,OATmB,CAUpB;;;AACA,YAAM,CAACvD,EAAD,IAAO4H,QAAQ,CAAC,MAAM/K,EAAE,CAACqL,SAAH,CAAa3E,KAAK,CAACgB,QAAnB,CAAP,CAArB;AACA,WAAKzG,MAAL,EAAakC,EAAb,EAAiBuD,KAAjB;AACD,KAzCe,CA2ChB;AACA;;;AACA,UAAM,CAACvD,EAAD,IAAOuD,KAAK,CAACgB,QAAN,KAAmB,KAAKxB,GAAxB,GAA8B,EAA9B,GACT6E,QAAQ,CAAC,MAAM3H,cAAc,CAACsD,KAAK,CAACgB,QAAP,CAArB,CADZ;AAEA,SAAKzG,MAAL,EAAakC,EAAb,EAAiBuD,KAAjB;AACD;;AAEI,GAAJxF,IAAI,EAAGwF,KAAH,EAAUsC,IAAV,EAAgB;AACnB,UAAMZ,IAAI,GAAG1B,KAAK,CAAC0B,IAAN,GAAa,MAAb,IAAuB,KAAK5B,KAAzC;;AAEA,UAAM8E,IAAI,GAAGnI,EAAE,IAAI;AACjB,UAAIoI,UAAJ;;AACA,UAAI;AACFvL,QAAAA,EAAE,CAACwL,SAAH,CAAa5C,EAAb;AACD,OAFD,CAEE,OAAO6C,CAAP,EAAU;AACVF,QAAAA,UAAU,GAAGE,CAAb;AACD;;AACD,UAAItI,EAAE,IAAIoI,UAAV,EACE,KAAK5J,OAAL,EAAcwB,EAAE,IAAIoI,UAApB,EAAgC7E,KAAhC;AACFsC,MAAAA,IAAI;AACL,KAVD;;AAYA,QAAIP,MAAJ;AACA,QAAIG,EAAJ;;AACA,QAAI;AACFA,MAAAA,EAAE,GAAG5I,EAAE,CAAC0L,QAAH,CAAYhF,KAAK,CAACgB,QAAlB,EAA4B,GAA5B,EAAiCU,IAAjC,CAAL;AACD,KAFD,CAEE,OAAOjF,EAAP,EAAW;AACX,aAAOmI,IAAI,CAACnI,EAAD,CAAX;AACD;;AACD,UAAMsG,EAAE,GAAG,KAAK5E,SAAL,GAAiB,KAAKA,SAAL,CAAe6B,KAAf,KAAyBA,KAA1C,GAAkDA,KAA7D;;AACA,QAAI+C,EAAE,KAAK/C,KAAX,EAAkB;AAChB+C,MAAAA,EAAE,CAAChD,EAAH,CAAM,OAAN,EAAetD,EAAE,IAAI,KAAKxB,OAAL,EAAcwB,EAAd,EAAkBuD,KAAlB,CAArB;AACAA,MAAAA,KAAK,CAACgD,IAAN,CAAWD,EAAX;AACD;;AAEDA,IAAAA,EAAE,CAAChD,EAAH,CAAM,MAAN,EAAckF,KAAK,IAAI;AACrB,UAAI;AACF3L,QAAAA,EAAE,CAAC4L,SAAH,CAAahD,EAAb,EAAiB+C,KAAjB,EAAwB,CAAxB,EAA2BA,KAAK,CAAC7E,MAAjC;AACD,OAFD,CAEE,OAAO3D,EAAP,EAAW;AACXmI,QAAAA,IAAI,CAACnI,EAAD,CAAJ;AACD;AACF,KAND;AAQAsG,IAAAA,EAAE,CAAChD,EAAH,CAAM,KAAN,EAAa9B,CAAC,IAAI;AAChB,UAAIxB,EAAE,GAAG,IAAT,CADgB,CAEhB;AACA;;AACA,UAAIuD,KAAK,CAACuC,KAAN,IAAe,CAAC,KAAKjD,OAAzB,EAAkC;AAChC,cAAMkD,KAAK,GAAGxC,KAAK,CAACwC,KAAN,IAAe,IAAIC,IAAJ,EAA7B;AACA,cAAMF,KAAK,GAAGvC,KAAK,CAACuC,KAApB;;AACA,YAAI;AACFjJ,UAAAA,EAAE,CAAC6L,WAAH,CAAejD,EAAf,EAAmBM,KAAnB,EAA0BD,KAA1B;AACD,SAFD,CAEE,OAAO6C,SAAP,EAAkB;AAClB,cAAI;AACF9L,YAAAA,EAAE,CAAC+L,UAAH,CAAcrF,KAAK,CAACgB,QAApB,EAA8BwB,KAA9B,EAAqCD,KAArC;AACD,WAFD,CAEE,OAAO+C,QAAP,EAAiB;AACjB7I,YAAAA,EAAE,GAAG2I,SAAL;AACD;AACF;AACF;;AAED,UAAI,KAAK5J,OAAL,EAAcwE,KAAd,CAAJ,EAA0B;AACxB,cAAMxB,GAAG,GAAG,KAAK/C,GAAL,EAAUuE,KAAV,CAAZ;AACA,cAAMvB,GAAG,GAAG,KAAK/C,GAAL,EAAUsE,KAAV,CAAZ;;AAEA,YAAI;AACF1G,UAAAA,EAAE,CAACiM,UAAH,CAAcrD,EAAd,EAAkB1D,GAAlB,EAAuBC,GAAvB;AACD,SAFD,CAEE,OAAO+G,QAAP,EAAiB;AACjB,cAAI;AACFlM,YAAAA,EAAE,CAACmM,SAAH,CAAazF,KAAK,CAACgB,QAAnB,EAA6BxC,GAA7B,EAAkCC,GAAlC;AACD,WAFD,CAEE,OAAOiH,OAAP,EAAgB;AAChBjJ,YAAAA,EAAE,GAAGA,EAAE,IAAI+I,QAAX;AACD;AACF;AACF;;AAEDZ,MAAAA,IAAI,CAACnI,EAAD,CAAJ;AACD,KAlCD;AAmCD;;AAES,GAAThC,SAAS,EAAGuF,KAAH,EAAUsC,IAAV,EAAgB;AACxB,UAAMZ,IAAI,GAAG1B,KAAK,CAAC0B,IAAN,GAAa,MAAb,IAAuB,KAAK7B,KAAzC;AACA,UAAMpD,EAAE,GAAG,KAAKzB,KAAL,EAAYgF,KAAK,CAACgB,QAAlB,EAA4BU,IAA5B,CAAX;;AACA,QAAIjF,EAAJ,EAAQ;AACN,WAAKxB,OAAL,EAAcwB,EAAd,EAAkBuD,KAAlB;AACAsC,MAAAA,IAAI;AACJ;AACD;;AACD,QAAItC,KAAK,CAACuC,KAAN,IAAe,CAAC,KAAKjD,OAAzB,EAAkC;AAChC,UAAI;AACFhG,QAAAA,EAAE,CAAC+L,UAAH,CAAcrF,KAAK,CAACgB,QAApB,EAA8BhB,KAAK,CAACwC,KAAN,IAAe,IAAIC,IAAJ,EAA7C,EAAyDzC,KAAK,CAACuC,KAA/D;AACD,OAFD,CAEE,OAAO9F,EAAP,EAAW,CAAE;AAChB;;AACD,QAAI,KAAKjB,OAAL,EAAcwE,KAAd,CAAJ,EAA0B;AACxB,UAAI;AACF1G,QAAAA,EAAE,CAACmM,SAAH,CAAazF,KAAK,CAACgB,QAAnB,EAA6B,KAAKvF,GAAL,EAAUuE,KAAV,CAA7B,EAA+C,KAAKtE,GAAL,EAAUsE,KAAV,CAA/C;AACD,OAFD,CAEE,OAAOvD,EAAP,EAAW,CAAE;AAChB;;AACD6F,IAAAA,IAAI;AACJtC,IAAAA,KAAK,CAACwB,MAAN;AACD;;AAEK,GAALxG,KAAK,EAAG4G,GAAH,EAAQF,IAAR,EAAc;AAClB,QAAI;AACF,aAAOjI,KAAK,CAACE,IAAN,CAAWI,QAAQ,CAAC6H,GAAD,CAAnB,EAA0B;AAC/BpD,QAAAA,GAAG,EAAE,KAAKA,GADqB;AAE/BC,QAAAA,GAAG,EAAE,KAAKA,GAFqB;AAG/BM,QAAAA,UAAU,EAAE,KAAKA,UAHc;AAI/BC,QAAAA,UAAU,EAAE,KAAKA,UAJc;AAK/BY,QAAAA,KAAK,EAAE,KAAKD,YALmB;AAM/BkC,QAAAA,QAAQ,EAAE,KAAKtC,aANgB;AAO/BnD,QAAAA,MAAM,EAAE,KAAKA,MAPkB;AAQ/BiB,QAAAA,KAAK,EAAE,KAAKiB,QARmB;AAS/BkB,QAAAA,GAAG,EAAE,KAAKA,GATqB;AAU/BkC,QAAAA,IAAI,EAAEA;AAVyB,OAA1B,CAAP;AAYD,KAbD,CAaE,OAAOjF,EAAP,EAAW;AACX,aAAOA,EAAP;AACD;AACF;;AAEI,GAAJ/B,IAAI,EAAGsF,KAAH,EAAUS,QAAV,EAAoB2D,IAApB,EAA0B9B,IAA1B,EAAgC;AACnC,QAAI;AACFhJ,MAAAA,EAAE,CAAC8K,IAAI,GAAG,MAAR,CAAF,CAAkB3D,QAAlB,EAA4BT,KAAK,CAACgB,QAAlC;AACAsB,MAAAA,IAAI;AACJtC,MAAAA,KAAK,CAACwB,MAAN;AACD,KAJD,CAIE,OAAO/E,EAAP,EAAW;AACX,aAAO,KAAKxB,OAAL,EAAcwB,EAAd,EAAkBuD,KAAlB,CAAP;AACD;AACF;;AAjL6B;;AAoLhCnC,MAAM,CAAC8H,IAAP,GAAcpB,UAAd;AACAqB,MAAM,CAACC,OAAP,GAAiBhI,MAAjB","sourcesContent":["'use strict'\n\n// the PEND/UNPEND stuff tracks whether we're ready to emit end/close yet.\n// but the path reservations are required to avoid race conditions where\n// parallelized unpack ops may mess with one another, due to dependencies\n// (like a Link depending on its target) or destructive operations (like\n// clobbering an fs object to create one of a different type.)\n\nconst assert = require('assert')\nconst EE = require('events').EventEmitter\nconst Parser = require('./parse.js')\nconst fs = require('fs')\nconst fsm = require('fs-minipass')\nconst path = require('path')\nconst mkdir = require('./mkdir.js')\nconst mkdirSync = mkdir.sync\nconst wc = require('./winchars.js')\nconst stripAbsolutePath = require('./strip-absolute-path.js')\nconst pathReservations = require('./path-reservations.js')\nconst normPath = require('./normalize-windows-path.js')\nconst stripSlash = require('./strip-trailing-slashes.js')\n\nconst ONENTRY = Symbol('onEntry')\nconst CHECKFS = Symbol('checkFs')\nconst CHECKFS2 = Symbol('checkFs2')\nconst PRUNECACHE = Symbol('pruneCache')\nconst ISREUSABLE = Symbol('isReusable')\nconst MAKEFS = Symbol('makeFs')\nconst FILE = Symbol('file')\nconst DIRECTORY = Symbol('directory')\nconst LINK = Symbol('link')\nconst SYMLINK = Symbol('symlink')\nconst HARDLINK = Symbol('hardlink')\nconst UNSUPPORTED = Symbol('unsupported')\nconst UNKNOWN = Symbol('unknown')\nconst CHECKPATH = Symbol('checkPath')\nconst MKDIR = Symbol('mkdir')\nconst ONERROR = Symbol('onError')\nconst PENDING = Symbol('pending')\nconst PEND = Symbol('pend')\nconst UNPEND = Symbol('unpend')\nconst ENDED = Symbol('ended')\nconst MAYBECLOSE = Symbol('maybeClose')\nconst SKIP = Symbol('skip')\nconst DOCHOWN = Symbol('doChown')\nconst UID = Symbol('uid')\nconst GID = Symbol('gid')\nconst CHECKED_CWD = Symbol('checkedCwd')\nconst crypto = require('crypto')\nconst platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform\nconst isWindows = platform === 'win32'\n\n// Unlinks on Windows are not atomic.\n//\n// This means that if you have a file entry, followed by another\n// file entry with an identical name, and you cannot re-use the file\n// (because it's a hardlink, or because unlink:true is set, or it's\n// Windows, which does not have useful nlink values), then the unlink\n// will be committed to the disk AFTER the new file has been written\n// over the old one, deleting the new file.\n//\n// To work around this, on Windows systems, we rename the file and then\n// delete the renamed file.  It's a sloppy kludge, but frankly, I do not\n// know of a better way to do this, given windows' non-atomic unlink\n// semantics.\n//\n// See: https://github.com/npm/node-tar/issues/183\n/* istanbul ignore next */\nconst unlinkFile = (path, cb) => {\n  if (!isWindows)\n    return fs.unlink(path, cb)\n\n  const name = path + '.DELETE.' + crypto.randomBytes(16).toString('hex')\n  fs.rename(path, name, er => {\n    if (er)\n      return cb(er)\n    fs.unlink(name, cb)\n  })\n}\n\n/* istanbul ignore next */\nconst unlinkFileSync = path => {\n  if (!isWindows)\n    return fs.unlinkSync(path)\n\n  const name = path + '.DELETE.' + crypto.randomBytes(16).toString('hex')\n  fs.renameSync(path, name)\n  fs.unlinkSync(name)\n}\n\n// this.gid, entry.gid, this.processUid\nconst uint32 = (a, b, c) =>\n  a === a >>> 0 ? a\n  : b === b >>> 0 ? b\n  : c\n\n// clear the cache if it's a case-insensitive unicode-squashing match.\n// we can't know if the current file system is case-sensitive or supports\n// unicode fully, so we check for similarity on the maximally compatible\n// representation.  Err on the side of pruning, since all it's doing is\n// preventing lstats, and it's not the end of the world if we get a false\n// positive.\n// Note that on windows, we always drop the entire cache whenever a\n// symbolic link is encountered, because 8.3 filenames are impossible\n// to reason about, and collisions are hazards rather than just failures.\nconst cacheKeyNormalize = path => stripSlash(normPath(path))\n  .normalize('NFKD')\n  .toLowerCase()\n\nconst pruneCache = (cache, abs) => {\n  abs = cacheKeyNormalize(abs)\n  for (const path of cache.keys()) {\n    const pnorm = cacheKeyNormalize(path)\n    if (pnorm === abs || pnorm.indexOf(abs + '/') === 0)\n      cache.delete(path)\n  }\n}\n\nconst dropCache = cache => {\n  for (const key of cache.keys())\n    cache.delete(key)\n}\n\nclass Unpack extends Parser {\n  constructor (opt) {\n    if (!opt)\n      opt = {}\n\n    opt.ondone = _ => {\n      this[ENDED] = true\n      this[MAYBECLOSE]()\n    }\n\n    super(opt)\n\n    this[CHECKED_CWD] = false\n\n    this.reservations = pathReservations()\n\n    this.transform = typeof opt.transform === 'function' ? opt.transform : null\n\n    this.writable = true\n    this.readable = false\n\n    this[PENDING] = 0\n    this[ENDED] = false\n\n    this.dirCache = opt.dirCache || new Map()\n\n    if (typeof opt.uid === 'number' || typeof opt.gid === 'number') {\n      // need both or neither\n      if (typeof opt.uid !== 'number' || typeof opt.gid !== 'number')\n        throw new TypeError('cannot set owner without number uid and gid')\n      if (opt.preserveOwner)\n        throw new TypeError(\n          'cannot preserve owner in archive and also set owner explicitly')\n      this.uid = opt.uid\n      this.gid = opt.gid\n      this.setOwner = true\n    } else {\n      this.uid = null\n      this.gid = null\n      this.setOwner = false\n    }\n\n    // default true for root\n    if (opt.preserveOwner === undefined && typeof opt.uid !== 'number')\n      this.preserveOwner = process.getuid && process.getuid() === 0\n    else\n      this.preserveOwner = !!opt.preserveOwner\n\n    this.processUid = (this.preserveOwner || this.setOwner) && process.getuid ?\n      process.getuid() : null\n    this.processGid = (this.preserveOwner || this.setOwner) && process.getgid ?\n      process.getgid() : null\n\n    // mostly just for testing, but useful in some cases.\n    // Forcibly trigger a chown on every entry, no matter what\n    this.forceChown = opt.forceChown === true\n\n    // turn ><?| in filenames into 0xf000-higher encoded forms\n    this.win32 = !!opt.win32 || isWindows\n\n    // do not unpack over files that are newer than what's in the archive\n    this.newer = !!opt.newer\n\n    // do not unpack over ANY files\n    this.keep = !!opt.keep\n\n    // do not set mtime/atime of extracted entries\n    this.noMtime = !!opt.noMtime\n\n    // allow .., absolute path entries, and unpacking through symlinks\n    // without this, warn and skip .., relativize absolutes, and error\n    // on symlinks in extraction path\n    this.preservePaths = !!opt.preservePaths\n\n    // unlink files and links before writing. This breaks existing hard\n    // links, and removes symlink directories rather than erroring\n    this.unlink = !!opt.unlink\n\n    this.cwd = normPath(path.resolve(opt.cwd || process.cwd()))\n    this.strip = +opt.strip || 0\n    this.processUmask = process.umask()\n    this.umask = typeof opt.umask === 'number' ? opt.umask : this.processUmask\n    // default mode for dirs created as parents\n    this.dmode = opt.dmode || (0o0777 & (~this.umask))\n    this.fmode = opt.fmode || (0o0666 & (~this.umask))\n    this.on('entry', entry => this[ONENTRY](entry))\n  }\n\n  [MAYBECLOSE] () {\n    if (this[ENDED] && this[PENDING] === 0) {\n      this.emit('prefinish')\n      this.emit('finish')\n      this.emit('end')\n      this.emit('close')\n    }\n  }\n\n  [CHECKPATH] (entry) {\n    if (this.strip) {\n      const parts = normPath(entry.path).split('/')\n      if (parts.length < this.strip)\n        return false\n      entry.path = parts.slice(this.strip).join('/')\n\n      if (entry.type === 'Link') {\n        const linkparts = normPath(entry.linkpath).split('/')\n        if (linkparts.length >= this.strip)\n          entry.linkpath = linkparts.slice(this.strip).join('/')\n        else\n          return false\n      }\n    }\n\n    if (!this.preservePaths) {\n      const p = normPath(entry.path)\n      const parts = p.split('/')\n      if (parts.includes('..') || isWindows && /^[a-z]:\\.\\.$/i.test(parts[0])) {\n        this.warn(`path contains '..'`, p)\n        return false\n      }\n\n      // strip off the root\n      const s = stripAbsolutePath(p)\n      if (s[0]) {\n        entry.path = s[1]\n        this.warn(`stripping ${s[0]} from absolute path`, p)\n      }\n    }\n\n    if (path.isAbsolute(entry.path))\n      entry.absolute = normPath(path.resolve(entry.path))\n    else\n      entry.absolute = normPath(path.resolve(this.cwd, entry.path))\n\n    // if we somehow ended up with a path that escapes the cwd, and we are\n    // not in preservePaths mode, then something is fishy!  This should have\n    // been prevented above, so ignore this for coverage.\n    /* istanbul ignore if - defense in depth */\n    if (!this.preservePaths &&\n        entry.absolute.indexOf(this.cwd + '/') !== 0 &&\n        entry.absolute !== this.cwd) {\n      this.warn('TAR_ENTRY_ERROR', 'path escaped extraction target', {\n        entry,\n        path: normPath(entry.path),\n        resolvedPath: entry.absolute,\n        cwd: this.cwd,\n      })\n      return false\n    }\n\n    // an archive can set properties on the extraction directory, but it\n    // may not replace the cwd with a different kind of thing entirely.\n    if (entry.absolute === this.cwd &&\n        entry.type !== 'Directory' &&\n        entry.type !== 'GNUDumpDir')\n      return false\n\n    // only encode : chars that aren't drive letter indicators\n    if (this.win32) {\n      const { root: aRoot } = path.win32.parse(entry.absolute)\n      entry.absolute = aRoot + wc.encode(entry.absolute.substr(aRoot.length))\n      const { root: pRoot } = path.win32.parse(entry.path)\n      entry.path = pRoot + wc.encode(entry.path.substr(pRoot.length))\n    }\n\n    return true\n  }\n\n  [ONENTRY] (entry) {\n    if (!this[CHECKPATH](entry))\n      return entry.resume()\n\n    assert.equal(typeof entry.absolute, 'string')\n\n    switch (entry.type) {\n      case 'Directory':\n      case 'GNUDumpDir':\n        if (entry.mode)\n          entry.mode = entry.mode | 0o700\n\n      case 'File':\n      case 'OldFile':\n      case 'ContiguousFile':\n      case 'Link':\n      case 'SymbolicLink':\n        return this[CHECKFS](entry)\n\n      case 'CharacterDevice':\n      case 'BlockDevice':\n      case 'FIFO':\n        return this[UNSUPPORTED](entry)\n    }\n  }\n\n  [ONERROR] (er, entry) {\n    // Cwd has to exist, or else nothing works. That's serious.\n    // Other errors are warnings, which raise the error in strict\n    // mode, but otherwise continue on.\n    if (er.name === 'CwdError')\n      this.emit('error', er)\n    else {\n      this.warn(er.message, er)\n      this[UNPEND]()\n      entry.resume()\n    }\n  }\n\n  [MKDIR] (dir, mode, cb) {\n    mkdir(normPath(dir), {\n      uid: this.uid,\n      gid: this.gid,\n      processUid: this.processUid,\n      processGid: this.processGid,\n      umask: this.processUmask,\n      preserve: this.preservePaths,\n      unlink: this.unlink,\n      cache: this.dirCache,\n      cwd: this.cwd,\n      mode: mode\n    }, cb)\n  }\n\n  [DOCHOWN] (entry) {\n    // in preserve owner mode, chown if the entry doesn't match process\n    // in set owner mode, chown if setting doesn't match process\n    return this.forceChown ||\n      this.preserveOwner &&\n      ( typeof entry.uid === 'number' && entry.uid !== this.processUid ||\n        typeof entry.gid === 'number' && entry.gid !== this.processGid )\n      ||\n      ( typeof this.uid === 'number' && this.uid !== this.processUid ||\n        typeof this.gid === 'number' && this.gid !== this.processGid )\n  }\n\n  [UID] (entry) {\n    return uint32(this.uid, entry.uid, this.processUid)\n  }\n\n  [GID] (entry) {\n    return uint32(this.gid, entry.gid, this.processGid)\n  }\n\n  [FILE] (entry, fullyDone) {\n    const mode = entry.mode & 0o7777 || this.fmode\n    const stream = new fsm.WriteStream(entry.absolute, {\n      mode: mode,\n      autoClose: false\n    })\n    stream.on('error', er => {\n      if (stream.fd)\n        fs.close(stream.fd, () => {})\n\n      // flush all the data out so that we aren't left hanging\n      // if the error wasn't actually fatal.  otherwise the parse\n      // is blocked, and we never proceed.\n      /* istanbul ignore next */\n      stream.write = () => true\n      this[ONERROR](er, entry)\n      fullyDone()\n    })\n\n    let actions = 1\n    const done = er => {\n      if (er) {\n        /* istanbul ignore else - we should always have a fd by now */\n        if (stream.fd)\n          fs.close(stream.fd, () => {})\n\n        this[ONERROR](er, entry)\n        fullyDone()\n        return\n      }\n\n      if (--actions === 0) {\n        fs.close(stream.fd, er => {\n          fullyDone()\n          /* istanbul ignore next */\n          er ? this[ONERROR](er, entry) : this[UNPEND]()\n        })\n      }\n    }\n\n    stream.on('finish', _ => {\n      // if futimes fails, try utimes\n      // if utimes fails, fail with the original error\n      // same for fchown/chown\n      const abs = entry.absolute\n      const fd = stream.fd\n\n      if (entry.mtime && !this.noMtime) {\n        actions++\n        const atime = entry.atime || new Date()\n        const mtime = entry.mtime\n        fs.futimes(fd, atime, mtime, er =>\n          er ? fs.utimes(abs, atime, mtime, er2 => done(er2 && er))\n          : done())\n      }\n\n      if (this[DOCHOWN](entry)) {\n        actions++\n        const uid = this[UID](entry)\n        const gid = this[GID](entry)\n        fs.fchown(fd, uid, gid, er =>\n          er ? fs.chown(abs, uid, gid, er2 => done(er2 && er))\n          : done())\n      }\n\n      done()\n    })\n\n    const tx = this.transform ? this.transform(entry) || entry : entry\n    if (tx !== entry) {\n      tx.on('error', er => this[ONERROR](er, entry))\n      entry.pipe(tx)\n    }\n    tx.pipe(stream)\n  }\n\n  [DIRECTORY] (entry, fullyDone) {\n    const mode = entry.mode & 0o7777 || this.dmode\n    this[MKDIR](entry.absolute, mode, er => {\n      if (er) {\n        fullyDone()\n        return this[ONERROR](er, entry)\n      }\n\n      let actions = 1\n      const done = _ => {\n        if (--actions === 0) {\n          fullyDone()\n          this[UNPEND]()\n          entry.resume()\n        }\n      }\n\n      if (entry.mtime && !this.noMtime) {\n        actions++\n        fs.utimes(entry.absolute, entry.atime || new Date(), entry.mtime, done)\n      }\n\n      if (this[DOCHOWN](entry)) {\n        actions++\n        fs.chown(entry.absolute, this[UID](entry), this[GID](entry), done)\n      }\n\n      done()\n    })\n  }\n\n  [UNSUPPORTED] (entry) {\n    this.warn('unsupported entry type: ' + entry.type, entry)\n    entry.resume()\n  }\n\n  [SYMLINK] (entry, done) {\n    this[LINK](entry, entry.linkpath, 'symlink', done)\n  }\n\n  [HARDLINK] (entry, done) {\n    const linkpath = normPath(path.resolve(this.cwd, entry.linkpath))\n    this[LINK](entry, linkpath, 'link', done)\n  }\n\n  [PEND] () {\n    this[PENDING]++\n  }\n\n  [UNPEND] () {\n    this[PENDING]--\n    this[MAYBECLOSE]()\n  }\n\n  [SKIP] (entry) {\n    this[UNPEND]()\n    entry.resume()\n  }\n\n  // Check if we can reuse an existing filesystem entry safely and\n  // overwrite it, rather than unlinking and recreating\n  // Windows doesn't report a useful nlink, so we just never reuse entries\n  [ISREUSABLE] (entry, st) {\n    return entry.type === 'File' &&\n      !this.unlink &&\n      st.isFile() &&\n      st.nlink <= 1 &&\n      !isWindows\n  }\n\n  // check if a thing is there, and if so, try to clobber it\n  [CHECKFS] (entry) {\n    this[PEND]()\n    const paths = [entry.path]\n    if (entry.linkpath)\n      paths.push(entry.linkpath)\n    this.reservations.reserve(paths, done => this[CHECKFS2](entry, done))\n  }\n\n  [PRUNECACHE] (entry) {\n    // if we are not creating a directory, and the path is in the dirCache,\n    // then that means we are about to delete the directory we created\n    // previously, and it is no longer going to be a directory, and neither\n    // is any of its children.\n    // If a symbolic link is encountered, all bets are off.  There is no\n    // reasonable way to sanitize the cache in such a way we will be able to\n    // avoid having filesystem collisions.  If this happens with a non-symlink\n    // entry, it'll just fail to unpack, but a symlink to a directory, using an\n    // 8.3 shortname or certain unicode attacks, can evade detection and lead\n    // to arbitrary writes to anywhere on the system.\n    if (entry.type === 'SymbolicLink')\n      dropCache(this.dirCache)\n    else if (entry.type !== 'Directory')\n      pruneCache(this.dirCache, entry.absolute)\n  }\n\n  [CHECKFS2] (entry, fullyDone) {\n    this[PRUNECACHE](entry)\n\n    const done = er => {\n      this[PRUNECACHE](entry)\n      fullyDone(er)\n    }\n\n    const checkCwd = () => {\n      this[MKDIR](this.cwd, this.dmode, er => {\n        if (er) {\n          this[ONERROR](er, entry)\n          done()\n          return\n        }\n        this[CHECKED_CWD] = true\n        start()\n      })\n    }\n\n    const start = () => {\n      if (entry.absolute !== this.cwd) {\n        const parent = normPath(path.dirname(entry.absolute))\n        if (parent !== this.cwd) {\n          return this[MKDIR](parent, this.dmode, er => {\n            if (er) {\n              this[ONERROR](er, entry)\n              done()\n              return\n            }\n            afterMakeParent()\n          })\n        }\n      }\n      afterMakeParent()\n    }\n\n    const afterMakeParent = () => {\n      fs.lstat(entry.absolute, (lstatEr, st) => {\n        if (st && (this.keep || this.newer && st.mtime > entry.mtime)) {\n          this[SKIP](entry)\n          done()\n          return\n        }\n        if (lstatEr || this[ISREUSABLE](entry, st))\n          return this[MAKEFS](null, entry, done)\n\n        if (st.isDirectory()) {\n          if (entry.type === 'Directory') {\n            const needChmod = !this.noChmod &&\n              entry.mode &&\n              (st.mode & 0o7777) !== entry.mode\n            const afterChmod = er => this[MAKEFS](er, entry, done)\n            if (!needChmod)\n              return afterChmod()\n            return fs.chmod(entry.absolute, entry.mode, afterChmod)\n          }\n          // Not a dir entry, have to remove it.\n          // NB: the only way to end up with an entry that is the cwd\n          // itself, in such a way that == does not detect, is a\n          // tricky windows absolute path with UNC or 8.3 parts (and\n          // preservePaths:true, or else it will have been stripped).\n          // In that case, the user has opted out of path protections\n          // explicitly, so if they blow away the cwd, c'est la vie.\n          if (entry.absolute !== this.cwd) {\n            return fs.rmdir(entry.absolute, er =>\n              this[MAKEFS](er, entry, done))\n          }\n        }\n\n        // not a dir, and not reusable\n        // don't remove if the cwd, we want that error\n        if (entry.absolute === this.cwd)\n          return this[MAKEFS](null, entry, done)\n\n        unlinkFile(entry.absolute, er =>\n          this[MAKEFS](er, entry, done))\n      })\n    }\n\n    if (this[CHECKED_CWD])\n      start()\n    else\n      checkCwd()\n  }\n\n  [MAKEFS] (er, entry, done) {\n    if (er)\n      return this[ONERROR](er, entry)\n\n    switch (entry.type) {\n      case 'File':\n      case 'OldFile':\n      case 'ContiguousFile':\n        return this[FILE](entry, done)\n\n      case 'Link':\n        return this[HARDLINK](entry, done)\n\n      case 'SymbolicLink':\n        return this[SYMLINK](entry, done)\n\n      case 'Directory':\n      case 'GNUDumpDir':\n        return this[DIRECTORY](entry, done)\n    }\n  }\n\n  [LINK] (entry, linkpath, link, done) {\n    // XXX: get the type ('symlink' or 'junction') for windows\n    fs[link](linkpath, entry.absolute, er => {\n      if (er)\n        return this[ONERROR](er, entry)\n      done()\n      this[UNPEND]()\n      entry.resume()\n    })\n  }\n}\n\nconst callSync = fn => {\n  try {\n    return [null, fn()]\n  } catch (er) {\n    return [er, null]\n  }\n}\nclass UnpackSync extends Unpack {\n  [MAKEFS] (er, entry) {\n    return super[MAKEFS](er, entry, /* istanbul ignore next */ () => {})\n  }\n\n  [CHECKFS] (entry) {\n    this[PRUNECACHE](entry)\n\n    if (!this[CHECKED_CWD]) {\n      const er = this[MKDIR](this.cwd, this.dmode)\n      if (er)\n        return this[ONERROR](er, entry)\n      this[CHECKED_CWD] = true\n    }\n\n    // don't bother to make the parent if the current entry is the cwd,\n    // we've already checked it.\n    if (entry.absolute !== this.cwd) {\n      const parent = normPath(path.dirname(entry.absolute))\n      if (parent !== this.cwd) {\n        const mkParent = this[MKDIR](parent, this.dmode)\n        if (mkParent)\n          return this[ONERROR](mkParent, entry)\n      }\n    }\n\n    const [lstatEr, st] = callSync(() => fs.lstatSync(entry.absolute))\n    if (st && (this.keep || this.newer && st.mtime > entry.mtime))\n      return this[SKIP](entry)\n\n    if (lstatEr || this[ISREUSABLE](entry, st))\n      return this[MAKEFS](null, entry)\n\n    if (st.isDirectory()) {\n      if (entry.type === 'Directory') {\n        const needChmod = !this.noChmod &&\n          entry.mode &&\n          (st.mode & 0o7777) !== entry.mode\n        const [er] = needChmod ? callSync(() => {\n          fs.chmodSync(entry.absolute, entry.mode)\n        }) : []\n        return this[MAKEFS](er, entry)\n      }\n      // not a dir entry, have to remove it\n      const [er] = callSync(() => fs.rmdirSync(entry.absolute))\n      this[MAKEFS](er, entry)\n    }\n\n    // not a dir, and not reusable.\n    // don't remove if it's the cwd, since we want that error.\n    const [er] = entry.absolute === this.cwd ? []\n      : callSync(() => unlinkFileSync(entry.absolute))\n    this[MAKEFS](er, entry)\n  }\n\n  [FILE] (entry, done) {\n    const mode = entry.mode & 0o7777 || this.fmode\n\n    const oner = er => {\n      let closeError\n      try {\n        fs.closeSync(fd)\n      } catch (e) {\n        closeError = e\n      }\n      if (er || closeError)\n        this[ONERROR](er || closeError, entry)\n      done()\n    }\n\n    let stream\n    let fd\n    try {\n      fd = fs.openSync(entry.absolute, 'w', mode)\n    } catch (er) {\n      return oner(er)\n    }\n    const tx = this.transform ? this.transform(entry) || entry : entry\n    if (tx !== entry) {\n      tx.on('error', er => this[ONERROR](er, entry))\n      entry.pipe(tx)\n    }\n\n    tx.on('data', chunk => {\n      try {\n        fs.writeSync(fd, chunk, 0, chunk.length)\n      } catch (er) {\n        oner(er)\n      }\n    })\n\n    tx.on('end', _ => {\n      let er = null\n      // try both, falling futimes back to utimes\n      // if either fails, handle the first error\n      if (entry.mtime && !this.noMtime) {\n        const atime = entry.atime || new Date()\n        const mtime = entry.mtime\n        try {\n          fs.futimesSync(fd, atime, mtime)\n        } catch (futimeser) {\n          try {\n            fs.utimesSync(entry.absolute, atime, mtime)\n          } catch (utimeser) {\n            er = futimeser\n          }\n        }\n      }\n\n      if (this[DOCHOWN](entry)) {\n        const uid = this[UID](entry)\n        const gid = this[GID](entry)\n\n        try {\n          fs.fchownSync(fd, uid, gid)\n        } catch (fchowner) {\n          try {\n            fs.chownSync(entry.absolute, uid, gid)\n          } catch (chowner) {\n            er = er || fchowner\n          }\n        }\n      }\n\n      oner(er)\n    })\n  }\n\n  [DIRECTORY] (entry, done) {\n    const mode = entry.mode & 0o7777 || this.dmode\n    const er = this[MKDIR](entry.absolute, mode)\n    if (er) {\n      this[ONERROR](er, entry)\n      done()\n      return\n    }\n    if (entry.mtime && !this.noMtime) {\n      try {\n        fs.utimesSync(entry.absolute, entry.atime || new Date(), entry.mtime)\n      } catch (er) {}\n    }\n    if (this[DOCHOWN](entry)) {\n      try {\n        fs.chownSync(entry.absolute, this[UID](entry), this[GID](entry))\n      } catch (er) {}\n    }\n    done()\n    entry.resume()\n  }\n\n  [MKDIR] (dir, mode) {\n    try {\n      return mkdir.sync(normPath(dir), {\n        uid: this.uid,\n        gid: this.gid,\n        processUid: this.processUid,\n        processGid: this.processGid,\n        umask: this.processUmask,\n        preserve: this.preservePaths,\n        unlink: this.unlink,\n        cache: this.dirCache,\n        cwd: this.cwd,\n        mode: mode\n      })\n    } catch (er) {\n      return er\n    }\n  }\n\n  [LINK] (entry, linkpath, link, done) {\n    try {\n      fs[link + 'Sync'](linkpath, entry.absolute)\n      done()\n      entry.resume()\n    } catch (er) {\n      return this[ONERROR](er, entry)\n    }\n  }\n}\n\nUnpack.Sync = UnpackSync\nmodule.exports = Unpack\n"]},"metadata":{},"sourceType":"script"}