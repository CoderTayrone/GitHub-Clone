{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RuntimeWorkerPool = exports.RuntimeWorker = exports.RuntimeWorkerState = void 0;\n\nconst uuid = require(\"uuid\");\n\nconst types_1 = require(\"./types\");\n\nconst functionsEmulatorShared_1 = require(\"./functionsEmulatorShared\");\n\nconst events_1 = require(\"events\");\n\nconst emulatorLogger_1 = require(\"./emulatorLogger\");\n\nconst error_1 = require(\"../error\");\n\nvar RuntimeWorkerState;\n\n(function (RuntimeWorkerState) {\n  RuntimeWorkerState[\"IDLE\"] = \"IDLE\";\n  RuntimeWorkerState[\"BUSY\"] = \"BUSY\";\n  RuntimeWorkerState[\"FINISHING\"] = \"FINISHING\";\n  RuntimeWorkerState[\"FINISHED\"] = \"FINISHED\";\n})(RuntimeWorkerState = exports.RuntimeWorkerState || (exports.RuntimeWorkerState = {}));\n\nclass RuntimeWorker {\n  constructor(key, runtime) {\n    this.stateEvents = new events_1.EventEmitter();\n    this.logListeners = [];\n    this._state = RuntimeWorkerState.IDLE;\n    this.id = uuid.v4();\n    this.key = key;\n    this.runtime = runtime;\n    this.runtime.events.on(\"log\", log => {\n      if (log.type === \"runtime-status\") {\n        if (log.data.state === \"idle\") {\n          if (this.state === RuntimeWorkerState.BUSY) {\n            this.state = RuntimeWorkerState.IDLE;\n          } else if (this.state === RuntimeWorkerState.FINISHING) {\n            this.log(`IDLE --> FINISHING`);\n            this.runtime.shutdown();\n          }\n        }\n      }\n    });\n    this.runtime.exit.then(() => {\n      this.log(\"exited\");\n      this.state = RuntimeWorkerState.FINISHED;\n    });\n  }\n\n  execute(frb, opts) {\n    const execFrb = Object.assign({}, frb);\n\n    if (!execFrb.socketPath) {\n      execFrb.socketPath = functionsEmulatorShared_1.getTemporarySocketPath(this.runtime.pid, execFrb.cwd);\n      this.log(`Assigning socketPath: ${execFrb.socketPath}`);\n    }\n\n    const args = {\n      frb: execFrb,\n      opts\n    };\n    this.state = RuntimeWorkerState.BUSY;\n    this.lastArgs = args;\n    this.runtime.send(args);\n  }\n\n  get state() {\n    return this._state;\n  }\n\n  set state(state) {\n    if (state === RuntimeWorkerState.BUSY) {\n      this.socketReady = types_1.EmulatorLog.waitForLog(this.runtime.events, \"SYSTEM\", \"runtime-status\", el => {\n        return el.data.state === \"ready\";\n      });\n    }\n\n    if (state === RuntimeWorkerState.IDLE) {\n      for (const l of this.logListeners) {\n        this.runtime.events.removeListener(\"log\", l);\n      }\n\n      this.logListeners = [];\n      this.socketReady = undefined;\n    }\n\n    if (state === RuntimeWorkerState.FINISHED) {\n      this.runtime.events.removeAllListeners();\n    }\n\n    this.log(state);\n    this._state = state;\n    this.stateEvents.emit(this._state);\n  }\n\n  onLogs(listener, forever = false) {\n    if (!forever) {\n      this.logListeners.push(listener);\n    }\n\n    this.runtime.events.on(\"log\", listener);\n  }\n\n  waitForDone() {\n    if (this.state === RuntimeWorkerState.IDLE || this.state === RuntimeWorkerState.FINISHED) {\n      return Promise.resolve();\n    }\n\n    return new Promise(res => {\n      const listener = () => {\n        this.stateEvents.removeListener(RuntimeWorkerState.IDLE, listener);\n        this.stateEvents.removeListener(RuntimeWorkerState.FINISHED, listener);\n        res();\n      };\n\n      this.stateEvents.once(RuntimeWorkerState.IDLE, listener);\n      this.stateEvents.once(RuntimeWorkerState.FINISHED, listener);\n    });\n  }\n\n  waitForSocketReady() {\n    return this.socketReady || Promise.reject(new Error(\"Cannot call waitForSocketReady() if runtime is not BUSY\"));\n  }\n\n  log(msg) {\n    emulatorLogger_1.EmulatorLogger.forEmulator(types_1.Emulators.FUNCTIONS).log(\"DEBUG\", `[worker-${this.key}-${this.id}]: ${msg}`);\n  }\n\n}\n\nexports.RuntimeWorker = RuntimeWorker;\n\nclass RuntimeWorkerPool {\n  constructor(mode = types_1.FunctionsExecutionMode.AUTO) {\n    this.mode = mode;\n    this.workers = new Map();\n  }\n\n  getKey(triggerId) {\n    if (this.mode === types_1.FunctionsExecutionMode.SEQUENTIAL) {\n      return \"~shared~\";\n    } else {\n      return triggerId || \"~diagnostic~\";\n    }\n  }\n\n  refresh() {\n    for (const arr of this.workers.values()) {\n      arr.forEach(w => {\n        if (w.state === RuntimeWorkerState.IDLE) {\n          this.log(`Shutting down IDLE worker (${w.key})`);\n          w.state = RuntimeWorkerState.FINISHING;\n          w.runtime.shutdown();\n        } else if (w.state === RuntimeWorkerState.BUSY) {\n          this.log(`Marking BUSY worker to finish (${w.key})`);\n          w.state = RuntimeWorkerState.FINISHING;\n        }\n      });\n    }\n  }\n\n  exit() {\n    for (const arr of this.workers.values()) {\n      arr.forEach(w => {\n        if (w.state === RuntimeWorkerState.IDLE) {\n          w.runtime.shutdown();\n        } else {\n          w.runtime.kill();\n        }\n      });\n    }\n  }\n\n  readyForWork(triggerId) {\n    const idleWorker = this.getIdleWorker(triggerId);\n    return !!idleWorker;\n  }\n\n  submitWork(triggerId, frb, opts) {\n    this.log(`submitWork(triggerId=${triggerId})`);\n    const worker = this.getIdleWorker(triggerId);\n\n    if (!worker) {\n      throw new error_1.FirebaseError(\"Internal Error: can't call submitWork without checking for idle workers\");\n    }\n\n    worker.execute(frb, opts);\n    return worker;\n  }\n\n  getIdleWorker(triggerId) {\n    this.cleanUpWorkers();\n    const triggerWorkers = this.getTriggerWorkers(triggerId);\n\n    if (!triggerWorkers.length) {\n      this.setTriggerWorkers(triggerId, []);\n      return;\n    }\n\n    for (const worker of triggerWorkers) {\n      if (worker.state === RuntimeWorkerState.IDLE) {\n        return worker;\n      }\n    }\n\n    return;\n  }\n\n  addWorker(triggerId, runtime) {\n    const worker = new RuntimeWorker(this.getKey(triggerId), runtime);\n    this.log(`addWorker(${worker.key})`);\n    const keyWorkers = this.getTriggerWorkers(triggerId);\n    keyWorkers.push(worker);\n    this.setTriggerWorkers(triggerId, keyWorkers);\n    const logger = triggerId ? emulatorLogger_1.EmulatorLogger.forFunction(triggerId) : emulatorLogger_1.EmulatorLogger.forEmulator(types_1.Emulators.FUNCTIONS);\n    worker.onLogs(log => {\n      logger.handleRuntimeLog(log);\n    }, true);\n    this.log(`Adding worker with key ${worker.key}, total=${keyWorkers.length}`);\n    return worker;\n  }\n\n  getTriggerWorkers(triggerId) {\n    return this.workers.get(this.getKey(triggerId)) || [];\n  }\n\n  setTriggerWorkers(triggerId, workers) {\n    this.workers.set(this.getKey(triggerId), workers);\n  }\n\n  cleanUpWorkers() {\n    for (const [key, keyWorkers] of this.workers.entries()) {\n      const notDoneWorkers = keyWorkers.filter(worker => {\n        return worker.state !== RuntimeWorkerState.FINISHED;\n      });\n\n      if (notDoneWorkers.length !== keyWorkers.length) {\n        this.log(`Cleaned up workers for ${key}: ${keyWorkers.length} --> ${notDoneWorkers.length}`);\n      }\n\n      this.setTriggerWorkers(key, notDoneWorkers);\n    }\n  }\n\n  log(msg) {\n    emulatorLogger_1.EmulatorLogger.forEmulator(types_1.Emulators.FUNCTIONS).log(\"DEBUG\", `[worker-pool] ${msg}`);\n  }\n\n}\n\nexports.RuntimeWorkerPool = RuntimeWorkerPool;","map":{"version":3,"sources":["/home/dev/Documentos/Projects/github-clone/node_modules/firebase-tools/lib/emulator/functionsRuntimeWorker.js"],"names":["Object","defineProperty","exports","value","RuntimeWorkerPool","RuntimeWorker","RuntimeWorkerState","uuid","require","types_1","functionsEmulatorShared_1","events_1","emulatorLogger_1","error_1","constructor","key","runtime","stateEvents","EventEmitter","logListeners","_state","IDLE","id","v4","events","on","log","type","data","state","BUSY","FINISHING","shutdown","exit","then","FINISHED","execute","frb","opts","execFrb","assign","socketPath","getTemporarySocketPath","pid","cwd","args","lastArgs","send","socketReady","EmulatorLog","waitForLog","el","l","removeListener","undefined","removeAllListeners","emit","onLogs","listener","forever","push","waitForDone","Promise","resolve","res","once","waitForSocketReady","reject","Error","msg","EmulatorLogger","forEmulator","Emulators","FUNCTIONS","mode","FunctionsExecutionMode","AUTO","workers","Map","getKey","triggerId","SEQUENTIAL","refresh","arr","values","forEach","w","kill","readyForWork","idleWorker","getIdleWorker","submitWork","worker","FirebaseError","cleanUpWorkers","triggerWorkers","getTriggerWorkers","length","setTriggerWorkers","addWorker","keyWorkers","logger","forFunction","handleRuntimeLog","get","set","entries","notDoneWorkers","filter"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RuntimeWorkerPool = exports.RuntimeWorker = exports.RuntimeWorkerState = void 0;\nconst uuid = require(\"uuid\");\nconst types_1 = require(\"./types\");\nconst functionsEmulatorShared_1 = require(\"./functionsEmulatorShared\");\nconst events_1 = require(\"events\");\nconst emulatorLogger_1 = require(\"./emulatorLogger\");\nconst error_1 = require(\"../error\");\nvar RuntimeWorkerState;\n(function (RuntimeWorkerState) {\n    RuntimeWorkerState[\"IDLE\"] = \"IDLE\";\n    RuntimeWorkerState[\"BUSY\"] = \"BUSY\";\n    RuntimeWorkerState[\"FINISHING\"] = \"FINISHING\";\n    RuntimeWorkerState[\"FINISHED\"] = \"FINISHED\";\n})(RuntimeWorkerState = exports.RuntimeWorkerState || (exports.RuntimeWorkerState = {}));\nclass RuntimeWorker {\n    constructor(key, runtime) {\n        this.stateEvents = new events_1.EventEmitter();\n        this.logListeners = [];\n        this._state = RuntimeWorkerState.IDLE;\n        this.id = uuid.v4();\n        this.key = key;\n        this.runtime = runtime;\n        this.runtime.events.on(\"log\", (log) => {\n            if (log.type === \"runtime-status\") {\n                if (log.data.state === \"idle\") {\n                    if (this.state === RuntimeWorkerState.BUSY) {\n                        this.state = RuntimeWorkerState.IDLE;\n                    }\n                    else if (this.state === RuntimeWorkerState.FINISHING) {\n                        this.log(`IDLE --> FINISHING`);\n                        this.runtime.shutdown();\n                    }\n                }\n            }\n        });\n        this.runtime.exit.then(() => {\n            this.log(\"exited\");\n            this.state = RuntimeWorkerState.FINISHED;\n        });\n    }\n    execute(frb, opts) {\n        const execFrb = Object.assign({}, frb);\n        if (!execFrb.socketPath) {\n            execFrb.socketPath = functionsEmulatorShared_1.getTemporarySocketPath(this.runtime.pid, execFrb.cwd);\n            this.log(`Assigning socketPath: ${execFrb.socketPath}`);\n        }\n        const args = { frb: execFrb, opts };\n        this.state = RuntimeWorkerState.BUSY;\n        this.lastArgs = args;\n        this.runtime.send(args);\n    }\n    get state() {\n        return this._state;\n    }\n    set state(state) {\n        if (state === RuntimeWorkerState.BUSY) {\n            this.socketReady = types_1.EmulatorLog.waitForLog(this.runtime.events, \"SYSTEM\", \"runtime-status\", (el) => {\n                return el.data.state === \"ready\";\n            });\n        }\n        if (state === RuntimeWorkerState.IDLE) {\n            for (const l of this.logListeners) {\n                this.runtime.events.removeListener(\"log\", l);\n            }\n            this.logListeners = [];\n            this.socketReady = undefined;\n        }\n        if (state === RuntimeWorkerState.FINISHED) {\n            this.runtime.events.removeAllListeners();\n        }\n        this.log(state);\n        this._state = state;\n        this.stateEvents.emit(this._state);\n    }\n    onLogs(listener, forever = false) {\n        if (!forever) {\n            this.logListeners.push(listener);\n        }\n        this.runtime.events.on(\"log\", listener);\n    }\n    waitForDone() {\n        if (this.state === RuntimeWorkerState.IDLE || this.state === RuntimeWorkerState.FINISHED) {\n            return Promise.resolve();\n        }\n        return new Promise((res) => {\n            const listener = () => {\n                this.stateEvents.removeListener(RuntimeWorkerState.IDLE, listener);\n                this.stateEvents.removeListener(RuntimeWorkerState.FINISHED, listener);\n                res();\n            };\n            this.stateEvents.once(RuntimeWorkerState.IDLE, listener);\n            this.stateEvents.once(RuntimeWorkerState.FINISHED, listener);\n        });\n    }\n    waitForSocketReady() {\n        return (this.socketReady ||\n            Promise.reject(new Error(\"Cannot call waitForSocketReady() if runtime is not BUSY\")));\n    }\n    log(msg) {\n        emulatorLogger_1.EmulatorLogger.forEmulator(types_1.Emulators.FUNCTIONS).log(\"DEBUG\", `[worker-${this.key}-${this.id}]: ${msg}`);\n    }\n}\nexports.RuntimeWorker = RuntimeWorker;\nclass RuntimeWorkerPool {\n    constructor(mode = types_1.FunctionsExecutionMode.AUTO) {\n        this.mode = mode;\n        this.workers = new Map();\n    }\n    getKey(triggerId) {\n        if (this.mode === types_1.FunctionsExecutionMode.SEQUENTIAL) {\n            return \"~shared~\";\n        }\n        else {\n            return triggerId || \"~diagnostic~\";\n        }\n    }\n    refresh() {\n        for (const arr of this.workers.values()) {\n            arr.forEach((w) => {\n                if (w.state === RuntimeWorkerState.IDLE) {\n                    this.log(`Shutting down IDLE worker (${w.key})`);\n                    w.state = RuntimeWorkerState.FINISHING;\n                    w.runtime.shutdown();\n                }\n                else if (w.state === RuntimeWorkerState.BUSY) {\n                    this.log(`Marking BUSY worker to finish (${w.key})`);\n                    w.state = RuntimeWorkerState.FINISHING;\n                }\n            });\n        }\n    }\n    exit() {\n        for (const arr of this.workers.values()) {\n            arr.forEach((w) => {\n                if (w.state === RuntimeWorkerState.IDLE) {\n                    w.runtime.shutdown();\n                }\n                else {\n                    w.runtime.kill();\n                }\n            });\n        }\n    }\n    readyForWork(triggerId) {\n        const idleWorker = this.getIdleWorker(triggerId);\n        return !!idleWorker;\n    }\n    submitWork(triggerId, frb, opts) {\n        this.log(`submitWork(triggerId=${triggerId})`);\n        const worker = this.getIdleWorker(triggerId);\n        if (!worker) {\n            throw new error_1.FirebaseError(\"Internal Error: can't call submitWork without checking for idle workers\");\n        }\n        worker.execute(frb, opts);\n        return worker;\n    }\n    getIdleWorker(triggerId) {\n        this.cleanUpWorkers();\n        const triggerWorkers = this.getTriggerWorkers(triggerId);\n        if (!triggerWorkers.length) {\n            this.setTriggerWorkers(triggerId, []);\n            return;\n        }\n        for (const worker of triggerWorkers) {\n            if (worker.state === RuntimeWorkerState.IDLE) {\n                return worker;\n            }\n        }\n        return;\n    }\n    addWorker(triggerId, runtime) {\n        const worker = new RuntimeWorker(this.getKey(triggerId), runtime);\n        this.log(`addWorker(${worker.key})`);\n        const keyWorkers = this.getTriggerWorkers(triggerId);\n        keyWorkers.push(worker);\n        this.setTriggerWorkers(triggerId, keyWorkers);\n        const logger = triggerId\n            ? emulatorLogger_1.EmulatorLogger.forFunction(triggerId)\n            : emulatorLogger_1.EmulatorLogger.forEmulator(types_1.Emulators.FUNCTIONS);\n        worker.onLogs((log) => {\n            logger.handleRuntimeLog(log);\n        }, true);\n        this.log(`Adding worker with key ${worker.key}, total=${keyWorkers.length}`);\n        return worker;\n    }\n    getTriggerWorkers(triggerId) {\n        return this.workers.get(this.getKey(triggerId)) || [];\n    }\n    setTriggerWorkers(triggerId, workers) {\n        this.workers.set(this.getKey(triggerId), workers);\n    }\n    cleanUpWorkers() {\n        for (const [key, keyWorkers] of this.workers.entries()) {\n            const notDoneWorkers = keyWorkers.filter((worker) => {\n                return worker.state !== RuntimeWorkerState.FINISHED;\n            });\n            if (notDoneWorkers.length !== keyWorkers.length) {\n                this.log(`Cleaned up workers for ${key}: ${keyWorkers.length} --> ${notDoneWorkers.length}`);\n            }\n            this.setTriggerWorkers(key, notDoneWorkers);\n        }\n    }\n    log(msg) {\n        emulatorLogger_1.EmulatorLogger.forEmulator(types_1.Emulators.FUNCTIONS).log(\"DEBUG\", `[worker-pool] ${msg}`);\n    }\n}\nexports.RuntimeWorkerPool = RuntimeWorkerPool;\n"]},"metadata":{},"sourceType":"script"}