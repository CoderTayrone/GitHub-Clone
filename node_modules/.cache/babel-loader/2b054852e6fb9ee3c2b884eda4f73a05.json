{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.exportEmulatorData = exports.startAll = exports.shouldStart = exports.filterEmulatorTargets = exports.cleanShutdown = exports.onExit = exports.exportOnExit = exports.startEmulator = void 0;\n\nconst _ = require(\"lodash\");\n\nconst clc = require(\"cli-color\");\n\nconst fs = require(\"fs\");\n\nconst path = require(\"path\");\n\nconst logger_1 = require(\"../logger\");\n\nconst track = require(\"../track\");\n\nconst utils = require(\"../utils\");\n\nconst registry_1 = require(\"./registry\");\n\nconst types_1 = require(\"./types\");\n\nconst constants_1 = require(\"./constants\");\n\nconst functionsEmulator_1 = require(\"./functionsEmulator\");\n\nconst functionsEmulatorUtils_1 = require(\"./functionsEmulatorUtils\");\n\nconst auth_1 = require(\"./auth\");\n\nconst databaseEmulator_1 = require(\"./databaseEmulator\");\n\nconst firestoreEmulator_1 = require(\"./firestoreEmulator\");\n\nconst hostingEmulator_1 = require(\"./hostingEmulator\");\n\nconst error_1 = require(\"../error\");\n\nconst projectUtils_1 = require(\"../projectUtils\");\n\nconst pubsubEmulator_1 = require(\"./pubsubEmulator\");\n\nconst commandUtils = require(\"./commandUtils\");\n\nconst hub_1 = require(\"./hub\");\n\nconst hubExport_1 = require(\"./hubExport\");\n\nconst ui_1 = require(\"./ui\");\n\nconst loggingEmulator_1 = require(\"./loggingEmulator\");\n\nconst dbRulesConfig = require(\"../database/rulesConfig\");\n\nconst emulatorLogger_1 = require(\"./emulatorLogger\");\n\nconst portUtils = require(\"./portUtils\");\n\nconst hubClient_1 = require(\"./hubClient\");\n\nconst prompt_1 = require(\"../prompt\");\n\nconst commandUtils_1 = require(\"./commandUtils\");\n\nconst fsutils_1 = require(\"../fsutils\");\n\nconst storage_1 = require(\"./storage\");\n\nconst getDefaultDatabaseInstance_1 = require(\"../getDefaultDatabaseInstance\");\n\nconst auth_2 = require(\"../auth\");\n\nasync function getAndCheckAddress(emulator, options) {\n  var _a, _b, _c, _d;\n\n  let host = ((_b = (_a = options.config.src.emulators) === null || _a === void 0 ? void 0 : _a[emulator]) === null || _b === void 0 ? void 0 : _b.host) || constants_1.Constants.getDefaultHost(emulator);\n\n  if (host === \"localhost\" && utils.isRunningInWSL()) {\n    host = \"127.0.0.1\";\n  }\n\n  const portVal = (_d = (_c = options.config.src.emulators) === null || _c === void 0 ? void 0 : _c[emulator]) === null || _d === void 0 ? void 0 : _d.port;\n  let port;\n  let findAvailablePort = false;\n\n  if (portVal) {\n    port = parseInt(`${portVal}`, 10);\n  } else {\n    port = constants_1.Constants.getDefaultPort(emulator);\n    findAvailablePort = constants_1.FIND_AVAILBLE_PORT_BY_DEFAULT[emulator];\n  }\n\n  const loggerForEmulator = emulatorLogger_1.EmulatorLogger.forEmulator(emulator);\n  const portOpen = await portUtils.checkPortOpen(port, host);\n\n  if (!portOpen) {\n    if (findAvailablePort) {\n      const newPort = await portUtils.findAvailablePort(host, port);\n\n      if (newPort != port) {\n        loggerForEmulator.logLabeled(\"WARN\", emulator, `${constants_1.Constants.description(emulator)} unable to start on port ${port}, starting on ${newPort} instead.`);\n        port = newPort;\n      }\n    } else {\n      await cleanShutdown();\n      const description = constants_1.Constants.description(emulator);\n      loggerForEmulator.logLabeled(\"WARN\", emulator, `Port ${port} is not open on ${host}, could not start ${description}.`);\n      loggerForEmulator.logLabeled(\"WARN\", emulator, `To select a different host/port, specify that host/port in a firebase.json config file:\n      {\n        // ...\n        \"emulators\": {\n          \"${emulator}\": {\n            \"host\": \"${clc.yellow(\"HOST\")}\",\n            \"port\": \"${clc.yellow(\"PORT\")}\"\n          }\n        }\n      }`);\n      return utils.reject(`Could not start ${description}, port taken.`, {});\n    }\n  }\n\n  if (portUtils.isRestricted(port)) {\n    const suggested = portUtils.suggestUnrestricted(port);\n    loggerForEmulator.logLabeled(\"WARN\", emulator, `Port ${port} is restricted by some web browsers, including Chrome. You may want to choose a different port such as ${suggested}.`);\n  }\n\n  return {\n    host,\n    port\n  };\n}\n\nasync function startEmulator(instance) {\n  const name = instance.getName();\n  track(\"Emulator Run\", name);\n  await registry_1.EmulatorRegistry.start(instance);\n}\n\nexports.startEmulator = startEmulator;\n\nasync function exportOnExit(options) {\n  const exportOnExitDir = options.exportOnExit;\n\n  if (exportOnExitDir) {\n    try {\n      utils.logBullet(`Automatically exporting data using ${commandUtils_1.FLAG_EXPORT_ON_EXIT_NAME} \"${exportOnExitDir}\" ` + \"please wait for the export to finish...\");\n      await exportEmulatorData(exportOnExitDir, options);\n    } catch (e) {\n      utils.logWarning(e);\n      utils.logWarning(`Automatic export to \"${exportOnExitDir}\" failed, going to exit now...`);\n    }\n  }\n}\n\nexports.exportOnExit = exportOnExit;\n\nasync function onExit(options) {\n  await exportOnExit(options);\n}\n\nexports.onExit = onExit;\n\nasync function cleanShutdown() {\n  emulatorLogger_1.EmulatorLogger.forEmulator(types_1.Emulators.HUB).logLabeled(\"BULLET\", \"emulators\", \"Shutting down emulators.\");\n  await registry_1.EmulatorRegistry.stopAll();\n}\n\nexports.cleanShutdown = cleanShutdown;\n\nfunction filterEmulatorTargets(options) {\n  let targets = types_1.ALL_SERVICE_EMULATORS.filter(e => {\n    return options.config.has(e) || options.config.has(`emulators.${e}`);\n  });\n  const onlyOptions = options.only;\n\n  if (onlyOptions) {\n    const only = onlyOptions.split(\",\").map(o => {\n      return o.split(\":\")[0];\n    });\n    targets = _.intersection(targets, only);\n  }\n\n  return targets;\n}\n\nexports.filterEmulatorTargets = filterEmulatorTargets;\n\nfunction shouldStart(options, name) {\n  var _a, _b, _c;\n\n  if (name === types_1.Emulators.HUB) {\n    return !!options.project;\n  }\n\n  const targets = filterEmulatorTargets(options);\n  const emulatorInTargets = targets.includes(name);\n\n  if (name === types_1.Emulators.UI) {\n    if (options.ui) {\n      return true;\n    }\n\n    if (((_b = (_a = options.config.src.emulators) === null || _a === void 0 ? void 0 : _a.ui) === null || _b === void 0 ? void 0 : _b.enabled) === false) {\n      return false;\n    }\n\n    return !!options.project && targets.some(target => types_1.EMULATORS_SUPPORTED_BY_UI.includes(target));\n  }\n\n  if (name === types_1.Emulators.FUNCTIONS && emulatorInTargets && !((_c = options.config.src.functions) === null || _c === void 0 ? void 0 : _c.source)) {\n    emulatorLogger_1.EmulatorLogger.forEmulator(types_1.Emulators.FUNCTIONS).logLabeled(\"WARN\", \"functions\", `The functions emulator is configured but there is no functions source directory. Have you run ${clc.bold(\"firebase init functions\")}?`);\n    return false;\n  }\n\n  if (name === types_1.Emulators.HOSTING && emulatorInTargets && !options.config.get(\"hosting\")) {\n    emulatorLogger_1.EmulatorLogger.forEmulator(types_1.Emulators.HOSTING).logLabeled(\"WARN\", \"hosting\", `The hosting emulator is configured but there is no hosting configuration. Have you run ${clc.bold(\"firebase init hosting\")}?`);\n    return false;\n  }\n\n  return emulatorInTargets;\n}\n\nexports.shouldStart = shouldStart;\n\nfunction findExportMetadata(importPath) {\n  const pathIsDirectory = fs.lstatSync(importPath).isDirectory();\n\n  if (!pathIsDirectory) {\n    return;\n  }\n\n  const importFilePath = path.join(importPath, hubExport_1.HubExport.METADATA_FILE_NAME);\n\n  if (fsutils_1.fileExistsSync(importFilePath)) {\n    return JSON.parse(fs.readFileSync(importFilePath, \"utf8\").toString());\n  }\n\n  const fileList = fs.readdirSync(importPath);\n  const firestoreMetadataFile = fileList.find(f => f.endsWith(\".overall_export_metadata\"));\n\n  if (firestoreMetadataFile) {\n    const metadata = {\n      version: hub_1.EmulatorHub.CLI_VERSION,\n      firestore: {\n        version: \"prod\",\n        path: importPath,\n        metadata_file: `${importPath}/${firestoreMetadataFile}`\n      }\n    };\n    emulatorLogger_1.EmulatorLogger.forEmulator(types_1.Emulators.FIRESTORE).logLabeled(\"BULLET\", \"firestore\", `Detected non-emulator Firestore export at ${importPath}`);\n    return metadata;\n  }\n\n  const rtdbDataFile = fileList.find(f => f.endsWith(\".json\"));\n\n  if (rtdbDataFile) {\n    const metadata = {\n      version: hub_1.EmulatorHub.CLI_VERSION,\n      database: {\n        version: \"prod\",\n        path: importPath\n      }\n    };\n    emulatorLogger_1.EmulatorLogger.forEmulator(types_1.Emulators.DATABASE).logLabeled(\"BULLET\", \"firestore\", `Detected non-emulator Database export at ${importPath}`);\n    return metadata;\n  }\n}\n\nasync function startAll(options, showUI = true) {\n  var _a;\n\n  const targets = filterEmulatorTargets(options);\n  options.targets = targets;\n\n  if (targets.length === 0) {\n    throw new error_1.FirebaseError(`No emulators to start, run ${clc.bold(\"firebase init emulators\")} to get started.`);\n  }\n\n  const hubLogger = emulatorLogger_1.EmulatorLogger.forEmulator(types_1.Emulators.HUB);\n  hubLogger.logLabeled(\"BULLET\", \"emulators\", `Starting emulators: ${targets.join(\", \")}`);\n  const projectId = projectUtils_1.getProjectId(options) || \"\";\n\n  if (constants_1.Constants.isDemoProject(projectId)) {\n    hubLogger.logLabeled(\"BULLET\", \"emulators\", `Detected demo project ID \"${projectId}\", emulated services will use a demo configuration and attempts to access non-emulated services for this project will fail.`);\n  }\n\n  const onlyOptions = options.only;\n\n  if (onlyOptions) {\n    const requested = onlyOptions.split(\",\").map(o => {\n      return o.split(\":\")[0];\n    });\n\n    const ignored = _.difference(requested, targets);\n\n    for (const name of ignored) {\n      if (types_1.isEmulator(name)) {\n        emulatorLogger_1.EmulatorLogger.forEmulator(name).logLabeled(\"WARN\", name, `Not starting the ${clc.bold(name)} emulator, make sure you have run ${clc.bold(\"firebase init\")}.`);\n      } else {\n        throw new error_1.FirebaseError(`${name} is not a valid emulator name, valid options are: ${JSON.stringify(types_1.ALL_SERVICE_EMULATORS)}`, {\n          exit: 1\n        });\n      }\n    }\n  }\n\n  if (shouldStart(options, types_1.Emulators.HUB)) {\n    const hubAddr = await getAndCheckAddress(types_1.Emulators.HUB, options);\n    const hub = new hub_1.EmulatorHub(Object.assign({\n      projectId\n    }, hubAddr));\n    track(\"emulators:start\", \"hub\");\n    await startEmulator(hub);\n  }\n\n  let exportMetadata = {\n    version: \"unknown\"\n  };\n\n  if (options.import) {\n    utils.assertIsString(options.import);\n    const importDir = path.resolve(options.import);\n    const foundMetadata = findExportMetadata(importDir);\n\n    if (foundMetadata) {\n      exportMetadata = foundMetadata;\n    } else {\n      hubLogger.logLabeled(\"WARN\", \"emulators\", `Could not find import/export metadata file, ${clc.bold(\"skipping data import!\")}`);\n    }\n  }\n\n  if (shouldStart(options, types_1.Emulators.FUNCTIONS)) {\n    const functionsLogger = emulatorLogger_1.EmulatorLogger.forEmulator(types_1.Emulators.FUNCTIONS);\n    const functionsAddr = await getAndCheckAddress(types_1.Emulators.FUNCTIONS, options);\n    const projectId = projectUtils_1.needProjectId(options);\n    utils.assertDefined(options.config.src.functions);\n    utils.assertDefined(options.config.src.functions.source, \"Error: 'functions.source' is not defined\");\n    utils.assertIsStringOrUndefined(options.extensionDir);\n    const functionsDir = path.join(options.extensionDir || options.config.projectDir, options.config.src.functions.source);\n    let inspectFunctions;\n\n    if (options.inspectFunctions) {\n      inspectFunctions = commandUtils.parseInspectionPort(options);\n      functionsLogger.logLabeled(\"WARN\", \"functions\", `You are running the functions emulator in debug mode (port=${inspectFunctions}). This means that functions will execute in sequence rather than in parallel.`);\n    }\n\n    const emulatorsNotRunning = types_1.ALL_SERVICE_EMULATORS.filter(e => {\n      return e !== types_1.Emulators.FUNCTIONS && !shouldStart(options, e);\n    });\n\n    if (emulatorsNotRunning.length > 0 && !constants_1.Constants.isDemoProject(projectId)) {\n      functionsLogger.logLabeled(\"WARN\", \"functions\", `The following emulators are not running, calls to these services from the Functions emulator will affect production: ${clc.bold(emulatorsNotRunning.join(\", \"))}`);\n    }\n\n    const account = auth_2.getProjectDefaultAccount(options.projectRoot);\n    const functionsEmulator = new functionsEmulator_1.FunctionsEmulator({\n      projectId,\n      functionsDir,\n      account,\n      host: functionsAddr.host,\n      port: functionsAddr.port,\n      debugPort: inspectFunctions,\n      env: Object.assign({}, options.extensionEnv),\n      predefinedTriggers: options.extensionTriggers,\n      nodeMajorVersion: functionsEmulatorUtils_1.parseRuntimeVersion(options.extensionNodeVersion || options.config.get(\"functions.runtime\"))\n    });\n    await startEmulator(functionsEmulator);\n  }\n\n  if (shouldStart(options, types_1.Emulators.FIRESTORE)) {\n    const firestoreLogger = emulatorLogger_1.EmulatorLogger.forEmulator(types_1.Emulators.FIRESTORE);\n    const firestoreAddr = await getAndCheckAddress(types_1.Emulators.FIRESTORE, options);\n    const args = {\n      host: firestoreAddr.host,\n      port: firestoreAddr.port,\n      projectId,\n      auto_download: true\n    };\n\n    if (exportMetadata.firestore) {\n      utils.assertIsString(options.import);\n      const importDirAbsPath = path.resolve(options.import);\n      const exportMetadataFilePath = path.resolve(importDirAbsPath, exportMetadata.firestore.metadata_file);\n      firestoreLogger.logLabeled(\"BULLET\", \"firestore\", `Importing data from ${exportMetadataFilePath}`);\n      args.seed_from_export = exportMetadataFilePath;\n    }\n\n    const config = options.config;\n    const rulesLocalPath = (_a = config.src.firestore) === null || _a === void 0 ? void 0 : _a.rules;\n    let rulesFileFound = false;\n\n    if (rulesLocalPath) {\n      const rules = config.path(rulesLocalPath);\n      rulesFileFound = fs.existsSync(rules);\n\n      if (rulesFileFound) {\n        args.rules = rules;\n      } else {\n        firestoreLogger.logLabeled(\"WARN\", \"firestore\", `Cloud Firestore rules file ${clc.bold(rules)} specified in firebase.json does not exist.`);\n      }\n    } else {\n      firestoreLogger.logLabeled(\"WARN\", \"firestore\", \"Did not find a Cloud Firestore rules file specified in a firebase.json config file.\");\n    }\n\n    if (!rulesFileFound) {\n      firestoreLogger.logLabeled(\"WARN\", \"firestore\", \"The emulator will default to allowing all reads and writes. Learn more about this option: https://firebase.google.com/docs/emulator-suite/install_and_configure#security_rules_configuration.\");\n    }\n\n    const firestoreEmulator = new firestoreEmulator_1.FirestoreEmulator(args);\n    await startEmulator(firestoreEmulator);\n  }\n\n  if (shouldStart(options, types_1.Emulators.DATABASE)) {\n    const databaseLogger = emulatorLogger_1.EmulatorLogger.forEmulator(types_1.Emulators.DATABASE);\n    const databaseAddr = await getAndCheckAddress(types_1.Emulators.DATABASE, options);\n    const args = {\n      host: databaseAddr.host,\n      port: databaseAddr.port,\n      projectId,\n      auto_download: true\n    };\n\n    try {\n      if (!options.instance) {\n        options.instance = await getDefaultDatabaseInstance_1.getDefaultDatabaseInstance(options);\n      }\n    } catch (e) {\n      databaseLogger.log(\"DEBUG\", `Failed to retrieve default database instance: ${JSON.stringify(e)}`);\n    }\n\n    const rc = dbRulesConfig.normalizeRulesConfig(dbRulesConfig.getRulesConfig(projectId, options), options);\n    logger_1.logger.debug(\"database rules config: \", JSON.stringify(rc));\n    args.rules = rc;\n\n    if (rc.length === 0) {\n      databaseLogger.logLabeled(\"WARN\", \"database\", \"Did not find a Realtime Database rules file specified in a firebase.json config file. The emulator will default to allowing all reads and writes. Learn more about this option: https://firebase.google.com/docs/emulator-suite/install_and_configure#security_rules_configuration.\");\n    } else {\n      for (const c of rc) {\n        const rules = c.rules;\n\n        if (!fs.existsSync(rules)) {\n          databaseLogger.logLabeled(\"WARN\", \"database\", `Realtime Database rules file ${clc.bold(rules)} specified in firebase.json does not exist.`);\n        }\n      }\n    }\n\n    const databaseEmulator = new databaseEmulator_1.DatabaseEmulator(args);\n    await startEmulator(databaseEmulator);\n\n    if (exportMetadata.database) {\n      utils.assertIsString(options.import);\n      const importDirAbsPath = path.resolve(options.import);\n      const databaseExportDir = path.resolve(importDirAbsPath, exportMetadata.database.path);\n      const files = fs.readdirSync(databaseExportDir).filter(f => f.endsWith(\".json\"));\n\n      for (const f of files) {\n        const fPath = path.join(databaseExportDir, f);\n        const ns = path.basename(f, \".json\");\n        await databaseEmulator.importData(ns, fPath);\n      }\n    }\n  }\n\n  if (shouldStart(options, types_1.Emulators.AUTH)) {\n    if (!projectId) {\n      throw new error_1.FirebaseError(`Cannot start the ${constants_1.Constants.description(types_1.Emulators.AUTH)} without a project: run 'firebase init' or provide the --project flag`);\n    }\n\n    const authAddr = await getAndCheckAddress(types_1.Emulators.AUTH, options);\n    const authEmulator = new auth_1.AuthEmulator({\n      host: authAddr.host,\n      port: authAddr.port,\n      projectId\n    });\n    await startEmulator(authEmulator);\n\n    if (exportMetadata.auth) {\n      utils.assertIsString(options.import);\n      const importDirAbsPath = path.resolve(options.import);\n      const authExportDir = path.resolve(importDirAbsPath, exportMetadata.auth.path);\n      await authEmulator.importData(authExportDir, projectId);\n    }\n  }\n\n  if (shouldStart(options, types_1.Emulators.PUBSUB)) {\n    if (!projectId) {\n      throw new error_1.FirebaseError(\"Cannot start the Pub/Sub emulator without a project: run 'firebase init' or provide the --project flag\");\n    }\n\n    const pubsubAddr = await getAndCheckAddress(types_1.Emulators.PUBSUB, options);\n    const pubsubEmulator = new pubsubEmulator_1.PubsubEmulator({\n      host: pubsubAddr.host,\n      port: pubsubAddr.port,\n      projectId,\n      auto_download: true\n    });\n    await startEmulator(pubsubEmulator);\n  }\n\n  if (shouldStart(options, types_1.Emulators.STORAGE)) {\n    const storageAddr = await getAndCheckAddress(types_1.Emulators.STORAGE, options);\n    const storageConfig = options.config.data.storage;\n\n    if (!(storageConfig === null || storageConfig === void 0 ? void 0 : storageConfig.rules)) {\n      throw new error_1.FirebaseError(\"Cannot start the Storage emulator without rules file specified in firebase.json: run 'firebase init' and set up your Storage configuration\");\n    }\n\n    const storageEmulator = new storage_1.StorageEmulator({\n      host: storageAddr.host,\n      port: storageAddr.port,\n      projectId: projectId,\n      rules: options.config.path(storageConfig.rules)\n    });\n    await startEmulator(storageEmulator);\n\n    if (exportMetadata.storage) {\n      utils.assertIsString(options.import);\n      const importDirAbsPath = path.resolve(options.import);\n      const storageExportDir = path.resolve(importDirAbsPath, exportMetadata.storage.path);\n      storageEmulator.storageLayer.import(storageExportDir);\n    }\n  }\n\n  if (shouldStart(options, types_1.Emulators.HOSTING)) {\n    const hostingAddr = await getAndCheckAddress(types_1.Emulators.HOSTING, options);\n    const hostingEmulator = new hostingEmulator_1.HostingEmulator({\n      host: hostingAddr.host,\n      port: hostingAddr.port,\n      options\n    });\n    await startEmulator(hostingEmulator);\n  }\n\n  if (showUI && !shouldStart(options, types_1.Emulators.UI)) {\n    hubLogger.logLabeled(\"WARN\", \"emulators\", \"The Emulator UI requires a project ID to start. Configure your default project with 'firebase use' or pass the --project flag.\");\n  }\n\n  if (showUI && shouldStart(options, types_1.Emulators.UI)) {\n    const loggingAddr = await getAndCheckAddress(types_1.Emulators.LOGGING, options);\n    const loggingEmulator = new loggingEmulator_1.LoggingEmulator({\n      host: loggingAddr.host,\n      port: loggingAddr.port\n    });\n    await startEmulator(loggingEmulator);\n    const uiAddr = await getAndCheckAddress(types_1.Emulators.UI, options);\n    const ui = new ui_1.EmulatorUI(Object.assign({\n      projectId: projectId,\n      auto_download: true\n    }, uiAddr));\n    await startEmulator(ui);\n  }\n\n  const running = registry_1.EmulatorRegistry.listRunning();\n\n  for (const name of running) {\n    const instance = registry_1.EmulatorRegistry.get(name);\n\n    if (instance) {\n      await instance.connect();\n    }\n  }\n}\n\nexports.startAll = startAll;\n\nasync function exportEmulatorData(exportPath, options) {\n  const projectId = options.project;\n\n  if (!projectId) {\n    throw new error_1.FirebaseError(\"Could not determine project ID, make sure you're running in a Firebase project directory or add the --project flag.\", {\n      exit: 1\n    });\n  }\n\n  const hubClient = new hubClient_1.EmulatorHubClient(projectId);\n\n  if (!hubClient.foundHub()) {\n    throw new error_1.FirebaseError(`Did not find any running emulators for project ${clc.bold(projectId)}.`, {\n      exit: 1\n    });\n  }\n\n  try {\n    await hubClient.getStatus();\n  } catch (e) {\n    const filePath = hub_1.EmulatorHub.getLocatorFilePath(projectId);\n    throw new error_1.FirebaseError(`The emulator hub for ${projectId} did not respond to a status check. If this error continues try shutting down all running emulators and deleting the file ${filePath}`, {\n      exit: 1\n    });\n  }\n\n  utils.logBullet(`Found running emulator hub for project ${clc.bold(projectId)} at ${hubClient.origin}`);\n  const exportAbsPath = path.resolve(exportPath);\n\n  if (!fs.existsSync(exportAbsPath)) {\n    utils.logBullet(`Creating export directory ${exportAbsPath}`);\n    fs.mkdirSync(exportAbsPath);\n  }\n\n  const existingMetadata = hubExport_1.HubExport.readMetadata(exportAbsPath);\n\n  if (existingMetadata && !(options.force || options.exportOnExit)) {\n    if (options.noninteractive) {\n      throw new error_1.FirebaseError(\"Export already exists in the target directory, re-run with --force to overwrite.\", {\n        exit: 1\n      });\n    }\n\n    const prompt = await prompt_1.promptOnce({\n      type: \"confirm\",\n      message: `The directory ${exportAbsPath} already contains export data. Exporting again to the same directory will overwrite all data. Do you want to continue?`,\n      default: false\n    });\n\n    if (!prompt) {\n      throw new error_1.FirebaseError(\"Command aborted\", {\n        exit: 1\n      });\n    }\n  }\n\n  utils.logBullet(`Exporting data to: ${exportAbsPath}`);\n\n  try {\n    await hubClient.postExport(exportAbsPath);\n  } catch (e) {\n    throw new error_1.FirebaseError(\"Export request failed, see emulator logs for more information.\", {\n      exit: 1,\n      original: e\n    });\n  }\n\n  utils.logSuccess(\"Export complete\");\n}\n\nexports.exportEmulatorData = exportEmulatorData;","map":{"version":3,"sources":["/home/dev/Documentos/Projects/github-clone/node_modules/firebase-tools/lib/emulator/controller.js"],"names":["Object","defineProperty","exports","value","exportEmulatorData","startAll","shouldStart","filterEmulatorTargets","cleanShutdown","onExit","exportOnExit","startEmulator","_","require","clc","fs","path","logger_1","track","utils","registry_1","types_1","constants_1","functionsEmulator_1","functionsEmulatorUtils_1","auth_1","databaseEmulator_1","firestoreEmulator_1","hostingEmulator_1","error_1","projectUtils_1","pubsubEmulator_1","commandUtils","hub_1","hubExport_1","ui_1","loggingEmulator_1","dbRulesConfig","emulatorLogger_1","portUtils","hubClient_1","prompt_1","commandUtils_1","fsutils_1","storage_1","getDefaultDatabaseInstance_1","auth_2","getAndCheckAddress","emulator","options","_a","_b","_c","_d","host","config","src","emulators","Constants","getDefaultHost","isRunningInWSL","portVal","port","findAvailablePort","parseInt","getDefaultPort","FIND_AVAILBLE_PORT_BY_DEFAULT","loggerForEmulator","EmulatorLogger","forEmulator","portOpen","checkPortOpen","newPort","logLabeled","description","yellow","reject","isRestricted","suggested","suggestUnrestricted","instance","name","getName","EmulatorRegistry","start","exportOnExitDir","logBullet","FLAG_EXPORT_ON_EXIT_NAME","e","logWarning","Emulators","HUB","stopAll","targets","ALL_SERVICE_EMULATORS","filter","has","onlyOptions","only","split","map","o","intersection","project","emulatorInTargets","includes","UI","ui","enabled","some","target","EMULATORS_SUPPORTED_BY_UI","FUNCTIONS","functions","source","bold","HOSTING","get","findExportMetadata","importPath","pathIsDirectory","lstatSync","isDirectory","importFilePath","join","HubExport","METADATA_FILE_NAME","fileExistsSync","JSON","parse","readFileSync","toString","fileList","readdirSync","firestoreMetadataFile","find","f","endsWith","metadata","version","EmulatorHub","CLI_VERSION","firestore","metadata_file","FIRESTORE","rtdbDataFile","database","DATABASE","showUI","length","FirebaseError","hubLogger","projectId","getProjectId","isDemoProject","requested","ignored","difference","isEmulator","stringify","exit","hubAddr","hub","assign","exportMetadata","import","assertIsString","importDir","resolve","foundMetadata","functionsLogger","functionsAddr","needProjectId","assertDefined","assertIsStringOrUndefined","extensionDir","functionsDir","projectDir","inspectFunctions","parseInspectionPort","emulatorsNotRunning","account","getProjectDefaultAccount","projectRoot","functionsEmulator","FunctionsEmulator","debugPort","env","extensionEnv","predefinedTriggers","extensionTriggers","nodeMajorVersion","parseRuntimeVersion","extensionNodeVersion","firestoreLogger","firestoreAddr","args","auto_download","importDirAbsPath","exportMetadataFilePath","seed_from_export","rulesLocalPath","rules","rulesFileFound","existsSync","firestoreEmulator","FirestoreEmulator","databaseLogger","databaseAddr","getDefaultDatabaseInstance","log","rc","normalizeRulesConfig","getRulesConfig","logger","debug","c","databaseEmulator","DatabaseEmulator","databaseExportDir","files","fPath","ns","basename","importData","AUTH","authAddr","authEmulator","AuthEmulator","auth","authExportDir","PUBSUB","pubsubAddr","pubsubEmulator","PubsubEmulator","STORAGE","storageAddr","storageConfig","data","storage","storageEmulator","StorageEmulator","storageExportDir","storageLayer","hostingAddr","hostingEmulator","HostingEmulator","loggingAddr","LOGGING","loggingEmulator","LoggingEmulator","uiAddr","EmulatorUI","running","listRunning","connect","exportPath","hubClient","EmulatorHubClient","foundHub","getStatus","filePath","getLocatorFilePath","origin","exportAbsPath","mkdirSync","existingMetadata","readMetadata","force","noninteractive","prompt","promptOnce","type","message","default","postExport","original","logSuccess"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.exportEmulatorData = exports.startAll = exports.shouldStart = exports.filterEmulatorTargets = exports.cleanShutdown = exports.onExit = exports.exportOnExit = exports.startEmulator = void 0;\nconst _ = require(\"lodash\");\nconst clc = require(\"cli-color\");\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst logger_1 = require(\"../logger\");\nconst track = require(\"../track\");\nconst utils = require(\"../utils\");\nconst registry_1 = require(\"./registry\");\nconst types_1 = require(\"./types\");\nconst constants_1 = require(\"./constants\");\nconst functionsEmulator_1 = require(\"./functionsEmulator\");\nconst functionsEmulatorUtils_1 = require(\"./functionsEmulatorUtils\");\nconst auth_1 = require(\"./auth\");\nconst databaseEmulator_1 = require(\"./databaseEmulator\");\nconst firestoreEmulator_1 = require(\"./firestoreEmulator\");\nconst hostingEmulator_1 = require(\"./hostingEmulator\");\nconst error_1 = require(\"../error\");\nconst projectUtils_1 = require(\"../projectUtils\");\nconst pubsubEmulator_1 = require(\"./pubsubEmulator\");\nconst commandUtils = require(\"./commandUtils\");\nconst hub_1 = require(\"./hub\");\nconst hubExport_1 = require(\"./hubExport\");\nconst ui_1 = require(\"./ui\");\nconst loggingEmulator_1 = require(\"./loggingEmulator\");\nconst dbRulesConfig = require(\"../database/rulesConfig\");\nconst emulatorLogger_1 = require(\"./emulatorLogger\");\nconst portUtils = require(\"./portUtils\");\nconst hubClient_1 = require(\"./hubClient\");\nconst prompt_1 = require(\"../prompt\");\nconst commandUtils_1 = require(\"./commandUtils\");\nconst fsutils_1 = require(\"../fsutils\");\nconst storage_1 = require(\"./storage\");\nconst getDefaultDatabaseInstance_1 = require(\"../getDefaultDatabaseInstance\");\nconst auth_2 = require(\"../auth\");\nasync function getAndCheckAddress(emulator, options) {\n    var _a, _b, _c, _d;\n    let host = ((_b = (_a = options.config.src.emulators) === null || _a === void 0 ? void 0 : _a[emulator]) === null || _b === void 0 ? void 0 : _b.host) || constants_1.Constants.getDefaultHost(emulator);\n    if (host === \"localhost\" && utils.isRunningInWSL()) {\n        host = \"127.0.0.1\";\n    }\n    const portVal = (_d = (_c = options.config.src.emulators) === null || _c === void 0 ? void 0 : _c[emulator]) === null || _d === void 0 ? void 0 : _d.port;\n    let port;\n    let findAvailablePort = false;\n    if (portVal) {\n        port = parseInt(`${portVal}`, 10);\n    }\n    else {\n        port = constants_1.Constants.getDefaultPort(emulator);\n        findAvailablePort = constants_1.FIND_AVAILBLE_PORT_BY_DEFAULT[emulator];\n    }\n    const loggerForEmulator = emulatorLogger_1.EmulatorLogger.forEmulator(emulator);\n    const portOpen = await portUtils.checkPortOpen(port, host);\n    if (!portOpen) {\n        if (findAvailablePort) {\n            const newPort = await portUtils.findAvailablePort(host, port);\n            if (newPort != port) {\n                loggerForEmulator.logLabeled(\"WARN\", emulator, `${constants_1.Constants.description(emulator)} unable to start on port ${port}, starting on ${newPort} instead.`);\n                port = newPort;\n            }\n        }\n        else {\n            await cleanShutdown();\n            const description = constants_1.Constants.description(emulator);\n            loggerForEmulator.logLabeled(\"WARN\", emulator, `Port ${port} is not open on ${host}, could not start ${description}.`);\n            loggerForEmulator.logLabeled(\"WARN\", emulator, `To select a different host/port, specify that host/port in a firebase.json config file:\n      {\n        // ...\n        \"emulators\": {\n          \"${emulator}\": {\n            \"host\": \"${clc.yellow(\"HOST\")}\",\n            \"port\": \"${clc.yellow(\"PORT\")}\"\n          }\n        }\n      }`);\n            return utils.reject(`Could not start ${description}, port taken.`, {});\n        }\n    }\n    if (portUtils.isRestricted(port)) {\n        const suggested = portUtils.suggestUnrestricted(port);\n        loggerForEmulator.logLabeled(\"WARN\", emulator, `Port ${port} is restricted by some web browsers, including Chrome. You may want to choose a different port such as ${suggested}.`);\n    }\n    return { host, port };\n}\nasync function startEmulator(instance) {\n    const name = instance.getName();\n    track(\"Emulator Run\", name);\n    await registry_1.EmulatorRegistry.start(instance);\n}\nexports.startEmulator = startEmulator;\nasync function exportOnExit(options) {\n    const exportOnExitDir = options.exportOnExit;\n    if (exportOnExitDir) {\n        try {\n            utils.logBullet(`Automatically exporting data using ${commandUtils_1.FLAG_EXPORT_ON_EXIT_NAME} \"${exportOnExitDir}\" ` +\n                \"please wait for the export to finish...\");\n            await exportEmulatorData(exportOnExitDir, options);\n        }\n        catch (e) {\n            utils.logWarning(e);\n            utils.logWarning(`Automatic export to \"${exportOnExitDir}\" failed, going to exit now...`);\n        }\n    }\n}\nexports.exportOnExit = exportOnExit;\nasync function onExit(options) {\n    await exportOnExit(options);\n}\nexports.onExit = onExit;\nasync function cleanShutdown() {\n    emulatorLogger_1.EmulatorLogger.forEmulator(types_1.Emulators.HUB).logLabeled(\"BULLET\", \"emulators\", \"Shutting down emulators.\");\n    await registry_1.EmulatorRegistry.stopAll();\n}\nexports.cleanShutdown = cleanShutdown;\nfunction filterEmulatorTargets(options) {\n    let targets = types_1.ALL_SERVICE_EMULATORS.filter((e) => {\n        return options.config.has(e) || options.config.has(`emulators.${e}`);\n    });\n    const onlyOptions = options.only;\n    if (onlyOptions) {\n        const only = onlyOptions.split(\",\").map((o) => {\n            return o.split(\":\")[0];\n        });\n        targets = _.intersection(targets, only);\n    }\n    return targets;\n}\nexports.filterEmulatorTargets = filterEmulatorTargets;\nfunction shouldStart(options, name) {\n    var _a, _b, _c;\n    if (name === types_1.Emulators.HUB) {\n        return !!options.project;\n    }\n    const targets = filterEmulatorTargets(options);\n    const emulatorInTargets = targets.includes(name);\n    if (name === types_1.Emulators.UI) {\n        if (options.ui) {\n            return true;\n        }\n        if (((_b = (_a = options.config.src.emulators) === null || _a === void 0 ? void 0 : _a.ui) === null || _b === void 0 ? void 0 : _b.enabled) === false) {\n            return false;\n        }\n        return (!!options.project && targets.some((target) => types_1.EMULATORS_SUPPORTED_BY_UI.includes(target)));\n    }\n    if (name === types_1.Emulators.FUNCTIONS && emulatorInTargets && !((_c = options.config.src.functions) === null || _c === void 0 ? void 0 : _c.source)) {\n        emulatorLogger_1.EmulatorLogger.forEmulator(types_1.Emulators.FUNCTIONS).logLabeled(\"WARN\", \"functions\", `The functions emulator is configured but there is no functions source directory. Have you run ${clc.bold(\"firebase init functions\")}?`);\n        return false;\n    }\n    if (name === types_1.Emulators.HOSTING && emulatorInTargets && !options.config.get(\"hosting\")) {\n        emulatorLogger_1.EmulatorLogger.forEmulator(types_1.Emulators.HOSTING).logLabeled(\"WARN\", \"hosting\", `The hosting emulator is configured but there is no hosting configuration. Have you run ${clc.bold(\"firebase init hosting\")}?`);\n        return false;\n    }\n    return emulatorInTargets;\n}\nexports.shouldStart = shouldStart;\nfunction findExportMetadata(importPath) {\n    const pathIsDirectory = fs.lstatSync(importPath).isDirectory();\n    if (!pathIsDirectory) {\n        return;\n    }\n    const importFilePath = path.join(importPath, hubExport_1.HubExport.METADATA_FILE_NAME);\n    if (fsutils_1.fileExistsSync(importFilePath)) {\n        return JSON.parse(fs.readFileSync(importFilePath, \"utf8\").toString());\n    }\n    const fileList = fs.readdirSync(importPath);\n    const firestoreMetadataFile = fileList.find((f) => f.endsWith(\".overall_export_metadata\"));\n    if (firestoreMetadataFile) {\n        const metadata = {\n            version: hub_1.EmulatorHub.CLI_VERSION,\n            firestore: {\n                version: \"prod\",\n                path: importPath,\n                metadata_file: `${importPath}/${firestoreMetadataFile}`,\n            },\n        };\n        emulatorLogger_1.EmulatorLogger.forEmulator(types_1.Emulators.FIRESTORE).logLabeled(\"BULLET\", \"firestore\", `Detected non-emulator Firestore export at ${importPath}`);\n        return metadata;\n    }\n    const rtdbDataFile = fileList.find((f) => f.endsWith(\".json\"));\n    if (rtdbDataFile) {\n        const metadata = {\n            version: hub_1.EmulatorHub.CLI_VERSION,\n            database: {\n                version: \"prod\",\n                path: importPath,\n            },\n        };\n        emulatorLogger_1.EmulatorLogger.forEmulator(types_1.Emulators.DATABASE).logLabeled(\"BULLET\", \"firestore\", `Detected non-emulator Database export at ${importPath}`);\n        return metadata;\n    }\n}\nasync function startAll(options, showUI = true) {\n    var _a;\n    const targets = filterEmulatorTargets(options);\n    options.targets = targets;\n    if (targets.length === 0) {\n        throw new error_1.FirebaseError(`No emulators to start, run ${clc.bold(\"firebase init emulators\")} to get started.`);\n    }\n    const hubLogger = emulatorLogger_1.EmulatorLogger.forEmulator(types_1.Emulators.HUB);\n    hubLogger.logLabeled(\"BULLET\", \"emulators\", `Starting emulators: ${targets.join(\", \")}`);\n    const projectId = projectUtils_1.getProjectId(options) || \"\";\n    if (constants_1.Constants.isDemoProject(projectId)) {\n        hubLogger.logLabeled(\"BULLET\", \"emulators\", `Detected demo project ID \"${projectId}\", emulated services will use a demo configuration and attempts to access non-emulated services for this project will fail.`);\n    }\n    const onlyOptions = options.only;\n    if (onlyOptions) {\n        const requested = onlyOptions.split(\",\").map((o) => {\n            return o.split(\":\")[0];\n        });\n        const ignored = _.difference(requested, targets);\n        for (const name of ignored) {\n            if (types_1.isEmulator(name)) {\n                emulatorLogger_1.EmulatorLogger.forEmulator(name).logLabeled(\"WARN\", name, `Not starting the ${clc.bold(name)} emulator, make sure you have run ${clc.bold(\"firebase init\")}.`);\n            }\n            else {\n                throw new error_1.FirebaseError(`${name} is not a valid emulator name, valid options are: ${JSON.stringify(types_1.ALL_SERVICE_EMULATORS)}`, { exit: 1 });\n            }\n        }\n    }\n    if (shouldStart(options, types_1.Emulators.HUB)) {\n        const hubAddr = await getAndCheckAddress(types_1.Emulators.HUB, options);\n        const hub = new hub_1.EmulatorHub(Object.assign({ projectId }, hubAddr));\n        track(\"emulators:start\", \"hub\");\n        await startEmulator(hub);\n    }\n    let exportMetadata = {\n        version: \"unknown\",\n    };\n    if (options.import) {\n        utils.assertIsString(options.import);\n        const importDir = path.resolve(options.import);\n        const foundMetadata = findExportMetadata(importDir);\n        if (foundMetadata) {\n            exportMetadata = foundMetadata;\n        }\n        else {\n            hubLogger.logLabeled(\"WARN\", \"emulators\", `Could not find import/export metadata file, ${clc.bold(\"skipping data import!\")}`);\n        }\n    }\n    if (shouldStart(options, types_1.Emulators.FUNCTIONS)) {\n        const functionsLogger = emulatorLogger_1.EmulatorLogger.forEmulator(types_1.Emulators.FUNCTIONS);\n        const functionsAddr = await getAndCheckAddress(types_1.Emulators.FUNCTIONS, options);\n        const projectId = projectUtils_1.needProjectId(options);\n        utils.assertDefined(options.config.src.functions);\n        utils.assertDefined(options.config.src.functions.source, \"Error: 'functions.source' is not defined\");\n        utils.assertIsStringOrUndefined(options.extensionDir);\n        const functionsDir = path.join(options.extensionDir || options.config.projectDir, options.config.src.functions.source);\n        let inspectFunctions;\n        if (options.inspectFunctions) {\n            inspectFunctions = commandUtils.parseInspectionPort(options);\n            functionsLogger.logLabeled(\"WARN\", \"functions\", `You are running the functions emulator in debug mode (port=${inspectFunctions}). This means that functions will execute in sequence rather than in parallel.`);\n        }\n        const emulatorsNotRunning = types_1.ALL_SERVICE_EMULATORS.filter((e) => {\n            return e !== types_1.Emulators.FUNCTIONS && !shouldStart(options, e);\n        });\n        if (emulatorsNotRunning.length > 0 && !constants_1.Constants.isDemoProject(projectId)) {\n            functionsLogger.logLabeled(\"WARN\", \"functions\", `The following emulators are not running, calls to these services from the Functions emulator will affect production: ${clc.bold(emulatorsNotRunning.join(\", \"))}`);\n        }\n        const account = auth_2.getProjectDefaultAccount(options.projectRoot);\n        const functionsEmulator = new functionsEmulator_1.FunctionsEmulator({\n            projectId,\n            functionsDir,\n            account,\n            host: functionsAddr.host,\n            port: functionsAddr.port,\n            debugPort: inspectFunctions,\n            env: Object.assign({}, options.extensionEnv),\n            predefinedTriggers: options.extensionTriggers,\n            nodeMajorVersion: functionsEmulatorUtils_1.parseRuntimeVersion(options.extensionNodeVersion || options.config.get(\"functions.runtime\")),\n        });\n        await startEmulator(functionsEmulator);\n    }\n    if (shouldStart(options, types_1.Emulators.FIRESTORE)) {\n        const firestoreLogger = emulatorLogger_1.EmulatorLogger.forEmulator(types_1.Emulators.FIRESTORE);\n        const firestoreAddr = await getAndCheckAddress(types_1.Emulators.FIRESTORE, options);\n        const args = {\n            host: firestoreAddr.host,\n            port: firestoreAddr.port,\n            projectId,\n            auto_download: true,\n        };\n        if (exportMetadata.firestore) {\n            utils.assertIsString(options.import);\n            const importDirAbsPath = path.resolve(options.import);\n            const exportMetadataFilePath = path.resolve(importDirAbsPath, exportMetadata.firestore.metadata_file);\n            firestoreLogger.logLabeled(\"BULLET\", \"firestore\", `Importing data from ${exportMetadataFilePath}`);\n            args.seed_from_export = exportMetadataFilePath;\n        }\n        const config = options.config;\n        const rulesLocalPath = (_a = config.src.firestore) === null || _a === void 0 ? void 0 : _a.rules;\n        let rulesFileFound = false;\n        if (rulesLocalPath) {\n            const rules = config.path(rulesLocalPath);\n            rulesFileFound = fs.existsSync(rules);\n            if (rulesFileFound) {\n                args.rules = rules;\n            }\n            else {\n                firestoreLogger.logLabeled(\"WARN\", \"firestore\", `Cloud Firestore rules file ${clc.bold(rules)} specified in firebase.json does not exist.`);\n            }\n        }\n        else {\n            firestoreLogger.logLabeled(\"WARN\", \"firestore\", \"Did not find a Cloud Firestore rules file specified in a firebase.json config file.\");\n        }\n        if (!rulesFileFound) {\n            firestoreLogger.logLabeled(\"WARN\", \"firestore\", \"The emulator will default to allowing all reads and writes. Learn more about this option: https://firebase.google.com/docs/emulator-suite/install_and_configure#security_rules_configuration.\");\n        }\n        const firestoreEmulator = new firestoreEmulator_1.FirestoreEmulator(args);\n        await startEmulator(firestoreEmulator);\n    }\n    if (shouldStart(options, types_1.Emulators.DATABASE)) {\n        const databaseLogger = emulatorLogger_1.EmulatorLogger.forEmulator(types_1.Emulators.DATABASE);\n        const databaseAddr = await getAndCheckAddress(types_1.Emulators.DATABASE, options);\n        const args = {\n            host: databaseAddr.host,\n            port: databaseAddr.port,\n            projectId,\n            auto_download: true,\n        };\n        try {\n            if (!options.instance) {\n                options.instance = await getDefaultDatabaseInstance_1.getDefaultDatabaseInstance(options);\n            }\n        }\n        catch (e) {\n            databaseLogger.log(\"DEBUG\", `Failed to retrieve default database instance: ${JSON.stringify(e)}`);\n        }\n        const rc = dbRulesConfig.normalizeRulesConfig(dbRulesConfig.getRulesConfig(projectId, options), options);\n        logger_1.logger.debug(\"database rules config: \", JSON.stringify(rc));\n        args.rules = rc;\n        if (rc.length === 0) {\n            databaseLogger.logLabeled(\"WARN\", \"database\", \"Did not find a Realtime Database rules file specified in a firebase.json config file. The emulator will default to allowing all reads and writes. Learn more about this option: https://firebase.google.com/docs/emulator-suite/install_and_configure#security_rules_configuration.\");\n        }\n        else {\n            for (const c of rc) {\n                const rules = c.rules;\n                if (!fs.existsSync(rules)) {\n                    databaseLogger.logLabeled(\"WARN\", \"database\", `Realtime Database rules file ${clc.bold(rules)} specified in firebase.json does not exist.`);\n                }\n            }\n        }\n        const databaseEmulator = new databaseEmulator_1.DatabaseEmulator(args);\n        await startEmulator(databaseEmulator);\n        if (exportMetadata.database) {\n            utils.assertIsString(options.import);\n            const importDirAbsPath = path.resolve(options.import);\n            const databaseExportDir = path.resolve(importDirAbsPath, exportMetadata.database.path);\n            const files = fs.readdirSync(databaseExportDir).filter((f) => f.endsWith(\".json\"));\n            for (const f of files) {\n                const fPath = path.join(databaseExportDir, f);\n                const ns = path.basename(f, \".json\");\n                await databaseEmulator.importData(ns, fPath);\n            }\n        }\n    }\n    if (shouldStart(options, types_1.Emulators.AUTH)) {\n        if (!projectId) {\n            throw new error_1.FirebaseError(`Cannot start the ${constants_1.Constants.description(types_1.Emulators.AUTH)} without a project: run 'firebase init' or provide the --project flag`);\n        }\n        const authAddr = await getAndCheckAddress(types_1.Emulators.AUTH, options);\n        const authEmulator = new auth_1.AuthEmulator({\n            host: authAddr.host,\n            port: authAddr.port,\n            projectId,\n        });\n        await startEmulator(authEmulator);\n        if (exportMetadata.auth) {\n            utils.assertIsString(options.import);\n            const importDirAbsPath = path.resolve(options.import);\n            const authExportDir = path.resolve(importDirAbsPath, exportMetadata.auth.path);\n            await authEmulator.importData(authExportDir, projectId);\n        }\n    }\n    if (shouldStart(options, types_1.Emulators.PUBSUB)) {\n        if (!projectId) {\n            throw new error_1.FirebaseError(\"Cannot start the Pub/Sub emulator without a project: run 'firebase init' or provide the --project flag\");\n        }\n        const pubsubAddr = await getAndCheckAddress(types_1.Emulators.PUBSUB, options);\n        const pubsubEmulator = new pubsubEmulator_1.PubsubEmulator({\n            host: pubsubAddr.host,\n            port: pubsubAddr.port,\n            projectId,\n            auto_download: true,\n        });\n        await startEmulator(pubsubEmulator);\n    }\n    if (shouldStart(options, types_1.Emulators.STORAGE)) {\n        const storageAddr = await getAndCheckAddress(types_1.Emulators.STORAGE, options);\n        const storageConfig = options.config.data.storage;\n        if (!(storageConfig === null || storageConfig === void 0 ? void 0 : storageConfig.rules)) {\n            throw new error_1.FirebaseError(\"Cannot start the Storage emulator without rules file specified in firebase.json: run 'firebase init' and set up your Storage configuration\");\n        }\n        const storageEmulator = new storage_1.StorageEmulator({\n            host: storageAddr.host,\n            port: storageAddr.port,\n            projectId: projectId,\n            rules: options.config.path(storageConfig.rules),\n        });\n        await startEmulator(storageEmulator);\n        if (exportMetadata.storage) {\n            utils.assertIsString(options.import);\n            const importDirAbsPath = path.resolve(options.import);\n            const storageExportDir = path.resolve(importDirAbsPath, exportMetadata.storage.path);\n            storageEmulator.storageLayer.import(storageExportDir);\n        }\n    }\n    if (shouldStart(options, types_1.Emulators.HOSTING)) {\n        const hostingAddr = await getAndCheckAddress(types_1.Emulators.HOSTING, options);\n        const hostingEmulator = new hostingEmulator_1.HostingEmulator({\n            host: hostingAddr.host,\n            port: hostingAddr.port,\n            options,\n        });\n        await startEmulator(hostingEmulator);\n    }\n    if (showUI && !shouldStart(options, types_1.Emulators.UI)) {\n        hubLogger.logLabeled(\"WARN\", \"emulators\", \"The Emulator UI requires a project ID to start. Configure your default project with 'firebase use' or pass the --project flag.\");\n    }\n    if (showUI && shouldStart(options, types_1.Emulators.UI)) {\n        const loggingAddr = await getAndCheckAddress(types_1.Emulators.LOGGING, options);\n        const loggingEmulator = new loggingEmulator_1.LoggingEmulator({\n            host: loggingAddr.host,\n            port: loggingAddr.port,\n        });\n        await startEmulator(loggingEmulator);\n        const uiAddr = await getAndCheckAddress(types_1.Emulators.UI, options);\n        const ui = new ui_1.EmulatorUI(Object.assign({ projectId: projectId, auto_download: true }, uiAddr));\n        await startEmulator(ui);\n    }\n    const running = registry_1.EmulatorRegistry.listRunning();\n    for (const name of running) {\n        const instance = registry_1.EmulatorRegistry.get(name);\n        if (instance) {\n            await instance.connect();\n        }\n    }\n}\nexports.startAll = startAll;\nasync function exportEmulatorData(exportPath, options) {\n    const projectId = options.project;\n    if (!projectId) {\n        throw new error_1.FirebaseError(\"Could not determine project ID, make sure you're running in a Firebase project directory or add the --project flag.\", { exit: 1 });\n    }\n    const hubClient = new hubClient_1.EmulatorHubClient(projectId);\n    if (!hubClient.foundHub()) {\n        throw new error_1.FirebaseError(`Did not find any running emulators for project ${clc.bold(projectId)}.`, { exit: 1 });\n    }\n    try {\n        await hubClient.getStatus();\n    }\n    catch (e) {\n        const filePath = hub_1.EmulatorHub.getLocatorFilePath(projectId);\n        throw new error_1.FirebaseError(`The emulator hub for ${projectId} did not respond to a status check. If this error continues try shutting down all running emulators and deleting the file ${filePath}`, { exit: 1 });\n    }\n    utils.logBullet(`Found running emulator hub for project ${clc.bold(projectId)} at ${hubClient.origin}`);\n    const exportAbsPath = path.resolve(exportPath);\n    if (!fs.existsSync(exportAbsPath)) {\n        utils.logBullet(`Creating export directory ${exportAbsPath}`);\n        fs.mkdirSync(exportAbsPath);\n    }\n    const existingMetadata = hubExport_1.HubExport.readMetadata(exportAbsPath);\n    if (existingMetadata && !(options.force || options.exportOnExit)) {\n        if (options.noninteractive) {\n            throw new error_1.FirebaseError(\"Export already exists in the target directory, re-run with --force to overwrite.\", { exit: 1 });\n        }\n        const prompt = await prompt_1.promptOnce({\n            type: \"confirm\",\n            message: `The directory ${exportAbsPath} already contains export data. Exporting again to the same directory will overwrite all data. Do you want to continue?`,\n            default: false,\n        });\n        if (!prompt) {\n            throw new error_1.FirebaseError(\"Command aborted\", { exit: 1 });\n        }\n    }\n    utils.logBullet(`Exporting data to: ${exportAbsPath}`);\n    try {\n        await hubClient.postExport(exportAbsPath);\n    }\n    catch (e) {\n        throw new error_1.FirebaseError(\"Export request failed, see emulator logs for more information.\", {\n            exit: 1,\n            original: e,\n        });\n    }\n    utils.logSuccess(\"Export complete\");\n}\nexports.exportEmulatorData = exportEmulatorData;\n"]},"metadata":{},"sourceType":"script"}