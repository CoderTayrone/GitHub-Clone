{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst promise_breaker_1 = __importDefault(require(\"promise-breaker\"));\n\nconst deep_freeze_1 = __importDefault(require(\"deep-freeze\"));\n\nconst ExegesisResponseImpl_1 = __importDefault(require(\"./ExegesisResponseImpl\"));\n\nconst errors_1 = require(\"../errors\");\n\nconst EMPTY_PARAMS = deep_freeze_1.default({\n  query: Object.create(null),\n  header: Object.create(null),\n  server: Object.create(null),\n  path: Object.create(null),\n  cookie: Object.create(null)\n});\nconst EMPTY_PARAM_LOCATIONS = deep_freeze_1.default({\n  query: Object.create(null),\n  header: Object.create(null),\n  path: Object.create(null),\n  cookie: Object.create(null)\n});\nconst EMPTY_ROUTE = deep_freeze_1.default({\n  path: ''\n});\n\nclass ExegesisContextImpl {\n  constructor(req, // http2.Http2ServerRequest,\n  res, // http2.Http2ServerResponse,\n  api, options) {\n    this.parameterLocations = EMPTY_PARAM_LOCATIONS;\n    this.route = EMPTY_ROUTE;\n    this.baseUrl = '';\n    this._paramsResolved = false;\n    this._bodyResolved = false;\n    const responseValidationEnabled = !!options.onResponseValidationError;\n    this.req = req;\n    this.origRes = res;\n    this.res = new ExegesisResponseImpl_1.default(res, responseValidationEnabled);\n    this.api = api;\n    this.options = options; // Temporarily set params to EMPTY_PARAMS.  While we're being a\n    // 'plugin context', this will be empty, but it will be filled in\n    // before we get to the controllers.\n\n    this.params = EMPTY_PARAMS;\n  }\n\n  _setOperation(baseUrl, path, operation) {\n    this.baseUrl = baseUrl;\n    this.route = {\n      path\n    };\n    this._operation = operation;\n    this.parameterLocations = operation.parameterLocations; // Set `req.baseUrl` and `req.path` to make this behave like Express.\n\n    const req = this.req;\n\n    if (req.baseUrl) {\n      req.baseUrl = `${req.baseUrl}${baseUrl}`;\n    } else {\n      req.baseUrl = baseUrl;\n    }\n\n    req.route = {\n      path\n    };\n  }\n\n  makeError(statusCode, message) {\n    return new errors_1.HttpError(statusCode, message);\n  }\n\n  makeValidationError(message, parameterLocation) {\n    return new errors_1.ValidationError([{\n      message,\n      location: parameterLocation\n    }]);\n  }\n  /**\n   * Returns true if the response has already been sent.\n   */\n\n\n  isResponseFinished() {\n    return this.res.ended || this.origRes.headersSent;\n  }\n\n  getParams(done) {\n    return promise_breaker_1.default.addCallback(done, () => {\n      if (!this._paramsResolved) {\n        if (!this._operation) {\n          throw new Error('Cannot get parameters - no resolved operation.');\n        }\n\n        this.params = this._operation.parseParameters();\n\n        const errors = this._operation.validateParameters(this.params);\n\n        if (errors && errors.length > 0) {\n          const err = new errors_1.ValidationError(errors);\n          throw err;\n        }\n\n        this._paramsResolved = true;\n      }\n\n      return this.params;\n    });\n  }\n\n  getRequestBody(done) {\n    return promise_breaker_1.default.addCallback(done, () => __awaiter(this, void 0, void 0, function* () {\n      if (!this._operation) {\n        throw new Error('Cannot get parameters - no resolved operation.');\n      }\n\n      if (!this._bodyResolved) {\n        let body; // Parse the body.\n\n        if (this._operation.bodyParser) {\n          const bodyParser = this._operation.bodyParser;\n          body = yield promise_breaker_1.default.call(done => bodyParser.parseReq(this.req, this.origRes, done));\n          body = body || this.req.body;\n        } // Validate the body.  We need to validate the body even if we\n        // didn't parse a body, since this is where we check if the\n        // body is required.\n\n\n        if (this._operation.validateBody) {\n          const validationResult = this._operation.validateBody(body);\n\n          if (validationResult.errors && validationResult.errors.length > 0) {\n            throw new errors_1.ValidationError(validationResult.errors);\n          }\n\n          body = validationResult.value;\n        } // Assign the body to the appropriate places\n\n\n        this.requestBody = this.req.body = body;\n        this._bodyResolved = true;\n      }\n\n      return this.requestBody;\n    }));\n  }\n\n}\n\nexports.default = ExegesisContextImpl;","map":{"version":3,"sources":["../../src/core/ExegesisContextImpl.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst promise_breaker_1 = __importDefault(require(\"promise-breaker\"));\nconst deep_freeze_1 = __importDefault(require(\"deep-freeze\"));\nconst ExegesisResponseImpl_1 = __importDefault(require(\"./ExegesisResponseImpl\"));\nconst errors_1 = require(\"../errors\");\nconst EMPTY_PARAMS = deep_freeze_1.default({\n    query: Object.create(null),\n    header: Object.create(null),\n    server: Object.create(null),\n    path: Object.create(null),\n    cookie: Object.create(null),\n});\nconst EMPTY_PARAM_LOCATIONS = deep_freeze_1.default({\n    query: Object.create(null),\n    header: Object.create(null),\n    path: Object.create(null),\n    cookie: Object.create(null),\n});\nconst EMPTY_ROUTE = deep_freeze_1.default({\n    path: '',\n});\nclass ExegesisContextImpl {\n    constructor(req, // http2.Http2ServerRequest,\n    res, // http2.Http2ServerResponse,\n    api, options) {\n        this.parameterLocations = EMPTY_PARAM_LOCATIONS;\n        this.route = EMPTY_ROUTE;\n        this.baseUrl = '';\n        this._paramsResolved = false;\n        this._bodyResolved = false;\n        const responseValidationEnabled = !!options.onResponseValidationError;\n        this.req = req;\n        this.origRes = res;\n        this.res = new ExegesisResponseImpl_1.default(res, responseValidationEnabled);\n        this.api = api;\n        this.options = options;\n        // Temporarily set params to EMPTY_PARAMS.  While we're being a\n        // 'plugin context', this will be empty, but it will be filled in\n        // before we get to the controllers.\n        this.params = EMPTY_PARAMS;\n    }\n    _setOperation(baseUrl, path, operation) {\n        this.baseUrl = baseUrl;\n        this.route = { path };\n        this._operation = operation;\n        this.parameterLocations = operation.parameterLocations;\n        // Set `req.baseUrl` and `req.path` to make this behave like Express.\n        const req = this.req;\n        if (req.baseUrl) {\n            req.baseUrl = `${req.baseUrl}${baseUrl}`;\n        }\n        else {\n            req.baseUrl = baseUrl;\n        }\n        req.route = { path };\n    }\n    makeError(statusCode, message) {\n        return new errors_1.HttpError(statusCode, message);\n    }\n    makeValidationError(message, parameterLocation) {\n        return new errors_1.ValidationError([{ message, location: parameterLocation }]);\n    }\n    /**\n     * Returns true if the response has already been sent.\n     */\n    isResponseFinished() {\n        return this.res.ended || this.origRes.headersSent;\n    }\n    getParams(done) {\n        return promise_breaker_1.default.addCallback(done, () => {\n            if (!this._paramsResolved) {\n                if (!this._operation) {\n                    throw new Error('Cannot get parameters - no resolved operation.');\n                }\n                this.params = this._operation.parseParameters();\n                const errors = this._operation.validateParameters(this.params);\n                if (errors && errors.length > 0) {\n                    const err = new errors_1.ValidationError(errors);\n                    throw err;\n                }\n                this._paramsResolved = true;\n            }\n            return this.params;\n        });\n    }\n    getRequestBody(done) {\n        return promise_breaker_1.default.addCallback(done, () => __awaiter(this, void 0, void 0, function* () {\n            if (!this._operation) {\n                throw new Error('Cannot get parameters - no resolved operation.');\n            }\n            if (!this._bodyResolved) {\n                let body;\n                // Parse the body.\n                if (this._operation.bodyParser) {\n                    const bodyParser = this._operation.bodyParser;\n                    body = yield promise_breaker_1.default.call((done) => bodyParser.parseReq(this.req, this.origRes, done));\n                    body = body || this.req.body;\n                }\n                // Validate the body.  We need to validate the body even if we\n                // didn't parse a body, since this is where we check if the\n                // body is required.\n                if (this._operation.validateBody) {\n                    const validationResult = this._operation.validateBody(body);\n                    if (validationResult.errors && validationResult.errors.length > 0) {\n                        throw new errors_1.ValidationError(validationResult.errors);\n                    }\n                    body = validationResult.value;\n                }\n                // Assign the body to the appropriate places\n                this.requestBody = this.req.body = body;\n                this._bodyResolved = true;\n            }\n            return this.requestBody;\n        }));\n    }\n}\nexports.default = ExegesisContextImpl;\n//# sourceMappingURL=ExegesisContextImpl.js.map"]},"metadata":{},"sourceType":"script"}