{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.readdirRecursive = void 0;\n\nconst path_1 = require(\"path\");\n\nconst fs_extra_1 = require(\"fs-extra\");\n\nconst _ = require(\"lodash\");\n\nconst minimatch = require(\"minimatch\");\n\nasync function readdirRecursiveHelper(options) {\n  const dirContents = fs_extra_1.readdirSync(options.path);\n  const fullPaths = dirContents.map(n => path_1.join(options.path, n));\n\n  const filteredPaths = _.reject(fullPaths, options.filter);\n\n  const filePromises = [];\n\n  for (const p of filteredPaths) {\n    const fstat = fs_extra_1.statSync(p);\n\n    if (fstat.isFile()) {\n      filePromises.push(Promise.resolve({\n        name: p,\n        mode: fstat.mode\n      }));\n    }\n\n    if (!fstat.isDirectory()) {\n      continue;\n    }\n\n    filePromises.push(readdirRecursiveHelper({\n      path: p,\n      filter: options.filter\n    }));\n  }\n\n  const files = await Promise.all(filePromises);\n\n  let flatFiles = _.flattenDeep(files);\n\n  flatFiles = _.reject(flatFiles, f => _.isNull(f));\n  return flatFiles;\n}\n\nasync function readdirRecursive(options) {\n  const mmopts = {\n    matchBase: true,\n    dot: true\n  };\n\n  const rules = _.map(options.ignore || [], glob => {\n    return p => minimatch(p, glob, mmopts);\n  });\n\n  const filter = t => {\n    return rules.some(rule => {\n      return rule(t);\n    });\n  };\n\n  return readdirRecursiveHelper({\n    path: options.path,\n    filter: filter\n  });\n}\n\nexports.readdirRecursive = readdirRecursive;","map":{"version":3,"sources":["/home/dev/Documentos/Projects/github-clone/node_modules/firebase-tools/lib/fsAsync.js"],"names":["Object","defineProperty","exports","value","readdirRecursive","path_1","require","fs_extra_1","_","minimatch","readdirRecursiveHelper","options","dirContents","readdirSync","path","fullPaths","map","n","join","filteredPaths","reject","filter","filePromises","p","fstat","statSync","isFile","push","Promise","resolve","name","mode","isDirectory","files","all","flatFiles","flattenDeep","f","isNull","mmopts","matchBase","dot","rules","ignore","glob","t","some","rule"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,gBAAR,GAA2B,KAAK,CAAhC;;AACA,MAAMC,MAAM,GAAGC,OAAO,CAAC,MAAD,CAAtB;;AACA,MAAMC,UAAU,GAAGD,OAAO,CAAC,UAAD,CAA1B;;AACA,MAAME,CAAC,GAAGF,OAAO,CAAC,QAAD,CAAjB;;AACA,MAAMG,SAAS,GAAGH,OAAO,CAAC,WAAD,CAAzB;;AACA,eAAeI,sBAAf,CAAsCC,OAAtC,EAA+C;AAC3C,QAAMC,WAAW,GAAGL,UAAU,CAACM,WAAX,CAAuBF,OAAO,CAACG,IAA/B,CAApB;AACA,QAAMC,SAAS,GAAGH,WAAW,CAACI,GAAZ,CAAiBC,CAAD,IAAOZ,MAAM,CAACa,IAAP,CAAYP,OAAO,CAACG,IAApB,EAA0BG,CAA1B,CAAvB,CAAlB;;AACA,QAAME,aAAa,GAAGX,CAAC,CAACY,MAAF,CAASL,SAAT,EAAoBJ,OAAO,CAACU,MAA5B,CAAtB;;AACA,QAAMC,YAAY,GAAG,EAArB;;AACA,OAAK,MAAMC,CAAX,IAAgBJ,aAAhB,EAA+B;AAC3B,UAAMK,KAAK,GAAGjB,UAAU,CAACkB,QAAX,CAAoBF,CAApB,CAAd;;AACA,QAAIC,KAAK,CAACE,MAAN,EAAJ,EAAoB;AAChBJ,MAAAA,YAAY,CAACK,IAAb,CAAkBC,OAAO,CAACC,OAAR,CAAgB;AAAEC,QAAAA,IAAI,EAAEP,CAAR;AAAWQ,QAAAA,IAAI,EAAEP,KAAK,CAACO;AAAvB,OAAhB,CAAlB;AACH;;AACD,QAAI,CAACP,KAAK,CAACQ,WAAN,EAAL,EAA0B;AACtB;AACH;;AACDV,IAAAA,YAAY,CAACK,IAAb,CAAkBjB,sBAAsB,CAAC;AAAEI,MAAAA,IAAI,EAAES,CAAR;AAAWF,MAAAA,MAAM,EAAEV,OAAO,CAACU;AAA3B,KAAD,CAAxC;AACH;;AACD,QAAMY,KAAK,GAAG,MAAML,OAAO,CAACM,GAAR,CAAYZ,YAAZ,CAApB;;AACA,MAAIa,SAAS,GAAG3B,CAAC,CAAC4B,WAAF,CAAcH,KAAd,CAAhB;;AACAE,EAAAA,SAAS,GAAG3B,CAAC,CAACY,MAAF,CAASe,SAAT,EAAqBE,CAAD,IAAO7B,CAAC,CAAC8B,MAAF,CAASD,CAAT,CAA3B,CAAZ;AACA,SAAOF,SAAP;AACH;;AACD,eAAe/B,gBAAf,CAAgCO,OAAhC,EAAyC;AACrC,QAAM4B,MAAM,GAAG;AAAEC,IAAAA,SAAS,EAAE,IAAb;AAAmBC,IAAAA,GAAG,EAAE;AAAxB,GAAf;;AACA,QAAMC,KAAK,GAAGlC,CAAC,CAACQ,GAAF,CAAML,OAAO,CAACgC,MAAR,IAAkB,EAAxB,EAA6BC,IAAD,IAAU;AAChD,WAAQrB,CAAD,IAAOd,SAAS,CAACc,CAAD,EAAIqB,IAAJ,EAAUL,MAAV,CAAvB;AACH,GAFa,CAAd;;AAGA,QAAMlB,MAAM,GAAIwB,CAAD,IAAO;AAClB,WAAOH,KAAK,CAACI,IAAN,CAAYC,IAAD,IAAU;AACxB,aAAOA,IAAI,CAACF,CAAD,CAAX;AACH,KAFM,CAAP;AAGH,GAJD;;AAKA,SAAOnC,sBAAsB,CAAC;AAC1BI,IAAAA,IAAI,EAAEH,OAAO,CAACG,IADY;AAE1BO,IAAAA,MAAM,EAAEA;AAFkB,GAAD,CAA7B;AAIH;;AACDnB,OAAO,CAACE,gBAAR,GAA2BA,gBAA3B","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.readdirRecursive = void 0;\nconst path_1 = require(\"path\");\nconst fs_extra_1 = require(\"fs-extra\");\nconst _ = require(\"lodash\");\nconst minimatch = require(\"minimatch\");\nasync function readdirRecursiveHelper(options) {\n    const dirContents = fs_extra_1.readdirSync(options.path);\n    const fullPaths = dirContents.map((n) => path_1.join(options.path, n));\n    const filteredPaths = _.reject(fullPaths, options.filter);\n    const filePromises = [];\n    for (const p of filteredPaths) {\n        const fstat = fs_extra_1.statSync(p);\n        if (fstat.isFile()) {\n            filePromises.push(Promise.resolve({ name: p, mode: fstat.mode }));\n        }\n        if (!fstat.isDirectory()) {\n            continue;\n        }\n        filePromises.push(readdirRecursiveHelper({ path: p, filter: options.filter }));\n    }\n    const files = await Promise.all(filePromises);\n    let flatFiles = _.flattenDeep(files);\n    flatFiles = _.reject(flatFiles, (f) => _.isNull(f));\n    return flatFiles;\n}\nasync function readdirRecursive(options) {\n    const mmopts = { matchBase: true, dot: true };\n    const rules = _.map(options.ignore || [], (glob) => {\n        return (p) => minimatch(p, glob, mmopts);\n    });\n    const filter = (t) => {\n        return rules.some((rule) => {\n            return rule(t);\n        });\n    };\n    return readdirRecursiveHelper({\n        path: options.path,\n        filter: filter,\n    });\n}\nexports.readdirRecursive = readdirRecursive;\n"]},"metadata":{},"sourceType":"script"}