{"ast":null,"code":"import { j as _inherits, k as _createSuper, c as _classCallCheck, T as Type, b as _createClass, R as Range, N as Node, g as YAMLSemanticError, l as _get, m as _getPrototypeOf, Y as YAMLSyntaxError, C as Char, e as _defineProperty, P as PlainValue } from './PlainValue-b8036b75.js';\n\nvar BlankLine = /*#__PURE__*/function (_Node) {\n  _inherits(BlankLine, _Node);\n\n  var _super = _createSuper(BlankLine);\n\n  function BlankLine() {\n    _classCallCheck(this, BlankLine);\n\n    return _super.call(this, Type.BLANK_LINE);\n  }\n  /* istanbul ignore next */\n\n\n  _createClass(BlankLine, [{\n    key: \"includesTrailingLines\",\n    get: function get() {\n      // This is never called from anywhere, but if it were,\n      // this is the value it should return.\n      return true;\n    }\n    /**\n     * Parses a blank line from the source\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first \\n character\n     * @returns {number} - Index of the character after this\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      this.range = new Range(start, start + 1);\n      return start + 1;\n    }\n  }]);\n\n  return BlankLine;\n}(Node);\n\nvar CollectionItem = /*#__PURE__*/function (_Node) {\n  _inherits(CollectionItem, _Node);\n\n  var _super = _createSuper(CollectionItem);\n\n  function CollectionItem(type, props) {\n    var _this;\n\n    _classCallCheck(this, CollectionItem);\n\n    _this = _super.call(this, type, props);\n    _this.node = null;\n    return _this;\n  }\n\n  _createClass(CollectionItem, [{\n    key: \"includesTrailingLines\",\n    get: function get() {\n      return !!this.node && this.node.includesTrailingLines;\n    }\n    /**\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var parseNode = context.parseNode,\n          src = context.src;\n      var atLineStart = context.atLineStart,\n          lineStart = context.lineStart;\n      if (!atLineStart && this.type === Type.SEQ_ITEM) this.error = new YAMLSemanticError(this, 'Sequence items must not have preceding content on the same line');\n      var indent = atLineStart ? start - lineStart : context.indent;\n      var offset = Node.endOfWhiteSpace(src, start + 1);\n      var ch = src[offset];\n      var inlineComment = ch === '#';\n      var comments = [];\n      var blankLine = null;\n\n      while (ch === '\\n' || ch === '#') {\n        if (ch === '#') {\n          var _end = Node.endOfLine(src, offset + 1);\n\n          comments.push(new Range(offset, _end));\n          offset = _end;\n        } else {\n          atLineStart = true;\n          lineStart = offset + 1;\n          var wsEnd = Node.endOfWhiteSpace(src, lineStart);\n\n          if (src[wsEnd] === '\\n' && comments.length === 0) {\n            blankLine = new BlankLine();\n            lineStart = blankLine.parse({\n              src: src\n            }, lineStart);\n          }\n\n          offset = Node.endOfIndent(src, lineStart);\n        }\n\n        ch = src[offset];\n      }\n\n      if (Node.nextNodeIsIndented(ch, offset - (lineStart + indent), this.type !== Type.SEQ_ITEM)) {\n        this.node = parseNode({\n          atLineStart: atLineStart,\n          inCollection: false,\n          indent: indent,\n          lineStart: lineStart,\n          parent: this\n        }, offset);\n      } else if (ch && lineStart > start + 1) {\n        offset = lineStart - 1;\n      }\n\n      if (this.node) {\n        if (blankLine) {\n          // Only blank lines preceding non-empty nodes are captured. Note that\n          // this means that collection item range start indices do not always\n          // increase monotonically. -- eemeli/yaml#126\n          var items = context.parent.items || context.parent.contents;\n          if (items) items.push(blankLine);\n        }\n\n        if (comments.length) Array.prototype.push.apply(this.props, comments);\n        offset = this.node.range.end;\n      } else {\n        if (inlineComment) {\n          var c = comments[0];\n          this.props.push(c);\n          offset = c.end;\n        } else {\n          offset = Node.endOfLine(src, start + 1);\n        }\n      }\n\n      var end = this.node ? this.node.valueRange.end : offset;\n      this.valueRange = new Range(start, end);\n      return offset;\n    }\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      offset = _get(_getPrototypeOf(CollectionItem.prototype), \"setOrigRanges\", this).call(this, cr, offset);\n      return this.node ? this.node.setOrigRanges(cr, offset) : offset;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var src = this.context.src,\n          node = this.node,\n          range = this.range,\n          value = this.value;\n      if (value != null) return value;\n      var str = node ? src.slice(range.start, node.range.start) + String(node) : src.slice(range.start, range.end);\n      return Node.addStringTerminator(src, range.end, str);\n    }\n  }]);\n\n  return CollectionItem;\n}(Node);\n\nvar Comment = /*#__PURE__*/function (_Node) {\n  _inherits(Comment, _Node);\n\n  var _super = _createSuper(Comment);\n\n  function Comment() {\n    _classCallCheck(this, Comment);\n\n    return _super.call(this, Type.COMMENT);\n  }\n  /**\n   * Parses a comment line from the source\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this scalar\n   */\n\n\n  _createClass(Comment, [{\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var offset = this.parseComment(start);\n      this.range = new Range(start, offset);\n      return offset;\n    }\n  }]);\n\n  return Comment;\n}(Node);\n\nfunction grabCollectionEndComments(node) {\n  var cnode = node;\n\n  while (cnode instanceof CollectionItem) {\n    cnode = cnode.node;\n  }\n\n  if (!(cnode instanceof Collection)) return null;\n  var len = cnode.items.length;\n  var ci = -1;\n\n  for (var i = len - 1; i >= 0; --i) {\n    var n = cnode.items[i];\n\n    if (n.type === Type.COMMENT) {\n      // Keep sufficiently indented comments with preceding node\n      var _n$context = n.context,\n          indent = _n$context.indent,\n          lineStart = _n$context.lineStart;\n      if (indent > 0 && n.range.start >= lineStart + indent) break;\n      ci = i;\n    } else if (n.type === Type.BLANK_LINE) ci = i;else break;\n  }\n\n  if (ci === -1) return null;\n  var ca = cnode.items.splice(ci, len - ci);\n  var prevEnd = ca[0].range.start;\n\n  while (true) {\n    cnode.range.end = prevEnd;\n    if (cnode.valueRange && cnode.valueRange.end > prevEnd) cnode.valueRange.end = prevEnd;\n    if (cnode === node) break;\n    cnode = cnode.context.parent;\n  }\n\n  return ca;\n}\n\nvar Collection = /*#__PURE__*/function (_Node) {\n  _inherits(Collection, _Node);\n\n  var _super = _createSuper(Collection);\n\n  function Collection(firstItem) {\n    var _this;\n\n    _classCallCheck(this, Collection);\n\n    _this = _super.call(this, firstItem.type === Type.SEQ_ITEM ? Type.SEQ : Type.MAP);\n\n    for (var i = firstItem.props.length - 1; i >= 0; --i) {\n      if (firstItem.props[i].start < firstItem.context.lineStart) {\n        // props on previous line are assumed by the collection\n        _this.props = firstItem.props.slice(0, i + 1);\n        firstItem.props = firstItem.props.slice(i + 1);\n        var itemRange = firstItem.props[0] || firstItem.valueRange;\n        firstItem.range.start = itemRange.start;\n        break;\n      }\n    }\n\n    _this.items = [firstItem];\n    var ec = grabCollectionEndComments(firstItem);\n    if (ec) Array.prototype.push.apply(_this.items, ec);\n    return _this;\n  }\n\n  _createClass(Collection, [{\n    key: \"includesTrailingLines\",\n    get: function get() {\n      return this.items.length > 0;\n    }\n    /**\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var parseNode = context.parseNode,\n          src = context.src; // It's easier to recalculate lineStart here rather than tracking down the\n      // last context from which to read it -- eemeli/yaml#2\n\n      var lineStart = Node.startOfLine(src, start);\n      var firstItem = this.items[0]; // First-item context needs to be correct for later comment handling\n      // -- eemeli/yaml#17\n\n      firstItem.context.parent = this;\n      this.valueRange = Range.copy(firstItem.valueRange);\n      var indent = firstItem.range.start - firstItem.context.lineStart;\n      var offset = start;\n      offset = Node.normalizeOffset(src, offset);\n      var ch = src[offset];\n      var atLineStart = Node.endOfWhiteSpace(src, lineStart) === offset;\n      var prevIncludesTrailingLines = false;\n\n      while (ch) {\n        while (ch === '\\n' || ch === '#') {\n          if (atLineStart && ch === '\\n' && !prevIncludesTrailingLines) {\n            var blankLine = new BlankLine();\n            offset = blankLine.parse({\n              src: src\n            }, offset);\n            this.valueRange.end = offset;\n\n            if (offset >= src.length) {\n              ch = null;\n              break;\n            }\n\n            this.items.push(blankLine);\n            offset -= 1; // blankLine.parse() consumes terminal newline\n          } else if (ch === '#') {\n            if (offset < lineStart + indent && !Collection.nextContentHasIndent(src, offset, indent)) {\n              return offset;\n            }\n\n            var comment = new Comment();\n            offset = comment.parse({\n              indent: indent,\n              lineStart: lineStart,\n              src: src\n            }, offset);\n            this.items.push(comment);\n            this.valueRange.end = offset;\n\n            if (offset >= src.length) {\n              ch = null;\n              break;\n            }\n          }\n\n          lineStart = offset + 1;\n          offset = Node.endOfIndent(src, lineStart);\n\n          if (Node.atBlank(src, offset)) {\n            var wsEnd = Node.endOfWhiteSpace(src, offset);\n            var next = src[wsEnd];\n\n            if (!next || next === '\\n' || next === '#') {\n              offset = wsEnd;\n            }\n          }\n\n          ch = src[offset];\n          atLineStart = true;\n        }\n\n        if (!ch) {\n          break;\n        }\n\n        if (offset !== lineStart + indent && (atLineStart || ch !== ':')) {\n          if (offset < lineStart + indent) {\n            if (lineStart > start) offset = lineStart;\n            break;\n          } else if (!this.error) {\n            var msg = 'All collection items must start at the same column';\n            this.error = new YAMLSyntaxError(this, msg);\n          }\n        }\n\n        if (firstItem.type === Type.SEQ_ITEM) {\n          if (ch !== '-') {\n            if (lineStart > start) offset = lineStart;\n            break;\n          }\n        } else if (ch === '-' && !this.error) {\n          // map key may start with -, as long as it's followed by a non-whitespace char\n          var _next = src[offset + 1];\n\n          if (!_next || _next === '\\n' || _next === '\\t' || _next === ' ') {\n            var _msg = 'A collection cannot be both a mapping and a sequence';\n            this.error = new YAMLSyntaxError(this, _msg);\n          }\n        }\n\n        var node = parseNode({\n          atLineStart: atLineStart,\n          inCollection: true,\n          indent: indent,\n          lineStart: lineStart,\n          parent: this\n        }, offset);\n        if (!node) return offset; // at next document start\n\n        this.items.push(node);\n        this.valueRange.end = node.valueRange.end;\n        offset = Node.normalizeOffset(src, node.range.end);\n        ch = src[offset];\n        atLineStart = false;\n        prevIncludesTrailingLines = node.includesTrailingLines; // Need to reset lineStart and atLineStart here if preceding node's range\n        // has advanced to check the current line's indentation level\n        // -- eemeli/yaml#10 & eemeli/yaml#38\n\n        if (ch) {\n          var ls = offset - 1;\n          var prev = src[ls];\n\n          while (prev === ' ' || prev === '\\t') {\n            prev = src[--ls];\n          }\n\n          if (prev === '\\n') {\n            lineStart = ls + 1;\n            atLineStart = true;\n          }\n        }\n\n        var ec = grabCollectionEndComments(node);\n        if (ec) Array.prototype.push.apply(this.items, ec);\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      offset = _get(_getPrototypeOf(Collection.prototype), \"setOrigRanges\", this).call(this, cr, offset);\n      this.items.forEach(function (node) {\n        offset = node.setOrigRanges(cr, offset);\n      });\n      return offset;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var src = this.context.src,\n          items = this.items,\n          range = this.range,\n          value = this.value;\n      if (value != null) return value;\n      var str = src.slice(range.start, items[0].range.start) + String(items[0]);\n\n      for (var i = 1; i < items.length; ++i) {\n        var item = items[i];\n        var _item$context = item.context,\n            atLineStart = _item$context.atLineStart,\n            indent = _item$context.indent;\n        if (atLineStart) for (var _i = 0; _i < indent; ++_i) {\n          str += ' ';\n        }\n        str += String(item);\n      }\n\n      return Node.addStringTerminator(src, range.end, str);\n    }\n  }], [{\n    key: \"nextContentHasIndent\",\n    value: function nextContentHasIndent(src, offset, indent) {\n      var lineStart = Node.endOfLine(src, offset) + 1;\n      offset = Node.endOfWhiteSpace(src, lineStart);\n      var ch = src[offset];\n      if (!ch) return false;\n      if (offset >= lineStart + indent) return true;\n      if (ch !== '#' && ch !== '\\n') return false;\n      return Collection.nextContentHasIndent(src, offset, indent);\n    }\n  }]);\n\n  return Collection;\n}(Node);\n\nvar Directive = /*#__PURE__*/function (_Node) {\n  _inherits(Directive, _Node);\n\n  var _super = _createSuper(Directive);\n\n  function Directive() {\n    var _this;\n\n    _classCallCheck(this, Directive);\n\n    _this = _super.call(this, Type.DIRECTIVE);\n    _this.name = null;\n    return _this;\n  }\n\n  _createClass(Directive, [{\n    key: \"parameters\",\n    get: function get() {\n      var raw = this.rawValue;\n      return raw ? raw.trim().split(/[ \\t]+/) : [];\n    }\n  }, {\n    key: \"parseName\",\n    value: function parseName(start) {\n      var src = this.context.src;\n      var offset = start;\n      var ch = src[offset];\n\n      while (ch && ch !== '\\n' && ch !== '\\t' && ch !== ' ') {\n        ch = src[offset += 1];\n      }\n\n      this.name = src.slice(start, offset);\n      return offset;\n    }\n  }, {\n    key: \"parseParameters\",\n    value: function parseParameters(start) {\n      var src = this.context.src;\n      var offset = start;\n      var ch = src[offset];\n\n      while (ch && ch !== '\\n' && ch !== '#') {\n        ch = src[offset += 1];\n      }\n\n      this.valueRange = new Range(start, offset);\n      return offset;\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var offset = this.parseName(start + 1);\n      offset = this.parseParameters(offset);\n      offset = this.parseComment(offset);\n      this.range = new Range(start, offset);\n      return offset;\n    }\n  }]);\n\n  return Directive;\n}(Node);\n\nvar Document = /*#__PURE__*/function (_Node) {\n  _inherits(Document, _Node);\n\n  var _super = _createSuper(Document);\n\n  function Document() {\n    var _this;\n\n    _classCallCheck(this, Document);\n\n    _this = _super.call(this, Type.DOCUMENT);\n    _this.directives = null;\n    _this.contents = null;\n    _this.directivesEndMarker = null;\n    _this.documentEndMarker = null;\n    return _this;\n  }\n\n  _createClass(Document, [{\n    key: \"parseDirectives\",\n    value: function parseDirectives(start) {\n      var src = this.context.src;\n      this.directives = [];\n      var atLineStart = true;\n      var hasDirectives = false;\n      var offset = start;\n\n      while (!Node.atDocumentBoundary(src, offset, Char.DIRECTIVES_END)) {\n        offset = Document.startCommentOrEndBlankLine(src, offset);\n\n        switch (src[offset]) {\n          case '\\n':\n            if (atLineStart) {\n              var blankLine = new BlankLine();\n              offset = blankLine.parse({\n                src: src\n              }, offset);\n\n              if (offset < src.length) {\n                this.directives.push(blankLine);\n              }\n            } else {\n              offset += 1;\n              atLineStart = true;\n            }\n\n            break;\n\n          case '#':\n            {\n              var comment = new Comment();\n              offset = comment.parse({\n                src: src\n              }, offset);\n              this.directives.push(comment);\n              atLineStart = false;\n            }\n            break;\n\n          case '%':\n            {\n              var directive = new Directive();\n              offset = directive.parse({\n                parent: this,\n                src: src\n              }, offset);\n              this.directives.push(directive);\n              hasDirectives = true;\n              atLineStart = false;\n            }\n            break;\n\n          default:\n            if (hasDirectives) {\n              this.error = new YAMLSemanticError(this, 'Missing directives-end indicator line');\n            } else if (this.directives.length > 0) {\n              this.contents = this.directives;\n              this.directives = [];\n            }\n\n            return offset;\n        }\n      }\n\n      if (src[offset]) {\n        this.directivesEndMarker = new Range(offset, offset + 3);\n        return offset + 3;\n      }\n\n      if (hasDirectives) {\n        this.error = new YAMLSemanticError(this, 'Missing directives-end indicator line');\n      } else if (this.directives.length > 0) {\n        this.contents = this.directives;\n        this.directives = [];\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"parseContents\",\n    value: function parseContents(start) {\n      var _this$context = this.context,\n          parseNode = _this$context.parseNode,\n          src = _this$context.src;\n      if (!this.contents) this.contents = [];\n      var lineStart = start;\n\n      while (src[lineStart - 1] === '-') {\n        lineStart -= 1;\n      }\n\n      var offset = Node.endOfWhiteSpace(src, start);\n      var atLineStart = lineStart === start;\n      this.valueRange = new Range(offset);\n\n      while (!Node.atDocumentBoundary(src, offset, Char.DOCUMENT_END)) {\n        switch (src[offset]) {\n          case '\\n':\n            if (atLineStart) {\n              var blankLine = new BlankLine();\n              offset = blankLine.parse({\n                src: src\n              }, offset);\n\n              if (offset < src.length) {\n                this.contents.push(blankLine);\n              }\n            } else {\n              offset += 1;\n              atLineStart = true;\n            }\n\n            lineStart = offset;\n            break;\n\n          case '#':\n            {\n              var comment = new Comment();\n              offset = comment.parse({\n                src: src\n              }, offset);\n              this.contents.push(comment);\n              atLineStart = false;\n            }\n            break;\n\n          default:\n            {\n              var iEnd = Node.endOfIndent(src, offset);\n              var context = {\n                atLineStart: atLineStart,\n                indent: -1,\n                inFlow: false,\n                inCollection: false,\n                lineStart: lineStart,\n                parent: this\n              };\n              var node = parseNode(context, iEnd);\n              if (!node) return this.valueRange.end = iEnd; // at next document start\n\n              this.contents.push(node);\n              offset = node.range.end;\n              atLineStart = false;\n              var ec = grabCollectionEndComments(node);\n              if (ec) Array.prototype.push.apply(this.contents, ec);\n            }\n        }\n\n        offset = Document.startCommentOrEndBlankLine(src, offset);\n      }\n\n      this.valueRange.end = offset;\n\n      if (src[offset]) {\n        this.documentEndMarker = new Range(offset, offset + 3);\n        offset += 3;\n\n        if (src[offset]) {\n          offset = Node.endOfWhiteSpace(src, offset);\n\n          if (src[offset] === '#') {\n            var _comment = new Comment();\n\n            offset = _comment.parse({\n              src: src\n            }, offset);\n            this.contents.push(_comment);\n          }\n\n          switch (src[offset]) {\n            case '\\n':\n              offset += 1;\n              break;\n\n            case undefined:\n              break;\n\n            default:\n              this.error = new YAMLSyntaxError(this, 'Document end marker line cannot have a non-comment suffix');\n          }\n        }\n      }\n\n      return offset;\n    }\n    /**\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      context.root = this;\n      this.context = context;\n      var src = context.src;\n      var offset = src.charCodeAt(start) === 0xfeff ? start + 1 : start; // skip BOM\n\n      offset = this.parseDirectives(offset);\n      offset = this.parseContents(offset);\n      return offset;\n    }\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      offset = _get(_getPrototypeOf(Document.prototype), \"setOrigRanges\", this).call(this, cr, offset);\n      this.directives.forEach(function (node) {\n        offset = node.setOrigRanges(cr, offset);\n      });\n      if (this.directivesEndMarker) offset = this.directivesEndMarker.setOrigRange(cr, offset);\n      this.contents.forEach(function (node) {\n        offset = node.setOrigRanges(cr, offset);\n      });\n      if (this.documentEndMarker) offset = this.documentEndMarker.setOrigRange(cr, offset);\n      return offset;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var contents = this.contents,\n          directives = this.directives,\n          value = this.value;\n      if (value != null) return value;\n      var str = directives.join('');\n\n      if (contents.length > 0) {\n        if (directives.length > 0 || contents[0].type === Type.COMMENT) str += '---\\n';\n        str += contents.join('');\n      }\n\n      if (str[str.length - 1] !== '\\n') str += '\\n';\n      return str;\n    }\n  }], [{\n    key: \"startCommentOrEndBlankLine\",\n    value: function startCommentOrEndBlankLine(src, start) {\n      var offset = Node.endOfWhiteSpace(src, start);\n      var ch = src[offset];\n      return ch === '#' || ch === '\\n' ? offset : start;\n    }\n  }]);\n\n  return Document;\n}(Node);\n\nvar Alias = /*#__PURE__*/function (_Node) {\n  _inherits(Alias, _Node);\n\n  var _super = _createSuper(Alias);\n\n  function Alias() {\n    _classCallCheck(this, Alias);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(Alias, [{\n    key: \"parse\",\n    value:\n    /**\n     * Parses an *alias from the source\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this scalar\n     */\n    function parse(context, start) {\n      this.context = context;\n      var src = context.src;\n      var offset = Node.endOfIdentifier(src, start + 1);\n      this.valueRange = new Range(start + 1, offset);\n      offset = Node.endOfWhiteSpace(src, offset);\n      offset = this.parseComment(offset);\n      return offset;\n    }\n  }]);\n\n  return Alias;\n}(Node);\n\nvar Chomp = {\n  CLIP: 'CLIP',\n  KEEP: 'KEEP',\n  STRIP: 'STRIP'\n};\n\nvar BlockValue = /*#__PURE__*/function (_Node) {\n  _inherits(BlockValue, _Node);\n\n  var _super = _createSuper(BlockValue);\n\n  function BlockValue(type, props) {\n    var _this;\n\n    _classCallCheck(this, BlockValue);\n\n    _this = _super.call(this, type, props);\n    _this.blockIndent = null;\n    _this.chomping = Chomp.CLIP;\n    _this.header = null;\n    return _this;\n  }\n\n  _createClass(BlockValue, [{\n    key: \"includesTrailingLines\",\n    get: function get() {\n      return this.chomping === Chomp.KEEP;\n    }\n  }, {\n    key: \"strValue\",\n    get: function get() {\n      if (!this.valueRange || !this.context) return null;\n      var _this$valueRange = this.valueRange,\n          start = _this$valueRange.start,\n          end = _this$valueRange.end;\n      var _this$context = this.context,\n          indent = _this$context.indent,\n          src = _this$context.src;\n      if (this.valueRange.isEmpty()) return '';\n      var lastNewLine = null;\n      var ch = src[end - 1];\n\n      while (ch === '\\n' || ch === '\\t' || ch === ' ') {\n        end -= 1;\n\n        if (end <= start) {\n          if (this.chomping === Chomp.KEEP) break;else return ''; // probably never happens\n        }\n\n        if (ch === '\\n') lastNewLine = end;\n        ch = src[end - 1];\n      }\n\n      var keepStart = end + 1;\n\n      if (lastNewLine) {\n        if (this.chomping === Chomp.KEEP) {\n          keepStart = lastNewLine;\n          end = this.valueRange.end;\n        } else {\n          end = lastNewLine;\n        }\n      }\n\n      var bi = indent + this.blockIndent;\n      var folded = this.type === Type.BLOCK_FOLDED;\n      var atStart = true;\n      var str = '';\n      var sep = '';\n      var prevMoreIndented = false;\n\n      for (var i = start; i < end; ++i) {\n        for (var j = 0; j < bi; ++j) {\n          if (src[i] !== ' ') break;\n          i += 1;\n        }\n\n        var _ch = src[i];\n\n        if (_ch === '\\n') {\n          if (sep === '\\n') str += '\\n';else sep = '\\n';\n        } else {\n          var lineEnd = Node.endOfLine(src, i);\n          var line = src.slice(i, lineEnd);\n          i = lineEnd;\n\n          if (folded && (_ch === ' ' || _ch === '\\t') && i < keepStart) {\n            if (sep === ' ') sep = '\\n';else if (!prevMoreIndented && !atStart && sep === '\\n') sep = '\\n\\n';\n            str += sep + line; //+ ((lineEnd < end && src[lineEnd]) || '')\n\n            sep = lineEnd < end && src[lineEnd] || '';\n            prevMoreIndented = true;\n          } else {\n            str += sep + line;\n            sep = folded && i < keepStart ? ' ' : '\\n';\n            prevMoreIndented = false;\n          }\n\n          if (atStart && line !== '') atStart = false;\n        }\n      }\n\n      return this.chomping === Chomp.STRIP ? str : str + '\\n';\n    }\n  }, {\n    key: \"parseBlockHeader\",\n    value: function parseBlockHeader(start) {\n      var src = this.context.src;\n      var offset = start + 1;\n      var bi = '';\n\n      while (true) {\n        var ch = src[offset];\n\n        switch (ch) {\n          case '-':\n            this.chomping = Chomp.STRIP;\n            break;\n\n          case '+':\n            this.chomping = Chomp.KEEP;\n            break;\n\n          case '0':\n          case '1':\n          case '2':\n          case '3':\n          case '4':\n          case '5':\n          case '6':\n          case '7':\n          case '8':\n          case '9':\n            bi += ch;\n            break;\n\n          default:\n            this.blockIndent = Number(bi) || null;\n            this.header = new Range(start, offset);\n            return offset;\n        }\n\n        offset += 1;\n      }\n    }\n  }, {\n    key: \"parseBlockValue\",\n    value: function parseBlockValue(start) {\n      var _this$context2 = this.context,\n          indent = _this$context2.indent,\n          src = _this$context2.src;\n      var explicit = !!this.blockIndent;\n      var offset = start;\n      var valueEnd = start;\n      var minBlockIndent = 1;\n\n      for (var ch = src[offset]; ch === '\\n'; ch = src[offset]) {\n        offset += 1;\n        if (Node.atDocumentBoundary(src, offset)) break;\n        var end = Node.endOfBlockIndent(src, indent, offset); // should not include tab?\n\n        if (end === null) break;\n        var _ch2 = src[end];\n        var lineIndent = end - (offset + indent);\n\n        if (!this.blockIndent) {\n          // no explicit block indent, none yet detected\n          if (src[end] !== '\\n') {\n            // first line with non-whitespace content\n            if (lineIndent < minBlockIndent) {\n              var msg = 'Block scalars with more-indented leading empty lines must use an explicit indentation indicator';\n              this.error = new YAMLSemanticError(this, msg);\n            }\n\n            this.blockIndent = lineIndent;\n          } else if (lineIndent > minBlockIndent) {\n            // empty line with more whitespace\n            minBlockIndent = lineIndent;\n          }\n        } else if (_ch2 && _ch2 !== '\\n' && lineIndent < this.blockIndent) {\n          if (src[end] === '#') break;\n\n          if (!this.error) {\n            var _src = explicit ? 'explicit indentation indicator' : 'first line';\n\n            var _msg = \"Block scalars must not be less indented than their \".concat(_src);\n\n            this.error = new YAMLSemanticError(this, _msg);\n          }\n        }\n\n        if (src[end] === '\\n') {\n          offset = end;\n        } else {\n          offset = valueEnd = Node.endOfLine(src, end);\n        }\n      }\n\n      if (this.chomping !== Chomp.KEEP) {\n        offset = src[valueEnd] ? valueEnd + 1 : valueEnd;\n      }\n\n      this.valueRange = new Range(start + 1, offset);\n      return offset;\n    }\n    /**\n     * Parses a block value from the source\n     *\n     * Accepted forms are:\n     * ```\n     * BS\n     * block\n     * lines\n     *\n     * BS #comment\n     * block\n     * lines\n     * ```\n     * where the block style BS matches the regexp `[|>][-+1-9]*` and block lines\n     * are empty or have an indent level greater than `indent`.\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this block\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var src = context.src;\n      var offset = this.parseBlockHeader(start);\n      offset = Node.endOfWhiteSpace(src, offset);\n      offset = this.parseComment(offset);\n      offset = this.parseBlockValue(offset);\n      return offset;\n    }\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      offset = _get(_getPrototypeOf(BlockValue.prototype), \"setOrigRanges\", this).call(this, cr, offset);\n      return this.header ? this.header.setOrigRange(cr, offset) : offset;\n    }\n  }]);\n\n  return BlockValue;\n}(Node);\n\nvar FlowCollection = /*#__PURE__*/function (_Node) {\n  _inherits(FlowCollection, _Node);\n\n  var _super = _createSuper(FlowCollection);\n\n  function FlowCollection(type, props) {\n    var _this;\n\n    _classCallCheck(this, FlowCollection);\n\n    _this = _super.call(this, type, props);\n    _this.items = null;\n    return _this;\n  }\n\n  _createClass(FlowCollection, [{\n    key: \"prevNodeIsJsonLike\",\n    value: function prevNodeIsJsonLike() {\n      var idx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.items.length;\n      var node = this.items[idx - 1];\n      return !!node && (node.jsonLike || node.type === Type.COMMENT && this.prevNodeIsJsonLike(idx - 1));\n    }\n    /**\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var parseNode = context.parseNode,\n          src = context.src;\n      var indent = context.indent,\n          lineStart = context.lineStart;\n      var char = src[start]; // { or [\n\n      this.items = [{\n        char: char,\n        offset: start\n      }];\n      var offset = Node.endOfWhiteSpace(src, start + 1);\n      char = src[offset];\n\n      while (char && char !== ']' && char !== '}') {\n        switch (char) {\n          case '\\n':\n            {\n              lineStart = offset + 1;\n              var wsEnd = Node.endOfWhiteSpace(src, lineStart);\n\n              if (src[wsEnd] === '\\n') {\n                var blankLine = new BlankLine();\n                lineStart = blankLine.parse({\n                  src: src\n                }, lineStart);\n                this.items.push(blankLine);\n              }\n\n              offset = Node.endOfIndent(src, lineStart);\n\n              if (offset <= lineStart + indent) {\n                char = src[offset];\n\n                if (offset < lineStart + indent || char !== ']' && char !== '}') {\n                  var msg = 'Insufficient indentation in flow collection';\n                  this.error = new YAMLSemanticError(this, msg);\n                }\n              }\n            }\n            break;\n\n          case ',':\n            {\n              this.items.push({\n                char: char,\n                offset: offset\n              });\n              offset += 1;\n            }\n            break;\n\n          case '#':\n            {\n              var comment = new Comment();\n              offset = comment.parse({\n                src: src\n              }, offset);\n              this.items.push(comment);\n            }\n            break;\n\n          case '?':\n          case ':':\n            {\n              var next = src[offset + 1];\n\n              if (next === '\\n' || next === '\\t' || next === ' ' || next === ',' || // in-flow : after JSON-like key does not need to be followed by whitespace\n              char === ':' && this.prevNodeIsJsonLike()) {\n                this.items.push({\n                  char: char,\n                  offset: offset\n                });\n                offset += 1;\n                break;\n              }\n            }\n          // fallthrough\n\n          default:\n            {\n              var node = parseNode({\n                atLineStart: false,\n                inCollection: false,\n                inFlow: true,\n                indent: -1,\n                lineStart: lineStart,\n                parent: this\n              }, offset);\n\n              if (!node) {\n                // at next document start\n                this.valueRange = new Range(start, offset);\n                return offset;\n              }\n\n              this.items.push(node);\n              offset = Node.normalizeOffset(src, node.range.end);\n            }\n        }\n\n        offset = Node.endOfWhiteSpace(src, offset);\n        char = src[offset];\n      }\n\n      this.valueRange = new Range(start, offset + 1);\n\n      if (char) {\n        this.items.push({\n          char: char,\n          offset: offset\n        });\n        offset = Node.endOfWhiteSpace(src, offset + 1);\n        offset = this.parseComment(offset);\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      offset = _get(_getPrototypeOf(FlowCollection.prototype), \"setOrigRanges\", this).call(this, cr, offset);\n      this.items.forEach(function (node) {\n        if (node instanceof Node) {\n          offset = node.setOrigRanges(cr, offset);\n        } else if (cr.length === 0) {\n          node.origOffset = node.offset;\n        } else {\n          var i = offset;\n\n          while (i < cr.length) {\n            if (cr[i] > node.offset) break;else ++i;\n          }\n\n          node.origOffset = node.offset + i;\n          offset = i;\n        }\n      });\n      return offset;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var src = this.context.src,\n          items = this.items,\n          range = this.range,\n          value = this.value;\n      if (value != null) return value;\n      var nodes = items.filter(function (item) {\n        return item instanceof Node;\n      });\n      var str = '';\n      var prevEnd = range.start;\n      nodes.forEach(function (node) {\n        var prefix = src.slice(prevEnd, node.range.start);\n        prevEnd = node.range.end;\n        str += prefix + String(node);\n\n        if (str[str.length - 1] === '\\n' && src[prevEnd - 1] !== '\\n' && src[prevEnd] === '\\n') {\n          // Comment range does not include the terminal newline, but its\n          // stringified value does. Without this fix, newlines at comment ends\n          // get duplicated.\n          prevEnd += 1;\n        }\n      });\n      str += src.slice(prevEnd, range.end);\n      return Node.addStringTerminator(src, range.end, str);\n    }\n  }]);\n\n  return FlowCollection;\n}(Node);\n\nvar QuoteDouble = /*#__PURE__*/function (_Node) {\n  _inherits(QuoteDouble, _Node);\n\n  var _super = _createSuper(QuoteDouble);\n\n  function QuoteDouble() {\n    _classCallCheck(this, QuoteDouble);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(QuoteDouble, [{\n    key: \"strValue\",\n    get:\n    /**\n     * @returns {string | { str: string, errors: YAMLSyntaxError[] }}\n     */\n    function get() {\n      if (!this.valueRange || !this.context) return null;\n      var errors = [];\n      var _this$valueRange = this.valueRange,\n          start = _this$valueRange.start,\n          end = _this$valueRange.end;\n      var _this$context = this.context,\n          indent = _this$context.indent,\n          src = _this$context.src;\n      if (src[end - 1] !== '\"') errors.push(new YAMLSyntaxError(this, 'Missing closing \"quote')); // Using String#replace is too painful with escaped newlines preceded by\n      // escaped backslashes; also, this should be faster.\n\n      var str = '';\n\n      for (var i = start + 1; i < end - 1; ++i) {\n        var ch = src[i];\n\n        if (ch === '\\n') {\n          if (Node.atDocumentBoundary(src, i + 1)) errors.push(new YAMLSemanticError(this, 'Document boundary indicators are not allowed within string values'));\n\n          var _Node$foldNewline = Node.foldNewline(src, i, indent),\n              fold = _Node$foldNewline.fold,\n              offset = _Node$foldNewline.offset,\n              error = _Node$foldNewline.error;\n\n          str += fold;\n          i = offset;\n          if (error) errors.push(new YAMLSemanticError(this, 'Multi-line double-quoted string needs to be sufficiently indented'));\n        } else if (ch === '\\\\') {\n          i += 1;\n\n          switch (src[i]) {\n            case '0':\n              str += '\\0';\n              break;\n            // null character\n\n            case 'a':\n              str += '\\x07';\n              break;\n            // bell character\n\n            case 'b':\n              str += '\\b';\n              break;\n            // backspace\n\n            case 'e':\n              str += '\\x1b';\n              break;\n            // escape character\n\n            case 'f':\n              str += '\\f';\n              break;\n            // form feed\n\n            case 'n':\n              str += '\\n';\n              break;\n            // line feed\n\n            case 'r':\n              str += '\\r';\n              break;\n            // carriage return\n\n            case 't':\n              str += '\\t';\n              break;\n            // horizontal tab\n\n            case 'v':\n              str += '\\v';\n              break;\n            // vertical tab\n\n            case 'N':\n              str += \"\\x85\";\n              break;\n            // Unicode next line\n\n            case '_':\n              str += \"\\xA0\";\n              break;\n            // Unicode non-breaking space\n\n            case 'L':\n              str += \"\\u2028\";\n              break;\n            // Unicode line separator\n\n            case 'P':\n              str += \"\\u2029\";\n              break;\n            // Unicode paragraph separator\n\n            case ' ':\n              str += ' ';\n              break;\n\n            case '\"':\n              str += '\"';\n              break;\n\n            case '/':\n              str += '/';\n              break;\n\n            case '\\\\':\n              str += '\\\\';\n              break;\n\n            case '\\t':\n              str += '\\t';\n              break;\n\n            case 'x':\n              str += this.parseCharCode(i + 1, 2, errors);\n              i += 2;\n              break;\n\n            case 'u':\n              str += this.parseCharCode(i + 1, 4, errors);\n              i += 4;\n              break;\n\n            case 'U':\n              str += this.parseCharCode(i + 1, 8, errors);\n              i += 8;\n              break;\n\n            case '\\n':\n              // skip escaped newlines, but still trim the following line\n              while (src[i + 1] === ' ' || src[i + 1] === '\\t') {\n                i += 1;\n              }\n\n              break;\n\n            default:\n              errors.push(new YAMLSyntaxError(this, \"Invalid escape sequence \".concat(src.substr(i - 1, 2))));\n              str += '\\\\' + src[i];\n          }\n        } else if (ch === ' ' || ch === '\\t') {\n          // trim trailing whitespace\n          var wsStart = i;\n          var next = src[i + 1];\n\n          while (next === ' ' || next === '\\t') {\n            i += 1;\n            next = src[i + 1];\n          }\n\n          if (next !== '\\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;\n        } else {\n          str += ch;\n        }\n      }\n\n      return errors.length > 0 ? {\n        errors: errors,\n        str: str\n      } : str;\n    }\n  }, {\n    key: \"parseCharCode\",\n    value: function parseCharCode(offset, length, errors) {\n      var src = this.context.src;\n      var cc = src.substr(offset, length);\n      var ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);\n      var code = ok ? parseInt(cc, 16) : NaN;\n\n      if (isNaN(code)) {\n        errors.push(new YAMLSyntaxError(this, \"Invalid escape sequence \".concat(src.substr(offset - 2, length + 2))));\n        return src.substr(offset - 2, length + 2);\n      }\n\n      return String.fromCodePoint(code);\n    }\n    /**\n     * Parses a \"double quoted\" value from the source\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this scalar\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var src = context.src;\n      var offset = QuoteDouble.endOfQuote(src, start + 1);\n      this.valueRange = new Range(start, offset);\n      offset = Node.endOfWhiteSpace(src, offset);\n      offset = this.parseComment(offset);\n      return offset;\n    }\n  }], [{\n    key: \"endOfQuote\",\n    value: function endOfQuote(src, offset) {\n      var ch = src[offset];\n\n      while (ch && ch !== '\"') {\n        offset += ch === '\\\\' ? 2 : 1;\n        ch = src[offset];\n      }\n\n      return offset + 1;\n    }\n  }]);\n\n  return QuoteDouble;\n}(Node);\n\nvar QuoteSingle = /*#__PURE__*/function (_Node) {\n  _inherits(QuoteSingle, _Node);\n\n  var _super = _createSuper(QuoteSingle);\n\n  function QuoteSingle() {\n    _classCallCheck(this, QuoteSingle);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(QuoteSingle, [{\n    key: \"strValue\",\n    get:\n    /**\n     * @returns {string | { str: string, errors: YAMLSyntaxError[] }}\n     */\n    function get() {\n      if (!this.valueRange || !this.context) return null;\n      var errors = [];\n      var _this$valueRange = this.valueRange,\n          start = _this$valueRange.start,\n          end = _this$valueRange.end;\n      var _this$context = this.context,\n          indent = _this$context.indent,\n          src = _this$context.src;\n      if (src[end - 1] !== \"'\") errors.push(new YAMLSyntaxError(this, \"Missing closing 'quote\"));\n      var str = '';\n\n      for (var i = start + 1; i < end - 1; ++i) {\n        var ch = src[i];\n\n        if (ch === '\\n') {\n          if (Node.atDocumentBoundary(src, i + 1)) errors.push(new YAMLSemanticError(this, 'Document boundary indicators are not allowed within string values'));\n\n          var _Node$foldNewline = Node.foldNewline(src, i, indent),\n              fold = _Node$foldNewline.fold,\n              offset = _Node$foldNewline.offset,\n              error = _Node$foldNewline.error;\n\n          str += fold;\n          i = offset;\n          if (error) errors.push(new YAMLSemanticError(this, 'Multi-line single-quoted string needs to be sufficiently indented'));\n        } else if (ch === \"'\") {\n          str += ch;\n          i += 1;\n          if (src[i] !== \"'\") errors.push(new YAMLSyntaxError(this, 'Unescaped single quote? This should not happen.'));\n        } else if (ch === ' ' || ch === '\\t') {\n          // trim trailing whitespace\n          var wsStart = i;\n          var next = src[i + 1];\n\n          while (next === ' ' || next === '\\t') {\n            i += 1;\n            next = src[i + 1];\n          }\n\n          if (next !== '\\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;\n        } else {\n          str += ch;\n        }\n      }\n\n      return errors.length > 0 ? {\n        errors: errors,\n        str: str\n      } : str;\n    }\n    /**\n     * Parses a 'single quoted' value from the source\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this scalar\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var src = context.src;\n      var offset = QuoteSingle.endOfQuote(src, start + 1);\n      this.valueRange = new Range(start, offset);\n      offset = Node.endOfWhiteSpace(src, offset);\n      offset = this.parseComment(offset);\n      return offset;\n    }\n  }], [{\n    key: \"endOfQuote\",\n    value: function endOfQuote(src, offset) {\n      var ch = src[offset];\n\n      while (ch) {\n        if (ch === \"'\") {\n          if (src[offset + 1] !== \"'\") break;\n          ch = src[offset += 2];\n        } else {\n          ch = src[offset += 1];\n        }\n      }\n\n      return offset + 1;\n    }\n  }]);\n\n  return QuoteSingle;\n}(Node);\n\nfunction createNewNode(type, props) {\n  switch (type) {\n    case Type.ALIAS:\n      return new Alias(type, props);\n\n    case Type.BLOCK_FOLDED:\n    case Type.BLOCK_LITERAL:\n      return new BlockValue(type, props);\n\n    case Type.FLOW_MAP:\n    case Type.FLOW_SEQ:\n      return new FlowCollection(type, props);\n\n    case Type.MAP_KEY:\n    case Type.MAP_VALUE:\n    case Type.SEQ_ITEM:\n      return new CollectionItem(type, props);\n\n    case Type.COMMENT:\n    case Type.PLAIN:\n      return new PlainValue(type, props);\n\n    case Type.QUOTE_DOUBLE:\n      return new QuoteDouble(type, props);\n\n    case Type.QUOTE_SINGLE:\n      return new QuoteSingle(type, props);\n\n    /* istanbul ignore next */\n\n    default:\n      return null;\n    // should never happen\n  }\n}\n/**\n * @param {boolean} atLineStart - Node starts at beginning of line\n * @param {boolean} inFlow - true if currently in a flow context\n * @param {boolean} inCollection - true if currently in a collection context\n * @param {number} indent - Current level of indentation\n * @param {number} lineStart - Start of the current line\n * @param {Node} parent - The parent of the node\n * @param {string} src - Source of the YAML document\n */\n\n\nvar ParseContext = /*#__PURE__*/function () {\n  function ParseContext() {\n    var _this = this;\n\n    var orig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        atLineStart = _ref.atLineStart,\n        inCollection = _ref.inCollection,\n        inFlow = _ref.inFlow,\n        indent = _ref.indent,\n        lineStart = _ref.lineStart,\n        parent = _ref.parent;\n\n    _classCallCheck(this, ParseContext);\n\n    _defineProperty(this, \"parseNode\", function (overlay, start) {\n      if (Node.atDocumentBoundary(_this.src, start)) return null;\n      var context = new ParseContext(_this, overlay);\n\n      var _context$parseProps = context.parseProps(start),\n          props = _context$parseProps.props,\n          type = _context$parseProps.type,\n          valueStart = _context$parseProps.valueStart;\n\n      var node = createNewNode(type, props);\n      var offset = node.parse(context, valueStart);\n      node.range = new Range(start, offset);\n      /* istanbul ignore if */\n\n      if (offset <= start) {\n        // This should never happen, but if it does, let's make sure to at least\n        // step one character forward to avoid a busy loop.\n        node.error = new Error(\"Node#parse consumed no characters\");\n        node.error.parseEnd = offset;\n        node.error.source = node;\n        node.range.end = start + 1;\n      }\n\n      if (context.nodeStartsCollection(node)) {\n        if (!node.error && !context.atLineStart && context.parent.type === Type.DOCUMENT) {\n          node.error = new YAMLSyntaxError(node, 'Block collection must not have preceding content here (e.g. directives-end indicator)');\n        }\n\n        var collection = new Collection(node);\n        offset = collection.parse(new ParseContext(context), offset);\n        collection.range = new Range(start, offset);\n        return collection;\n      }\n\n      return node;\n    });\n\n    this.atLineStart = atLineStart != null ? atLineStart : orig.atLineStart || false;\n    this.inCollection = inCollection != null ? inCollection : orig.inCollection || false;\n    this.inFlow = inFlow != null ? inFlow : orig.inFlow || false;\n    this.indent = indent != null ? indent : orig.indent;\n    this.lineStart = lineStart != null ? lineStart : orig.lineStart;\n    this.parent = parent != null ? parent : orig.parent || {};\n    this.root = orig.root;\n    this.src = orig.src;\n  }\n\n  _createClass(ParseContext, [{\n    key: \"nodeStartsCollection\",\n    value: function nodeStartsCollection(node) {\n      var inCollection = this.inCollection,\n          inFlow = this.inFlow,\n          src = this.src;\n      if (inCollection || inFlow) return false;\n      if (node instanceof CollectionItem) return true; // check for implicit key\n\n      var offset = node.range.end;\n      if (src[offset] === '\\n' || src[offset - 1] === '\\n') return false;\n      offset = Node.endOfWhiteSpace(src, offset);\n      return src[offset] === ':';\n    } // Anchor and tag are before type, which determines the node implementation\n    // class; hence this intermediate step.\n\n  }, {\n    key: \"parseProps\",\n    value: function parseProps(offset) {\n      var inFlow = this.inFlow,\n          parent = this.parent,\n          src = this.src;\n      var props = [];\n      var lineHasProps = false;\n      offset = this.atLineStart ? Node.endOfIndent(src, offset) : Node.endOfWhiteSpace(src, offset);\n      var ch = src[offset];\n\n      while (ch === Char.ANCHOR || ch === Char.COMMENT || ch === Char.TAG || ch === '\\n') {\n        if (ch === '\\n') {\n          var inEnd = offset;\n          var lineStart = void 0;\n\n          do {\n            lineStart = inEnd + 1;\n            inEnd = Node.endOfIndent(src, lineStart);\n          } while (src[inEnd] === '\\n');\n\n          var indentDiff = inEnd - (lineStart + this.indent);\n          var noIndicatorAsIndent = parent.type === Type.SEQ_ITEM && parent.context.atLineStart;\n          if (src[inEnd] !== '#' && !Node.nextNodeIsIndented(src[inEnd], indentDiff, !noIndicatorAsIndent)) break;\n          this.atLineStart = true;\n          this.lineStart = lineStart;\n          lineHasProps = false;\n          offset = inEnd;\n        } else if (ch === Char.COMMENT) {\n          var end = Node.endOfLine(src, offset + 1);\n          props.push(new Range(offset, end));\n          offset = end;\n        } else {\n          var _end = Node.endOfIdentifier(src, offset + 1);\n\n          if (ch === Char.TAG && src[_end] === ',' && /^[a-zA-Z0-9-]+\\.[a-zA-Z0-9-]+,\\d\\d\\d\\d(-\\d\\d){0,2}\\/\\S/.test(src.slice(offset + 1, _end + 13))) {\n            // Let's presume we're dealing with a YAML 1.0 domain tag here, rather\n            // than an empty but 'foo.bar' private-tagged node in a flow collection\n            // followed without whitespace by a plain string starting with a year\n            // or date divided by something.\n            _end = Node.endOfIdentifier(src, _end + 5);\n          }\n\n          props.push(new Range(offset, _end));\n          lineHasProps = true;\n          offset = Node.endOfWhiteSpace(src, _end);\n        }\n\n        ch = src[offset];\n      } // '- &a : b' has an anchor on an empty node\n\n\n      if (lineHasProps && ch === ':' && Node.atBlank(src, offset + 1, true)) offset -= 1;\n      var type = ParseContext.parseType(src, offset, inFlow);\n      return {\n        props: props,\n        type: type,\n        valueStart: offset\n      };\n    }\n    /**\n     * Parses a node from the source\n     * @param {ParseContext} overlay\n     * @param {number} start - Index of first non-whitespace character for the node\n     * @returns {?Node} - null if at a document boundary\n     */\n\n  }], [{\n    key: \"parseType\",\n    value: function parseType(src, offset, inFlow) {\n      switch (src[offset]) {\n        case '*':\n          return Type.ALIAS;\n\n        case '>':\n          return Type.BLOCK_FOLDED;\n\n        case '|':\n          return Type.BLOCK_LITERAL;\n\n        case '{':\n          return Type.FLOW_MAP;\n\n        case '[':\n          return Type.FLOW_SEQ;\n\n        case '?':\n          return !inFlow && Node.atBlank(src, offset + 1, true) ? Type.MAP_KEY : Type.PLAIN;\n\n        case ':':\n          return !inFlow && Node.atBlank(src, offset + 1, true) ? Type.MAP_VALUE : Type.PLAIN;\n\n        case '-':\n          return !inFlow && Node.atBlank(src, offset + 1, true) ? Type.SEQ_ITEM : Type.PLAIN;\n\n        case '\"':\n          return Type.QUOTE_DOUBLE;\n\n        case \"'\":\n          return Type.QUOTE_SINGLE;\n\n        default:\n          return Type.PLAIN;\n      }\n    }\n  }]);\n\n  return ParseContext;\n}(); // Published as 'yaml/parse-cst'\n\n\nfunction parse(src) {\n  var cr = [];\n\n  if (src.indexOf('\\r') !== -1) {\n    src = src.replace(/\\r\\n?/g, function (match, offset) {\n      if (match.length > 1) cr.push(offset);\n      return '\\n';\n    });\n  }\n\n  var documents = [];\n  var offset = 0;\n\n  do {\n    var doc = new Document();\n    var context = new ParseContext({\n      src: src\n    });\n    offset = doc.parse(context, offset);\n    documents.push(doc);\n  } while (offset < src.length);\n\n  documents.setOrigRanges = function () {\n    if (cr.length === 0) return false;\n\n    for (var i = 1; i < cr.length; ++i) {\n      cr[i] -= i;\n    }\n\n    var crOffset = 0;\n\n    for (var _i = 0; _i < documents.length; ++_i) {\n      crOffset = documents[_i].setOrigRanges(cr, crOffset);\n    }\n\n    cr.splice(0, cr.length);\n    return true;\n  };\n\n  documents.toString = function () {\n    return documents.join('...\\n');\n  };\n\n  return documents;\n}\n\nexport { parse };","map":{"version":3,"sources":["/home/dev/Documentos/Projects/github-clone/node_modules/yaml/browser/dist/parse-cst.js"],"names":["j","_inherits","k","_createSuper","c","_classCallCheck","T","Type","b","_createClass","R","Range","N","Node","g","YAMLSemanticError","l","_get","m","_getPrototypeOf","Y","YAMLSyntaxError","C","Char","e","_defineProperty","P","PlainValue","BlankLine","_Node","_super","call","BLANK_LINE","key","get","value","parse","context","start","range","CollectionItem","type","props","_this","node","includesTrailingLines","parseNode","src","atLineStart","lineStart","SEQ_ITEM","error","indent","offset","endOfWhiteSpace","ch","inlineComment","comments","blankLine","_end","endOfLine","push","wsEnd","length","endOfIndent","nextNodeIsIndented","inCollection","parent","items","contents","Array","prototype","apply","end","valueRange","setOrigRanges","cr","toString","str","slice","String","addStringTerminator","Comment","COMMENT","parseComment","grabCollectionEndComments","cnode","Collection","len","ci","i","n","_n$context","ca","splice","prevEnd","firstItem","SEQ","MAP","itemRange","ec","startOfLine","copy","normalizeOffset","prevIncludesTrailingLines","nextContentHasIndent","comment","atBlank","next","msg","_next","_msg","ls","prev","forEach","item","_item$context","_i","Directive","DIRECTIVE","name","raw","rawValue","trim","split","parseName","parseParameters","Document","DOCUMENT","directives","directivesEndMarker","documentEndMarker","parseDirectives","hasDirectives","atDocumentBoundary","DIRECTIVES_END","startCommentOrEndBlankLine","directive","parseContents","_this$context","DOCUMENT_END","iEnd","inFlow","_comment","undefined","root","charCodeAt","setOrigRange","join","Alias","arguments","endOfIdentifier","Chomp","CLIP","KEEP","STRIP","BlockValue","blockIndent","chomping","header","_this$valueRange","isEmpty","lastNewLine","keepStart","bi","folded","BLOCK_FOLDED","atStart","sep","prevMoreIndented","_ch","lineEnd","line","parseBlockHeader","Number","parseBlockValue","_this$context2","explicit","valueEnd","minBlockIndent","endOfBlockIndent","_ch2","lineIndent","_src","concat","FlowCollection","prevNodeIsJsonLike","idx","jsonLike","char","origOffset","nodes","filter","prefix","QuoteDouble","errors","_Node$foldNewline","foldNewline","fold","parseCharCode","substr","wsStart","cc","ok","test","code","parseInt","NaN","isNaN","fromCodePoint","endOfQuote","QuoteSingle","createNewNode","ALIAS","BLOCK_LITERAL","FLOW_MAP","FLOW_SEQ","MAP_KEY","MAP_VALUE","PLAIN","QUOTE_DOUBLE","QUOTE_SINGLE","ParseContext","orig","_ref","overlay","_context$parseProps","parseProps","valueStart","Error","parseEnd","source","nodeStartsCollection","collection","lineHasProps","ANCHOR","TAG","inEnd","indentDiff","noIndicatorAsIndent","parseType","indexOf","replace","match","documents","doc","crOffset"],"mappings":"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","sourcesContent":["import { j as _inherits, k as _createSuper, c as _classCallCheck, T as Type, b as _createClass, R as Range, N as Node, g as YAMLSemanticError, l as _get, m as _getPrototypeOf, Y as YAMLSyntaxError, C as Char, e as _defineProperty, P as PlainValue } from './PlainValue-b8036b75.js';\n\nvar BlankLine = /*#__PURE__*/function (_Node) {\n  _inherits(BlankLine, _Node);\n\n  var _super = _createSuper(BlankLine);\n\n  function BlankLine() {\n    _classCallCheck(this, BlankLine);\n\n    return _super.call(this, Type.BLANK_LINE);\n  }\n  /* istanbul ignore next */\n\n\n  _createClass(BlankLine, [{\n    key: \"includesTrailingLines\",\n    get: function get() {\n      // This is never called from anywhere, but if it were,\n      // this is the value it should return.\n      return true;\n    }\n    /**\n     * Parses a blank line from the source\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first \\n character\n     * @returns {number} - Index of the character after this\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      this.range = new Range(start, start + 1);\n      return start + 1;\n    }\n  }]);\n\n  return BlankLine;\n}(Node);\n\nvar CollectionItem = /*#__PURE__*/function (_Node) {\n  _inherits(CollectionItem, _Node);\n\n  var _super = _createSuper(CollectionItem);\n\n  function CollectionItem(type, props) {\n    var _this;\n\n    _classCallCheck(this, CollectionItem);\n\n    _this = _super.call(this, type, props);\n    _this.node = null;\n    return _this;\n  }\n\n  _createClass(CollectionItem, [{\n    key: \"includesTrailingLines\",\n    get: function get() {\n      return !!this.node && this.node.includesTrailingLines;\n    }\n    /**\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var parseNode = context.parseNode,\n          src = context.src;\n      var atLineStart = context.atLineStart,\n          lineStart = context.lineStart;\n      if (!atLineStart && this.type === Type.SEQ_ITEM) this.error = new YAMLSemanticError(this, 'Sequence items must not have preceding content on the same line');\n      var indent = atLineStart ? start - lineStart : context.indent;\n      var offset = Node.endOfWhiteSpace(src, start + 1);\n      var ch = src[offset];\n      var inlineComment = ch === '#';\n      var comments = [];\n      var blankLine = null;\n\n      while (ch === '\\n' || ch === '#') {\n        if (ch === '#') {\n          var _end = Node.endOfLine(src, offset + 1);\n\n          comments.push(new Range(offset, _end));\n          offset = _end;\n        } else {\n          atLineStart = true;\n          lineStart = offset + 1;\n          var wsEnd = Node.endOfWhiteSpace(src, lineStart);\n\n          if (src[wsEnd] === '\\n' && comments.length === 0) {\n            blankLine = new BlankLine();\n            lineStart = blankLine.parse({\n              src: src\n            }, lineStart);\n          }\n\n          offset = Node.endOfIndent(src, lineStart);\n        }\n\n        ch = src[offset];\n      }\n\n      if (Node.nextNodeIsIndented(ch, offset - (lineStart + indent), this.type !== Type.SEQ_ITEM)) {\n        this.node = parseNode({\n          atLineStart: atLineStart,\n          inCollection: false,\n          indent: indent,\n          lineStart: lineStart,\n          parent: this\n        }, offset);\n      } else if (ch && lineStart > start + 1) {\n        offset = lineStart - 1;\n      }\n\n      if (this.node) {\n        if (blankLine) {\n          // Only blank lines preceding non-empty nodes are captured. Note that\n          // this means that collection item range start indices do not always\n          // increase monotonically. -- eemeli/yaml#126\n          var items = context.parent.items || context.parent.contents;\n          if (items) items.push(blankLine);\n        }\n\n        if (comments.length) Array.prototype.push.apply(this.props, comments);\n        offset = this.node.range.end;\n      } else {\n        if (inlineComment) {\n          var c = comments[0];\n          this.props.push(c);\n          offset = c.end;\n        } else {\n          offset = Node.endOfLine(src, start + 1);\n        }\n      }\n\n      var end = this.node ? this.node.valueRange.end : offset;\n      this.valueRange = new Range(start, end);\n      return offset;\n    }\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      offset = _get(_getPrototypeOf(CollectionItem.prototype), \"setOrigRanges\", this).call(this, cr, offset);\n      return this.node ? this.node.setOrigRanges(cr, offset) : offset;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var src = this.context.src,\n          node = this.node,\n          range = this.range,\n          value = this.value;\n      if (value != null) return value;\n      var str = node ? src.slice(range.start, node.range.start) + String(node) : src.slice(range.start, range.end);\n      return Node.addStringTerminator(src, range.end, str);\n    }\n  }]);\n\n  return CollectionItem;\n}(Node);\n\nvar Comment = /*#__PURE__*/function (_Node) {\n  _inherits(Comment, _Node);\n\n  var _super = _createSuper(Comment);\n\n  function Comment() {\n    _classCallCheck(this, Comment);\n\n    return _super.call(this, Type.COMMENT);\n  }\n  /**\n   * Parses a comment line from the source\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this scalar\n   */\n\n\n  _createClass(Comment, [{\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var offset = this.parseComment(start);\n      this.range = new Range(start, offset);\n      return offset;\n    }\n  }]);\n\n  return Comment;\n}(Node);\n\nfunction grabCollectionEndComments(node) {\n  var cnode = node;\n\n  while (cnode instanceof CollectionItem) {\n    cnode = cnode.node;\n  }\n\n  if (!(cnode instanceof Collection)) return null;\n  var len = cnode.items.length;\n  var ci = -1;\n\n  for (var i = len - 1; i >= 0; --i) {\n    var n = cnode.items[i];\n\n    if (n.type === Type.COMMENT) {\n      // Keep sufficiently indented comments with preceding node\n      var _n$context = n.context,\n          indent = _n$context.indent,\n          lineStart = _n$context.lineStart;\n      if (indent > 0 && n.range.start >= lineStart + indent) break;\n      ci = i;\n    } else if (n.type === Type.BLANK_LINE) ci = i;else break;\n  }\n\n  if (ci === -1) return null;\n  var ca = cnode.items.splice(ci, len - ci);\n  var prevEnd = ca[0].range.start;\n\n  while (true) {\n    cnode.range.end = prevEnd;\n    if (cnode.valueRange && cnode.valueRange.end > prevEnd) cnode.valueRange.end = prevEnd;\n    if (cnode === node) break;\n    cnode = cnode.context.parent;\n  }\n\n  return ca;\n}\nvar Collection = /*#__PURE__*/function (_Node) {\n  _inherits(Collection, _Node);\n\n  var _super = _createSuper(Collection);\n\n  function Collection(firstItem) {\n    var _this;\n\n    _classCallCheck(this, Collection);\n\n    _this = _super.call(this, firstItem.type === Type.SEQ_ITEM ? Type.SEQ : Type.MAP);\n\n    for (var i = firstItem.props.length - 1; i >= 0; --i) {\n      if (firstItem.props[i].start < firstItem.context.lineStart) {\n        // props on previous line are assumed by the collection\n        _this.props = firstItem.props.slice(0, i + 1);\n        firstItem.props = firstItem.props.slice(i + 1);\n        var itemRange = firstItem.props[0] || firstItem.valueRange;\n        firstItem.range.start = itemRange.start;\n        break;\n      }\n    }\n\n    _this.items = [firstItem];\n    var ec = grabCollectionEndComments(firstItem);\n    if (ec) Array.prototype.push.apply(_this.items, ec);\n    return _this;\n  }\n\n  _createClass(Collection, [{\n    key: \"includesTrailingLines\",\n    get: function get() {\n      return this.items.length > 0;\n    }\n    /**\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var parseNode = context.parseNode,\n          src = context.src; // It's easier to recalculate lineStart here rather than tracking down the\n      // last context from which to read it -- eemeli/yaml#2\n\n      var lineStart = Node.startOfLine(src, start);\n      var firstItem = this.items[0]; // First-item context needs to be correct for later comment handling\n      // -- eemeli/yaml#17\n\n      firstItem.context.parent = this;\n      this.valueRange = Range.copy(firstItem.valueRange);\n      var indent = firstItem.range.start - firstItem.context.lineStart;\n      var offset = start;\n      offset = Node.normalizeOffset(src, offset);\n      var ch = src[offset];\n      var atLineStart = Node.endOfWhiteSpace(src, lineStart) === offset;\n      var prevIncludesTrailingLines = false;\n\n      while (ch) {\n        while (ch === '\\n' || ch === '#') {\n          if (atLineStart && ch === '\\n' && !prevIncludesTrailingLines) {\n            var blankLine = new BlankLine();\n            offset = blankLine.parse({\n              src: src\n            }, offset);\n            this.valueRange.end = offset;\n\n            if (offset >= src.length) {\n              ch = null;\n              break;\n            }\n\n            this.items.push(blankLine);\n            offset -= 1; // blankLine.parse() consumes terminal newline\n          } else if (ch === '#') {\n            if (offset < lineStart + indent && !Collection.nextContentHasIndent(src, offset, indent)) {\n              return offset;\n            }\n\n            var comment = new Comment();\n            offset = comment.parse({\n              indent: indent,\n              lineStart: lineStart,\n              src: src\n            }, offset);\n            this.items.push(comment);\n            this.valueRange.end = offset;\n\n            if (offset >= src.length) {\n              ch = null;\n              break;\n            }\n          }\n\n          lineStart = offset + 1;\n          offset = Node.endOfIndent(src, lineStart);\n\n          if (Node.atBlank(src, offset)) {\n            var wsEnd = Node.endOfWhiteSpace(src, offset);\n            var next = src[wsEnd];\n\n            if (!next || next === '\\n' || next === '#') {\n              offset = wsEnd;\n            }\n          }\n\n          ch = src[offset];\n          atLineStart = true;\n        }\n\n        if (!ch) {\n          break;\n        }\n\n        if (offset !== lineStart + indent && (atLineStart || ch !== ':')) {\n          if (offset < lineStart + indent) {\n            if (lineStart > start) offset = lineStart;\n            break;\n          } else if (!this.error) {\n            var msg = 'All collection items must start at the same column';\n            this.error = new YAMLSyntaxError(this, msg);\n          }\n        }\n\n        if (firstItem.type === Type.SEQ_ITEM) {\n          if (ch !== '-') {\n            if (lineStart > start) offset = lineStart;\n            break;\n          }\n        } else if (ch === '-' && !this.error) {\n          // map key may start with -, as long as it's followed by a non-whitespace char\n          var _next = src[offset + 1];\n\n          if (!_next || _next === '\\n' || _next === '\\t' || _next === ' ') {\n            var _msg = 'A collection cannot be both a mapping and a sequence';\n            this.error = new YAMLSyntaxError(this, _msg);\n          }\n        }\n\n        var node = parseNode({\n          atLineStart: atLineStart,\n          inCollection: true,\n          indent: indent,\n          lineStart: lineStart,\n          parent: this\n        }, offset);\n        if (!node) return offset; // at next document start\n\n        this.items.push(node);\n        this.valueRange.end = node.valueRange.end;\n        offset = Node.normalizeOffset(src, node.range.end);\n        ch = src[offset];\n        atLineStart = false;\n        prevIncludesTrailingLines = node.includesTrailingLines; // Need to reset lineStart and atLineStart here if preceding node's range\n        // has advanced to check the current line's indentation level\n        // -- eemeli/yaml#10 & eemeli/yaml#38\n\n        if (ch) {\n          var ls = offset - 1;\n          var prev = src[ls];\n\n          while (prev === ' ' || prev === '\\t') {\n            prev = src[--ls];\n          }\n\n          if (prev === '\\n') {\n            lineStart = ls + 1;\n            atLineStart = true;\n          }\n        }\n\n        var ec = grabCollectionEndComments(node);\n        if (ec) Array.prototype.push.apply(this.items, ec);\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      offset = _get(_getPrototypeOf(Collection.prototype), \"setOrigRanges\", this).call(this, cr, offset);\n      this.items.forEach(function (node) {\n        offset = node.setOrigRanges(cr, offset);\n      });\n      return offset;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var src = this.context.src,\n          items = this.items,\n          range = this.range,\n          value = this.value;\n      if (value != null) return value;\n      var str = src.slice(range.start, items[0].range.start) + String(items[0]);\n\n      for (var i = 1; i < items.length; ++i) {\n        var item = items[i];\n        var _item$context = item.context,\n            atLineStart = _item$context.atLineStart,\n            indent = _item$context.indent;\n        if (atLineStart) for (var _i = 0; _i < indent; ++_i) {\n          str += ' ';\n        }\n        str += String(item);\n      }\n\n      return Node.addStringTerminator(src, range.end, str);\n    }\n  }], [{\n    key: \"nextContentHasIndent\",\n    value: function nextContentHasIndent(src, offset, indent) {\n      var lineStart = Node.endOfLine(src, offset) + 1;\n      offset = Node.endOfWhiteSpace(src, lineStart);\n      var ch = src[offset];\n      if (!ch) return false;\n      if (offset >= lineStart + indent) return true;\n      if (ch !== '#' && ch !== '\\n') return false;\n      return Collection.nextContentHasIndent(src, offset, indent);\n    }\n  }]);\n\n  return Collection;\n}(Node);\n\nvar Directive = /*#__PURE__*/function (_Node) {\n  _inherits(Directive, _Node);\n\n  var _super = _createSuper(Directive);\n\n  function Directive() {\n    var _this;\n\n    _classCallCheck(this, Directive);\n\n    _this = _super.call(this, Type.DIRECTIVE);\n    _this.name = null;\n    return _this;\n  }\n\n  _createClass(Directive, [{\n    key: \"parameters\",\n    get: function get() {\n      var raw = this.rawValue;\n      return raw ? raw.trim().split(/[ \\t]+/) : [];\n    }\n  }, {\n    key: \"parseName\",\n    value: function parseName(start) {\n      var src = this.context.src;\n      var offset = start;\n      var ch = src[offset];\n\n      while (ch && ch !== '\\n' && ch !== '\\t' && ch !== ' ') {\n        ch = src[offset += 1];\n      }\n\n      this.name = src.slice(start, offset);\n      return offset;\n    }\n  }, {\n    key: \"parseParameters\",\n    value: function parseParameters(start) {\n      var src = this.context.src;\n      var offset = start;\n      var ch = src[offset];\n\n      while (ch && ch !== '\\n' && ch !== '#') {\n        ch = src[offset += 1];\n      }\n\n      this.valueRange = new Range(start, offset);\n      return offset;\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var offset = this.parseName(start + 1);\n      offset = this.parseParameters(offset);\n      offset = this.parseComment(offset);\n      this.range = new Range(start, offset);\n      return offset;\n    }\n  }]);\n\n  return Directive;\n}(Node);\n\nvar Document = /*#__PURE__*/function (_Node) {\n  _inherits(Document, _Node);\n\n  var _super = _createSuper(Document);\n\n  function Document() {\n    var _this;\n\n    _classCallCheck(this, Document);\n\n    _this = _super.call(this, Type.DOCUMENT);\n    _this.directives = null;\n    _this.contents = null;\n    _this.directivesEndMarker = null;\n    _this.documentEndMarker = null;\n    return _this;\n  }\n\n  _createClass(Document, [{\n    key: \"parseDirectives\",\n    value: function parseDirectives(start) {\n      var src = this.context.src;\n      this.directives = [];\n      var atLineStart = true;\n      var hasDirectives = false;\n      var offset = start;\n\n      while (!Node.atDocumentBoundary(src, offset, Char.DIRECTIVES_END)) {\n        offset = Document.startCommentOrEndBlankLine(src, offset);\n\n        switch (src[offset]) {\n          case '\\n':\n            if (atLineStart) {\n              var blankLine = new BlankLine();\n              offset = blankLine.parse({\n                src: src\n              }, offset);\n\n              if (offset < src.length) {\n                this.directives.push(blankLine);\n              }\n            } else {\n              offset += 1;\n              atLineStart = true;\n            }\n\n            break;\n\n          case '#':\n            {\n              var comment = new Comment();\n              offset = comment.parse({\n                src: src\n              }, offset);\n              this.directives.push(comment);\n              atLineStart = false;\n            }\n            break;\n\n          case '%':\n            {\n              var directive = new Directive();\n              offset = directive.parse({\n                parent: this,\n                src: src\n              }, offset);\n              this.directives.push(directive);\n              hasDirectives = true;\n              atLineStart = false;\n            }\n            break;\n\n          default:\n            if (hasDirectives) {\n              this.error = new YAMLSemanticError(this, 'Missing directives-end indicator line');\n            } else if (this.directives.length > 0) {\n              this.contents = this.directives;\n              this.directives = [];\n            }\n\n            return offset;\n        }\n      }\n\n      if (src[offset]) {\n        this.directivesEndMarker = new Range(offset, offset + 3);\n        return offset + 3;\n      }\n\n      if (hasDirectives) {\n        this.error = new YAMLSemanticError(this, 'Missing directives-end indicator line');\n      } else if (this.directives.length > 0) {\n        this.contents = this.directives;\n        this.directives = [];\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"parseContents\",\n    value: function parseContents(start) {\n      var _this$context = this.context,\n          parseNode = _this$context.parseNode,\n          src = _this$context.src;\n      if (!this.contents) this.contents = [];\n      var lineStart = start;\n\n      while (src[lineStart - 1] === '-') {\n        lineStart -= 1;\n      }\n\n      var offset = Node.endOfWhiteSpace(src, start);\n      var atLineStart = lineStart === start;\n      this.valueRange = new Range(offset);\n\n      while (!Node.atDocumentBoundary(src, offset, Char.DOCUMENT_END)) {\n        switch (src[offset]) {\n          case '\\n':\n            if (atLineStart) {\n              var blankLine = new BlankLine();\n              offset = blankLine.parse({\n                src: src\n              }, offset);\n\n              if (offset < src.length) {\n                this.contents.push(blankLine);\n              }\n            } else {\n              offset += 1;\n              atLineStart = true;\n            }\n\n            lineStart = offset;\n            break;\n\n          case '#':\n            {\n              var comment = new Comment();\n              offset = comment.parse({\n                src: src\n              }, offset);\n              this.contents.push(comment);\n              atLineStart = false;\n            }\n            break;\n\n          default:\n            {\n              var iEnd = Node.endOfIndent(src, offset);\n              var context = {\n                atLineStart: atLineStart,\n                indent: -1,\n                inFlow: false,\n                inCollection: false,\n                lineStart: lineStart,\n                parent: this\n              };\n              var node = parseNode(context, iEnd);\n              if (!node) return this.valueRange.end = iEnd; // at next document start\n\n              this.contents.push(node);\n              offset = node.range.end;\n              atLineStart = false;\n              var ec = grabCollectionEndComments(node);\n              if (ec) Array.prototype.push.apply(this.contents, ec);\n            }\n        }\n\n        offset = Document.startCommentOrEndBlankLine(src, offset);\n      }\n\n      this.valueRange.end = offset;\n\n      if (src[offset]) {\n        this.documentEndMarker = new Range(offset, offset + 3);\n        offset += 3;\n\n        if (src[offset]) {\n          offset = Node.endOfWhiteSpace(src, offset);\n\n          if (src[offset] === '#') {\n            var _comment = new Comment();\n\n            offset = _comment.parse({\n              src: src\n            }, offset);\n            this.contents.push(_comment);\n          }\n\n          switch (src[offset]) {\n            case '\\n':\n              offset += 1;\n              break;\n\n            case undefined:\n              break;\n\n            default:\n              this.error = new YAMLSyntaxError(this, 'Document end marker line cannot have a non-comment suffix');\n          }\n        }\n      }\n\n      return offset;\n    }\n    /**\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      context.root = this;\n      this.context = context;\n      var src = context.src;\n      var offset = src.charCodeAt(start) === 0xfeff ? start + 1 : start; // skip BOM\n\n      offset = this.parseDirectives(offset);\n      offset = this.parseContents(offset);\n      return offset;\n    }\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      offset = _get(_getPrototypeOf(Document.prototype), \"setOrigRanges\", this).call(this, cr, offset);\n      this.directives.forEach(function (node) {\n        offset = node.setOrigRanges(cr, offset);\n      });\n      if (this.directivesEndMarker) offset = this.directivesEndMarker.setOrigRange(cr, offset);\n      this.contents.forEach(function (node) {\n        offset = node.setOrigRanges(cr, offset);\n      });\n      if (this.documentEndMarker) offset = this.documentEndMarker.setOrigRange(cr, offset);\n      return offset;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var contents = this.contents,\n          directives = this.directives,\n          value = this.value;\n      if (value != null) return value;\n      var str = directives.join('');\n\n      if (contents.length > 0) {\n        if (directives.length > 0 || contents[0].type === Type.COMMENT) str += '---\\n';\n        str += contents.join('');\n      }\n\n      if (str[str.length - 1] !== '\\n') str += '\\n';\n      return str;\n    }\n  }], [{\n    key: \"startCommentOrEndBlankLine\",\n    value: function startCommentOrEndBlankLine(src, start) {\n      var offset = Node.endOfWhiteSpace(src, start);\n      var ch = src[offset];\n      return ch === '#' || ch === '\\n' ? offset : start;\n    }\n  }]);\n\n  return Document;\n}(Node);\n\nvar Alias = /*#__PURE__*/function (_Node) {\n  _inherits(Alias, _Node);\n\n  var _super = _createSuper(Alias);\n\n  function Alias() {\n    _classCallCheck(this, Alias);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(Alias, [{\n    key: \"parse\",\n    value:\n    /**\n     * Parses an *alias from the source\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this scalar\n     */\n    function parse(context, start) {\n      this.context = context;\n      var src = context.src;\n      var offset = Node.endOfIdentifier(src, start + 1);\n      this.valueRange = new Range(start + 1, offset);\n      offset = Node.endOfWhiteSpace(src, offset);\n      offset = this.parseComment(offset);\n      return offset;\n    }\n  }]);\n\n  return Alias;\n}(Node);\n\nvar Chomp = {\n  CLIP: 'CLIP',\n  KEEP: 'KEEP',\n  STRIP: 'STRIP'\n};\nvar BlockValue = /*#__PURE__*/function (_Node) {\n  _inherits(BlockValue, _Node);\n\n  var _super = _createSuper(BlockValue);\n\n  function BlockValue(type, props) {\n    var _this;\n\n    _classCallCheck(this, BlockValue);\n\n    _this = _super.call(this, type, props);\n    _this.blockIndent = null;\n    _this.chomping = Chomp.CLIP;\n    _this.header = null;\n    return _this;\n  }\n\n  _createClass(BlockValue, [{\n    key: \"includesTrailingLines\",\n    get: function get() {\n      return this.chomping === Chomp.KEEP;\n    }\n  }, {\n    key: \"strValue\",\n    get: function get() {\n      if (!this.valueRange || !this.context) return null;\n      var _this$valueRange = this.valueRange,\n          start = _this$valueRange.start,\n          end = _this$valueRange.end;\n      var _this$context = this.context,\n          indent = _this$context.indent,\n          src = _this$context.src;\n      if (this.valueRange.isEmpty()) return '';\n      var lastNewLine = null;\n      var ch = src[end - 1];\n\n      while (ch === '\\n' || ch === '\\t' || ch === ' ') {\n        end -= 1;\n\n        if (end <= start) {\n          if (this.chomping === Chomp.KEEP) break;else return ''; // probably never happens\n        }\n\n        if (ch === '\\n') lastNewLine = end;\n        ch = src[end - 1];\n      }\n\n      var keepStart = end + 1;\n\n      if (lastNewLine) {\n        if (this.chomping === Chomp.KEEP) {\n          keepStart = lastNewLine;\n          end = this.valueRange.end;\n        } else {\n          end = lastNewLine;\n        }\n      }\n\n      var bi = indent + this.blockIndent;\n      var folded = this.type === Type.BLOCK_FOLDED;\n      var atStart = true;\n      var str = '';\n      var sep = '';\n      var prevMoreIndented = false;\n\n      for (var i = start; i < end; ++i) {\n        for (var j = 0; j < bi; ++j) {\n          if (src[i] !== ' ') break;\n          i += 1;\n        }\n\n        var _ch = src[i];\n\n        if (_ch === '\\n') {\n          if (sep === '\\n') str += '\\n';else sep = '\\n';\n        } else {\n          var lineEnd = Node.endOfLine(src, i);\n          var line = src.slice(i, lineEnd);\n          i = lineEnd;\n\n          if (folded && (_ch === ' ' || _ch === '\\t') && i < keepStart) {\n            if (sep === ' ') sep = '\\n';else if (!prevMoreIndented && !atStart && sep === '\\n') sep = '\\n\\n';\n            str += sep + line; //+ ((lineEnd < end && src[lineEnd]) || '')\n\n            sep = lineEnd < end && src[lineEnd] || '';\n            prevMoreIndented = true;\n          } else {\n            str += sep + line;\n            sep = folded && i < keepStart ? ' ' : '\\n';\n            prevMoreIndented = false;\n          }\n\n          if (atStart && line !== '') atStart = false;\n        }\n      }\n\n      return this.chomping === Chomp.STRIP ? str : str + '\\n';\n    }\n  }, {\n    key: \"parseBlockHeader\",\n    value: function parseBlockHeader(start) {\n      var src = this.context.src;\n      var offset = start + 1;\n      var bi = '';\n\n      while (true) {\n        var ch = src[offset];\n\n        switch (ch) {\n          case '-':\n            this.chomping = Chomp.STRIP;\n            break;\n\n          case '+':\n            this.chomping = Chomp.KEEP;\n            break;\n\n          case '0':\n          case '1':\n          case '2':\n          case '3':\n          case '4':\n          case '5':\n          case '6':\n          case '7':\n          case '8':\n          case '9':\n            bi += ch;\n            break;\n\n          default:\n            this.blockIndent = Number(bi) || null;\n            this.header = new Range(start, offset);\n            return offset;\n        }\n\n        offset += 1;\n      }\n    }\n  }, {\n    key: \"parseBlockValue\",\n    value: function parseBlockValue(start) {\n      var _this$context2 = this.context,\n          indent = _this$context2.indent,\n          src = _this$context2.src;\n      var explicit = !!this.blockIndent;\n      var offset = start;\n      var valueEnd = start;\n      var minBlockIndent = 1;\n\n      for (var ch = src[offset]; ch === '\\n'; ch = src[offset]) {\n        offset += 1;\n        if (Node.atDocumentBoundary(src, offset)) break;\n        var end = Node.endOfBlockIndent(src, indent, offset); // should not include tab?\n\n        if (end === null) break;\n        var _ch2 = src[end];\n        var lineIndent = end - (offset + indent);\n\n        if (!this.blockIndent) {\n          // no explicit block indent, none yet detected\n          if (src[end] !== '\\n') {\n            // first line with non-whitespace content\n            if (lineIndent < minBlockIndent) {\n              var msg = 'Block scalars with more-indented leading empty lines must use an explicit indentation indicator';\n              this.error = new YAMLSemanticError(this, msg);\n            }\n\n            this.blockIndent = lineIndent;\n          } else if (lineIndent > minBlockIndent) {\n            // empty line with more whitespace\n            minBlockIndent = lineIndent;\n          }\n        } else if (_ch2 && _ch2 !== '\\n' && lineIndent < this.blockIndent) {\n          if (src[end] === '#') break;\n\n          if (!this.error) {\n            var _src = explicit ? 'explicit indentation indicator' : 'first line';\n\n            var _msg = \"Block scalars must not be less indented than their \".concat(_src);\n\n            this.error = new YAMLSemanticError(this, _msg);\n          }\n        }\n\n        if (src[end] === '\\n') {\n          offset = end;\n        } else {\n          offset = valueEnd = Node.endOfLine(src, end);\n        }\n      }\n\n      if (this.chomping !== Chomp.KEEP) {\n        offset = src[valueEnd] ? valueEnd + 1 : valueEnd;\n      }\n\n      this.valueRange = new Range(start + 1, offset);\n      return offset;\n    }\n    /**\n     * Parses a block value from the source\n     *\n     * Accepted forms are:\n     * ```\n     * BS\n     * block\n     * lines\n     *\n     * BS #comment\n     * block\n     * lines\n     * ```\n     * where the block style BS matches the regexp `[|>][-+1-9]*` and block lines\n     * are empty or have an indent level greater than `indent`.\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this block\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var src = context.src;\n      var offset = this.parseBlockHeader(start);\n      offset = Node.endOfWhiteSpace(src, offset);\n      offset = this.parseComment(offset);\n      offset = this.parseBlockValue(offset);\n      return offset;\n    }\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      offset = _get(_getPrototypeOf(BlockValue.prototype), \"setOrigRanges\", this).call(this, cr, offset);\n      return this.header ? this.header.setOrigRange(cr, offset) : offset;\n    }\n  }]);\n\n  return BlockValue;\n}(Node);\n\nvar FlowCollection = /*#__PURE__*/function (_Node) {\n  _inherits(FlowCollection, _Node);\n\n  var _super = _createSuper(FlowCollection);\n\n  function FlowCollection(type, props) {\n    var _this;\n\n    _classCallCheck(this, FlowCollection);\n\n    _this = _super.call(this, type, props);\n    _this.items = null;\n    return _this;\n  }\n\n  _createClass(FlowCollection, [{\n    key: \"prevNodeIsJsonLike\",\n    value: function prevNodeIsJsonLike() {\n      var idx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.items.length;\n      var node = this.items[idx - 1];\n      return !!node && (node.jsonLike || node.type === Type.COMMENT && this.prevNodeIsJsonLike(idx - 1));\n    }\n    /**\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var parseNode = context.parseNode,\n          src = context.src;\n      var indent = context.indent,\n          lineStart = context.lineStart;\n      var char = src[start]; // { or [\n\n      this.items = [{\n        char: char,\n        offset: start\n      }];\n      var offset = Node.endOfWhiteSpace(src, start + 1);\n      char = src[offset];\n\n      while (char && char !== ']' && char !== '}') {\n        switch (char) {\n          case '\\n':\n            {\n              lineStart = offset + 1;\n              var wsEnd = Node.endOfWhiteSpace(src, lineStart);\n\n              if (src[wsEnd] === '\\n') {\n                var blankLine = new BlankLine();\n                lineStart = blankLine.parse({\n                  src: src\n                }, lineStart);\n                this.items.push(blankLine);\n              }\n\n              offset = Node.endOfIndent(src, lineStart);\n\n              if (offset <= lineStart + indent) {\n                char = src[offset];\n\n                if (offset < lineStart + indent || char !== ']' && char !== '}') {\n                  var msg = 'Insufficient indentation in flow collection';\n                  this.error = new YAMLSemanticError(this, msg);\n                }\n              }\n            }\n            break;\n\n          case ',':\n            {\n              this.items.push({\n                char: char,\n                offset: offset\n              });\n              offset += 1;\n            }\n            break;\n\n          case '#':\n            {\n              var comment = new Comment();\n              offset = comment.parse({\n                src: src\n              }, offset);\n              this.items.push(comment);\n            }\n            break;\n\n          case '?':\n          case ':':\n            {\n              var next = src[offset + 1];\n\n              if (next === '\\n' || next === '\\t' || next === ' ' || next === ',' || // in-flow : after JSON-like key does not need to be followed by whitespace\n              char === ':' && this.prevNodeIsJsonLike()) {\n                this.items.push({\n                  char: char,\n                  offset: offset\n                });\n                offset += 1;\n                break;\n              }\n            }\n          // fallthrough\n\n          default:\n            {\n              var node = parseNode({\n                atLineStart: false,\n                inCollection: false,\n                inFlow: true,\n                indent: -1,\n                lineStart: lineStart,\n                parent: this\n              }, offset);\n\n              if (!node) {\n                // at next document start\n                this.valueRange = new Range(start, offset);\n                return offset;\n              }\n\n              this.items.push(node);\n              offset = Node.normalizeOffset(src, node.range.end);\n            }\n        }\n\n        offset = Node.endOfWhiteSpace(src, offset);\n        char = src[offset];\n      }\n\n      this.valueRange = new Range(start, offset + 1);\n\n      if (char) {\n        this.items.push({\n          char: char,\n          offset: offset\n        });\n        offset = Node.endOfWhiteSpace(src, offset + 1);\n        offset = this.parseComment(offset);\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      offset = _get(_getPrototypeOf(FlowCollection.prototype), \"setOrigRanges\", this).call(this, cr, offset);\n      this.items.forEach(function (node) {\n        if (node instanceof Node) {\n          offset = node.setOrigRanges(cr, offset);\n        } else if (cr.length === 0) {\n          node.origOffset = node.offset;\n        } else {\n          var i = offset;\n\n          while (i < cr.length) {\n            if (cr[i] > node.offset) break;else ++i;\n          }\n\n          node.origOffset = node.offset + i;\n          offset = i;\n        }\n      });\n      return offset;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var src = this.context.src,\n          items = this.items,\n          range = this.range,\n          value = this.value;\n      if (value != null) return value;\n      var nodes = items.filter(function (item) {\n        return item instanceof Node;\n      });\n      var str = '';\n      var prevEnd = range.start;\n      nodes.forEach(function (node) {\n        var prefix = src.slice(prevEnd, node.range.start);\n        prevEnd = node.range.end;\n        str += prefix + String(node);\n\n        if (str[str.length - 1] === '\\n' && src[prevEnd - 1] !== '\\n' && src[prevEnd] === '\\n') {\n          // Comment range does not include the terminal newline, but its\n          // stringified value does. Without this fix, newlines at comment ends\n          // get duplicated.\n          prevEnd += 1;\n        }\n      });\n      str += src.slice(prevEnd, range.end);\n      return Node.addStringTerminator(src, range.end, str);\n    }\n  }]);\n\n  return FlowCollection;\n}(Node);\n\nvar QuoteDouble = /*#__PURE__*/function (_Node) {\n  _inherits(QuoteDouble, _Node);\n\n  var _super = _createSuper(QuoteDouble);\n\n  function QuoteDouble() {\n    _classCallCheck(this, QuoteDouble);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(QuoteDouble, [{\n    key: \"strValue\",\n    get:\n    /**\n     * @returns {string | { str: string, errors: YAMLSyntaxError[] }}\n     */\n    function get() {\n      if (!this.valueRange || !this.context) return null;\n      var errors = [];\n      var _this$valueRange = this.valueRange,\n          start = _this$valueRange.start,\n          end = _this$valueRange.end;\n      var _this$context = this.context,\n          indent = _this$context.indent,\n          src = _this$context.src;\n      if (src[end - 1] !== '\"') errors.push(new YAMLSyntaxError(this, 'Missing closing \"quote')); // Using String#replace is too painful with escaped newlines preceded by\n      // escaped backslashes; also, this should be faster.\n\n      var str = '';\n\n      for (var i = start + 1; i < end - 1; ++i) {\n        var ch = src[i];\n\n        if (ch === '\\n') {\n          if (Node.atDocumentBoundary(src, i + 1)) errors.push(new YAMLSemanticError(this, 'Document boundary indicators are not allowed within string values'));\n\n          var _Node$foldNewline = Node.foldNewline(src, i, indent),\n              fold = _Node$foldNewline.fold,\n              offset = _Node$foldNewline.offset,\n              error = _Node$foldNewline.error;\n\n          str += fold;\n          i = offset;\n          if (error) errors.push(new YAMLSemanticError(this, 'Multi-line double-quoted string needs to be sufficiently indented'));\n        } else if (ch === '\\\\') {\n          i += 1;\n\n          switch (src[i]) {\n            case '0':\n              str += '\\0';\n              break;\n            // null character\n\n            case 'a':\n              str += '\\x07';\n              break;\n            // bell character\n\n            case 'b':\n              str += '\\b';\n              break;\n            // backspace\n\n            case 'e':\n              str += '\\x1b';\n              break;\n            // escape character\n\n            case 'f':\n              str += '\\f';\n              break;\n            // form feed\n\n            case 'n':\n              str += '\\n';\n              break;\n            // line feed\n\n            case 'r':\n              str += '\\r';\n              break;\n            // carriage return\n\n            case 't':\n              str += '\\t';\n              break;\n            // horizontal tab\n\n            case 'v':\n              str += '\\v';\n              break;\n            // vertical tab\n\n            case 'N':\n              str += \"\\x85\";\n              break;\n            // Unicode next line\n\n            case '_':\n              str += \"\\xA0\";\n              break;\n            // Unicode non-breaking space\n\n            case 'L':\n              str += \"\\u2028\";\n              break;\n            // Unicode line separator\n\n            case 'P':\n              str += \"\\u2029\";\n              break;\n            // Unicode paragraph separator\n\n            case ' ':\n              str += ' ';\n              break;\n\n            case '\"':\n              str += '\"';\n              break;\n\n            case '/':\n              str += '/';\n              break;\n\n            case '\\\\':\n              str += '\\\\';\n              break;\n\n            case '\\t':\n              str += '\\t';\n              break;\n\n            case 'x':\n              str += this.parseCharCode(i + 1, 2, errors);\n              i += 2;\n              break;\n\n            case 'u':\n              str += this.parseCharCode(i + 1, 4, errors);\n              i += 4;\n              break;\n\n            case 'U':\n              str += this.parseCharCode(i + 1, 8, errors);\n              i += 8;\n              break;\n\n            case '\\n':\n              // skip escaped newlines, but still trim the following line\n              while (src[i + 1] === ' ' || src[i + 1] === '\\t') {\n                i += 1;\n              }\n\n              break;\n\n            default:\n              errors.push(new YAMLSyntaxError(this, \"Invalid escape sequence \".concat(src.substr(i - 1, 2))));\n              str += '\\\\' + src[i];\n          }\n        } else if (ch === ' ' || ch === '\\t') {\n          // trim trailing whitespace\n          var wsStart = i;\n          var next = src[i + 1];\n\n          while (next === ' ' || next === '\\t') {\n            i += 1;\n            next = src[i + 1];\n          }\n\n          if (next !== '\\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;\n        } else {\n          str += ch;\n        }\n      }\n\n      return errors.length > 0 ? {\n        errors: errors,\n        str: str\n      } : str;\n    }\n  }, {\n    key: \"parseCharCode\",\n    value: function parseCharCode(offset, length, errors) {\n      var src = this.context.src;\n      var cc = src.substr(offset, length);\n      var ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);\n      var code = ok ? parseInt(cc, 16) : NaN;\n\n      if (isNaN(code)) {\n        errors.push(new YAMLSyntaxError(this, \"Invalid escape sequence \".concat(src.substr(offset - 2, length + 2))));\n        return src.substr(offset - 2, length + 2);\n      }\n\n      return String.fromCodePoint(code);\n    }\n    /**\n     * Parses a \"double quoted\" value from the source\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this scalar\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var src = context.src;\n      var offset = QuoteDouble.endOfQuote(src, start + 1);\n      this.valueRange = new Range(start, offset);\n      offset = Node.endOfWhiteSpace(src, offset);\n      offset = this.parseComment(offset);\n      return offset;\n    }\n  }], [{\n    key: \"endOfQuote\",\n    value: function endOfQuote(src, offset) {\n      var ch = src[offset];\n\n      while (ch && ch !== '\"') {\n        offset += ch === '\\\\' ? 2 : 1;\n        ch = src[offset];\n      }\n\n      return offset + 1;\n    }\n  }]);\n\n  return QuoteDouble;\n}(Node);\n\nvar QuoteSingle = /*#__PURE__*/function (_Node) {\n  _inherits(QuoteSingle, _Node);\n\n  var _super = _createSuper(QuoteSingle);\n\n  function QuoteSingle() {\n    _classCallCheck(this, QuoteSingle);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(QuoteSingle, [{\n    key: \"strValue\",\n    get:\n    /**\n     * @returns {string | { str: string, errors: YAMLSyntaxError[] }}\n     */\n    function get() {\n      if (!this.valueRange || !this.context) return null;\n      var errors = [];\n      var _this$valueRange = this.valueRange,\n          start = _this$valueRange.start,\n          end = _this$valueRange.end;\n      var _this$context = this.context,\n          indent = _this$context.indent,\n          src = _this$context.src;\n      if (src[end - 1] !== \"'\") errors.push(new YAMLSyntaxError(this, \"Missing closing 'quote\"));\n      var str = '';\n\n      for (var i = start + 1; i < end - 1; ++i) {\n        var ch = src[i];\n\n        if (ch === '\\n') {\n          if (Node.atDocumentBoundary(src, i + 1)) errors.push(new YAMLSemanticError(this, 'Document boundary indicators are not allowed within string values'));\n\n          var _Node$foldNewline = Node.foldNewline(src, i, indent),\n              fold = _Node$foldNewline.fold,\n              offset = _Node$foldNewline.offset,\n              error = _Node$foldNewline.error;\n\n          str += fold;\n          i = offset;\n          if (error) errors.push(new YAMLSemanticError(this, 'Multi-line single-quoted string needs to be sufficiently indented'));\n        } else if (ch === \"'\") {\n          str += ch;\n          i += 1;\n          if (src[i] !== \"'\") errors.push(new YAMLSyntaxError(this, 'Unescaped single quote? This should not happen.'));\n        } else if (ch === ' ' || ch === '\\t') {\n          // trim trailing whitespace\n          var wsStart = i;\n          var next = src[i + 1];\n\n          while (next === ' ' || next === '\\t') {\n            i += 1;\n            next = src[i + 1];\n          }\n\n          if (next !== '\\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;\n        } else {\n          str += ch;\n        }\n      }\n\n      return errors.length > 0 ? {\n        errors: errors,\n        str: str\n      } : str;\n    }\n    /**\n     * Parses a 'single quoted' value from the source\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this scalar\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var src = context.src;\n      var offset = QuoteSingle.endOfQuote(src, start + 1);\n      this.valueRange = new Range(start, offset);\n      offset = Node.endOfWhiteSpace(src, offset);\n      offset = this.parseComment(offset);\n      return offset;\n    }\n  }], [{\n    key: \"endOfQuote\",\n    value: function endOfQuote(src, offset) {\n      var ch = src[offset];\n\n      while (ch) {\n        if (ch === \"'\") {\n          if (src[offset + 1] !== \"'\") break;\n          ch = src[offset += 2];\n        } else {\n          ch = src[offset += 1];\n        }\n      }\n\n      return offset + 1;\n    }\n  }]);\n\n  return QuoteSingle;\n}(Node);\n\nfunction createNewNode(type, props) {\n  switch (type) {\n    case Type.ALIAS:\n      return new Alias(type, props);\n\n    case Type.BLOCK_FOLDED:\n    case Type.BLOCK_LITERAL:\n      return new BlockValue(type, props);\n\n    case Type.FLOW_MAP:\n    case Type.FLOW_SEQ:\n      return new FlowCollection(type, props);\n\n    case Type.MAP_KEY:\n    case Type.MAP_VALUE:\n    case Type.SEQ_ITEM:\n      return new CollectionItem(type, props);\n\n    case Type.COMMENT:\n    case Type.PLAIN:\n      return new PlainValue(type, props);\n\n    case Type.QUOTE_DOUBLE:\n      return new QuoteDouble(type, props);\n\n    case Type.QUOTE_SINGLE:\n      return new QuoteSingle(type, props);\n\n    /* istanbul ignore next */\n\n    default:\n      return null;\n    // should never happen\n  }\n}\n/**\n * @param {boolean} atLineStart - Node starts at beginning of line\n * @param {boolean} inFlow - true if currently in a flow context\n * @param {boolean} inCollection - true if currently in a collection context\n * @param {number} indent - Current level of indentation\n * @param {number} lineStart - Start of the current line\n * @param {Node} parent - The parent of the node\n * @param {string} src - Source of the YAML document\n */\n\n\nvar ParseContext = /*#__PURE__*/function () {\n  function ParseContext() {\n    var _this = this;\n\n    var orig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        atLineStart = _ref.atLineStart,\n        inCollection = _ref.inCollection,\n        inFlow = _ref.inFlow,\n        indent = _ref.indent,\n        lineStart = _ref.lineStart,\n        parent = _ref.parent;\n\n    _classCallCheck(this, ParseContext);\n\n    _defineProperty(this, \"parseNode\", function (overlay, start) {\n      if (Node.atDocumentBoundary(_this.src, start)) return null;\n      var context = new ParseContext(_this, overlay);\n\n      var _context$parseProps = context.parseProps(start),\n          props = _context$parseProps.props,\n          type = _context$parseProps.type,\n          valueStart = _context$parseProps.valueStart;\n\n      var node = createNewNode(type, props);\n      var offset = node.parse(context, valueStart);\n      node.range = new Range(start, offset);\n      /* istanbul ignore if */\n\n      if (offset <= start) {\n        // This should never happen, but if it does, let's make sure to at least\n        // step one character forward to avoid a busy loop.\n        node.error = new Error(\"Node#parse consumed no characters\");\n        node.error.parseEnd = offset;\n        node.error.source = node;\n        node.range.end = start + 1;\n      }\n\n      if (context.nodeStartsCollection(node)) {\n        if (!node.error && !context.atLineStart && context.parent.type === Type.DOCUMENT) {\n          node.error = new YAMLSyntaxError(node, 'Block collection must not have preceding content here (e.g. directives-end indicator)');\n        }\n\n        var collection = new Collection(node);\n        offset = collection.parse(new ParseContext(context), offset);\n        collection.range = new Range(start, offset);\n        return collection;\n      }\n\n      return node;\n    });\n\n    this.atLineStart = atLineStart != null ? atLineStart : orig.atLineStart || false;\n    this.inCollection = inCollection != null ? inCollection : orig.inCollection || false;\n    this.inFlow = inFlow != null ? inFlow : orig.inFlow || false;\n    this.indent = indent != null ? indent : orig.indent;\n    this.lineStart = lineStart != null ? lineStart : orig.lineStart;\n    this.parent = parent != null ? parent : orig.parent || {};\n    this.root = orig.root;\n    this.src = orig.src;\n  }\n\n  _createClass(ParseContext, [{\n    key: \"nodeStartsCollection\",\n    value: function nodeStartsCollection(node) {\n      var inCollection = this.inCollection,\n          inFlow = this.inFlow,\n          src = this.src;\n      if (inCollection || inFlow) return false;\n      if (node instanceof CollectionItem) return true; // check for implicit key\n\n      var offset = node.range.end;\n      if (src[offset] === '\\n' || src[offset - 1] === '\\n') return false;\n      offset = Node.endOfWhiteSpace(src, offset);\n      return src[offset] === ':';\n    } // Anchor and tag are before type, which determines the node implementation\n    // class; hence this intermediate step.\n\n  }, {\n    key: \"parseProps\",\n    value: function parseProps(offset) {\n      var inFlow = this.inFlow,\n          parent = this.parent,\n          src = this.src;\n      var props = [];\n      var lineHasProps = false;\n      offset = this.atLineStart ? Node.endOfIndent(src, offset) : Node.endOfWhiteSpace(src, offset);\n      var ch = src[offset];\n\n      while (ch === Char.ANCHOR || ch === Char.COMMENT || ch === Char.TAG || ch === '\\n') {\n        if (ch === '\\n') {\n          var inEnd = offset;\n          var lineStart = void 0;\n\n          do {\n            lineStart = inEnd + 1;\n            inEnd = Node.endOfIndent(src, lineStart);\n          } while (src[inEnd] === '\\n');\n\n          var indentDiff = inEnd - (lineStart + this.indent);\n          var noIndicatorAsIndent = parent.type === Type.SEQ_ITEM && parent.context.atLineStart;\n          if (src[inEnd] !== '#' && !Node.nextNodeIsIndented(src[inEnd], indentDiff, !noIndicatorAsIndent)) break;\n          this.atLineStart = true;\n          this.lineStart = lineStart;\n          lineHasProps = false;\n          offset = inEnd;\n        } else if (ch === Char.COMMENT) {\n          var end = Node.endOfLine(src, offset + 1);\n          props.push(new Range(offset, end));\n          offset = end;\n        } else {\n          var _end = Node.endOfIdentifier(src, offset + 1);\n\n          if (ch === Char.TAG && src[_end] === ',' && /^[a-zA-Z0-9-]+\\.[a-zA-Z0-9-]+,\\d\\d\\d\\d(-\\d\\d){0,2}\\/\\S/.test(src.slice(offset + 1, _end + 13))) {\n            // Let's presume we're dealing with a YAML 1.0 domain tag here, rather\n            // than an empty but 'foo.bar' private-tagged node in a flow collection\n            // followed without whitespace by a plain string starting with a year\n            // or date divided by something.\n            _end = Node.endOfIdentifier(src, _end + 5);\n          }\n\n          props.push(new Range(offset, _end));\n          lineHasProps = true;\n          offset = Node.endOfWhiteSpace(src, _end);\n        }\n\n        ch = src[offset];\n      } // '- &a : b' has an anchor on an empty node\n\n\n      if (lineHasProps && ch === ':' && Node.atBlank(src, offset + 1, true)) offset -= 1;\n      var type = ParseContext.parseType(src, offset, inFlow);\n      return {\n        props: props,\n        type: type,\n        valueStart: offset\n      };\n    }\n    /**\n     * Parses a node from the source\n     * @param {ParseContext} overlay\n     * @param {number} start - Index of first non-whitespace character for the node\n     * @returns {?Node} - null if at a document boundary\n     */\n\n  }], [{\n    key: \"parseType\",\n    value: function parseType(src, offset, inFlow) {\n      switch (src[offset]) {\n        case '*':\n          return Type.ALIAS;\n\n        case '>':\n          return Type.BLOCK_FOLDED;\n\n        case '|':\n          return Type.BLOCK_LITERAL;\n\n        case '{':\n          return Type.FLOW_MAP;\n\n        case '[':\n          return Type.FLOW_SEQ;\n\n        case '?':\n          return !inFlow && Node.atBlank(src, offset + 1, true) ? Type.MAP_KEY : Type.PLAIN;\n\n        case ':':\n          return !inFlow && Node.atBlank(src, offset + 1, true) ? Type.MAP_VALUE : Type.PLAIN;\n\n        case '-':\n          return !inFlow && Node.atBlank(src, offset + 1, true) ? Type.SEQ_ITEM : Type.PLAIN;\n\n        case '\"':\n          return Type.QUOTE_DOUBLE;\n\n        case \"'\":\n          return Type.QUOTE_SINGLE;\n\n        default:\n          return Type.PLAIN;\n      }\n    }\n  }]);\n\n  return ParseContext;\n}();\n\n// Published as 'yaml/parse-cst'\nfunction parse(src) {\n  var cr = [];\n\n  if (src.indexOf('\\r') !== -1) {\n    src = src.replace(/\\r\\n?/g, function (match, offset) {\n      if (match.length > 1) cr.push(offset);\n      return '\\n';\n    });\n  }\n\n  var documents = [];\n  var offset = 0;\n\n  do {\n    var doc = new Document();\n    var context = new ParseContext({\n      src: src\n    });\n    offset = doc.parse(context, offset);\n    documents.push(doc);\n  } while (offset < src.length);\n\n  documents.setOrigRanges = function () {\n    if (cr.length === 0) return false;\n\n    for (var i = 1; i < cr.length; ++i) {\n      cr[i] -= i;\n    }\n\n    var crOffset = 0;\n\n    for (var _i = 0; _i < documents.length; ++_i) {\n      crOffset = documents[_i].setOrigRanges(cr, crOffset);\n    }\n\n    cr.splice(0, cr.length);\n    return true;\n  };\n\n  documents.toString = function () {\n    return documents.join('...\\n');\n  };\n\n  return documents;\n}\n\nexport { parse };\n"]},"metadata":{},"sourceType":"module"}