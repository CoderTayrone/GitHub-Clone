{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.errorRequestHandler = exports.proxyRequestHandler = void 0;\n\nconst lodash_1 = require(\"lodash\");\n\nconst node_fetch_1 = require(\"node-fetch\");\n\nconst stream_1 = require(\"stream\");\n\nconst url_1 = require(\"url\");\n\nconst apiv2_1 = require(\"../apiv2\");\n\nconst error_1 = require(\"../error\");\n\nconst logger_1 = require(\"../logger\");\n\nconst REQUIRED_VARY_VALUES = [\"Accept-Encoding\", \"Authorization\", \"Cookie\"];\n\nfunction makeVary(vary = \"\") {\n  if (!vary) {\n    return \"Accept-Encoding, Authorization, Cookie\";\n  }\n\n  const varies = vary.split(/, ?/).map(v => {\n    return v.split(\"-\").map(part => lodash_1.capitalize(part)).join(\"-\");\n  });\n  REQUIRED_VARY_VALUES.forEach(requiredVary => {\n    if (!lodash_1.includes(varies, requiredVary)) {\n      varies.push(requiredVary);\n    }\n  });\n  return varies.join(\", \");\n}\n\nfunction proxyRequestHandler(url, rewriteIdentifier) {\n  return async (req, res, next) => {\n    var _a;\n\n    logger_1.logger.info(`[hosting] Rewriting ${req.url} to ${url} for ${rewriteIdentifier}`);\n    const cookie = req.headers.cookie || \"\";\n    const sessionCookie = cookie.split(/; ?/).find(c => {\n      return c.trim().startsWith(\"__session=\");\n    });\n    const u = new url_1.URL(url + req.url);\n    const c = new apiv2_1.Client({\n      urlPrefix: u.origin,\n      auth: false\n    });\n    let passThrough;\n\n    if (req.method && ![\"GET\", \"HEAD\"].includes(req.method)) {\n      passThrough = new stream_1.PassThrough();\n      req.pipe(passThrough);\n    }\n\n    const headers = new node_fetch_1.Headers({\n      \"X-Forwarded-Host\": req.headers.host || \"\",\n      \"X-Original-Url\": req.url || \"\",\n      Pragma: \"no-cache\",\n      \"Cache-Control\": \"no-cache, no-store\",\n      Cookie: sessionCookie || \"\"\n    });\n    const headersToSkip = new Set([\"host\"]);\n\n    for (const key of Object.keys(req.headers)) {\n      if (headersToSkip.has(key)) {\n        continue;\n      }\n\n      const value = req.headers[key];\n\n      if (value == undefined) {\n        headers.delete(key);\n      } else if (Array.isArray(value)) {\n        headers.delete(key);\n\n        for (const v of value) {\n          headers.append(key, v);\n        }\n      } else {\n        headers.set(key, value);\n      }\n    }\n\n    let proxyRes;\n\n    try {\n      proxyRes = await c.request({\n        method: req.method || \"GET\",\n        path: u.pathname,\n        queryParams: u.searchParams,\n        headers,\n        resolveOnHTTPError: true,\n        responseType: \"stream\",\n        redirect: \"manual\",\n        body: passThrough,\n        timeout: 60000,\n        compress: false\n      });\n    } catch (err) {\n      const isAbortError = err instanceof error_1.FirebaseError && ((_a = err.original) === null || _a === void 0 ? void 0 : _a.name.includes(\"AbortError\"));\n      const isTimeoutError = err instanceof error_1.FirebaseError && err.original instanceof node_fetch_1.FetchError && err.original.code === \"ETIMEDOUT\";\n      const isSocketTimeoutError = err instanceof error_1.FirebaseError && err.original instanceof node_fetch_1.FetchError && err.original.code === \"ESOCKETTIMEDOUT\";\n\n      if (isAbortError || isTimeoutError || isSocketTimeoutError) {\n        res.statusCode = 504;\n        return res.end(\"Timed out waiting for function to respond.\\n\");\n      }\n\n      res.statusCode = 500;\n      return res.end(`An internal error occurred while proxying for ${rewriteIdentifier}\\n`);\n    }\n\n    if (proxyRes.status === 404) {\n      const cascade = proxyRes.response.headers.get(\"x-cascade\");\n\n      if (cascade && cascade.toUpperCase() === \"PASS\") {\n        return next();\n      }\n    }\n\n    if (!proxyRes.response.headers.get(\"cache-control\")) {\n      proxyRes.response.headers.set(\"cache-control\", \"private\");\n    }\n\n    const cc = proxyRes.response.headers.get(\"cache-control\");\n\n    if (cc && !cc.includes(\"private\")) {\n      proxyRes.response.headers.delete(\"set-cookie\");\n    }\n\n    proxyRes.response.headers.set(\"vary\", makeVary(proxyRes.response.headers.get(\"vary\")));\n    const location = proxyRes.response.headers.get(\"location\");\n\n    if (location) {\n      try {\n        const locationURL = new url_1.URL(location);\n\n        if (locationURL.origin == u.origin) {\n          const unborkedLocation = location.replace(locationURL.origin, \"\");\n          proxyRes.response.headers.set(\"location\", unborkedLocation);\n        }\n      } catch (e) {\n        logger_1.logger.debug(`[hosting] had trouble parsing location header, but this may be okay: \"${location}\"`);\n      }\n    }\n\n    for (const [key, value] of Object.entries(proxyRes.response.headers.raw())) {\n      res.setHeader(key, value);\n    }\n\n    res.statusCode = proxyRes.status;\n    proxyRes.response.body.pipe(res);\n  };\n}\n\nexports.proxyRequestHandler = proxyRequestHandler;\n\nfunction errorRequestHandler(error) {\n  return (req, res, next) => {\n    res.statusCode = 500;\n    const out = `A problem occurred while trying to handle a proxied rewrite: ${error}`;\n    logger_1.logger.error(out);\n    res.end(out);\n  };\n}\n\nexports.errorRequestHandler = errorRequestHandler;","map":{"version":3,"sources":["/home/dev/Documentos/Projects/github-clone/node_modules/firebase-tools/lib/hosting/proxy.js"],"names":["Object","defineProperty","exports","value","errorRequestHandler","proxyRequestHandler","lodash_1","require","node_fetch_1","stream_1","url_1","apiv2_1","error_1","logger_1","REQUIRED_VARY_VALUES","makeVary","vary","varies","split","map","v","part","capitalize","join","forEach","requiredVary","includes","push","url","rewriteIdentifier","req","res","next","_a","logger","info","cookie","headers","sessionCookie","find","c","trim","startsWith","u","URL","Client","urlPrefix","origin","auth","passThrough","method","PassThrough","pipe","Headers","host","Pragma","Cookie","headersToSkip","Set","key","keys","has","undefined","delete","Array","isArray","append","set","proxyRes","request","path","pathname","queryParams","searchParams","resolveOnHTTPError","responseType","redirect","body","timeout","compress","err","isAbortError","FirebaseError","original","name","isTimeoutError","FetchError","code","isSocketTimeoutError","statusCode","end","status","cascade","response","get","toUpperCase","cc","location","locationURL","unborkedLocation","replace","e","debug","entries","raw","setHeader","error","out"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.errorRequestHandler = exports.proxyRequestHandler = void 0;\nconst lodash_1 = require(\"lodash\");\nconst node_fetch_1 = require(\"node-fetch\");\nconst stream_1 = require(\"stream\");\nconst url_1 = require(\"url\");\nconst apiv2_1 = require(\"../apiv2\");\nconst error_1 = require(\"../error\");\nconst logger_1 = require(\"../logger\");\nconst REQUIRED_VARY_VALUES = [\"Accept-Encoding\", \"Authorization\", \"Cookie\"];\nfunction makeVary(vary = \"\") {\n    if (!vary) {\n        return \"Accept-Encoding, Authorization, Cookie\";\n    }\n    const varies = vary.split(/, ?/).map((v) => {\n        return v\n            .split(\"-\")\n            .map((part) => lodash_1.capitalize(part))\n            .join(\"-\");\n    });\n    REQUIRED_VARY_VALUES.forEach((requiredVary) => {\n        if (!lodash_1.includes(varies, requiredVary)) {\n            varies.push(requiredVary);\n        }\n    });\n    return varies.join(\", \");\n}\nfunction proxyRequestHandler(url, rewriteIdentifier) {\n    return async (req, res, next) => {\n        var _a;\n        logger_1.logger.info(`[hosting] Rewriting ${req.url} to ${url} for ${rewriteIdentifier}`);\n        const cookie = req.headers.cookie || \"\";\n        const sessionCookie = cookie.split(/; ?/).find((c) => {\n            return c.trim().startsWith(\"__session=\");\n        });\n        const u = new url_1.URL(url + req.url);\n        const c = new apiv2_1.Client({ urlPrefix: u.origin, auth: false });\n        let passThrough;\n        if (req.method && ![\"GET\", \"HEAD\"].includes(req.method)) {\n            passThrough = new stream_1.PassThrough();\n            req.pipe(passThrough);\n        }\n        const headers = new node_fetch_1.Headers({\n            \"X-Forwarded-Host\": req.headers.host || \"\",\n            \"X-Original-Url\": req.url || \"\",\n            Pragma: \"no-cache\",\n            \"Cache-Control\": \"no-cache, no-store\",\n            Cookie: sessionCookie || \"\",\n        });\n        const headersToSkip = new Set([\"host\"]);\n        for (const key of Object.keys(req.headers)) {\n            if (headersToSkip.has(key)) {\n                continue;\n            }\n            const value = req.headers[key];\n            if (value == undefined) {\n                headers.delete(key);\n            }\n            else if (Array.isArray(value)) {\n                headers.delete(key);\n                for (const v of value) {\n                    headers.append(key, v);\n                }\n            }\n            else {\n                headers.set(key, value);\n            }\n        }\n        let proxyRes;\n        try {\n            proxyRes = await c.request({\n                method: (req.method || \"GET\"),\n                path: u.pathname,\n                queryParams: u.searchParams,\n                headers,\n                resolveOnHTTPError: true,\n                responseType: \"stream\",\n                redirect: \"manual\",\n                body: passThrough,\n                timeout: 60000,\n                compress: false,\n            });\n        }\n        catch (err) {\n            const isAbortError = err instanceof error_1.FirebaseError && ((_a = err.original) === null || _a === void 0 ? void 0 : _a.name.includes(\"AbortError\"));\n            const isTimeoutError = err instanceof error_1.FirebaseError &&\n                err.original instanceof node_fetch_1.FetchError &&\n                err.original.code === \"ETIMEDOUT\";\n            const isSocketTimeoutError = err instanceof error_1.FirebaseError &&\n                err.original instanceof node_fetch_1.FetchError &&\n                err.original.code === \"ESOCKETTIMEDOUT\";\n            if (isAbortError || isTimeoutError || isSocketTimeoutError) {\n                res.statusCode = 504;\n                return res.end(\"Timed out waiting for function to respond.\\n\");\n            }\n            res.statusCode = 500;\n            return res.end(`An internal error occurred while proxying for ${rewriteIdentifier}\\n`);\n        }\n        if (proxyRes.status === 404) {\n            const cascade = proxyRes.response.headers.get(\"x-cascade\");\n            if (cascade && cascade.toUpperCase() === \"PASS\") {\n                return next();\n            }\n        }\n        if (!proxyRes.response.headers.get(\"cache-control\")) {\n            proxyRes.response.headers.set(\"cache-control\", \"private\");\n        }\n        const cc = proxyRes.response.headers.get(\"cache-control\");\n        if (cc && !cc.includes(\"private\")) {\n            proxyRes.response.headers.delete(\"set-cookie\");\n        }\n        proxyRes.response.headers.set(\"vary\", makeVary(proxyRes.response.headers.get(\"vary\")));\n        const location = proxyRes.response.headers.get(\"location\");\n        if (location) {\n            try {\n                const locationURL = new url_1.URL(location);\n                if (locationURL.origin == u.origin) {\n                    const unborkedLocation = location.replace(locationURL.origin, \"\");\n                    proxyRes.response.headers.set(\"location\", unborkedLocation);\n                }\n            }\n            catch (e) {\n                logger_1.logger.debug(`[hosting] had trouble parsing location header, but this may be okay: \"${location}\"`);\n            }\n        }\n        for (const [key, value] of Object.entries(proxyRes.response.headers.raw())) {\n            res.setHeader(key, value);\n        }\n        res.statusCode = proxyRes.status;\n        proxyRes.response.body.pipe(res);\n    };\n}\nexports.proxyRequestHandler = proxyRequestHandler;\nfunction errorRequestHandler(error) {\n    return (req, res, next) => {\n        res.statusCode = 500;\n        const out = `A problem occurred while trying to handle a proxied rewrite: ${error}`;\n        logger_1.logger.error(out);\n        res.end(out);\n    };\n}\nexports.errorRequestHandler = errorRequestHandler;\n"]},"metadata":{},"sourceType":"script"}