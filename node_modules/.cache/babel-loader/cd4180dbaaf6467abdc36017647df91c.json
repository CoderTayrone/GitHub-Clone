{"ast":null,"code":"\"use strict\";\n\nconst fs = require(\"fs\");\n\nconst {\n  ono\n} = require(\"@jsdevtools/ono\");\n\nconst url = require(\"../util/url\");\n\nconst {\n  ResolverError\n} = require(\"../util/errors\");\n\nmodule.exports = {\n  /**\n   * The order that this resolver will run, in relation to other resolvers.\n   *\n   * @type {number}\n   */\n  order: 100,\n\n  /**\n   * Determines whether this resolver can read a given file reference.\n   * Resolvers that return true will be tried, in order, until one successfully resolves the file.\n   * Resolvers that return false will not be given a chance to resolve the file.\n   *\n   * @param {object} file           - An object containing information about the referenced file\n   * @param {string} file.url       - The full URL of the referenced file\n   * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n   * @returns {boolean}\n   */\n  canRead(file) {\n    return url.isFileSystemPath(file.url);\n  },\n\n  /**\n   * Reads the given file and returns its raw contents as a Buffer.\n   *\n   * @param {object} file           - An object containing information about the referenced file\n   * @param {string} file.url       - The full URL of the referenced file\n   * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n   * @returns {Promise<Buffer>}\n   */\n  read(file) {\n    return new Promise((resolve, reject) => {\n      let path;\n\n      try {\n        path = url.toFileSystemPath(file.url);\n      } catch (err) {\n        reject(new ResolverError(ono.uri(err, `Malformed URI: ${file.url}`), file.url));\n      } // console.log('Opening file: %s', path);\n\n\n      try {\n        fs.readFile(path, (err, data) => {\n          if (err) {\n            reject(new ResolverError(ono(err, `Error opening file \"${path}\"`), path));\n          } else {\n            resolve(data);\n          }\n        });\n      } catch (err) {\n        reject(new ResolverError(ono(err, `Error opening file \"${path}\"`), path));\n      }\n    });\n  }\n\n};","map":{"version":3,"sources":["/home/dev/Documentos/Projects/github-clone/node_modules/@apidevtools/json-schema-ref-parser/lib/resolvers/file.js"],"names":["fs","require","ono","url","ResolverError","module","exports","order","canRead","file","isFileSystemPath","read","Promise","resolve","reject","path","toFileSystemPath","err","uri","readFile","data"],"mappings":"AAAA;;AACA,MAAMA,EAAE,GAAGC,OAAO,CAAC,IAAD,CAAlB;;AACA,MAAM;AAAEC,EAAAA;AAAF,IAAUD,OAAO,CAAC,iBAAD,CAAvB;;AACA,MAAME,GAAG,GAAGF,OAAO,CAAC,aAAD,CAAnB;;AACA,MAAM;AAAEG,EAAAA;AAAF,IAAoBH,OAAO,CAAC,gBAAD,CAAjC;;AAEAI,MAAM,CAACC,OAAP,GAAiB;AACf;AACF;AACA;AACA;AACA;AACEC,EAAAA,KAAK,EAAE,GANQ;;AAQf;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACEC,EAAAA,OAAO,CAAEC,IAAF,EAAQ;AACb,WAAON,GAAG,CAACO,gBAAJ,CAAqBD,IAAI,CAACN,GAA1B,CAAP;AACD,GApBc;;AAsBf;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACEQ,EAAAA,IAAI,CAAEF,IAAF,EAAQ;AACV,WAAO,IAAIG,OAAJ,CAAa,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACvC,UAAIC,IAAJ;;AACA,UAAI;AACFA,QAAAA,IAAI,GAAGZ,GAAG,CAACa,gBAAJ,CAAqBP,IAAI,CAACN,GAA1B,CAAP;AACD,OAFD,CAGA,OAAOc,GAAP,EAAY;AACVH,QAAAA,MAAM,CAAC,IAAIV,aAAJ,CAAkBF,GAAG,CAACgB,GAAJ,CAAQD,GAAR,EAAc,kBAAiBR,IAAI,CAACN,GAAI,EAAxC,CAAlB,EAA8DM,IAAI,CAACN,GAAnE,CAAD,CAAN;AACD,OAPsC,CASvC;;;AAEA,UAAI;AACFH,QAAAA,EAAE,CAACmB,QAAH,CAAYJ,IAAZ,EAAkB,CAACE,GAAD,EAAMG,IAAN,KAAe;AAC/B,cAAIH,GAAJ,EAAS;AACPH,YAAAA,MAAM,CAAC,IAAIV,aAAJ,CAAkBF,GAAG,CAACe,GAAD,EAAO,uBAAsBF,IAAK,GAAlC,CAArB,EAA4DA,IAA5D,CAAD,CAAN;AACD,WAFD,MAGK;AACHF,YAAAA,OAAO,CAACO,IAAD,CAAP;AACD;AACF,SAPD;AAQD,OATD,CAUA,OAAOH,GAAP,EAAY;AACVH,QAAAA,MAAM,CAAC,IAAIV,aAAJ,CAAkBF,GAAG,CAACe,GAAD,EAAO,uBAAsBF,IAAK,GAAlC,CAArB,EAA4DA,IAA5D,CAAD,CAAN;AACD;AACF,KAxBM,CAAP;AAyBD;;AAxDc,CAAjB","sourcesContent":["\"use strict\";\nconst fs = require(\"fs\");\nconst { ono } = require(\"@jsdevtools/ono\");\nconst url = require(\"../util/url\");\nconst { ResolverError } = require(\"../util/errors\");\n\nmodule.exports = {\n  /**\n   * The order that this resolver will run, in relation to other resolvers.\n   *\n   * @type {number}\n   */\n  order: 100,\n\n  /**\n   * Determines whether this resolver can read a given file reference.\n   * Resolvers that return true will be tried, in order, until one successfully resolves the file.\n   * Resolvers that return false will not be given a chance to resolve the file.\n   *\n   * @param {object} file           - An object containing information about the referenced file\n   * @param {string} file.url       - The full URL of the referenced file\n   * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n   * @returns {boolean}\n   */\n  canRead (file) {\n    return url.isFileSystemPath(file.url);\n  },\n\n  /**\n   * Reads the given file and returns its raw contents as a Buffer.\n   *\n   * @param {object} file           - An object containing information about the referenced file\n   * @param {string} file.url       - The full URL of the referenced file\n   * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n   * @returns {Promise<Buffer>}\n   */\n  read (file) {\n    return new Promise(((resolve, reject) => {\n      let path;\n      try {\n        path = url.toFileSystemPath(file.url);\n      }\n      catch (err) {\n        reject(new ResolverError(ono.uri(err, `Malformed URI: ${file.url}`), file.url));\n      }\n\n      // console.log('Opening file: %s', path);\n\n      try {\n        fs.readFile(path, (err, data) => {\n          if (err) {\n            reject(new ResolverError(ono(err, `Error opening file \"${path}\"`), path));\n          }\n          else {\n            resolve(data);\n          }\n        });\n      }\n      catch (err) {\n        reject(new ResolverError(ono(err, `Error opening file \"${path}\"`), path));\n      }\n    }));\n  }\n};\n"]},"metadata":{},"sourceType":"script"}