{"ast":null,"code":"(function (root, factory) {\n  /* istanbul ignore next */\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define(['exports'], factory);\n  }\n  /* istanbul ignore else */\n  else if (typeof exports === 'object') {\n    // CommonJS\n    factory(exports);\n  } else {\n    // Browser globals\n    factory(root.promiseBreaker = {});\n  }\n})(this, function (exports) {\n  /* istanbul ignore next */\n  var globals = global || window;\n  /* Returns an array of `count` unique identifiers. */\n\n  function makeParams(count) {\n    var answer = [];\n\n    for (var i = 0; i < count; i++) {\n      answer.push('p' + i);\n    }\n\n    return answer;\n  }\n  /* Converts an array of parameter names into a comma delimited list. */\n\n\n  function toList(params, extraParam, appendComma) {\n    if (extraParam) {\n      params = params.concat([extraParam]);\n    }\n\n    return params.join(', ') + (appendComma && params.length ? ',' : '');\n  }\n  /* Returns true if `fn` is a function/ */\n\n\n  function isFunction(fn) {\n    var str = Object.prototype.toString.call(fn);\n    return !!fn && (typeof fn === 'object' || typeof fn === 'function') && (str === '[object Function]' || str === '[object AsyncFunction]');\n  }\n\n  function validatePromise(p) {\n    if (!p) {\n      throw new Error('Promise is undefined. Define Promise as global variable or call withPromise()');\n    }\n\n    if (!isFunction(p)) {\n      throw new Error('Expect Promise to be a constructor');\n    }\n  }\n  /* Note if `promiseImpl` is `null`, this will use globals.Promise. */\n\n\n  exports.withPromise = function (promiseImpl) {\n    // If a promise implementation is provided, we can validate it right away, and fail\n    // earlier.  If not, we can't validate globals.Promise, since globals.Promise might\n    // get polyfilled after promise-breaker is initialized.\n    if (promiseImpl) {\n      validatePromise(promiseImpl);\n    }\n\n    var pb = {};\n\n    pb.make = function (options, asyncFn) {\n      if (!asyncFn) {\n        asyncFn = options;\n        options = {};\n      }\n\n      if (!isFunction(asyncFn)) {\n        throw new Error('Function required');\n      }\n\n      if (!promiseImpl) {\n        validatePromise(globals.Promise);\n      }\n\n      var argumentCount = options.args || asyncFn.length;\n      var args = makeParams(argumentCount - 1);\n      var fn = new Function(['asyncFn', 'Promise'], 'return function(' + toList(args, 'done') + ') {\\n' + '    if(done) {\\n' + '        return asyncFn.call(this, ' + toList(args, 'done') + ');\\n' + '    } else {\\n' + '        var _this = this;\\n' + '        return new Promise(function(resolve, reject) {\\n' + '            asyncFn.call(_this, ' + toList(args, null, true) + ' function(err, result) {\\n' + '                if(err) {\\n' + '                    reject(err);\\n' + '                } else {\\n' + // If multiple arguments were passed to the callback, then turn them into an array.\n      '                    if(arguments.length > 2) {' + '                        resolve([].slice.call(arguments, 1));' + '                    } else {' + '                        resolve(result);\\n' + '                    }' + '                }\\n' + '            });\\n' + '        });\\n' + '    }\\n' + '};');\n      return fn(asyncFn, promiseImpl || globals.Promise);\n    };\n\n    pb['break'] = function (options, promiseFn) {\n      if (!promiseFn) {\n        promiseFn = options;\n        options = {};\n      }\n\n      if (!isFunction(promiseFn)) {\n        throw new Error('Function required');\n      }\n\n      var argumentCount = options.args || promiseFn.length;\n      var args = makeParams(argumentCount);\n      var params = ['this'].concat(args);\n      var fn = new Function(['promiseFn'], 'return function(' + toList(args, 'done') + ') {\\n' + '    if(done) {\\n' + // Call `done()` inside `setTimeout()`, so that if `done` throws an error, it will\n      // be turned into an uncaught exception, instead of being swallowed by the Promise.\n      '        promiseFn.call(' + toList(params) + ').then(\\n' + '            function(result) {setTimeout(function() {done(null, result);}, 0);},\\n' + '            function(err) {setTimeout(function() {done(err);}, 0);}\\n' + '        );\\n' + '        return null;\\n' + '    } else {\\n' + '        return promiseFn.call(' + toList(params) + ');\\n' + '    }\\n' + '};');\n      return fn(promiseFn);\n    };\n\n    pb.addPromise = function (done, fn) {\n      var answer = null;\n\n      if (done) {\n        fn(done);\n      } else {\n        answer = new Promise(function (resolve, reject) {\n          fn(function (err, result) {\n            if (err) {\n              reject(err);\n            } else if (arguments.length > 2) {\n              // If multiple arguments were passed to the callback, then turn them into an array.\n              resolve([].slice.call(arguments, 1));\n            } else {\n              resolve(result);\n            }\n          });\n        });\n      }\n\n      return answer;\n    };\n\n    pb.addCallback = function (done, promise) {\n      var answer;\n\n      if (!promise) {\n        throw new Error('addCallback() expected promise or function as second paramater');\n      } else if (isFunction(promise.then)) {\n        answer = promise;\n      } else if (isFunction(promise)) {\n        answer = Promise.resolve().then(function () {\n          return promise();\n        });\n      } else {\n        throw new Error(\"addCallback() don't know what to do with \" + typeof promise);\n      }\n\n      if (done) {\n        // Call `done()` inside `setTimeout()`, so that if `done` throws an error, it will\n        // be turned into an uncaught exception, instead of being swallowed by the Promise.\n        answer.then(function (result) {\n          setTimeout(function () {\n            done(null, result);\n          }, 0);\n        }, function (err) {\n          setTimeout(function () {\n            done(err);\n          }, 0);\n        });\n        answer = null;\n      }\n\n      return answer;\n    };\n\n    pb.applyFn = function (fn, argumentCount, thisArg, args, done) {\n      argumentCount = argumentCount || 0;\n      args = args || [];\n\n      if (fn.length > argumentCount + 1) {\n        return pb.addCallback(done, Promise.reject(new Error('Expected function with ' + argumentCount + ' or fewer arguments which returns Promise, ' + 'or function with ' + (argumentCount + 1) + ' arguments which takes callback - got function with ' + fn.length + ' arguments.')));\n      }\n\n      return pb.addCallback(done, Promise.resolve().then(function () {\n        var isCallbackFn = argumentCount < fn.length;\n        var donePromise;\n\n        if (args.length < argumentCount || isCallbackFn) {\n          // Clone args\n          args = args.slice(0); // Fill with undefineds.\n\n          while (args.length < argumentCount) {\n            args.push(undefined);\n          } // Add a callback to `args` if required.\n\n\n          if (isCallbackFn) {\n            donePromise = new (promiseImpl || globals.Promise)(function (resolve, reject) {\n              // Pass in a callback.\n              args[argumentCount] = function (err, result) {\n                if (err) {\n                  reject(err);\n                } else {\n                  resolve(result);\n                }\n              };\n            });\n          }\n        }\n\n        var returnedPromise = fn.apply(thisArg, args);\n        return donePromise || returnedPromise;\n      }));\n    };\n\n    pb.apply = function (fn, thisArg, args, done) {\n      args = args || [];\n      return pb.applyFn(fn, args.length, thisArg, args, done);\n    };\n\n    pb.callFn = function (fn, argumentCount, thisArg) {\n      argumentCount = argumentCount || 0;\n      var maxArgumentsToFetch = Math.min(arguments.length - 3, argumentCount);\n      var args = [];\n\n      if (maxArgumentsToFetch > 0) {\n        args = [].slice.call(arguments, 3, 3 + maxArgumentsToFetch);\n      } // Fetch `done` if it's there.\n\n\n      var done = arguments[3 + argumentCount];\n      return pb.applyFn(fn, argumentCount, thisArg, args, done);\n    };\n\n    pb.call = function (fn, thisArg) {\n      var args = [].slice.call(arguments, 2);\n      return pb.applyFn(fn, args.length, thisArg, args);\n    };\n\n    pb.callWithCb = function (fn, thisArg) {\n      var args = [].slice.call(arguments, 2, arguments.length - 1);\n      var done = arguments[arguments.length - 1];\n\n      if (!isFunction(done)) {\n        throw new Error('callWithCb requires function as last parameter.');\n      }\n\n      return pb.applyFn(fn, args.length, thisArg, args, done);\n    };\n\n    return pb;\n  };\n\n  var usingDefaultPromise = exports.withPromise();\n\n  for (var k in usingDefaultPromise) {\n    /* istanbul ignore else */\n    if ({}.hasOwnProperty.call(usingDefaultPromise, k)) {\n      exports[k] = usingDefaultPromise[k];\n    }\n  }\n\n  exports.usingDefaultPromise = usingDefaultPromise;\n});","map":{"version":3,"sources":["/home/dev/Documentos/Projects/github-clone/node_modules/promise-breaker/index.js"],"names":["root","factory","define","amd","exports","promiseBreaker","globals","global","window","makeParams","count","answer","i","push","toList","params","extraParam","appendComma","concat","join","length","isFunction","fn","str","Object","prototype","toString","call","validatePromise","p","Error","withPromise","promiseImpl","pb","make","options","asyncFn","Promise","argumentCount","args","Function","promiseFn","addPromise","done","resolve","reject","err","result","arguments","slice","addCallback","promise","then","setTimeout","applyFn","thisArg","isCallbackFn","donePromise","undefined","returnedPromise","apply","callFn","maxArgumentsToFetch","Math","min","callWithCb","usingDefaultPromise","k","hasOwnProperty"],"mappings":"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","sourcesContent":["(function(root, factory) {\n    /* istanbul ignore next */\n    if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define(['exports'], factory);\n    } /* istanbul ignore else */ else if (typeof exports === 'object') {\n        // CommonJS\n        factory(exports);\n    } else {\n        // Browser globals\n        factory((root.promiseBreaker = {}));\n    }\n})(this, function(exports) {\n    /* istanbul ignore next */\n    var globals = global || window;\n\n    /* Returns an array of `count` unique identifiers. */\n    function makeParams(count) {\n        var answer = [];\n        for (var i = 0; i < count; i++) {\n            answer.push('p' + i);\n        }\n        return answer;\n    }\n\n    /* Converts an array of parameter names into a comma delimited list. */\n    function toList(params, extraParam, appendComma) {\n        if (extraParam) {\n            params = params.concat([extraParam]);\n        }\n        return params.join(', ') + (appendComma && params.length ? ',' : '');\n    }\n\n    /* Returns true if `fn` is a function/ */\n    function isFunction(fn) {\n        var str = Object.prototype.toString.call(fn);\n        return (\n            !!fn &&\n            (typeof fn === 'object' || typeof fn === 'function') &&\n            (str === '[object Function]' || str === '[object AsyncFunction]')\n        );\n    }\n\n    function validatePromise(p) {\n        if (!p) {\n            throw new Error(\n                'Promise is undefined. Define Promise as global variable or call withPromise()'\n            );\n        }\n        if (!isFunction(p)) {\n            throw new Error('Expect Promise to be a constructor');\n        }\n    }\n\n    /* Note if `promiseImpl` is `null`, this will use globals.Promise. */\n    exports.withPromise = function(promiseImpl) {\n        // If a promise implementation is provided, we can validate it right away, and fail\n        // earlier.  If not, we can't validate globals.Promise, since globals.Promise might\n        // get polyfilled after promise-breaker is initialized.\n        if (promiseImpl) {\n            validatePromise(promiseImpl);\n        }\n\n        var pb = {};\n\n        pb.make = function(options, asyncFn) {\n            if (!asyncFn) {\n                asyncFn = options;\n                options = {};\n            }\n\n            if (!isFunction(asyncFn)) {\n                throw new Error('Function required');\n            }\n            if (!promiseImpl) {\n                validatePromise(globals.Promise);\n            }\n\n            var argumentCount = options.args || asyncFn.length;\n            var args = makeParams(argumentCount - 1);\n\n            var fn = new Function(\n                ['asyncFn', 'Promise'],\n                'return function(' +\n                    toList(args, 'done') +\n                    ') {\\n' +\n                    '    if(done) {\\n' +\n                    '        return asyncFn.call(this, ' +\n                    toList(args, 'done') +\n                    ');\\n' +\n                    '    } else {\\n' +\n                    '        var _this = this;\\n' +\n                    '        return new Promise(function(resolve, reject) {\\n' +\n                    '            asyncFn.call(_this, ' +\n                    toList(args, null, true) +\n                    ' function(err, result) {\\n' +\n                    '                if(err) {\\n' +\n                    '                    reject(err);\\n' +\n                    '                } else {\\n' +\n                    // If multiple arguments were passed to the callback, then turn them into an array.\n                    '                    if(arguments.length > 2) {' +\n                    '                        resolve([].slice.call(arguments, 1));' +\n                    '                    } else {' +\n                    '                        resolve(result);\\n' +\n                    '                    }' +\n                    '                }\\n' +\n                    '            });\\n' +\n                    '        });\\n' +\n                    '    }\\n' +\n                    '};'\n            );\n            return fn(asyncFn, promiseImpl || globals.Promise);\n        };\n\n        pb['break'] = function(options, promiseFn) {\n            if (!promiseFn) {\n                promiseFn = options;\n                options = {};\n            }\n\n            if (!isFunction(promiseFn)) {\n                throw new Error('Function required');\n            }\n\n            var argumentCount = options.args || promiseFn.length;\n            var args = makeParams(argumentCount);\n            var params = ['this'].concat(args);\n\n            var fn = new Function(\n                ['promiseFn'],\n                'return function(' +\n                    toList(args, 'done') +\n                    ') {\\n' +\n                    '    if(done) {\\n' +\n                    // Call `done()` inside `setTimeout()`, so that if `done` throws an error, it will\n                    // be turned into an uncaught exception, instead of being swallowed by the Promise.\n                    '        promiseFn.call(' +\n                    toList(params) +\n                    ').then(\\n' +\n                    '            function(result) {setTimeout(function() {done(null, result);}, 0);},\\n' +\n                    '            function(err) {setTimeout(function() {done(err);}, 0);}\\n' +\n                    '        );\\n' +\n                    '        return null;\\n' +\n                    '    } else {\\n' +\n                    '        return promiseFn.call(' +\n                    toList(params) +\n                    ');\\n' +\n                    '    }\\n' +\n                    '};'\n            );\n            return fn(promiseFn);\n        };\n\n        pb.addPromise = function(done, fn) {\n            var answer = null;\n            if (done) {\n                fn(done);\n            } else {\n                answer = new Promise(function(resolve, reject) {\n                    fn(function(err, result) {\n                        if (err) {\n                            reject(err);\n                        } else if (arguments.length > 2) {\n                            // If multiple arguments were passed to the callback, then turn them into an array.\n                            resolve([].slice.call(arguments, 1));\n                        } else {\n                            resolve(result);\n                        }\n                    });\n                });\n            }\n            return answer;\n        };\n\n        pb.addCallback = function(done, promise) {\n            var answer;\n            if (!promise) {\n                throw new Error('addCallback() expected promise or function as second paramater');\n            } else if (isFunction(promise.then)) {\n                answer = promise;\n            } else if (isFunction(promise)) {\n                answer = Promise.resolve().then(function() {\n                    return promise();\n                });\n            } else {\n                throw new Error(\"addCallback() don't know what to do with \" + typeof promise);\n            }\n\n            if (done) {\n                // Call `done()` inside `setTimeout()`, so that if `done` throws an error, it will\n                // be turned into an uncaught exception, instead of being swallowed by the Promise.\n                answer.then(\n                    function(result) {\n                        setTimeout(function() {\n                            done(null, result);\n                        }, 0);\n                    },\n                    function(err) {\n                        setTimeout(function() {\n                            done(err);\n                        }, 0);\n                    }\n                );\n                answer = null;\n            }\n\n            return answer;\n        };\n\n        pb.applyFn = function(fn, argumentCount, thisArg, args, done) {\n            argumentCount = argumentCount || 0;\n            args = args || [];\n\n            if (fn.length > argumentCount + 1) {\n                return pb.addCallback(\n                    done,\n                    Promise.reject(\n                        new Error(\n                            'Expected function with ' +\n                                argumentCount +\n                                ' or fewer arguments which returns Promise, ' +\n                                'or function with ' +\n                                (argumentCount + 1) +\n                                ' arguments which takes callback - got function with ' +\n                                fn.length +\n                                ' arguments.'\n                        )\n                    )\n                );\n            }\n\n            return pb.addCallback(\n                done,\n                Promise.resolve().then(function() {\n                    var isCallbackFn = argumentCount < fn.length;\n                    var donePromise;\n\n                    if (args.length < argumentCount || isCallbackFn) {\n                        // Clone args\n                        args = args.slice(0);\n\n                        // Fill with undefineds.\n                        while (args.length < argumentCount) {\n                            args.push(undefined);\n                        }\n\n                        // Add a callback to `args` if required.\n                        if (isCallbackFn) {\n                            donePromise = new (promiseImpl || globals.Promise)(function(\n                                resolve,\n                                reject\n                            ) {\n                                // Pass in a callback.\n                                args[argumentCount] = function(err, result) {\n                                    if (err) {\n                                        reject(err);\n                                    } else {\n                                        resolve(result);\n                                    }\n                                };\n                            });\n                        }\n                    }\n\n                    var returnedPromise = fn.apply(thisArg, args);\n                    return donePromise || returnedPromise;\n                })\n            );\n        };\n\n        pb.apply = function(fn, thisArg, args, done) {\n            args = args || [];\n            return pb.applyFn(fn, args.length, thisArg, args, done);\n        };\n\n        pb.callFn = function(fn, argumentCount, thisArg) {\n            argumentCount = argumentCount || 0;\n\n            var maxArgumentsToFetch = Math.min(arguments.length - 3, argumentCount);\n            var args = [];\n            if (maxArgumentsToFetch > 0) {\n                args = [].slice.call(arguments, 3, 3 + maxArgumentsToFetch);\n            }\n\n            // Fetch `done` if it's there.\n            var done = arguments[3 + argumentCount];\n\n            return pb.applyFn(fn, argumentCount, thisArg, args, done);\n        };\n\n        pb.call = function(fn, thisArg) {\n            var args = [].slice.call(arguments, 2);\n            return pb.applyFn(fn, args.length, thisArg, args);\n        };\n\n        pb.callWithCb = function(fn, thisArg) {\n            var args = [].slice.call(arguments, 2, arguments.length - 1);\n            var done = arguments[arguments.length - 1];\n            if (!isFunction(done)) {\n                throw new Error('callWithCb requires function as last parameter.');\n            }\n            return pb.applyFn(fn, args.length, thisArg, args, done);\n        };\n\n        return pb;\n    };\n\n    var usingDefaultPromise = exports.withPromise();\n    for (var k in usingDefaultPromise) {\n        /* istanbul ignore else */\n        if ({}.hasOwnProperty.call(usingDefaultPromise, k)) {\n            exports[k] = usingDefaultPromise[k];\n        }\n    }\n\n    exports.usingDefaultPromise = usingDefaultPromise;\n});\n"]},"metadata":{},"sourceType":"script"}