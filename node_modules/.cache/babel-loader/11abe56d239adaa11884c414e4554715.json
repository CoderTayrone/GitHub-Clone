{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.generateBodyParser = exports.generateStringParser = void 0;\n\nconst jsonPtr = __importStar(require(\"json-ptr\"));\n\nconst querystring_1 = __importDefault(require(\"querystring\"));\n\nconst BodyParserWrapper_1 = __importDefault(require(\"../bodyParsers/BodyParserWrapper\"));\n\nconst json_schema_resolve_ref_1 = require(\"../utils/json-schema-resolve-ref\");\n\nconst jsonSchema_1 = require(\"../utils/jsonSchema\");\n\nconst parameterParsers_1 = require(\"./parameterParsers\"); // OAS3 has special handling for 'application/x-www-form-urlencoded'.  Parameters\n// and bodies of this type are allowed to define an `encoding` section with\n// special treatment for specific properties.  This handles generating a parser\n// for this content-type.\n// Find a property in a JSON Schema.\n\n\nfunction findProperty(path, schema, propertyName) {\n  if (schema.properties && schema.properties[propertyName]) {\n    return path;\n  }\n\n  const allOf = schema.allOf || [];\n\n  for (let index = 0; index < allOf.length; index++) {\n    const childSchema = json_schema_resolve_ref_1.resolveRef(schema, allOf[index]);\n    const answer = findProperty(path.concat(['allOf', `${index}`]), childSchema, propertyName);\n\n    if (answer) {\n      return answer;\n    }\n  }\n\n  return undefined;\n}\n\nfunction generateStringParser(context, mediaType, parameterLocation) {\n  const parameterParsers = [];\n\n  if (mediaType.encoding) {\n    if (!mediaType.schema) {\n      throw new Error(`Media Type Object ${context.jsonPointer} with 'content' must have a 'schema'`);\n    } // Find the schema object for the mediaType.\n\n\n    const schema = json_schema_resolve_ref_1.resolveRef(context.openApiDoc, `${context.jsonPointer}/schema`); // The encoding object describes how parameters should be parsed from the document.\n\n    for (const parameterName of Object.keys(mediaType.encoding)) {\n      const encoding = mediaType.encoding[parameterName];\n      const parameterSchemaPath = findProperty([], schema, parameterName);\n\n      if (!parameterSchemaPath) {\n        throw new Error(`Cannot find parameter ${parameterName} in schema for ${context.jsonPointer}`);\n      }\n\n      const parameterSchema = jsonSchema_1.extractSchema(context.openApiDoc, jsonPtr.encodePointer(parameterSchemaPath));\n      let parameterDescriptor;\n\n      if (encoding.contentType) {\n        const parser = context.options.parameterParsers.get(encoding.contentType);\n\n        if (!parser) {\n          throw new Error(`No string parser found for ${encoding.contentType} in ${context.jsonPointer}`);\n        }\n\n        parameterDescriptor = {\n          contentType: encoding.contentType,\n          parser,\n          uriEncoded: true,\n          schema: parameterSchema\n        };\n      } else {\n        parameterDescriptor = {\n          style: encoding.style || 'form',\n          explode: encoding.explode || false,\n          allowReserved: encoding.allowReserved || false,\n          schema: parameterSchema\n        };\n      }\n\n      parameterParsers.push({\n        location: {\n          in: parameterLocation.in,\n          name: parameterName,\n          docPath: context.childContext(['encoding', parameterName]).jsonPointer\n        },\n        parser: parameterParsers_1.generateParser(parameterDescriptor)\n      });\n    }\n  }\n\n  return {\n    parseString(encoded) {\n      const rawResult = querystring_1.default.parse(encoded);\n      const parsedResult = parameterParsers_1.parseQueryParameters(parameterParsers, encoded);\n      return Object.assign(rawResult, parsedResult);\n    }\n\n  };\n}\n\nexports.generateStringParser = generateStringParser;\n\nfunction generateBodyParser(context, mediaType, parameterLocation) {\n  const stringParser = generateStringParser(context, mediaType, parameterLocation);\n  return new BodyParserWrapper_1.default(stringParser, context.options.defaultMaxBodySize);\n}\n\nexports.generateBodyParser = generateBodyParser;","map":{"version":3,"sources":["../../src/oas3/urlEncodedBodyParser.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.generateBodyParser = exports.generateStringParser = void 0;\nconst jsonPtr = __importStar(require(\"json-ptr\"));\nconst querystring_1 = __importDefault(require(\"querystring\"));\nconst BodyParserWrapper_1 = __importDefault(require(\"../bodyParsers/BodyParserWrapper\"));\nconst json_schema_resolve_ref_1 = require(\"../utils/json-schema-resolve-ref\");\nconst jsonSchema_1 = require(\"../utils/jsonSchema\");\nconst parameterParsers_1 = require(\"./parameterParsers\");\n// OAS3 has special handling for 'application/x-www-form-urlencoded'.  Parameters\n// and bodies of this type are allowed to define an `encoding` section with\n// special treatment for specific properties.  This handles generating a parser\n// for this content-type.\n// Find a property in a JSON Schema.\nfunction findProperty(path, schema, propertyName) {\n    if (schema.properties && schema.properties[propertyName]) {\n        return path;\n    }\n    const allOf = schema.allOf || [];\n    for (let index = 0; index < allOf.length; index++) {\n        const childSchema = json_schema_resolve_ref_1.resolveRef(schema, allOf[index]);\n        const answer = findProperty(path.concat(['allOf', `${index}`]), childSchema, propertyName);\n        if (answer) {\n            return answer;\n        }\n    }\n    return undefined;\n}\nfunction generateStringParser(context, mediaType, parameterLocation) {\n    const parameterParsers = [];\n    if (mediaType.encoding) {\n        if (!mediaType.schema) {\n            throw new Error(`Media Type Object ${context.jsonPointer} with 'content' must have a 'schema'`);\n        }\n        // Find the schema object for the mediaType.\n        const schema = json_schema_resolve_ref_1.resolveRef(context.openApiDoc, `${context.jsonPointer}/schema`);\n        // The encoding object describes how parameters should be parsed from the document.\n        for (const parameterName of Object.keys(mediaType.encoding)) {\n            const encoding = mediaType.encoding[parameterName];\n            const parameterSchemaPath = findProperty([], schema, parameterName);\n            if (!parameterSchemaPath) {\n                throw new Error(`Cannot find parameter ${parameterName} in schema for ${context.jsonPointer}`);\n            }\n            const parameterSchema = jsonSchema_1.extractSchema(context.openApiDoc, jsonPtr.encodePointer(parameterSchemaPath));\n            let parameterDescriptor;\n            if (encoding.contentType) {\n                const parser = context.options.parameterParsers.get(encoding.contentType);\n                if (!parser) {\n                    throw new Error(`No string parser found for ${encoding.contentType} in ${context.jsonPointer}`);\n                }\n                parameterDescriptor = {\n                    contentType: encoding.contentType,\n                    parser,\n                    uriEncoded: true,\n                    schema: parameterSchema,\n                };\n            }\n            else {\n                parameterDescriptor = {\n                    style: encoding.style || 'form',\n                    explode: encoding.explode || false,\n                    allowReserved: encoding.allowReserved || false,\n                    schema: parameterSchema,\n                };\n            }\n            parameterParsers.push({\n                location: {\n                    in: parameterLocation.in,\n                    name: parameterName,\n                    docPath: context.childContext(['encoding', parameterName]).jsonPointer,\n                },\n                parser: parameterParsers_1.generateParser(parameterDescriptor),\n            });\n        }\n    }\n    return {\n        parseString(encoded) {\n            const rawResult = querystring_1.default.parse(encoded);\n            const parsedResult = parameterParsers_1.parseQueryParameters(parameterParsers, encoded);\n            return Object.assign(rawResult, parsedResult);\n        },\n    };\n}\nexports.generateStringParser = generateStringParser;\nfunction generateBodyParser(context, mediaType, parameterLocation) {\n    const stringParser = generateStringParser(context, mediaType, parameterLocation);\n    return new BodyParserWrapper_1.default(stringParser, context.options.defaultMaxBodySize);\n}\nexports.generateBodyParser = generateBodyParser;\n//# sourceMappingURL=urlEncodedBodyParser.js.map"]},"metadata":{},"sourceType":"script"}