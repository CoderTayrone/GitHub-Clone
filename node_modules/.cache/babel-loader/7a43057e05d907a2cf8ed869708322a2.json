{"ast":null,"code":"\"use strict\";\n/*\nCopyright (c) 2014 Petka Antonov\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\nfunction Url() {\n  //For more efficient internal representation and laziness.\n  //The non-underscore versions of these properties are accessor functions\n  //defined on the prototype.\n  this._protocol = null;\n  this._href = \"\";\n  this._port = -1;\n  this._query = null;\n  this.auth = null;\n  this.slashes = null;\n  this.host = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.pathname = null;\n  this._prependSlash = false;\n}\n\nvar querystring = require(\"querystring\");\n\nUrl.queryString = querystring;\n\nUrl.prototype.parse = function Url$parse(str, parseQueryString, hostDenotesSlash, disableAutoEscapeChars) {\n  if (typeof str !== \"string\") {\n    throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof str);\n  }\n\n  var start = 0;\n  var end = str.length - 1; //Trim leading and trailing ws\n\n  while (str.charCodeAt(start) <= 0x20\n  /*' '*/\n  ) start++;\n\n  while (str.charCodeAt(end) <= 0x20\n  /*' '*/\n  ) end--;\n\n  start = this._parseProtocol(str, start, end); //Javascript doesn't have host\n\n  if (this._protocol !== \"javascript\") {\n    start = this._parseHost(str, start, end, hostDenotesSlash);\n    var proto = this._protocol;\n\n    if (!this.hostname && (this.slashes || proto && !slashProtocols[proto])) {\n      this.hostname = this.host = \"\";\n    }\n  }\n\n  if (start <= end) {\n    var ch = str.charCodeAt(start);\n\n    if (ch === 0x2F\n    /*'/'*/\n    || ch === 0x5C\n    /*'\\'*/\n    ) {\n      this._parsePath(str, start, end, disableAutoEscapeChars);\n    } else if (ch === 0x3F\n    /*'?'*/\n    ) {\n      this._parseQuery(str, start, end, disableAutoEscapeChars);\n    } else if (ch === 0x23\n    /*'#'*/\n    ) {\n      this._parseHash(str, start, end, disableAutoEscapeChars);\n    } else if (this._protocol !== \"javascript\") {\n      this._parsePath(str, start, end, disableAutoEscapeChars);\n    } else {\n      //For javascript the pathname is just the rest of it\n      this.pathname = str.slice(start, end + 1);\n    }\n  }\n\n  if (!this.pathname && this.hostname && this._slashProtocols[this._protocol]) {\n    this.pathname = \"/\";\n  }\n\n  if (parseQueryString) {\n    var search = this.search;\n\n    if (search == null) {\n      search = this.search = \"\";\n    }\n\n    if (search.charCodeAt(0) === 0x3F\n    /*'?'*/\n    ) {\n      search = search.slice(1);\n    } //This calls a setter function, there is no .query data property\n\n\n    this.query = Url.queryString.parse(search);\n  }\n};\n\nUrl.prototype.resolve = function Url$resolve(relative) {\n  return this.resolveObject(Url.parse(relative, false, true)).format();\n};\n\nUrl.prototype.format = function Url$format() {\n  var auth = this.auth || \"\";\n\n  if (auth) {\n    auth = encodeURIComponent(auth);\n    auth = auth.replace(/%3A/i, \":\");\n    auth += \"@\";\n  }\n\n  var protocol = this.protocol || \"\";\n  var pathname = this.pathname || \"\";\n  var hash = this.hash || \"\";\n  var search = this.search || \"\";\n  var query = \"\";\n  var hostname = this.hostname || \"\";\n  var port = this.port || \"\";\n  var host = false;\n  var scheme = \"\"; //Cache the result of the getter function\n\n  var q = this.query;\n\n  if (q && typeof q === \"object\") {\n    query = Url.queryString.stringify(q);\n  }\n\n  if (!search) {\n    search = query ? \"?\" + query : \"\";\n  }\n\n  if (protocol && protocol.charCodeAt(protocol.length - 1) !== 0x3A\n  /*':'*/\n  ) protocol += \":\";\n\n  if (this.host) {\n    host = auth + this.host;\n  } else if (hostname) {\n    var ip6 = hostname.indexOf(\":\") > -1;\n    if (ip6) hostname = \"[\" + hostname + \"]\";\n    host = auth + hostname + (port ? \":\" + port : \"\");\n  }\n\n  var slashes = this.slashes || (!protocol || slashProtocols[protocol]) && host !== false;\n  if (protocol) scheme = protocol + (slashes ? \"//\" : \"\");else if (slashes) scheme = \"//\";\n\n  if (slashes && pathname && pathname.charCodeAt(0) !== 0x2F\n  /*'/'*/\n  ) {\n    pathname = \"/\" + pathname;\n  }\n\n  if (search && search.charCodeAt(0) !== 0x3F\n  /*'?'*/\n  ) search = \"?\" + search;\n  if (hash && hash.charCodeAt(0) !== 0x23\n  /*'#'*/\n  ) hash = \"#\" + hash;\n  pathname = escapePathName(pathname);\n  search = escapeSearch(search);\n  return scheme + (host === false ? \"\" : host) + pathname + search + hash;\n};\n\nUrl.prototype.resolveObject = function Url$resolveObject(relative) {\n  if (typeof relative === \"string\") relative = Url.parse(relative, false, true);\n\n  var result = this._clone(); // hash is always overridden, no matter what.\n  // even href=\"\" will remove it.\n\n\n  result.hash = relative.hash; // if the relative url is empty, then there\"s nothing left to do here.\n\n  if (!relative.href) {\n    result._href = \"\";\n    return result;\n  } // hrefs like //foo/bar always cut to the protocol.\n\n\n  if (relative.slashes && !relative._protocol) {\n    relative._copyPropsTo(result, true);\n\n    if (slashProtocols[result._protocol] && result.hostname && !result.pathname) {\n      result.pathname = \"/\";\n    }\n\n    result._href = \"\";\n    return result;\n  }\n\n  if (relative._protocol && relative._protocol !== result._protocol) {\n    // if it\"s a known url protocol, then changing\n    // the protocol does weird things\n    // first, if it\"s not file:, then we MUST have a host,\n    // and if there was a path\n    // to begin with, then we MUST have a path.\n    // if it is file:, then the host is dropped,\n    // because that\"s known to be hostless.\n    // anything else is assumed to be absolute.\n    if (!slashProtocols[relative._protocol]) {\n      relative._copyPropsTo(result, false);\n\n      result._href = \"\";\n      return result;\n    }\n\n    result._protocol = relative._protocol;\n\n    if (!relative.host && relative._protocol !== \"javascript\") {\n      var relPath = (relative.pathname || \"\").split(\"/\");\n\n      while (relPath.length && !(relative.host = relPath.shift()));\n\n      if (!relative.host) relative.host = \"\";\n      if (!relative.hostname) relative.hostname = \"\";\n      if (relPath[0] !== \"\") relPath.unshift(\"\");\n      if (relPath.length < 2) relPath.unshift(\"\");\n      result.pathname = relPath.join(\"/\");\n    } else {\n      result.pathname = relative.pathname;\n    }\n\n    result.search = relative.search;\n    result.host = relative.host || \"\";\n    result.auth = relative.auth;\n    result.hostname = relative.hostname || relative.host;\n    result._port = relative._port;\n    result.slashes = result.slashes || relative.slashes;\n    result._href = \"\";\n    return result;\n  }\n\n  var isSourceAbs = result.pathname && result.pathname.charCodeAt(0) === 0x2F\n  /*'/'*/\n  ;\n  var isRelAbs = relative.host || relative.pathname && relative.pathname.charCodeAt(0) === 0x2F\n  /*'/'*/\n  ;\n  var mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname;\n  var removeAllDots = mustEndAbs;\n  var srcPath = result.pathname && result.pathname.split(\"/\") || [];\n  var relPath = relative.pathname && relative.pathname.split(\"/\") || [];\n  var psychotic = result._protocol && !slashProtocols[result._protocol]; // if the url is a non-slashed url, then relative\n  // links like ../.. should be able\n  // to crawl up to the hostname, as well.  This is strange.\n  // result.protocol has already been set by now.\n  // Later on, put the first path part into the host field.\n\n  if (psychotic) {\n    result.hostname = \"\";\n    result._port = -1;\n\n    if (result.host) {\n      if (srcPath[0] === \"\") srcPath[0] = result.host;else srcPath.unshift(result.host);\n    }\n\n    result.host = \"\";\n\n    if (relative._protocol) {\n      relative.hostname = \"\";\n      relative._port = -1;\n\n      if (relative.host) {\n        if (relPath[0] === \"\") relPath[0] = relative.host;else relPath.unshift(relative.host);\n      }\n\n      relative.host = \"\";\n    }\n\n    mustEndAbs = mustEndAbs && (relPath[0] === \"\" || srcPath[0] === \"\");\n  }\n\n  if (isRelAbs) {\n    // it\"s absolute.\n    result.host = relative.host ? relative.host : result.host;\n    result.hostname = relative.hostname ? relative.hostname : result.hostname;\n    result.search = relative.search;\n    srcPath = relPath; // fall through to the dot-handling below.\n  } else if (relPath.length) {\n    // it\"s relative\n    // throw away the existing file, and take the new path instead.\n    if (!srcPath) srcPath = [];\n    srcPath.pop();\n    srcPath = srcPath.concat(relPath);\n    result.search = relative.search;\n  } else if (relative.search) {\n    // just pull out the search.\n    // like href=\"?foo\".\n    // Put this after the other two cases because it simplifies the booleans\n    if (psychotic) {\n      result.hostname = result.host = srcPath.shift(); //occationaly the auth can get stuck only in host\n      //this especialy happens in cases like\n      //url.resolveObject(\"mailto:local1@domain1\", \"local2@domain2\")\n\n      var authInHost = result.host && result.host.indexOf(\"@\") > 0 ? result.host.split(\"@\") : false;\n\n      if (authInHost) {\n        result.auth = authInHost.shift();\n        result.host = result.hostname = authInHost.shift();\n      }\n    }\n\n    result.search = relative.search;\n    result._href = \"\";\n    return result;\n  }\n\n  if (!srcPath.length) {\n    // no path at all.  easy.\n    // we\"ve already handled the other stuff above.\n    result.pathname = null;\n    result._href = \"\";\n    return result;\n  } // if a url ENDs in . or .., then it must get a trailing slash.\n  // however, if it ends in anything else non-slashy,\n  // then it must NOT get a trailing slash.\n\n\n  var last = srcPath.slice(-1)[0];\n  var hasTrailingSlash = (result.host || relative.host) && (last === \".\" || last === \"..\") || last === \"\"; // strip single dots, resolve double dots to parent dir\n  // if the path tries to go above the root, `up` ends up > 0\n\n  var up = 0;\n\n  for (var i = srcPath.length; i >= 0; i--) {\n    last = srcPath[i];\n\n    if (last === \".\") {\n      srcPath.splice(i, 1);\n    } else if (last === \"..\") {\n      srcPath.splice(i, 1);\n      up++;\n    } else if (up) {\n      srcPath.splice(i, 1);\n      up--;\n    }\n  } // if the path is allowed to go above the root, restore leading ..s\n\n\n  if (!mustEndAbs && !removeAllDots) {\n    for (; up--; up) {\n      srcPath.unshift(\"..\");\n    }\n  }\n\n  if (mustEndAbs && srcPath[0] !== \"\" && (!srcPath[0] || srcPath[0].charCodeAt(0) !== 0x2F\n  /*'/'*/\n  )) {\n    srcPath.unshift(\"\");\n  }\n\n  if (hasTrailingSlash && srcPath.join(\"/\").substr(-1) !== \"/\") {\n    srcPath.push(\"\");\n  }\n\n  var isAbsolute = srcPath[0] === \"\" || srcPath[0] && srcPath[0].charCodeAt(0) === 0x2F\n  /*'/'*/\n  ; // put the host back\n\n  if (psychotic) {\n    result.hostname = result.host = isAbsolute ? \"\" : srcPath.length ? srcPath.shift() : \"\"; //occationaly the auth can get stuck only in host\n    //this especialy happens in cases like\n    //url.resolveObject(\"mailto:local1@domain1\", \"local2@domain2\")\n\n    var authInHost = result.host && result.host.indexOf(\"@\") > 0 ? result.host.split(\"@\") : false;\n\n    if (authInHost) {\n      result.auth = authInHost.shift();\n      result.host = result.hostname = authInHost.shift();\n    }\n  }\n\n  mustEndAbs = mustEndAbs || result.host && srcPath.length;\n\n  if (mustEndAbs && !isAbsolute) {\n    srcPath.unshift(\"\");\n  }\n\n  result.pathname = srcPath.length === 0 ? null : srcPath.join(\"/\");\n  result.auth = relative.auth || result.auth;\n  result.slashes = result.slashes || relative.slashes;\n  result._href = \"\";\n  return result;\n};\n\nvar punycode = require(\"punycode\");\n\nUrl.prototype._hostIdna = function Url$_hostIdna(hostname) {\n  // IDNA Support: Returns a punycoded representation of \"domain\".\n  // It only converts parts of the domain name that\n  // have non-ASCII characters, i.e. it doesn't matter if\n  // you call it with a domain that already is ASCII-only.\n  return punycode.toASCII(hostname);\n};\n\nvar escapePathName = Url.prototype._escapePathName = function Url$_escapePathName(pathname) {\n  if (!containsCharacter2(pathname, 0x23\n  /*'#'*/\n  , 0x3F\n  /*'?'*/\n  )) {\n    return pathname;\n  } //Avoid closure creation to keep this inlinable\n\n\n  return _escapePath(pathname);\n};\n\nvar escapeSearch = Url.prototype._escapeSearch = function Url$_escapeSearch(search) {\n  if (!containsCharacter2(search, 0x23\n  /*'#'*/\n  , -1)) return search; //Avoid closure creation to keep this inlinable\n\n  return _escapeSearch(search);\n};\n\nUrl.prototype._parseProtocol = function Url$_parseProtocol(str, start, end) {\n  var doLowerCase = false;\n  var protocolCharacters = this._protocolCharacters;\n\n  for (var i = start; i <= end; ++i) {\n    var ch = str.charCodeAt(i);\n\n    if (ch === 0x3A\n    /*':'*/\n    ) {\n      var protocol = str.slice(start, i);\n      if (doLowerCase) protocol = protocol.toLowerCase();\n      this._protocol = protocol;\n      return i + 1;\n    } else if (protocolCharacters[ch] === 1) {\n      if (ch < 0x61\n      /*'a'*/\n      ) doLowerCase = true;\n    } else {\n      return start;\n    }\n  }\n\n  return start;\n};\n\nUrl.prototype._parseAuth = function Url$_parseAuth(str, start, end, decode) {\n  var auth = str.slice(start, end + 1);\n\n  if (decode) {\n    auth = decodeURIComponent(auth);\n  }\n\n  this.auth = auth;\n};\n\nUrl.prototype._parsePort = function Url$_parsePort(str, start, end) {\n  //Internal format is integer for more efficient parsing\n  //and for efficient trimming of leading zeros\n  var port = 0; //Distinguish between :0 and : (no port number at all)\n\n  var hadChars = false;\n  var validPort = true;\n\n  for (var i = start; i <= end; ++i) {\n    var ch = str.charCodeAt(i);\n\n    if (0x30\n    /*'0'*/\n    <= ch && ch <= 0x39\n    /*'9'*/\n    ) {\n      port = 10 * port + (ch - 0x30\n      /*'0'*/\n      );\n      hadChars = true;\n    } else {\n      validPort = false;\n\n      if (ch === 0x5C\n      /*'\\'*/\n      || ch === 0x2F\n      /*'/'*/\n      ) {\n        validPort = true;\n      }\n\n      break;\n    }\n  }\n\n  if (port === 0 && !hadChars || !validPort) {\n    if (!validPort) {\n      this._port = -2;\n    }\n\n    return 0;\n  }\n\n  this._port = port;\n  return i - start;\n};\n\nUrl.prototype._parseHost = function Url$_parseHost(str, start, end, slashesDenoteHost) {\n  var hostEndingCharacters = this._hostEndingCharacters;\n  var first = str.charCodeAt(start);\n  var second = str.charCodeAt(start + 1);\n\n  if ((first === 0x2F\n  /*'/'*/\n  || first === 0x5C\n  /*'\\'*/\n  ) && (second === 0x2F\n  /*'/'*/\n  || second === 0x5C\n  /*'\\'*/\n  )) {\n    this.slashes = true; //The string starts with //\n\n    if (start === 0) {\n      //The string is just \"//\"\n      if (end < 2) return start; //If slashes do not denote host and there is no auth,\n      //there is no host when the string starts with //\n\n      var hasAuth = containsCharacter(str, 0x40\n      /*'@'*/\n      , 2, hostEndingCharacters);\n\n      if (!hasAuth && !slashesDenoteHost) {\n        this.slashes = null;\n        return start;\n      }\n    } //There is a host that starts after the //\n\n\n    start += 2;\n  } //If there is no slashes, there is no hostname if\n  //1. there was no protocol at all\n  else if (!this._protocol || //2. there was a protocol that requires slashes\n  //e.g. in 'http:asd' 'asd' is not a hostname\n  slashProtocols[this._protocol]) {\n    return start;\n  }\n\n  var doLowerCase = false;\n  var idna = false;\n  var hostNameStart = start;\n  var hostNameEnd = end;\n  var lastCh = -1;\n  var portLength = 0;\n  var charsAfterDot = 0;\n  var authNeedsDecoding = false;\n  var j = -1; //Find the last occurrence of an @-sign until hostending character is met\n  //also mark if decoding is needed for the auth portion\n\n  for (var i = start; i <= end; ++i) {\n    var ch = str.charCodeAt(i);\n\n    if (ch === 0x40\n    /*'@'*/\n    ) {\n      j = i;\n    } //This check is very, very cheap. Unneeded decodeURIComponent is very\n    //very expensive\n    else if (ch === 0x25\n    /*'%'*/\n    ) {\n      authNeedsDecoding = true;\n    } else if (hostEndingCharacters[ch] === 1) {\n      break;\n    }\n  } //@-sign was found at index j, everything to the left from it\n  //is auth part\n\n\n  if (j > -1) {\n    this._parseAuth(str, start, j - 1, authNeedsDecoding); //hostname starts after the last @-sign\n\n\n    start = hostNameStart = j + 1;\n  } //Host name is starting with a [\n\n\n  if (str.charCodeAt(start) === 0x5B\n  /*'['*/\n  ) {\n    for (var i = start + 1; i <= end; ++i) {\n      var ch = str.charCodeAt(i); //Assume valid IP6 is between the brackets\n\n      if (ch === 0x5D\n      /*']'*/\n      ) {\n        if (str.charCodeAt(i + 1) === 0x3A\n        /*':'*/\n        ) {\n          portLength = this._parsePort(str, i + 2, end) + 1;\n        }\n\n        var hostname = str.slice(start + 1, i).toLowerCase();\n        this.hostname = hostname;\n        this.host = this._port > 0 ? \"[\" + hostname + \"]:\" + this._port : \"[\" + hostname + \"]\";\n        this.pathname = \"/\";\n        return i + portLength + 1;\n      }\n    } //Empty hostname, [ starts a path\n\n\n    return start;\n  }\n\n  for (var i = start; i <= end; ++i) {\n    if (charsAfterDot > 62) {\n      this.hostname = this.host = str.slice(start, i);\n      return i;\n    }\n\n    var ch = str.charCodeAt(i);\n\n    if (ch === 0x3A\n    /*':'*/\n    ) {\n      portLength = this._parsePort(str, i + 1, end) + 1;\n      hostNameEnd = i - 1;\n      break;\n    } else if (ch < 0x61\n    /*'a'*/\n    ) {\n      if (ch === 0x2E\n      /*'.'*/\n      ) {\n        //Node.js ignores this error\n\n        /*\n        if (lastCh === DOT || lastCh === -1) {\n            this.hostname = this.host = \"\";\n            return start;\n        }\n        */\n        charsAfterDot = -1;\n      } else if (0x41\n      /*'A'*/\n      <= ch && ch <= 0x5A\n      /*'Z'*/\n      ) {\n        doLowerCase = true;\n      } //Valid characters other than ASCII letters -, _, +, 0-9\n      else if (!(ch === 0x2D\n      /*'-'*/\n      || ch === 0x5F\n      /*'_'*/\n      || ch === 0x2B\n      /*'+'*/\n      || 0x30\n      /*'0'*/\n      <= ch && ch <= 0x39\n      /*'9'*/\n      )) {\n        if (hostEndingCharacters[ch] === 0 && this._noPrependSlashHostEnders[ch] === 0) {\n          this._prependSlash = true;\n        }\n\n        hostNameEnd = i - 1;\n        break;\n      }\n    } else if (ch >= 0x7B\n    /*'{'*/\n    ) {\n      if (ch <= 0x7E\n      /*'~'*/\n      ) {\n        if (this._noPrependSlashHostEnders[ch] === 0) {\n          this._prependSlash = true;\n        }\n\n        hostNameEnd = i - 1;\n        break;\n      }\n\n      idna = true;\n    }\n\n    lastCh = ch;\n    charsAfterDot++;\n  } //Node.js ignores this error\n\n  /*\n  if (lastCh === DOT) {\n      hostNameEnd--;\n  }\n  */\n\n\n  if (hostNameEnd + 1 !== start && hostNameEnd - hostNameStart <= 256) {\n    var hostname = str.slice(hostNameStart, hostNameEnd + 1);\n    if (doLowerCase) hostname = hostname.toLowerCase();\n    if (idna) hostname = this._hostIdna(hostname);\n    this.hostname = hostname;\n    this.host = this._port > 0 ? hostname + \":\" + this._port : hostname;\n  }\n\n  return hostNameEnd + 1 + portLength;\n};\n\nUrl.prototype._copyPropsTo = function Url$_copyPropsTo(input, noProtocol) {\n  if (!noProtocol) {\n    input._protocol = this._protocol;\n  }\n\n  input._href = this._href;\n  input._port = this._port;\n  input._prependSlash = this._prependSlash;\n  input.auth = this.auth;\n  input.slashes = this.slashes;\n  input.host = this.host;\n  input.hostname = this.hostname;\n  input.hash = this.hash;\n  input.search = this.search;\n  input.pathname = this.pathname;\n};\n\nUrl.prototype._clone = function Url$_clone() {\n  var ret = new Url();\n  ret._protocol = this._protocol;\n  ret._href = this._href;\n  ret._port = this._port;\n  ret._prependSlash = this._prependSlash;\n  ret.auth = this.auth;\n  ret.slashes = this.slashes;\n  ret.host = this.host;\n  ret.hostname = this.hostname;\n  ret.hash = this.hash;\n  ret.search = this.search;\n  ret.pathname = this.pathname;\n  return ret;\n};\n\nUrl.prototype._getComponentEscaped = function Url$_getComponentEscaped(str, start, end, isAfterQuery) {\n  var cur = start;\n  var i = start;\n  var ret = \"\";\n  var autoEscapeMap = isAfterQuery ? this._afterQueryAutoEscapeMap : this._autoEscapeMap;\n\n  for (; i <= end; ++i) {\n    var ch = str.charCodeAt(i);\n    var escaped = autoEscapeMap[ch];\n\n    if (escaped !== \"\" && escaped !== undefined) {\n      if (cur < i) ret += str.slice(cur, i);\n      ret += escaped;\n      cur = i + 1;\n    }\n  }\n\n  if (cur < i + 1) ret += str.slice(cur, i);\n  return ret;\n};\n\nUrl.prototype._parsePath = function Url$_parsePath(str, start, end, disableAutoEscapeChars) {\n  var pathStart = start;\n  var pathEnd = end;\n  var escape = false;\n  var autoEscapeCharacters = this._autoEscapeCharacters;\n  var prePath = this._port === -2 ? \"/:\" : \"\";\n\n  for (var i = start; i <= end; ++i) {\n    var ch = str.charCodeAt(i);\n\n    if (ch === 0x23\n    /*'#'*/\n    ) {\n      this._parseHash(str, i, end, disableAutoEscapeChars);\n\n      pathEnd = i - 1;\n      break;\n    } else if (ch === 0x3F\n    /*'?'*/\n    ) {\n      this._parseQuery(str, i, end, disableAutoEscapeChars);\n\n      pathEnd = i - 1;\n      break;\n    } else if (!disableAutoEscapeChars && !escape && autoEscapeCharacters[ch] === 1) {\n      escape = true;\n    }\n  }\n\n  if (pathStart > pathEnd) {\n    this.pathname = prePath === \"\" ? \"/\" : prePath;\n    return;\n  }\n\n  var path;\n\n  if (escape) {\n    path = this._getComponentEscaped(str, pathStart, pathEnd, false);\n  } else {\n    path = str.slice(pathStart, pathEnd + 1);\n  }\n\n  this.pathname = prePath === \"\" ? this._prependSlash ? \"/\" + path : path : prePath + path;\n};\n\nUrl.prototype._parseQuery = function Url$_parseQuery(str, start, end, disableAutoEscapeChars) {\n  var queryStart = start;\n  var queryEnd = end;\n  var escape = false;\n  var autoEscapeCharacters = this._autoEscapeCharacters;\n\n  for (var i = start; i <= end; ++i) {\n    var ch = str.charCodeAt(i);\n\n    if (ch === 0x23\n    /*'#'*/\n    ) {\n      this._parseHash(str, i, end, disableAutoEscapeChars);\n\n      queryEnd = i - 1;\n      break;\n    } else if (!disableAutoEscapeChars && !escape && autoEscapeCharacters[ch] === 1) {\n      escape = true;\n    }\n  }\n\n  if (queryStart > queryEnd) {\n    this.search = \"\";\n    return;\n  }\n\n  var query;\n\n  if (escape) {\n    query = this._getComponentEscaped(str, queryStart, queryEnd, true);\n  } else {\n    query = str.slice(queryStart, queryEnd + 1);\n  }\n\n  this.search = query;\n};\n\nUrl.prototype._parseHash = function Url$_parseHash(str, start, end, disableAutoEscapeChars) {\n  if (start > end) {\n    this.hash = \"\";\n    return;\n  }\n\n  this.hash = disableAutoEscapeChars ? str.slice(start, end + 1) : this._getComponentEscaped(str, start, end, true);\n};\n\nObject.defineProperty(Url.prototype, \"port\", {\n  get: function () {\n    if (this._port >= 0) {\n      return \"\" + this._port;\n    }\n\n    return null;\n  },\n  set: function (v) {\n    if (v == null) {\n      this._port = -1;\n    } else {\n      this._port = parseInt(v, 10);\n    }\n  }\n});\nObject.defineProperty(Url.prototype, \"query\", {\n  get: function () {\n    var query = this._query;\n\n    if (query != null) {\n      return query;\n    }\n\n    var search = this.search;\n\n    if (search) {\n      if (search.charCodeAt(0) === 0x3F\n      /*'?'*/\n      ) {\n        search = search.slice(1);\n      }\n\n      if (search !== \"\") {\n        this._query = search;\n        return search;\n      }\n    }\n\n    return search;\n  },\n  set: function (v) {\n    this._query = v;\n  }\n});\nObject.defineProperty(Url.prototype, \"path\", {\n  get: function () {\n    var p = this.pathname || \"\";\n    var s = this.search || \"\";\n\n    if (p || s) {\n      return p + s;\n    }\n\n    return p == null && s ? \"/\" + s : null;\n  },\n  set: function () {}\n});\nObject.defineProperty(Url.prototype, \"protocol\", {\n  get: function () {\n    var proto = this._protocol;\n    return proto ? proto + \":\" : proto;\n  },\n  set: function (v) {\n    if (typeof v === \"string\") {\n      var end = v.length - 1;\n\n      if (v.charCodeAt(end) === 0x3A\n      /*':'*/\n      ) {\n        this._protocol = v.slice(0, end);\n      } else {\n        this._protocol = v;\n      }\n    } else if (v == null) {\n      this._protocol = null;\n    }\n  }\n});\nObject.defineProperty(Url.prototype, \"href\", {\n  get: function () {\n    var href = this._href;\n\n    if (!href) {\n      href = this._href = this.format();\n    }\n\n    return href;\n  },\n  set: function (v) {\n    this._href = v;\n  }\n});\n\nUrl.parse = function Url$Parse(str, parseQueryString, hostDenotesSlash, disableAutoEscapeChars) {\n  if (str instanceof Url) return str;\n  var ret = new Url();\n  ret.parse(str, !!parseQueryString, !!hostDenotesSlash, !!disableAutoEscapeChars);\n  return ret;\n};\n\nUrl.format = function Url$Format(obj) {\n  if (typeof obj === \"string\") {\n    obj = Url.parse(obj);\n  }\n\n  if (!(obj instanceof Url)) {\n    return Url.prototype.format.call(obj);\n  }\n\n  return obj.format();\n};\n\nUrl.resolve = function Url$Resolve(source, relative) {\n  return Url.parse(source, false, true).resolve(relative);\n};\n\nUrl.resolveObject = function Url$ResolveObject(source, relative) {\n  if (!source) return relative;\n  return Url.parse(source, false, true).resolveObject(relative);\n};\n\nfunction _escapePath(pathname) {\n  return pathname.replace(/[?#]/g, function (match) {\n    return encodeURIComponent(match);\n  });\n}\n\nfunction _escapeSearch(search) {\n  return search.replace(/#/g, function (match) {\n    return encodeURIComponent(match);\n  });\n} //Search `char1` (integer code for a character) in `string`\n//starting from `fromIndex` and ending at `string.length - 1`\n//or when a stop character is found\n\n\nfunction containsCharacter(string, char1, fromIndex, stopCharacterTable) {\n  var len = string.length;\n\n  for (var i = fromIndex; i < len; ++i) {\n    var ch = string.charCodeAt(i);\n\n    if (ch === char1) {\n      return true;\n    } else if (stopCharacterTable[ch] === 1) {\n      return false;\n    }\n  }\n\n  return false;\n} //See if `char1` or `char2` (integer codes for characters)\n//is contained in `string`\n\n\nfunction containsCharacter2(string, char1, char2) {\n  for (var i = 0, len = string.length; i < len; ++i) {\n    var ch = string.charCodeAt(i);\n    if (ch === char1 || ch === char2) return true;\n  }\n\n  return false;\n} //Makes an array of 128 uint8's which represent boolean values.\n//Spec is an array of ascii code points or ascii code point ranges\n//ranges are expressed as [start, end]\n//Create a table with the characters 0x30-0x39 (decimals '0' - '9') and\n//0x7A (lowercaseletter 'z') as `true`:\n//\n//var a = makeAsciiTable([[0x30, 0x39], 0x7A]);\n//a[0x30]; //1\n//a[0x15]; //0\n//a[0x35]; //1\n\n\nfunction makeAsciiTable(spec) {\n  var ret = new Uint8Array(128);\n  spec.forEach(function (item) {\n    if (typeof item === \"number\") {\n      ret[item] = 1;\n    } else {\n      var start = item[0];\n      var end = item[1];\n\n      for (var j = start; j <= end; ++j) {\n        ret[j] = 1;\n      }\n    }\n  });\n  return ret;\n}\n\nvar autoEscape = [\"<\", \">\", \"\\\"\", \"`\", \" \", \"\\r\", \"\\n\", \"\\t\", \"{\", \"}\", \"|\", \"\\\\\", \"^\", \"`\", \"'\"];\nvar autoEscapeMap = new Array(128);\n\nfor (var i = 0, len = autoEscapeMap.length; i < len; ++i) {\n  autoEscapeMap[i] = \"\";\n}\n\nfor (var i = 0, len = autoEscape.length; i < len; ++i) {\n  var c = autoEscape[i];\n  var esc = encodeURIComponent(c);\n\n  if (esc === c) {\n    esc = escape(c);\n  }\n\n  autoEscapeMap[c.charCodeAt(0)] = esc;\n}\n\nvar afterQueryAutoEscapeMap = autoEscapeMap.slice();\nautoEscapeMap[0x5C\n/*'\\'*/\n] = \"/\";\nvar slashProtocols = Url.prototype._slashProtocols = {\n  http: true,\n  https: true,\n  gopher: true,\n  file: true,\n  ftp: true,\n  \"http:\": true,\n  \"https:\": true,\n  \"gopher:\": true,\n  \"file:\": true,\n  \"ftp:\": true\n}; //Optimize back from normalized object caused by non-identifier keys\n\nfunction f() {}\n\nf.prototype = slashProtocols;\nUrl.prototype._protocolCharacters = makeAsciiTable([[0x61\n/*'a'*/\n, 0x7A\n/*'z'*/\n], [0x41\n/*'A'*/\n, 0x5A\n/*'Z'*/\n], 0x2E\n/*'.'*/\n, 0x2B\n/*'+'*/\n, 0x2D\n/*'-'*/\n]);\nUrl.prototype._hostEndingCharacters = makeAsciiTable([0x23\n/*'#'*/\n, 0x3F\n/*'?'*/\n, 0x2F\n/*'/'*/\n, 0x5C\n/*'\\'*/\n]);\nUrl.prototype._autoEscapeCharacters = makeAsciiTable(autoEscape.map(function (v) {\n  return v.charCodeAt(0);\n})); //If these characters end a host name, the path will not be prepended a /\n\nUrl.prototype._noPrependSlashHostEnders = makeAsciiTable([\"<\", \">\", \"'\", \"`\", \" \", \"\\r\", \"\\n\", \"\\t\", \"{\", \"}\", \"|\", \"^\", \"`\", \"\\\"\", \"%\", \";\"].map(function (v) {\n  return v.charCodeAt(0);\n}));\nUrl.prototype._autoEscapeMap = autoEscapeMap;\nUrl.prototype._afterQueryAutoEscapeMap = afterQueryAutoEscapeMap;\nmodule.exports = Url;\n\nUrl.replace = function Url$Replace() {\n  require.cache.url = {\n    exports: Url\n  };\n};","map":{"version":3,"sources":["/home/dev/Documentos/Projects/github-clone/node_modules/fast-url-parser/src/urlparser.js"],"names":["Url","_protocol","_href","_port","_query","auth","slashes","host","hostname","hash","search","pathname","_prependSlash","querystring","require","queryString","prototype","parse","Url$parse","str","parseQueryString","hostDenotesSlash","disableAutoEscapeChars","TypeError","start","end","length","charCodeAt","_parseProtocol","_parseHost","proto","slashProtocols","ch","_parsePath","_parseQuery","_parseHash","slice","_slashProtocols","query","resolve","Url$resolve","relative","resolveObject","format","Url$format","encodeURIComponent","replace","protocol","port","scheme","q","stringify","ip6","indexOf","escapePathName","escapeSearch","Url$resolveObject","result","_clone","href","_copyPropsTo","relPath","split","shift","unshift","join","isSourceAbs","isRelAbs","mustEndAbs","removeAllDots","srcPath","psychotic","pop","concat","authInHost","last","hasTrailingSlash","up","i","splice","substr","push","isAbsolute","punycode","_hostIdna","Url$_hostIdna","toASCII","_escapePathName","Url$_escapePathName","containsCharacter2","_escapePath","_escapeSearch","Url$_escapeSearch","Url$_parseProtocol","doLowerCase","protocolCharacters","_protocolCharacters","toLowerCase","_parseAuth","Url$_parseAuth","decode","decodeURIComponent","_parsePort","Url$_parsePort","hadChars","validPort","Url$_parseHost","slashesDenoteHost","hostEndingCharacters","_hostEndingCharacters","first","second","hasAuth","containsCharacter","idna","hostNameStart","hostNameEnd","lastCh","portLength","charsAfterDot","authNeedsDecoding","j","_noPrependSlashHostEnders","Url$_copyPropsTo","input","noProtocol","Url$_clone","ret","_getComponentEscaped","Url$_getComponentEscaped","isAfterQuery","cur","autoEscapeMap","_afterQueryAutoEscapeMap","_autoEscapeMap","escaped","undefined","Url$_parsePath","pathStart","pathEnd","escape","autoEscapeCharacters","_autoEscapeCharacters","prePath","path","Url$_parseQuery","queryStart","queryEnd","Url$_parseHash","Object","defineProperty","get","set","v","parseInt","p","s","Url$Parse","Url$Format","obj","call","Url$Resolve","source","Url$ResolveObject","match","string","char1","fromIndex","stopCharacterTable","len","char2","makeAsciiTable","spec","Uint8Array","forEach","item","autoEscape","Array","c","esc","afterQueryAutoEscapeMap","http","https","gopher","file","ftp","f","map","module","exports","Url$Replace","cache","url"],"mappings":"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","sourcesContent":["\"use strict\";\n/*\nCopyright (c) 2014 Petka Antonov\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\nfunction Url() {\n    //For more efficient internal representation and laziness.\n    //The non-underscore versions of these properties are accessor functions\n    //defined on the prototype.\n    this._protocol = null;\n    this._href = \"\";\n    this._port = -1;\n    this._query = null;\n\n    this.auth = null;\n    this.slashes = null;\n    this.host = null;\n    this.hostname = null;\n    this.hash = null;\n    this.search = null;\n    this.pathname = null;\n\n    this._prependSlash = false;\n}\n\nvar querystring = require(\"querystring\");\n\nUrl.queryString = querystring;\n\nUrl.prototype.parse =\nfunction Url$parse(str, parseQueryString, hostDenotesSlash, disableAutoEscapeChars) {\n    if (typeof str !== \"string\") {\n        throw new TypeError(\"Parameter 'url' must be a string, not \" +\n            typeof str);\n    }\n    var start = 0;\n    var end = str.length - 1;\n\n    //Trim leading and trailing ws\n    while (str.charCodeAt(start) <= 0x20 /*' '*/) start++;\n    while (str.charCodeAt(end) <= 0x20 /*' '*/) end--;\n\n    start = this._parseProtocol(str, start, end);\n\n    //Javascript doesn't have host\n    if (this._protocol !== \"javascript\") {\n        start = this._parseHost(str, start, end, hostDenotesSlash);\n        var proto = this._protocol;\n        if (!this.hostname &&\n            (this.slashes || (proto && !slashProtocols[proto]))) {\n            this.hostname = this.host = \"\";\n        }\n    }\n\n    if (start <= end) {\n        var ch = str.charCodeAt(start);\n\n        if (ch === 0x2F /*'/'*/ || ch === 0x5C /*'\\'*/) {\n            this._parsePath(str, start, end, disableAutoEscapeChars);\n        }\n        else if (ch === 0x3F /*'?'*/) {\n            this._parseQuery(str, start, end, disableAutoEscapeChars);\n        }\n        else if (ch === 0x23 /*'#'*/) {\n          this._parseHash(str, start, end, disableAutoEscapeChars);\n        }\n        else if (this._protocol !== \"javascript\") {\n            this._parsePath(str, start, end, disableAutoEscapeChars);\n        }\n        else { //For javascript the pathname is just the rest of it\n            this.pathname = str.slice(start, end + 1 );\n        }\n\n    }\n\n    if (!this.pathname && this.hostname &&\n        this._slashProtocols[this._protocol]) {\n        this.pathname = \"/\";\n    }\n\n    if (parseQueryString) {\n        var search = this.search;\n        if (search == null) {\n            search = this.search = \"\";\n        }\n        if (search.charCodeAt(0) === 0x3F /*'?'*/) {\n            search = search.slice(1);\n        }\n        //This calls a setter function, there is no .query data property\n        this.query = Url.queryString.parse(search);\n    }\n};\n\nUrl.prototype.resolve = function Url$resolve(relative) {\n    return this.resolveObject(Url.parse(relative, false, true)).format();\n};\n\nUrl.prototype.format = function Url$format() {\n    var auth = this.auth || \"\";\n\n    if (auth) {\n        auth = encodeURIComponent(auth);\n        auth = auth.replace(/%3A/i, \":\");\n        auth += \"@\";\n    }\n\n    var protocol = this.protocol || \"\";\n    var pathname = this.pathname || \"\";\n    var hash = this.hash || \"\";\n    var search = this.search || \"\";\n    var query = \"\";\n    var hostname = this.hostname || \"\";\n    var port = this.port || \"\";\n    var host = false;\n    var scheme = \"\";\n\n    //Cache the result of the getter function\n    var q = this.query;\n    if (q && typeof q === \"object\") {\n        query = Url.queryString.stringify(q);\n    }\n\n    if (!search) {\n        search = query ? \"?\" + query : \"\";\n    }\n\n    if (protocol && protocol.charCodeAt(protocol.length - 1) !== 0x3A /*':'*/)\n        protocol += \":\";\n\n    if (this.host) {\n        host = auth + this.host;\n    }\n    else if (hostname) {\n        var ip6 = hostname.indexOf(\":\") > -1;\n        if (ip6) hostname = \"[\" + hostname + \"]\";\n        host = auth + hostname + (port ? \":\" + port : \"\");\n    }\n\n    var slashes = this.slashes ||\n        ((!protocol ||\n        slashProtocols[protocol]) && host !== false);\n\n\n    if (protocol) scheme = protocol + (slashes ? \"//\" : \"\");\n    else if (slashes) scheme = \"//\";\n\n    if (slashes && pathname && pathname.charCodeAt(0) !== 0x2F /*'/'*/) {\n        pathname = \"/\" + pathname;\n    }\n    if (search && search.charCodeAt(0) !== 0x3F /*'?'*/)\n        search = \"?\" + search;\n    if (hash && hash.charCodeAt(0) !== 0x23 /*'#'*/)\n        hash = \"#\" + hash;\n\n    pathname = escapePathName(pathname);\n    search = escapeSearch(search);\n\n    return scheme + (host === false ? \"\" : host) + pathname + search + hash;\n};\n\nUrl.prototype.resolveObject = function Url$resolveObject(relative) {\n    if (typeof relative === \"string\")\n        relative = Url.parse(relative, false, true);\n\n    var result = this._clone();\n\n    // hash is always overridden, no matter what.\n    // even href=\"\" will remove it.\n    result.hash = relative.hash;\n\n    // if the relative url is empty, then there\"s nothing left to do here.\n    if (!relative.href) {\n        result._href = \"\";\n        return result;\n    }\n\n    // hrefs like //foo/bar always cut to the protocol.\n    if (relative.slashes && !relative._protocol) {\n        relative._copyPropsTo(result, true);\n\n        if (slashProtocols[result._protocol] &&\n            result.hostname && !result.pathname) {\n            result.pathname = \"/\";\n        }\n        result._href = \"\";\n        return result;\n    }\n\n    if (relative._protocol && relative._protocol !== result._protocol) {\n        // if it\"s a known url protocol, then changing\n        // the protocol does weird things\n        // first, if it\"s not file:, then we MUST have a host,\n        // and if there was a path\n        // to begin with, then we MUST have a path.\n        // if it is file:, then the host is dropped,\n        // because that\"s known to be hostless.\n        // anything else is assumed to be absolute.\n        if (!slashProtocols[relative._protocol]) {\n            relative._copyPropsTo(result, false);\n            result._href = \"\";\n            return result;\n        }\n\n        result._protocol = relative._protocol;\n        if (!relative.host && relative._protocol !== \"javascript\") {\n            var relPath = (relative.pathname || \"\").split(\"/\");\n            while (relPath.length && !(relative.host = relPath.shift()));\n            if (!relative.host) relative.host = \"\";\n            if (!relative.hostname) relative.hostname = \"\";\n            if (relPath[0] !== \"\") relPath.unshift(\"\");\n            if (relPath.length < 2) relPath.unshift(\"\");\n            result.pathname = relPath.join(\"/\");\n        } else {\n            result.pathname = relative.pathname;\n        }\n\n        result.search = relative.search;\n        result.host = relative.host || \"\";\n        result.auth = relative.auth;\n        result.hostname = relative.hostname || relative.host;\n        result._port = relative._port;\n        result.slashes = result.slashes || relative.slashes;\n        result._href = \"\";\n        return result;\n    }\n\n    var isSourceAbs =\n        (result.pathname && result.pathname.charCodeAt(0) === 0x2F /*'/'*/);\n    var isRelAbs = (\n            relative.host ||\n            (relative.pathname &&\n            relative.pathname.charCodeAt(0) === 0x2F /*'/'*/)\n        );\n    var mustEndAbs = (isRelAbs || isSourceAbs ||\n                        (result.host && relative.pathname));\n\n    var removeAllDots = mustEndAbs;\n\n    var srcPath = result.pathname && result.pathname.split(\"/\") || [];\n    var relPath = relative.pathname && relative.pathname.split(\"/\") || [];\n    var psychotic = result._protocol && !slashProtocols[result._protocol];\n\n    // if the url is a non-slashed url, then relative\n    // links like ../.. should be able\n    // to crawl up to the hostname, as well.  This is strange.\n    // result.protocol has already been set by now.\n    // Later on, put the first path part into the host field.\n    if (psychotic) {\n        result.hostname = \"\";\n        result._port = -1;\n        if (result.host) {\n            if (srcPath[0] === \"\") srcPath[0] = result.host;\n            else srcPath.unshift(result.host);\n        }\n        result.host = \"\";\n        if (relative._protocol) {\n            relative.hostname = \"\";\n            relative._port = -1;\n            if (relative.host) {\n                if (relPath[0] === \"\") relPath[0] = relative.host;\n                else relPath.unshift(relative.host);\n            }\n            relative.host = \"\";\n        }\n        mustEndAbs = mustEndAbs && (relPath[0] === \"\" || srcPath[0] === \"\");\n    }\n\n    if (isRelAbs) {\n        // it\"s absolute.\n        result.host = relative.host ?\n            relative.host : result.host;\n        result.hostname = relative.hostname ?\n            relative.hostname : result.hostname;\n        result.search = relative.search;\n        srcPath = relPath;\n        // fall through to the dot-handling below.\n    } else if (relPath.length) {\n        // it\"s relative\n        // throw away the existing file, and take the new path instead.\n        if (!srcPath) srcPath = [];\n        srcPath.pop();\n        srcPath = srcPath.concat(relPath);\n        result.search = relative.search;\n    } else if (relative.search) {\n        // just pull out the search.\n        // like href=\"?foo\".\n        // Put this after the other two cases because it simplifies the booleans\n        if (psychotic) {\n            result.hostname = result.host = srcPath.shift();\n            //occationaly the auth can get stuck only in host\n            //this especialy happens in cases like\n            //url.resolveObject(\"mailto:local1@domain1\", \"local2@domain2\")\n            var authInHost = result.host && result.host.indexOf(\"@\") > 0 ?\n                result.host.split(\"@\") : false;\n            if (authInHost) {\n                result.auth = authInHost.shift();\n                result.host = result.hostname = authInHost.shift();\n            }\n        }\n        result.search = relative.search;\n        result._href = \"\";\n        return result;\n    }\n\n    if (!srcPath.length) {\n        // no path at all.  easy.\n        // we\"ve already handled the other stuff above.\n        result.pathname = null;\n        result._href = \"\";\n        return result;\n    }\n\n    // if a url ENDs in . or .., then it must get a trailing slash.\n    // however, if it ends in anything else non-slashy,\n    // then it must NOT get a trailing slash.\n    var last = srcPath.slice(-1)[0];\n    var hasTrailingSlash = (\n        (result.host || relative.host) && (last === \".\" || last === \"..\") ||\n        last === \"\");\n\n    // strip single dots, resolve double dots to parent dir\n    // if the path tries to go above the root, `up` ends up > 0\n    var up = 0;\n    for (var i = srcPath.length; i >= 0; i--) {\n        last = srcPath[i];\n        if (last === \".\") {\n            srcPath.splice(i, 1);\n        } else if (last === \"..\") {\n            srcPath.splice(i, 1);\n            up++;\n        } else if (up) {\n            srcPath.splice(i, 1);\n            up--;\n        }\n    }\n\n    // if the path is allowed to go above the root, restore leading ..s\n    if (!mustEndAbs && !removeAllDots) {\n        for (; up--; up) {\n            srcPath.unshift(\"..\");\n        }\n    }\n\n    if (mustEndAbs && srcPath[0] !== \"\" &&\n        (!srcPath[0] || srcPath[0].charCodeAt(0) !== 0x2F /*'/'*/)) {\n        srcPath.unshift(\"\");\n    }\n\n    if (hasTrailingSlash && (srcPath.join(\"/\").substr(-1) !== \"/\")) {\n        srcPath.push(\"\");\n    }\n\n    var isAbsolute = srcPath[0] === \"\" ||\n        (srcPath[0] && srcPath[0].charCodeAt(0) === 0x2F /*'/'*/);\n\n    // put the host back\n    if (psychotic) {\n        result.hostname = result.host = isAbsolute ? \"\" :\n            srcPath.length ? srcPath.shift() : \"\";\n        //occationaly the auth can get stuck only in host\n        //this especialy happens in cases like\n        //url.resolveObject(\"mailto:local1@domain1\", \"local2@domain2\")\n        var authInHost = result.host && result.host.indexOf(\"@\") > 0 ?\n            result.host.split(\"@\") : false;\n        if (authInHost) {\n            result.auth = authInHost.shift();\n            result.host = result.hostname = authInHost.shift();\n        }\n    }\n\n    mustEndAbs = mustEndAbs || (result.host && srcPath.length);\n\n    if (mustEndAbs && !isAbsolute) {\n        srcPath.unshift(\"\");\n    }\n\n    result.pathname = srcPath.length === 0 ? null : srcPath.join(\"/\");\n    result.auth = relative.auth || result.auth;\n    result.slashes = result.slashes || relative.slashes;\n    result._href = \"\";\n    return result;\n};\n\nvar punycode = require(\"punycode\");\nUrl.prototype._hostIdna = function Url$_hostIdna(hostname) {\n    // IDNA Support: Returns a punycoded representation of \"domain\".\n    // It only converts parts of the domain name that\n    // have non-ASCII characters, i.e. it doesn't matter if\n    // you call it with a domain that already is ASCII-only.\n    return punycode.toASCII(hostname);\n};\n\nvar escapePathName = Url.prototype._escapePathName =\nfunction Url$_escapePathName(pathname) {\n    if (!containsCharacter2(pathname, 0x23 /*'#'*/, 0x3F /*'?'*/)) {\n        return pathname;\n    }\n    //Avoid closure creation to keep this inlinable\n    return _escapePath(pathname);\n};\n\nvar escapeSearch = Url.prototype._escapeSearch =\nfunction Url$_escapeSearch(search) {\n    if (!containsCharacter2(search, 0x23 /*'#'*/, -1)) return search;\n    //Avoid closure creation to keep this inlinable\n    return _escapeSearch(search);\n};\n\nUrl.prototype._parseProtocol = function Url$_parseProtocol(str, start, end) {\n    var doLowerCase = false;\n    var protocolCharacters = this._protocolCharacters;\n\n    for (var i = start; i <= end; ++i) {\n        var ch = str.charCodeAt(i);\n\n        if (ch === 0x3A /*':'*/) {\n            var protocol = str.slice(start, i);\n            if (doLowerCase) protocol = protocol.toLowerCase();\n            this._protocol = protocol;\n            return i + 1;\n        }\n        else if (protocolCharacters[ch] === 1) {\n            if (ch < 0x61 /*'a'*/)\n                doLowerCase = true;\n        }\n        else {\n            return start;\n        }\n\n    }\n    return start;\n};\n\nUrl.prototype._parseAuth = function Url$_parseAuth(str, start, end, decode) {\n    var auth = str.slice(start, end + 1);\n    if (decode) {\n        auth = decodeURIComponent(auth);\n    }\n    this.auth = auth;\n};\n\nUrl.prototype._parsePort = function Url$_parsePort(str, start, end) {\n    //Internal format is integer for more efficient parsing\n    //and for efficient trimming of leading zeros\n    var port = 0;\n    //Distinguish between :0 and : (no port number at all)\n    var hadChars = false;\n    var validPort = true;\n\n    for (var i = start; i <= end; ++i) {\n        var ch = str.charCodeAt(i);\n\n        if (0x30 /*'0'*/ <= ch && ch <= 0x39 /*'9'*/) {\n            port = (10 * port) + (ch - 0x30 /*'0'*/);\n            hadChars = true;\n        }\n        else {\n            validPort = false;\n            if (ch === 0x5C/*'\\'*/ || ch === 0x2F/*'/'*/) {\n                validPort = true;\n            }\n            break;\n        }\n\n    }\n    if ((port === 0 && !hadChars) || !validPort) {\n        if (!validPort) {\n            this._port = -2;\n        }\n        return 0;\n    }\n\n    this._port = port;\n    return i - start;\n};\n\nUrl.prototype._parseHost =\nfunction Url$_parseHost(str, start, end, slashesDenoteHost) {\n    var hostEndingCharacters = this._hostEndingCharacters;\n    var first = str.charCodeAt(start);\n    var second = str.charCodeAt(start + 1);\n    if ((first === 0x2F /*'/'*/ || first === 0x5C /*'\\'*/) &&\n        (second === 0x2F /*'/'*/ || second === 0x5C /*'\\'*/)) {\n        this.slashes = true;\n\n        //The string starts with //\n        if (start === 0) {\n            //The string is just \"//\"\n            if (end < 2) return start;\n            //If slashes do not denote host and there is no auth,\n            //there is no host when the string starts with //\n            var hasAuth =\n                containsCharacter(str, 0x40 /*'@'*/, 2, hostEndingCharacters);\n            if (!hasAuth && !slashesDenoteHost) {\n                this.slashes = null;\n                return start;\n            }\n        }\n        //There is a host that starts after the //\n        start += 2;\n    }\n    //If there is no slashes, there is no hostname if\n    //1. there was no protocol at all\n    else if (!this._protocol ||\n        //2. there was a protocol that requires slashes\n        //e.g. in 'http:asd' 'asd' is not a hostname\n        slashProtocols[this._protocol]\n    ) {\n        return start;\n    }\n\n    var doLowerCase = false;\n    var idna = false;\n    var hostNameStart = start;\n    var hostNameEnd = end;\n    var lastCh = -1;\n    var portLength = 0;\n    var charsAfterDot = 0;\n    var authNeedsDecoding = false;\n\n    var j = -1;\n\n    //Find the last occurrence of an @-sign until hostending character is met\n    //also mark if decoding is needed for the auth portion\n    for (var i = start; i <= end; ++i) {\n        var ch = str.charCodeAt(i);\n\n        if (ch === 0x40 /*'@'*/) {\n            j = i;\n        }\n        //This check is very, very cheap. Unneeded decodeURIComponent is very\n        //very expensive\n        else if (ch === 0x25 /*'%'*/) {\n            authNeedsDecoding = true;\n        }\n        else if (hostEndingCharacters[ch] === 1) {\n            break;\n        }\n    }\n\n    //@-sign was found at index j, everything to the left from it\n    //is auth part\n    if (j > -1) {\n        this._parseAuth(str, start, j - 1, authNeedsDecoding);\n        //hostname starts after the last @-sign\n        start = hostNameStart = j + 1;\n    }\n\n    //Host name is starting with a [\n    if (str.charCodeAt(start) === 0x5B /*'['*/) {\n        for (var i = start + 1; i <= end; ++i) {\n            var ch = str.charCodeAt(i);\n\n            //Assume valid IP6 is between the brackets\n            if (ch === 0x5D /*']'*/) {\n                if (str.charCodeAt(i + 1) === 0x3A /*':'*/) {\n                    portLength = this._parsePort(str, i + 2, end) + 1;\n                }\n                var hostname = str.slice(start + 1, i).toLowerCase();\n                this.hostname = hostname;\n                this.host = this._port > 0 ?\n                    \"[\" + hostname + \"]:\" + this._port :\n                    \"[\" + hostname + \"]\";\n                this.pathname = \"/\";\n                return i + portLength + 1;\n            }\n        }\n        //Empty hostname, [ starts a path\n        return start;\n    }\n\n    for (var i = start; i <= end; ++i) {\n        if (charsAfterDot > 62) {\n            this.hostname = this.host = str.slice(start, i);\n            return i;\n        }\n        var ch = str.charCodeAt(i);\n\n        if (ch === 0x3A /*':'*/) {\n            portLength = this._parsePort(str, i + 1, end) + 1;\n            hostNameEnd = i - 1;\n            break;\n        }\n        else if (ch < 0x61 /*'a'*/) {\n            if (ch === 0x2E /*'.'*/) {\n                //Node.js ignores this error\n                /*\n                if (lastCh === DOT || lastCh === -1) {\n                    this.hostname = this.host = \"\";\n                    return start;\n                }\n                */\n                charsAfterDot = -1;\n            }\n            else if (0x41 /*'A'*/ <= ch && ch <= 0x5A /*'Z'*/) {\n                doLowerCase = true;\n            }\n            //Valid characters other than ASCII letters -, _, +, 0-9\n            else if (!(ch === 0x2D /*'-'*/ ||\n                       ch === 0x5F /*'_'*/ ||\n                       ch === 0x2B /*'+'*/ ||\n                       (0x30 /*'0'*/ <= ch && ch <= 0x39 /*'9'*/))\n                ) {\n                if (hostEndingCharacters[ch] === 0 &&\n                    this._noPrependSlashHostEnders[ch] === 0) {\n                    this._prependSlash = true;\n                }\n                hostNameEnd = i - 1;\n                break;\n            }\n        }\n        else if (ch >= 0x7B /*'{'*/) {\n            if (ch <= 0x7E /*'~'*/) {\n                if (this._noPrependSlashHostEnders[ch] === 0) {\n                    this._prependSlash = true;\n                }\n                hostNameEnd = i - 1;\n                break;\n            }\n            idna = true;\n        }\n        lastCh = ch;\n        charsAfterDot++;\n    }\n\n    //Node.js ignores this error\n    /*\n    if (lastCh === DOT) {\n        hostNameEnd--;\n    }\n    */\n\n    if (hostNameEnd + 1 !== start &&\n        hostNameEnd - hostNameStart <= 256) {\n        var hostname = str.slice(hostNameStart, hostNameEnd + 1);\n        if (doLowerCase) hostname = hostname.toLowerCase();\n        if (idna) hostname = this._hostIdna(hostname);\n        this.hostname = hostname;\n        this.host = this._port > 0 ? hostname + \":\" + this._port : hostname;\n    }\n\n    return hostNameEnd + 1 + portLength;\n\n};\n\nUrl.prototype._copyPropsTo = function Url$_copyPropsTo(input, noProtocol) {\n    if (!noProtocol) {\n        input._protocol = this._protocol;\n    }\n    input._href = this._href;\n    input._port = this._port;\n    input._prependSlash = this._prependSlash;\n    input.auth = this.auth;\n    input.slashes = this.slashes;\n    input.host = this.host;\n    input.hostname = this.hostname;\n    input.hash = this.hash;\n    input.search = this.search;\n    input.pathname = this.pathname;\n};\n\nUrl.prototype._clone = function Url$_clone() {\n    var ret = new Url();\n    ret._protocol = this._protocol;\n    ret._href = this._href;\n    ret._port = this._port;\n    ret._prependSlash = this._prependSlash;\n    ret.auth = this.auth;\n    ret.slashes = this.slashes;\n    ret.host = this.host;\n    ret.hostname = this.hostname;\n    ret.hash = this.hash;\n    ret.search = this.search;\n    ret.pathname = this.pathname;\n    return ret;\n};\n\nUrl.prototype._getComponentEscaped =\nfunction Url$_getComponentEscaped(str, start, end, isAfterQuery) {\n    var cur = start;\n    var i = start;\n    var ret = \"\";\n    var autoEscapeMap = isAfterQuery ?\n        this._afterQueryAutoEscapeMap : this._autoEscapeMap;\n    for (; i <= end; ++i) {\n        var ch = str.charCodeAt(i);\n        var escaped = autoEscapeMap[ch];\n\n        if (escaped !== \"\" && escaped !== undefined) {\n            if (cur < i) ret += str.slice(cur, i);\n            ret += escaped;\n            cur = i + 1;\n        }\n    }\n    if (cur < i + 1) ret += str.slice(cur, i);\n    return ret;\n};\n\nUrl.prototype._parsePath =\nfunction Url$_parsePath(str, start, end, disableAutoEscapeChars) {\n    var pathStart = start;\n    var pathEnd = end;\n    var escape = false;\n    var autoEscapeCharacters = this._autoEscapeCharacters;\n    var prePath = this._port === -2 ? \"/:\" : \"\";\n\n    for (var i = start; i <= end; ++i) {\n        var ch = str.charCodeAt(i);\n        if (ch === 0x23 /*'#'*/) {\n          this._parseHash(str, i, end, disableAutoEscapeChars);\n            pathEnd = i - 1;\n            break;\n        }\n        else if (ch === 0x3F /*'?'*/) {\n            this._parseQuery(str, i, end, disableAutoEscapeChars);\n            pathEnd = i - 1;\n            break;\n        }\n        else if (!disableAutoEscapeChars && !escape && autoEscapeCharacters[ch] === 1) {\n            escape = true;\n        }\n    }\n\n    if (pathStart > pathEnd) {\n        this.pathname = prePath === \"\" ? \"/\" : prePath;\n        return;\n    }\n\n    var path;\n    if (escape) {\n        path = this._getComponentEscaped(str, pathStart, pathEnd, false);\n    }\n    else {\n        path = str.slice(pathStart, pathEnd + 1);\n    }\n    this.pathname = prePath === \"\"\n        ? (this._prependSlash ? \"/\" + path : path)\n        : prePath + path;\n};\n\nUrl.prototype._parseQuery = function Url$_parseQuery(str, start, end, disableAutoEscapeChars) {\n    var queryStart = start;\n    var queryEnd = end;\n    var escape = false;\n    var autoEscapeCharacters = this._autoEscapeCharacters;\n\n    for (var i = start; i <= end; ++i) {\n        var ch = str.charCodeAt(i);\n\n        if (ch === 0x23 /*'#'*/) {\n            this._parseHash(str, i, end, disableAutoEscapeChars);\n            queryEnd = i - 1;\n            break;\n        }\n        else if (!disableAutoEscapeChars && !escape && autoEscapeCharacters[ch] === 1) {\n            escape = true;\n        }\n    }\n\n    if (queryStart > queryEnd) {\n        this.search = \"\";\n        return;\n    }\n\n    var query;\n    if (escape) {\n        query = this._getComponentEscaped(str, queryStart, queryEnd, true);\n    }\n    else {\n        query = str.slice(queryStart, queryEnd + 1);\n    }\n    this.search = query;\n};\n\nUrl.prototype._parseHash = function Url$_parseHash(str, start, end, disableAutoEscapeChars) {\n    if (start > end) {\n        this.hash = \"\";\n        return;\n    }\n\n    this.hash = disableAutoEscapeChars ?\n        str.slice(start, end + 1) : this._getComponentEscaped(str, start, end, true);\n};\n\nObject.defineProperty(Url.prototype, \"port\", {\n    get: function() {\n        if (this._port >= 0) {\n            return (\"\" + this._port);\n        }\n        return null;\n    },\n    set: function(v) {\n        if (v == null) {\n            this._port = -1;\n        }\n        else {\n            this._port = parseInt(v, 10);\n        }\n    }\n});\n\nObject.defineProperty(Url.prototype, \"query\", {\n    get: function() {\n        var query = this._query;\n        if (query != null) {\n            return query;\n        }\n        var search = this.search;\n\n        if (search) {\n            if (search.charCodeAt(0) === 0x3F /*'?'*/) {\n                search = search.slice(1);\n            }\n            if (search !== \"\") {\n                this._query = search;\n                return search;\n            }\n        }\n        return search;\n    },\n    set: function(v) {\n        this._query = v;\n    }\n});\n\nObject.defineProperty(Url.prototype, \"path\", {\n    get: function() {\n        var p = this.pathname || \"\";\n        var s = this.search || \"\";\n        if (p || s) {\n            return p + s;\n        }\n        return (p == null && s) ? (\"/\" + s) : null;\n    },\n    set: function() {}\n});\n\nObject.defineProperty(Url.prototype, \"protocol\", {\n    get: function() {\n        var proto = this._protocol;\n        return proto ? proto + \":\" : proto;\n    },\n    set: function(v) {\n        if (typeof v === \"string\") {\n            var end = v.length - 1;\n            if (v.charCodeAt(end) === 0x3A /*':'*/) {\n                this._protocol = v.slice(0, end);\n            }\n            else {\n                this._protocol = v;\n            }\n        }\n        else if (v == null) {\n            this._protocol = null;\n        }\n    }\n});\n\nObject.defineProperty(Url.prototype, \"href\", {\n    get: function() {\n        var href = this._href;\n        if (!href) {\n            href = this._href = this.format();\n        }\n        return href;\n    },\n    set: function(v) {\n        this._href = v;\n    }\n});\n\nUrl.parse = function Url$Parse(str, parseQueryString, hostDenotesSlash, disableAutoEscapeChars) {\n    if (str instanceof Url) return str;\n    var ret = new Url();\n    ret.parse(str, !!parseQueryString, !!hostDenotesSlash, !!disableAutoEscapeChars);\n    return ret;\n};\n\nUrl.format = function Url$Format(obj) {\n    if (typeof obj === \"string\") {\n        obj = Url.parse(obj);\n    }\n    if (!(obj instanceof Url)) {\n        return Url.prototype.format.call(obj);\n    }\n    return obj.format();\n};\n\nUrl.resolve = function Url$Resolve(source, relative) {\n    return Url.parse(source, false, true).resolve(relative);\n};\n\nUrl.resolveObject = function Url$ResolveObject(source, relative) {\n    if (!source) return relative;\n    return Url.parse(source, false, true).resolveObject(relative);\n};\n\nfunction _escapePath(pathname) {\n    return pathname.replace(/[?#]/g, function(match) {\n        return encodeURIComponent(match);\n    });\n}\n\nfunction _escapeSearch(search) {\n    return search.replace(/#/g, function(match) {\n        return encodeURIComponent(match);\n    });\n}\n\n//Search `char1` (integer code for a character) in `string`\n//starting from `fromIndex` and ending at `string.length - 1`\n//or when a stop character is found\nfunction containsCharacter(string, char1, fromIndex, stopCharacterTable) {\n    var len = string.length;\n    for (var i = fromIndex; i < len; ++i) {\n        var ch = string.charCodeAt(i);\n\n        if (ch === char1) {\n            return true;\n        }\n        else if (stopCharacterTable[ch] === 1) {\n            return false;\n        }\n    }\n    return false;\n}\n\n//See if `char1` or `char2` (integer codes for characters)\n//is contained in `string`\nfunction containsCharacter2(string, char1, char2) {\n    for (var i = 0, len = string.length; i < len; ++i) {\n        var ch = string.charCodeAt(i);\n        if (ch === char1 || ch === char2) return true;\n    }\n    return false;\n}\n\n//Makes an array of 128 uint8's which represent boolean values.\n//Spec is an array of ascii code points or ascii code point ranges\n//ranges are expressed as [start, end]\n\n//Create a table with the characters 0x30-0x39 (decimals '0' - '9') and\n//0x7A (lowercaseletter 'z') as `true`:\n//\n//var a = makeAsciiTable([[0x30, 0x39], 0x7A]);\n//a[0x30]; //1\n//a[0x15]; //0\n//a[0x35]; //1\nfunction makeAsciiTable(spec) {\n    var ret = new Uint8Array(128);\n    spec.forEach(function(item){\n        if (typeof item === \"number\") {\n            ret[item] = 1;\n        }\n        else {\n            var start = item[0];\n            var end = item[1];\n            for (var j = start; j <= end; ++j) {\n                ret[j] = 1;\n            }\n        }\n    });\n\n    return ret;\n}\n\n\nvar autoEscape = [\"<\", \">\", \"\\\"\", \"`\", \" \", \"\\r\", \"\\n\",\n    \"\\t\", \"{\", \"}\", \"|\", \"\\\\\", \"^\", \"`\", \"'\"];\n\nvar autoEscapeMap = new Array(128);\n\n\n\nfor (var i = 0, len = autoEscapeMap.length; i < len; ++i) {\n    autoEscapeMap[i] = \"\";\n}\n\nfor (var i = 0, len = autoEscape.length; i < len; ++i) {\n    var c = autoEscape[i];\n    var esc = encodeURIComponent(c);\n    if (esc === c) {\n        esc = escape(c);\n    }\n    autoEscapeMap[c.charCodeAt(0)] = esc;\n}\nvar afterQueryAutoEscapeMap = autoEscapeMap.slice();\nautoEscapeMap[0x5C /*'\\'*/] = \"/\";\n\nvar slashProtocols = Url.prototype._slashProtocols = {\n    http: true,\n    https: true,\n    gopher: true,\n    file: true,\n    ftp: true,\n\n    \"http:\": true,\n    \"https:\": true,\n    \"gopher:\": true,\n    \"file:\": true,\n    \"ftp:\": true\n};\n\n//Optimize back from normalized object caused by non-identifier keys\nfunction f(){}\nf.prototype = slashProtocols;\n\nUrl.prototype._protocolCharacters = makeAsciiTable([\n    [0x61 /*'a'*/, 0x7A /*'z'*/],\n    [0x41 /*'A'*/, 0x5A /*'Z'*/],\n    0x2E /*'.'*/, 0x2B /*'+'*/, 0x2D /*'-'*/\n]);\n\nUrl.prototype._hostEndingCharacters = makeAsciiTable([\n    0x23 /*'#'*/, 0x3F /*'?'*/, 0x2F /*'/'*/, 0x5C /*'\\'*/\n]);\n\nUrl.prototype._autoEscapeCharacters = makeAsciiTable(\n    autoEscape.map(function(v) {\n        return v.charCodeAt(0);\n    })\n);\n\n//If these characters end a host name, the path will not be prepended a /\nUrl.prototype._noPrependSlashHostEnders = makeAsciiTable(\n    [\n        \"<\", \">\", \"'\", \"`\", \" \", \"\\r\",\n        \"\\n\", \"\\t\", \"{\", \"}\", \"|\",\n        \"^\", \"`\", \"\\\"\", \"%\", \";\"\n    ].map(function(v) {\n        return v.charCodeAt(0);\n    })\n);\n\nUrl.prototype._autoEscapeMap = autoEscapeMap;\nUrl.prototype._afterQueryAutoEscapeMap = afterQueryAutoEscapeMap;\n\nmodule.exports = Url;\n\nUrl.replace = function Url$Replace() {\n    require.cache.url = {\n        exports: Url\n    };\n};\n"]},"metadata":{},"sourceType":"script"}