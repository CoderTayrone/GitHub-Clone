{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst ora = require(\"ora\");\n\nconst fs = require(\"fs-extra\");\n\nconst command_1 = require(\"../command\");\n\nconst apps_1 = require(\"../management/apps\");\n\nconst projectUtils_1 = require(\"../projectUtils\");\n\nconst projects_1 = require(\"../management/projects\");\n\nconst error_1 = require(\"../error\");\n\nconst requireAuth_1 = require(\"../requireAuth\");\n\nconst logger_1 = require(\"../logger\");\n\nconst prompt_1 = require(\"../prompt\");\n\nasync function selectAppInteractively(apps, appPlatform) {\n  if (apps.length === 0) {\n    throw new error_1.FirebaseError(`There are no ${appPlatform === apps_1.AppPlatform.ANY ? \"\" : appPlatform + \" \"}apps ` + \"associated with this Firebase project\");\n  }\n\n  const choices = apps.map(app => {\n    return {\n      name: `${app.displayName || app.bundleId || app.packageName}` + ` - ${app.appId} (${app.platform})`,\n      value: app\n    };\n  });\n  return await prompt_1.promptOnce({\n    type: \"list\",\n    message: `Select the ${appPlatform === apps_1.AppPlatform.ANY ? \"\" : appPlatform + \" \"}` + \"app to get the configuration data:\",\n    choices\n  });\n}\n\nmodule.exports = new command_1.Command(\"apps:sdkconfig [platform] [appId]\").description(\"print the Google Services config of a Firebase app. \" + \"[platform] can be IOS, ANDROID or WEB (case insensitive)\").option(\"-o, --out [file]\", \"(optional) write config output to a file\").before(requireAuth_1.requireAuth).action(async (platform = \"\", appId = \"\", options) => {\n  let appPlatform = apps_1.getAppPlatform(platform);\n\n  if (!appId) {\n    let projectId = projectUtils_1.needProjectId(options);\n\n    if (options.nonInteractive && !projectId) {\n      throw new error_1.FirebaseError(\"Must supply app and project ids in non-interactive mode.\");\n    } else if (!projectId) {\n      const result = await projects_1.getOrPromptProject(options);\n      projectId = result.projectId;\n    }\n\n    const apps = await apps_1.listFirebaseApps(projectId, appPlatform);\n\n    if (apps.length === 1) {\n      appId = apps[0].appId;\n      appPlatform = apps[0].platform;\n    } else if (options.nonInteractive) {\n      throw new error_1.FirebaseError(`Project ${projectId} has multiple apps, must specify an app id.`);\n    } else {\n      const appMetadata = await selectAppInteractively(apps, appPlatform);\n      appId = appMetadata.appId;\n      appPlatform = appMetadata.platform;\n    }\n  }\n\n  let configData;\n  const spinner = ora(`Downloading configuration data of your Firebase ${appPlatform} app`).start();\n\n  try {\n    configData = await apps_1.getAppConfig(appId, appPlatform);\n  } catch (err) {\n    spinner.fail();\n    throw err;\n  }\n\n  spinner.succeed();\n  const fileInfo = apps_1.getAppConfigFile(configData, appPlatform);\n\n  if (appPlatform == apps_1.AppPlatform.WEB) {\n    fileInfo.sdkConfig = configData;\n  }\n\n  if (options.out === undefined) {\n    logger_1.logger.info(fileInfo.fileContents);\n    return fileInfo;\n  }\n\n  const shouldUseDefaultFilename = options.out === true || options.out === \"\";\n  const filename = shouldUseDefaultFilename ? configData.fileName : options.out;\n\n  if (fs.existsSync(filename)) {\n    if (options.nonInteractive) {\n      throw new error_1.FirebaseError(`${filename} already exists`);\n    }\n\n    const overwrite = await prompt_1.promptOnce({\n      type: \"confirm\",\n      default: false,\n      message: `${filename} already exists. Do you want to overwrite?`\n    });\n\n    if (!overwrite) {\n      return configData;\n    }\n  }\n\n  fs.writeFileSync(filename, fileInfo.fileContents);\n  logger_1.logger.info(`App configuration is written in ${filename}`);\n  return configData;\n});","map":{"version":3,"sources":["/home/dev/Documentos/Projects/github-clone/node_modules/firebase-tools/lib/commands/apps-sdkconfig.js"],"names":["Object","defineProperty","exports","value","ora","require","fs","command_1","apps_1","projectUtils_1","projects_1","error_1","requireAuth_1","logger_1","prompt_1","selectAppInteractively","apps","appPlatform","length","FirebaseError","AppPlatform","ANY","choices","map","app","name","displayName","bundleId","packageName","appId","platform","promptOnce","type","message","module","Command","description","option","before","requireAuth","action","options","getAppPlatform","projectId","needProjectId","nonInteractive","result","getOrPromptProject","listFirebaseApps","appMetadata","configData","spinner","start","getAppConfig","err","fail","succeed","fileInfo","getAppConfigFile","WEB","sdkConfig","out","undefined","logger","info","fileContents","shouldUseDefaultFilename","filename","fileName","existsSync","overwrite","default","writeFileSync"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ora = require(\"ora\");\nconst fs = require(\"fs-extra\");\nconst command_1 = require(\"../command\");\nconst apps_1 = require(\"../management/apps\");\nconst projectUtils_1 = require(\"../projectUtils\");\nconst projects_1 = require(\"../management/projects\");\nconst error_1 = require(\"../error\");\nconst requireAuth_1 = require(\"../requireAuth\");\nconst logger_1 = require(\"../logger\");\nconst prompt_1 = require(\"../prompt\");\nasync function selectAppInteractively(apps, appPlatform) {\n    if (apps.length === 0) {\n        throw new error_1.FirebaseError(`There are no ${appPlatform === apps_1.AppPlatform.ANY ? \"\" : appPlatform + \" \"}apps ` +\n            \"associated with this Firebase project\");\n    }\n    const choices = apps.map((app) => {\n        return {\n            name: `${app.displayName || app.bundleId || app.packageName}` +\n                ` - ${app.appId} (${app.platform})`,\n            value: app,\n        };\n    });\n    return await prompt_1.promptOnce({\n        type: \"list\",\n        message: `Select the ${appPlatform === apps_1.AppPlatform.ANY ? \"\" : appPlatform + \" \"}` +\n            \"app to get the configuration data:\",\n        choices,\n    });\n}\nmodule.exports = new command_1.Command(\"apps:sdkconfig [platform] [appId]\")\n    .description(\"print the Google Services config of a Firebase app. \" +\n    \"[platform] can be IOS, ANDROID or WEB (case insensitive)\")\n    .option(\"-o, --out [file]\", \"(optional) write config output to a file\")\n    .before(requireAuth_1.requireAuth)\n    .action(async (platform = \"\", appId = \"\", options) => {\n    let appPlatform = apps_1.getAppPlatform(platform);\n    if (!appId) {\n        let projectId = projectUtils_1.needProjectId(options);\n        if (options.nonInteractive && !projectId) {\n            throw new error_1.FirebaseError(\"Must supply app and project ids in non-interactive mode.\");\n        }\n        else if (!projectId) {\n            const result = await projects_1.getOrPromptProject(options);\n            projectId = result.projectId;\n        }\n        const apps = await apps_1.listFirebaseApps(projectId, appPlatform);\n        if (apps.length === 1) {\n            appId = apps[0].appId;\n            appPlatform = apps[0].platform;\n        }\n        else if (options.nonInteractive) {\n            throw new error_1.FirebaseError(`Project ${projectId} has multiple apps, must specify an app id.`);\n        }\n        else {\n            const appMetadata = await selectAppInteractively(apps, appPlatform);\n            appId = appMetadata.appId;\n            appPlatform = appMetadata.platform;\n        }\n    }\n    let configData;\n    const spinner = ora(`Downloading configuration data of your Firebase ${appPlatform} app`).start();\n    try {\n        configData = await apps_1.getAppConfig(appId, appPlatform);\n    }\n    catch (err) {\n        spinner.fail();\n        throw err;\n    }\n    spinner.succeed();\n    const fileInfo = apps_1.getAppConfigFile(configData, appPlatform);\n    if (appPlatform == apps_1.AppPlatform.WEB) {\n        fileInfo.sdkConfig = configData;\n    }\n    if (options.out === undefined) {\n        logger_1.logger.info(fileInfo.fileContents);\n        return fileInfo;\n    }\n    const shouldUseDefaultFilename = options.out === true || options.out === \"\";\n    const filename = shouldUseDefaultFilename ? configData.fileName : options.out;\n    if (fs.existsSync(filename)) {\n        if (options.nonInteractive) {\n            throw new error_1.FirebaseError(`${filename} already exists`);\n        }\n        const overwrite = await prompt_1.promptOnce({\n            type: \"confirm\",\n            default: false,\n            message: `${filename} already exists. Do you want to overwrite?`,\n        });\n        if (!overwrite) {\n            return configData;\n        }\n    }\n    fs.writeFileSync(filename, fileInfo.fileContents);\n    logger_1.logger.info(`App configuration is written in ${filename}`);\n    return configData;\n});\n"]},"metadata":{},"sourceType":"script"}