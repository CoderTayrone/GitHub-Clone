{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst cli_color_1 = require(\"cli-color\");\n\nconst command_1 = require(\"../command\");\n\nconst error_1 = require(\"../error\");\n\nconst api_1 = require(\"../hosting/api\");\n\nconst normalizedHostingConfigs_1 = require(\"../hosting/normalizedHostingConfigs\");\n\nconst requirePermissions_1 = require(\"../requirePermissions\");\n\nconst deploy = require(\"../deploy\");\n\nconst projectUtils_1 = require(\"../projectUtils\");\n\nconst logger_1 = require(\"../logger\");\n\nconst requireConfig = require(\"../requireConfig\");\n\nconst expireUtils_1 = require(\"../hosting/expireUtils\");\n\nconst utils_1 = require(\"../utils\");\n\nconst marked = require(\"marked\");\n\nconst requireHostingSite_1 = require(\"../requireHostingSite\");\n\nconst LOG_TAG = \"hosting:channel\";\nexports.default = new command_1.Command(\"hosting:channel:deploy [channelId]\").description(\"deploy to a specific Firebase Hosting channel\").option(\"-e, --expires <duration>\", \"duration string (e.g. 12h, 30d) for channel expiration, max 30d; defaults to 7d\").option(\"--only <target1,target2...>\", \"only create previews for specified targets\").option(\"--open\", \"open a browser to the channel after deploying\").option(\"--no-authorized-domains\", \"do not sync channel domains with Firebase Auth\").before(requireConfig).before(requirePermissions_1.requirePermissions, [\"firebasehosting.sites.update\"]).before(requireHostingSite_1.requireHostingSite).action(async (channelId, options) => {\n  const projectId = projectUtils_1.needProjectId(options);\n\n  if (options.open) {\n    throw new error_1.FirebaseError(\"open is not yet implemented\");\n  }\n\n  if (options[\"no-authorized-domains\"]) {\n    throw new error_1.FirebaseError(\"no-authorized-domains is not yet implemented\");\n  }\n\n  let expireTTL = expireUtils_1.DEFAULT_DURATION;\n\n  if (options.expires) {\n    expireTTL = expireUtils_1.calculateChannelExpireTTL(options.expires);\n    logger_1.logger.debug(`Expires TTL: ${expireTTL}`);\n  }\n\n  if (!channelId) {\n    throw new error_1.FirebaseError(\"channelID is currently required\");\n  }\n\n  channelId = api_1.normalizeName(channelId);\n\n  if (channelId.toLowerCase().trim() === \"live\") {\n    throw new error_1.FirebaseError(`Cannot deploy to the ${cli_color_1.bold(\"live\")} channel using this command. Please use ${cli_color_1.bold(cli_color_1.yellow(\"firebase deploy\"))} instead.`);\n  }\n\n  if (options.only) {\n    options.only = options.only.split(\",\").map(o => `hosting:${o}`).join(\",\");\n  }\n\n  const sites = normalizedHostingConfigs_1.normalizedHostingConfigs(options, {\n    resolveTargets: true\n  }).map(cfg => ({\n    site: cfg.site,\n    target: cfg.target,\n    url: \"\",\n    version: \"\",\n    expireTime: \"\"\n  }));\n  await Promise.all(sites.map(async siteInfo => {\n    const site = siteInfo.site;\n    let chan = await api_1.getChannel(projectId, site, channelId);\n\n    if (chan) {\n      logger_1.logger.debug(\"[hosting] found existing channel for site\", site, chan);\n      const channelExpires = Boolean(chan.expireTime);\n\n      if (!channelExpires && options.expires) {\n        chan = await api_1.updateChannelTtl(projectId, site, channelId, expireTTL);\n      } else if (channelExpires) {\n        const channelTimeRemaining = new Date(chan.expireTime).getTime() - Date.now();\n\n        if (options.expires || channelTimeRemaining < expireTTL) {\n          chan = await api_1.updateChannelTtl(projectId, site, channelId, expireTTL);\n          logger_1.logger.debug(\"[hosting] updated TTL for existing channel for site\", site, chan);\n        }\n      }\n    } else {\n      chan = await api_1.createChannel(projectId, site, channelId, expireTTL);\n      logger_1.logger.debug(\"[hosting] created new channnel for site\", site, chan);\n      utils_1.logLabeledSuccess(LOG_TAG, `Channel ${cli_color_1.bold(channelId)} has been created on site ${cli_color_1.bold(site)}.`);\n    }\n\n    siteInfo.url = chan.url;\n    siteInfo.expireTime = chan.expireTime;\n    return;\n  }));\n  const {\n    hosting\n  } = await deploy([\"hosting\"], options, {\n    hostingChannel: channelId\n  });\n  const versionNames = [];\n\n  if (typeof hosting === \"string\") {\n    versionNames.push(hosting);\n  } else if (Array.isArray(hosting)) {\n    hosting.forEach(version => {\n      versionNames.push(version);\n    });\n  }\n\n  logger_1.logger.info();\n  await syncAuthState(projectId, sites);\n  const deploys = {};\n  sites.forEach(d => {\n    deploys[d.target || d.site] = d;\n    let expires = \"\";\n\n    if (d.expireTime) {\n      expires = `[expires ${cli_color_1.bold(utils_1.datetimeString(new Date(d.expireTime)))}]`;\n    }\n\n    const versionPrefix = `sites/${d.site}/versions/`;\n    const versionName = versionNames.find(v => {\n      return v.startsWith(versionPrefix);\n    });\n    let version = \"\";\n\n    if (versionName) {\n      d.version = versionName.replace(versionPrefix, \"\");\n      version = ` [version ${cli_color_1.bold(d.version)}]`;\n    }\n\n    utils_1.logLabeledSuccess(LOG_TAG, `Channel URL (${cli_color_1.bold(d.site || d.target)}): ${d.url} ${expires}${version}`);\n  });\n  return deploys;\n});\n\nasync function syncAuthState(projectId, sites) {\n  const siteNames = sites.map(d => d.site);\n  const urlNames = sites.map(d => d.url);\n\n  try {\n    await api_1.addAuthDomains(projectId, urlNames);\n    logger_1.logger.debug(\"[hosting] added auth domain for urls\", urlNames);\n  } catch (e) {\n    utils_1.logLabeledWarning(LOG_TAG, marked(`Unable to add channel domain to Firebase Auth. Visit the Firebase Console at ${utils_1.consoleUrl(projectId, \"/authentication/providers\")}`));\n    logger_1.logger.debug(\"[hosting] unable to add auth domain\", e);\n  }\n\n  try {\n    await api_1.cleanAuthState(projectId, siteNames);\n  } catch (e) {\n    utils_1.logLabeledWarning(LOG_TAG, \"Unable to sync Firebase Auth state.\");\n    logger_1.logger.debug(\"[hosting] unable to sync auth domain\", e);\n  }\n}","map":{"version":3,"sources":["/home/dev/Documentos/Projects/github-clone/node_modules/firebase-tools/lib/commands/hosting-channel-deploy.js"],"names":["Object","defineProperty","exports","value","cli_color_1","require","command_1","error_1","api_1","normalizedHostingConfigs_1","requirePermissions_1","deploy","projectUtils_1","logger_1","requireConfig","expireUtils_1","utils_1","marked","requireHostingSite_1","LOG_TAG","default","Command","description","option","before","requirePermissions","requireHostingSite","action","channelId","options","projectId","needProjectId","open","FirebaseError","expireTTL","DEFAULT_DURATION","expires","calculateChannelExpireTTL","logger","debug","normalizeName","toLowerCase","trim","bold","yellow","only","split","map","o","join","sites","normalizedHostingConfigs","resolveTargets","cfg","site","target","url","version","expireTime","Promise","all","siteInfo","chan","getChannel","channelExpires","Boolean","updateChannelTtl","channelTimeRemaining","Date","getTime","now","createChannel","logLabeledSuccess","hosting","hostingChannel","versionNames","push","Array","isArray","forEach","info","syncAuthState","deploys","d","datetimeString","versionPrefix","versionName","find","v","startsWith","replace","siteNames","urlNames","addAuthDomains","e","logLabeledWarning","consoleUrl","cleanAuthState"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst cli_color_1 = require(\"cli-color\");\nconst command_1 = require(\"../command\");\nconst error_1 = require(\"../error\");\nconst api_1 = require(\"../hosting/api\");\nconst normalizedHostingConfigs_1 = require(\"../hosting/normalizedHostingConfigs\");\nconst requirePermissions_1 = require(\"../requirePermissions\");\nconst deploy = require(\"../deploy\");\nconst projectUtils_1 = require(\"../projectUtils\");\nconst logger_1 = require(\"../logger\");\nconst requireConfig = require(\"../requireConfig\");\nconst expireUtils_1 = require(\"../hosting/expireUtils\");\nconst utils_1 = require(\"../utils\");\nconst marked = require(\"marked\");\nconst requireHostingSite_1 = require(\"../requireHostingSite\");\nconst LOG_TAG = \"hosting:channel\";\nexports.default = new command_1.Command(\"hosting:channel:deploy [channelId]\")\n    .description(\"deploy to a specific Firebase Hosting channel\")\n    .option(\"-e, --expires <duration>\", \"duration string (e.g. 12h, 30d) for channel expiration, max 30d; defaults to 7d\")\n    .option(\"--only <target1,target2...>\", \"only create previews for specified targets\")\n    .option(\"--open\", \"open a browser to the channel after deploying\")\n    .option(\"--no-authorized-domains\", \"do not sync channel domains with Firebase Auth\")\n    .before(requireConfig)\n    .before(requirePermissions_1.requirePermissions, [\"firebasehosting.sites.update\"])\n    .before(requireHostingSite_1.requireHostingSite)\n    .action(async (channelId, options) => {\n    const projectId = projectUtils_1.needProjectId(options);\n    if (options.open) {\n        throw new error_1.FirebaseError(\"open is not yet implemented\");\n    }\n    if (options[\"no-authorized-domains\"]) {\n        throw new error_1.FirebaseError(\"no-authorized-domains is not yet implemented\");\n    }\n    let expireTTL = expireUtils_1.DEFAULT_DURATION;\n    if (options.expires) {\n        expireTTL = expireUtils_1.calculateChannelExpireTTL(options.expires);\n        logger_1.logger.debug(`Expires TTL: ${expireTTL}`);\n    }\n    if (!channelId) {\n        throw new error_1.FirebaseError(\"channelID is currently required\");\n    }\n    channelId = api_1.normalizeName(channelId);\n    if (channelId.toLowerCase().trim() === \"live\") {\n        throw new error_1.FirebaseError(`Cannot deploy to the ${cli_color_1.bold(\"live\")} channel using this command. Please use ${cli_color_1.bold(cli_color_1.yellow(\"firebase deploy\"))} instead.`);\n    }\n    if (options.only) {\n        options.only = options.only\n            .split(\",\")\n            .map((o) => `hosting:${o}`)\n            .join(\",\");\n    }\n    const sites = normalizedHostingConfigs_1.normalizedHostingConfigs(options, {\n        resolveTargets: true,\n    }).map((cfg) => ({\n        site: cfg.site,\n        target: cfg.target,\n        url: \"\",\n        version: \"\",\n        expireTime: \"\",\n    }));\n    await Promise.all(sites.map(async (siteInfo) => {\n        const site = siteInfo.site;\n        let chan = await api_1.getChannel(projectId, site, channelId);\n        if (chan) {\n            logger_1.logger.debug(\"[hosting] found existing channel for site\", site, chan);\n            const channelExpires = Boolean(chan.expireTime);\n            if (!channelExpires && options.expires) {\n                chan = await api_1.updateChannelTtl(projectId, site, channelId, expireTTL);\n            }\n            else if (channelExpires) {\n                const channelTimeRemaining = new Date(chan.expireTime).getTime() - Date.now();\n                if (options.expires || channelTimeRemaining < expireTTL) {\n                    chan = await api_1.updateChannelTtl(projectId, site, channelId, expireTTL);\n                    logger_1.logger.debug(\"[hosting] updated TTL for existing channel for site\", site, chan);\n                }\n            }\n        }\n        else {\n            chan = await api_1.createChannel(projectId, site, channelId, expireTTL);\n            logger_1.logger.debug(\"[hosting] created new channnel for site\", site, chan);\n            utils_1.logLabeledSuccess(LOG_TAG, `Channel ${cli_color_1.bold(channelId)} has been created on site ${cli_color_1.bold(site)}.`);\n        }\n        siteInfo.url = chan.url;\n        siteInfo.expireTime = chan.expireTime;\n        return;\n    }));\n    const { hosting } = await deploy([\"hosting\"], options, { hostingChannel: channelId });\n    const versionNames = [];\n    if (typeof hosting === \"string\") {\n        versionNames.push(hosting);\n    }\n    else if (Array.isArray(hosting)) {\n        hosting.forEach((version) => {\n            versionNames.push(version);\n        });\n    }\n    logger_1.logger.info();\n    await syncAuthState(projectId, sites);\n    const deploys = {};\n    sites.forEach((d) => {\n        deploys[d.target || d.site] = d;\n        let expires = \"\";\n        if (d.expireTime) {\n            expires = `[expires ${cli_color_1.bold(utils_1.datetimeString(new Date(d.expireTime)))}]`;\n        }\n        const versionPrefix = `sites/${d.site}/versions/`;\n        const versionName = versionNames.find((v) => {\n            return v.startsWith(versionPrefix);\n        });\n        let version = \"\";\n        if (versionName) {\n            d.version = versionName.replace(versionPrefix, \"\");\n            version = ` [version ${cli_color_1.bold(d.version)}]`;\n        }\n        utils_1.logLabeledSuccess(LOG_TAG, `Channel URL (${cli_color_1.bold(d.site || d.target)}): ${d.url} ${expires}${version}`);\n    });\n    return deploys;\n});\nasync function syncAuthState(projectId, sites) {\n    const siteNames = sites.map((d) => d.site);\n    const urlNames = sites.map((d) => d.url);\n    try {\n        await api_1.addAuthDomains(projectId, urlNames);\n        logger_1.logger.debug(\"[hosting] added auth domain for urls\", urlNames);\n    }\n    catch (e) {\n        utils_1.logLabeledWarning(LOG_TAG, marked(`Unable to add channel domain to Firebase Auth. Visit the Firebase Console at ${utils_1.consoleUrl(projectId, \"/authentication/providers\")}`));\n        logger_1.logger.debug(\"[hosting] unable to add auth domain\", e);\n    }\n    try {\n        await api_1.cleanAuthState(projectId, siteNames);\n    }\n    catch (e) {\n        utils_1.logLabeledWarning(LOG_TAG, \"Unable to sync Firebase Auth state.\");\n        logger_1.logger.debug(\"[hosting] unable to sync auth domain\", e);\n    }\n}\n"]},"metadata":{},"sourceType":"script"}