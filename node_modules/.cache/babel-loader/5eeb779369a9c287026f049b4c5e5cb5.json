{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.extractSchema = void 0;\n\nconst lodash_1 = __importDefault(require(\"lodash\"));\n\nconst json_schema_traverse_1 = __importDefault(require(\"json-schema-traverse\"));\n\nconst jsonPaths = __importStar(require(\"./jsonPaths\"));\n\nconst jsonPtr = __importStar(require(\"json-ptr\"));\n\nconst json_schema_resolve_ref_1 = require(\"./json-schema-resolve-ref\");\n\nfunction extractSchemaPriv(subtreeRef, refResolver, options, context) {\n  const subtreeObject = refResolver(subtreeRef);\n\n  if (!subtreeObject) {\n    throw new Error(`Could not find ref ${subtreeRef}`);\n  }\n\n  const result = lodash_1.default.cloneDeep(subtreeObject);\n  const ctx = context || {\n    result: result,\n    replaced: {},\n    replacements: [],\n    schemaCount: 0,\n    rootSubtreeRef: subtreeRef\n  };\n  json_schema_traverse_1.default(result, schema => {\n    if (schema.$ref && typeof schema.$ref === 'string') {\n      if (ctx.replaced[schema.$ref]) {\n        schema.$ref = ctx.replaced[schema.$ref];\n      } else if (jsonPaths.jsonPointerStartsWith(schema.$ref, ctx.rootSubtreeRef + '/')) {\n        ctx.replaced[schema.$ref] = jsonPaths.jsonPointerStripPrefix(schema.$ref, ctx.rootSubtreeRef);\n        schema.$ref = ctx.replaced[schema.$ref];\n      } else if (!refResolver(schema.$ref)) {\n        // Don't know how to resolve this ref\n        if (!options.skipUnknownRefs) {\n          throw new Error(`Can't find ref ${schema.$ref}`);\n        }\n      } else {\n        ctx.result.definitions = ctx.result.definitions || {}; // Find a name to store this under in 'definitions'.\n        //\n        // Because we try to pick a \"sensible\" name for the new definition,\n        // when we recurse into `extractSchemaPriv` below, if there's a child\n        // schema with the same name as the one we just picked, we could\n        // end up accidentally giving two different schemas the same name\n        // and clobbering one with the other.  To avoid this, we record\n        // all the `newRefSuffix`es we pick in `ctx.replacements`, and\n        // then we can make sure this doesn't happen.\n\n        const origRef = schema.$ref;\n        const jsonPath = jsonPtr.JsonPointer.decode(schema.$ref);\n        let newRefSuffix = jsonPath.length > 0 ? `${jsonPath[jsonPath.length - 1]}` : undefined;\n\n        while (!newRefSuffix || ctx.result.definitions[newRefSuffix] || ctx.replacements.includes(newRefSuffix)) {\n          newRefSuffix = `schema${ctx.schemaCount++}`;\n        }\n\n        ctx.replacements.push(newRefSuffix); // Do the replacement.\n\n        schema.$ref = ctx.replaced[schema.$ref] = `#/definitions/${newRefSuffix}`;\n        ctx.result.definitions[newRefSuffix] = extractSchemaPriv(origRef, refResolver, options, ctx);\n      }\n    }\n  });\n  return result;\n}\n/**\n * Extracts a subtree from a JSON document, fixing any \"$ref\" JSON refs so they\n * now\n *\n * @param document - The document to extract a subtree from.\n * @param subtree - A JSON ref to the subtree to extract, or a child node of `document`.\n * @param [options.resolveRef] - A function which, given a JSON reference, resolves the node\n *   it refers to.\n * @param [options.skipUnknownRefs] - If true, skip any unknown refs instead of\n *   throwing an error.\n * @returns the extracted document.  The returned document is a copy, and shares\n *   no children with the original document.\n */\n\n\nfunction extractSchema(document, subtreeRef, options = {}) {\n  const refResolver = options.resolveRef || json_schema_resolve_ref_1.resolveRef.bind(null, document);\n  return extractSchemaPriv(subtreeRef, refResolver, options, undefined);\n}\n\nexports.extractSchema = extractSchema;","map":{"version":3,"sources":["../../src/utils/jsonSchema.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.extractSchema = void 0;\nconst lodash_1 = __importDefault(require(\"lodash\"));\nconst json_schema_traverse_1 = __importDefault(require(\"json-schema-traverse\"));\nconst jsonPaths = __importStar(require(\"./jsonPaths\"));\nconst jsonPtr = __importStar(require(\"json-ptr\"));\nconst json_schema_resolve_ref_1 = require(\"./json-schema-resolve-ref\");\nfunction extractSchemaPriv(subtreeRef, refResolver, options, context) {\n    const subtreeObject = refResolver(subtreeRef);\n    if (!subtreeObject) {\n        throw new Error(`Could not find ref ${subtreeRef}`);\n    }\n    const result = lodash_1.default.cloneDeep(subtreeObject);\n    const ctx = context || {\n        result: result,\n        replaced: {},\n        replacements: [],\n        schemaCount: 0,\n        rootSubtreeRef: subtreeRef,\n    };\n    json_schema_traverse_1.default(result, (schema) => {\n        if (schema.$ref && typeof schema.$ref === 'string') {\n            if (ctx.replaced[schema.$ref]) {\n                schema.$ref = ctx.replaced[schema.$ref];\n            }\n            else if (jsonPaths.jsonPointerStartsWith(schema.$ref, ctx.rootSubtreeRef + '/')) {\n                ctx.replaced[schema.$ref] = jsonPaths.jsonPointerStripPrefix(schema.$ref, ctx.rootSubtreeRef);\n                schema.$ref = ctx.replaced[schema.$ref];\n            }\n            else if (!refResolver(schema.$ref)) {\n                // Don't know how to resolve this ref\n                if (!options.skipUnknownRefs) {\n                    throw new Error(`Can't find ref ${schema.$ref}`);\n                }\n            }\n            else {\n                ctx.result.definitions = ctx.result.definitions || {};\n                // Find a name to store this under in 'definitions'.\n                //\n                // Because we try to pick a \"sensible\" name for the new definition,\n                // when we recurse into `extractSchemaPriv` below, if there's a child\n                // schema with the same name as the one we just picked, we could\n                // end up accidentally giving two different schemas the same name\n                // and clobbering one with the other.  To avoid this, we record\n                // all the `newRefSuffix`es we pick in `ctx.replacements`, and\n                // then we can make sure this doesn't happen.\n                const origRef = schema.$ref;\n                const jsonPath = jsonPtr.JsonPointer.decode(schema.$ref);\n                let newRefSuffix = jsonPath.length > 0 ? `${jsonPath[jsonPath.length - 1]}` : undefined;\n                while (!newRefSuffix ||\n                    ctx.result.definitions[newRefSuffix] ||\n                    ctx.replacements.includes(newRefSuffix)) {\n                    newRefSuffix = `schema${ctx.schemaCount++}`;\n                }\n                ctx.replacements.push(newRefSuffix);\n                // Do the replacement.\n                schema.$ref = ctx.replaced[schema.$ref] = `#/definitions/${newRefSuffix}`;\n                ctx.result.definitions[newRefSuffix] = extractSchemaPriv(origRef, refResolver, options, ctx);\n            }\n        }\n    });\n    return result;\n}\n/**\n * Extracts a subtree from a JSON document, fixing any \"$ref\" JSON refs so they\n * now\n *\n * @param document - The document to extract a subtree from.\n * @param subtree - A JSON ref to the subtree to extract, or a child node of `document`.\n * @param [options.resolveRef] - A function which, given a JSON reference, resolves the node\n *   it refers to.\n * @param [options.skipUnknownRefs] - If true, skip any unknown refs instead of\n *   throwing an error.\n * @returns the extracted document.  The returned document is a copy, and shares\n *   no children with the original document.\n */\nfunction extractSchema(document, subtreeRef, options = {}) {\n    const refResolver = options.resolveRef || json_schema_resolve_ref_1.resolveRef.bind(null, document);\n    return extractSchemaPriv(subtreeRef, refResolver, options, undefined);\n}\nexports.extractSchema = extractSchema;\n//# sourceMappingURL=jsonSchema.js.map"]},"metadata":{},"sourceType":"script"}