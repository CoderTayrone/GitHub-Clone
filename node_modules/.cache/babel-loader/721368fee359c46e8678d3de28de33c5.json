{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.compileTemplatePath = exports.hasTemplates = void 0;\n\nconst lodash_1 = require(\"lodash\");\n\nconst TEMPLATE_RE = /^(.*?){(.*?)}(.*)$/;\n/**\n * @param path - The path to check.\n * @returns true if the specified path uses templating, false otherwise.\n */\n\nfunction hasTemplates(path) {\n  return !!TEMPLATE_RE.exec(path);\n}\n\nexports.hasTemplates = hasTemplates;\n/**\n * Given a path containing template parts (e.g. \"/foo/{bar}/baz\"), returns\n * a regular expression that matches the path, and a list of parameters found.\n *\n * @param path - The path to convert.\n * @param options.openEnded - If true, then the returned `regex` will\n *   accept extra input at the end of the path.\n *\n * @returns A `{regex, params, parser}`, where:\n * - `params` is a list of parameters found in the path.\n * - `regex` is a regular expression that will match the path.  When calling\n *   `match = regex.exec(str)`, each parameter in `params[i]` will be present\n *   in `match[i+1]`.\n * - `parser` is a `fn(str)` that, given a path, will return null if\n *   the string does not match, and a `{matched, pathParams}` object if the\n *   path matches.  `pathParams` is an object where keys are parameter names\n *   and values are strings from the `path`.  `matched` is full string matched\n *   by the regex.\n */\n\nfunction compileTemplatePath(path, options = {}) {\n  const params = []; // Split up the path at each parameter.\n\n  const regexParts = [];\n  let remainingPath = path;\n  let tempateMatch;\n\n  do {\n    tempateMatch = TEMPLATE_RE.exec(remainingPath);\n\n    if (tempateMatch) {\n      regexParts.push(tempateMatch[1]);\n      params.push(tempateMatch[2]);\n      remainingPath = tempateMatch[3];\n    }\n  } while (tempateMatch);\n\n  regexParts.push(remainingPath);\n  const regexStr = regexParts.map(lodash_1.escapeRegExp).join('([^/]*)');\n  const regex = options.openEnded ? new RegExp(`^${regexStr}`) : new RegExp(`^${regexStr}$`);\n\n  const parser = urlPathname => {\n    const match = regex.exec(urlPathname);\n\n    if (match) {\n      return {\n        matched: match[0],\n        rawPathParams: params.reduce((result, paramName, index) => {\n          result[paramName] = match[index + 1];\n          return result;\n        }, {})\n      };\n    } else {\n      return null;\n    }\n  };\n\n  return {\n    regex,\n    params,\n    parser\n  };\n}\n\nexports.compileTemplatePath = compileTemplatePath;\n\nclass PathResolver {\n  // TODO: Pass in variable styles.  Some variable styles start with a special\n  // character, and we can check to see if the character is there or not.\n  // (Or, replace this whole class with a uri-template engine.)\n  constructor() {\n    this._staticPaths = Object.create(null);\n    this._dynamicPaths = [];\n  }\n\n  registerPath(path, value) {\n    if (!path.startsWith('/')) {\n      throw new Error(`Invalid path \"${path}\"`);\n    }\n\n    if (hasTemplates(path)) {\n      const {\n        parser\n      } = compileTemplatePath(path);\n\n      this._dynamicPaths.push({\n        value,\n        parser,\n        path\n      });\n    } else {\n      this._staticPaths[path] = value;\n    }\n  }\n  /**\n   * Given a `pathname` from a URL (e.g. \"/foo/bar\") this will return the\n   * a static path if one exists, otherwise a path with templates if one\n   * exists.\n   *\n   * @param urlPathname - The pathname to search for.\n   * @returns A `{value, rawPathParams} object if a path is matched, or\n   *   undefined if there was no match.\n   */\n\n\n  resolvePath(urlPathname) {\n    let value = this._staticPaths[urlPathname];\n    let rawPathParams;\n    let path = urlPathname;\n\n    if (!value) {\n      for (const dynamicPath of this._dynamicPaths) {\n        const matched = dynamicPath.parser(urlPathname);\n\n        if (matched) {\n          value = dynamicPath.value;\n          rawPathParams = matched.rawPathParams;\n          path = dynamicPath.path;\n        }\n      }\n    }\n\n    if (value) {\n      return {\n        value,\n        rawPathParams,\n        path\n      };\n    } else {\n      return undefined;\n    }\n  }\n\n}\n\nexports.default = PathResolver;","map":{"version":3,"sources":["../../../src/oas3/Paths/PathResolver.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.compileTemplatePath = exports.hasTemplates = void 0;\nconst lodash_1 = require(\"lodash\");\nconst TEMPLATE_RE = /^(.*?){(.*?)}(.*)$/;\n/**\n * @param path - The path to check.\n * @returns true if the specified path uses templating, false otherwise.\n */\nfunction hasTemplates(path) {\n    return !!TEMPLATE_RE.exec(path);\n}\nexports.hasTemplates = hasTemplates;\n/**\n * Given a path containing template parts (e.g. \"/foo/{bar}/baz\"), returns\n * a regular expression that matches the path, and a list of parameters found.\n *\n * @param path - The path to convert.\n * @param options.openEnded - If true, then the returned `regex` will\n *   accept extra input at the end of the path.\n *\n * @returns A `{regex, params, parser}`, where:\n * - `params` is a list of parameters found in the path.\n * - `regex` is a regular expression that will match the path.  When calling\n *   `match = regex.exec(str)`, each parameter in `params[i]` will be present\n *   in `match[i+1]`.\n * - `parser` is a `fn(str)` that, given a path, will return null if\n *   the string does not match, and a `{matched, pathParams}` object if the\n *   path matches.  `pathParams` is an object where keys are parameter names\n *   and values are strings from the `path`.  `matched` is full string matched\n *   by the regex.\n */\nfunction compileTemplatePath(path, options = {}) {\n    const params = [];\n    // Split up the path at each parameter.\n    const regexParts = [];\n    let remainingPath = path;\n    let tempateMatch;\n    do {\n        tempateMatch = TEMPLATE_RE.exec(remainingPath);\n        if (tempateMatch) {\n            regexParts.push(tempateMatch[1]);\n            params.push(tempateMatch[2]);\n            remainingPath = tempateMatch[3];\n        }\n    } while (tempateMatch);\n    regexParts.push(remainingPath);\n    const regexStr = regexParts.map(lodash_1.escapeRegExp).join('([^/]*)');\n    const regex = options.openEnded ? new RegExp(`^${regexStr}`) : new RegExp(`^${regexStr}$`);\n    const parser = (urlPathname) => {\n        const match = regex.exec(urlPathname);\n        if (match) {\n            return {\n                matched: match[0],\n                rawPathParams: params.reduce((result, paramName, index) => {\n                    result[paramName] = match[index + 1];\n                    return result;\n                }, {}),\n            };\n        }\n        else {\n            return null;\n        }\n    };\n    return { regex, params, parser };\n}\nexports.compileTemplatePath = compileTemplatePath;\nclass PathResolver {\n    // TODO: Pass in variable styles.  Some variable styles start with a special\n    // character, and we can check to see if the character is there or not.\n    // (Or, replace this whole class with a uri-template engine.)\n    constructor() {\n        this._staticPaths = Object.create(null);\n        this._dynamicPaths = [];\n    }\n    registerPath(path, value) {\n        if (!path.startsWith('/')) {\n            throw new Error(`Invalid path \"${path}\"`);\n        }\n        if (hasTemplates(path)) {\n            const { parser } = compileTemplatePath(path);\n            this._dynamicPaths.push({ value, parser, path });\n        }\n        else {\n            this._staticPaths[path] = value;\n        }\n    }\n    /**\n     * Given a `pathname` from a URL (e.g. \"/foo/bar\") this will return the\n     * a static path if one exists, otherwise a path with templates if one\n     * exists.\n     *\n     * @param urlPathname - The pathname to search for.\n     * @returns A `{value, rawPathParams} object if a path is matched, or\n     *   undefined if there was no match.\n     */\n    resolvePath(urlPathname) {\n        let value = this._staticPaths[urlPathname];\n        let rawPathParams;\n        let path = urlPathname;\n        if (!value) {\n            for (const dynamicPath of this._dynamicPaths) {\n                const matched = dynamicPath.parser(urlPathname);\n                if (matched) {\n                    value = dynamicPath.value;\n                    rawPathParams = matched.rawPathParams;\n                    path = dynamicPath.path;\n                }\n            }\n        }\n        if (value) {\n            return {\n                value,\n                rawPathParams,\n                path,\n            };\n        }\n        else {\n            return undefined;\n        }\n    }\n}\nexports.default = PathResolver;\n//# sourceMappingURL=PathResolver.js.map"]},"metadata":{},"sourceType":"script"}