{"ast":null,"code":"var binary = require('binary');\n\nvar PullStream = require('../PullStream');\n\nvar unzip = require('./unzip');\n\nvar Promise = require('bluebird');\n\nvar BufferStream = require('../BufferStream');\n\nvar parseExtraField = require('../parseExtraField');\n\nvar Buffer = require('../Buffer');\n\nvar path = require('path');\n\nvar Writer = require('fstream').Writer;\n\nvar parseDateTime = require('../parseDateTime');\n\nvar signature = Buffer.alloc(4);\nsignature.writeUInt32LE(0x06054b50, 0);\n\nfunction getCrxHeader(source) {\n  var sourceStream = source.stream(0).pipe(PullStream());\n  return sourceStream.pull(4).then(function (data) {\n    var signature = data.readUInt32LE(0);\n\n    if (signature === 0x34327243) {\n      var crxHeader;\n      return sourceStream.pull(12).then(function (data) {\n        crxHeader = binary.parse(data).word32lu('version').word32lu('pubKeyLength').word32lu('signatureLength').vars;\n      }).then(function () {\n        return sourceStream.pull(crxHeader.pubKeyLength + crxHeader.signatureLength);\n      }).then(function (data) {\n        crxHeader.publicKey = data.slice(0, crxHeader.pubKeyLength);\n        crxHeader.signature = data.slice(crxHeader.pubKeyLength);\n        crxHeader.size = 16 + crxHeader.pubKeyLength + crxHeader.signatureLength;\n        return crxHeader;\n      });\n    }\n  });\n} // Zip64 File Format Notes: https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT\n\n\nfunction getZip64CentralDirectory(source, zip64CDL) {\n  var d64loc = binary.parse(zip64CDL).word32lu('signature').word32lu('diskNumber').word64lu('offsetToStartOfCentralDirectory').word32lu('numberOfDisks').vars;\n\n  if (d64loc.signature != 0x07064b50) {\n    throw new Error('invalid zip64 end of central dir locator signature (0x07064b50): 0x' + d64loc.signature.toString(16));\n  }\n\n  var dir64 = PullStream();\n  source.stream(d64loc.offsetToStartOfCentralDirectory).pipe(dir64);\n  return dir64.pull(56);\n} // Zip64 File Format Notes: https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT\n\n\nfunction parseZip64DirRecord(dir64record) {\n  var vars = binary.parse(dir64record).word32lu('signature').word64lu('sizeOfCentralDirectory').word16lu('version').word16lu('versionsNeededToExtract').word32lu('diskNumber').word32lu('diskStart').word64lu('numberOfRecordsOnDisk').word64lu('numberOfRecords').word64lu('sizeOfCentralDirectory').word64lu('offsetToStartOfCentralDirectory').vars;\n\n  if (vars.signature != 0x06064b50) {\n    throw new Error('invalid zip64 end of central dir locator signature (0x06064b50): 0x0' + vars.signature.toString(16));\n  }\n\n  return vars;\n}\n\nmodule.exports = function centralDirectory(source, options) {\n  var endDir = PullStream(),\n      records = PullStream(),\n      tailSize = options && options.tailSize || 80,\n      sourceSize,\n      crxHeader,\n      startOffset,\n      vars;\n  if (options && options.crx) crxHeader = getCrxHeader(source);\n  return source.size().then(function (size) {\n    sourceSize = size;\n    source.stream(Math.max(0, size - tailSize)).on('error', function (error) {\n      endDir.emit('error', error);\n    }).pipe(endDir);\n    return endDir.pull(signature);\n  }).then(function () {\n    return Promise.props({\n      directory: endDir.pull(22),\n      crxHeader: crxHeader\n    });\n  }).then(function (d) {\n    var data = d.directory;\n    startOffset = d.crxHeader && d.crxHeader.size || 0;\n    vars = binary.parse(data).word32lu('signature').word16lu('diskNumber').word16lu('diskStart').word16lu('numberOfRecordsOnDisk').word16lu('numberOfRecords').word32lu('sizeOfCentralDirectory').word32lu('offsetToStartOfCentralDirectory').word16lu('commentLength').vars; // Is this zip file using zip64 format? Use same check as Go:\n    // https://github.com/golang/go/blob/master/src/archive/zip/reader.go#L503\n    // For zip64 files, need to find zip64 central directory locator header to extract\n    // relative offset for zip64 central directory record.\n\n    if (vars.numberOfRecords == 0xffff || vars.numberOfRecords == 0xffff || vars.offsetToStartOfCentralDirectory == 0xffffffff) {\n      // Offset to zip64 CDL is 20 bytes before normal CDR\n      const zip64CDLSize = 20;\n      const zip64CDLOffset = sourceSize - (tailSize - endDir.match + zip64CDLSize);\n      const zip64CDLStream = PullStream();\n      source.stream(zip64CDLOffset).pipe(zip64CDLStream);\n      return zip64CDLStream.pull(zip64CDLSize).then(function (d) {\n        return getZip64CentralDirectory(source, d);\n      }).then(function (dir64record) {\n        vars = parseZip64DirRecord(dir64record);\n      });\n    } else {\n      vars.offsetToStartOfCentralDirectory += startOffset;\n    }\n  }).then(function () {\n    source.stream(vars.offsetToStartOfCentralDirectory).pipe(records);\n\n    vars.extract = function (opts) {\n      if (!opts || !opts.path) throw new Error('PATH_MISSING');\n      return vars.files.then(function (files) {\n        return Promise.map(files, function (entry) {\n          if (entry.type == 'Directory') return; // to avoid zip slip (writing outside of the destination), we resolve\n          // the target path, and make sure it's nested in the intended\n          // destination, or not extract it otherwise.\n\n          var extractPath = path.join(opts.path, entry.path);\n\n          if (extractPath.indexOf(opts.path) != 0) {\n            return;\n          }\n\n          var writer = opts.getWriter ? opts.getWriter({\n            path: extractPath\n          }) : Writer({\n            path: extractPath\n          });\n          return new Promise(function (resolve, reject) {\n            entry.stream(opts.password).on('error', reject).pipe(writer).on('close', resolve).on('error', reject);\n          });\n        }, opts.concurrency > 1 ? {\n          concurrency: opts.concurrency || undefined\n        } : undefined);\n      });\n    };\n\n    vars.files = Promise.mapSeries(Array(vars.numberOfRecords), function () {\n      return records.pull(46).then(function (data) {\n        var vars = binary.parse(data).word32lu('signature').word16lu('versionMadeBy').word16lu('versionsNeededToExtract').word16lu('flags').word16lu('compressionMethod').word16lu('lastModifiedTime').word16lu('lastModifiedDate').word32lu('crc32').word32lu('compressedSize').word32lu('uncompressedSize').word16lu('fileNameLength').word16lu('extraFieldLength').word16lu('fileCommentLength').word16lu('diskNumber').word16lu('internalFileAttributes').word32lu('externalFileAttributes').word32lu('offsetToLocalFileHeader').vars;\n        vars.offsetToLocalFileHeader += startOffset;\n        vars.lastModifiedDateTime = parseDateTime(vars.lastModifiedDate, vars.lastModifiedTime);\n        return records.pull(vars.fileNameLength).then(function (fileNameBuffer) {\n          vars.pathBuffer = fileNameBuffer;\n          vars.path = fileNameBuffer.toString('utf8');\n          vars.isUnicode = vars.flags & 0x11;\n          return records.pull(vars.extraFieldLength);\n        }).then(function (extraField) {\n          vars.extra = parseExtraField(extraField, vars);\n          return records.pull(vars.fileCommentLength);\n        }).then(function (comment) {\n          vars.comment = comment;\n          vars.type = vars.uncompressedSize === 0 && /[\\/\\\\]$/.test(vars.path) ? 'Directory' : 'File';\n\n          vars.stream = function (_password) {\n            return unzip(source, vars.offsetToLocalFileHeader, _password, vars);\n          };\n\n          vars.buffer = function (_password) {\n            return BufferStream(vars.stream(_password));\n          };\n\n          return vars;\n        });\n      });\n    });\n    return Promise.props(vars);\n  });\n};","map":{"version":3,"sources":["/home/dev/Documentos/Projects/github-clone/node_modules/unzipper/lib/Open/directory.js"],"names":["binary","require","PullStream","unzip","Promise","BufferStream","parseExtraField","Buffer","path","Writer","parseDateTime","signature","alloc","writeUInt32LE","getCrxHeader","source","sourceStream","stream","pipe","pull","then","data","readUInt32LE","crxHeader","parse","word32lu","vars","pubKeyLength","signatureLength","publicKey","slice","size","getZip64CentralDirectory","zip64CDL","d64loc","word64lu","Error","toString","dir64","offsetToStartOfCentralDirectory","parseZip64DirRecord","dir64record","word16lu","module","exports","centralDirectory","options","endDir","records","tailSize","sourceSize","startOffset","crx","Math","max","on","error","emit","props","directory","d","numberOfRecords","zip64CDLSize","zip64CDLOffset","match","zip64CDLStream","extract","opts","files","map","entry","type","extractPath","join","indexOf","writer","getWriter","resolve","reject","password","concurrency","undefined","mapSeries","Array","offsetToLocalFileHeader","lastModifiedDateTime","lastModifiedDate","lastModifiedTime","fileNameLength","fileNameBuffer","pathBuffer","isUnicode","flags","extraFieldLength","extraField","extra","fileCommentLength","comment","uncompressedSize","test","_password","buffer"],"mappings":"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","sourcesContent":["var binary = require('binary');\nvar PullStream = require('../PullStream');\nvar unzip = require('./unzip');\nvar Promise = require('bluebird');\nvar BufferStream = require('../BufferStream');\nvar parseExtraField = require('../parseExtraField');\nvar Buffer = require('../Buffer');\nvar path = require('path');\nvar Writer = require('fstream').Writer;\nvar parseDateTime = require('../parseDateTime');\n\nvar signature = Buffer.alloc(4);\nsignature.writeUInt32LE(0x06054b50,0);\n\nfunction getCrxHeader(source) {\n  var sourceStream = source.stream(0).pipe(PullStream());\n\n  return sourceStream.pull(4).then(function(data) {\n    var signature = data.readUInt32LE(0);\n    if (signature === 0x34327243) {\n      var crxHeader;\n      return sourceStream.pull(12).then(function(data) {\n        crxHeader = binary.parse(data)\n          .word32lu('version')\n          .word32lu('pubKeyLength')\n          .word32lu('signatureLength')\n          .vars;\n      }).then(function() {\n        return sourceStream.pull(crxHeader.pubKeyLength +crxHeader.signatureLength);\n      }).then(function(data) {\n        crxHeader.publicKey = data.slice(0,crxHeader.pubKeyLength);\n        crxHeader.signature = data.slice(crxHeader.pubKeyLength);\n        crxHeader.size = 16 + crxHeader.pubKeyLength +crxHeader.signatureLength;\n        return crxHeader;\n      });\n    }\n  });\n}\n\n// Zip64 File Format Notes: https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT\nfunction getZip64CentralDirectory(source, zip64CDL) {\n  var d64loc = binary.parse(zip64CDL)\n    .word32lu('signature')\n    .word32lu('diskNumber')\n    .word64lu('offsetToStartOfCentralDirectory')\n    .word32lu('numberOfDisks')\n    .vars;\n\n  if (d64loc.signature != 0x07064b50) {\n    throw new Error('invalid zip64 end of central dir locator signature (0x07064b50): 0x' + d64loc.signature.toString(16));\n  }\n\n  var dir64 = PullStream();\n  source.stream(d64loc.offsetToStartOfCentralDirectory).pipe(dir64);\n\n  return dir64.pull(56)\n}\n\n// Zip64 File Format Notes: https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT\nfunction parseZip64DirRecord (dir64record) {\n  var vars = binary.parse(dir64record)\n    .word32lu('signature')\n    .word64lu('sizeOfCentralDirectory')\n    .word16lu('version')\n    .word16lu('versionsNeededToExtract')\n    .word32lu('diskNumber')\n    .word32lu('diskStart')\n    .word64lu('numberOfRecordsOnDisk')\n    .word64lu('numberOfRecords')\n    .word64lu('sizeOfCentralDirectory')\n    .word64lu('offsetToStartOfCentralDirectory')\n    .vars;\n\n  if (vars.signature != 0x06064b50) {\n    throw new Error('invalid zip64 end of central dir locator signature (0x06064b50): 0x0' + vars.signature.toString(16));\n  }\n\n  return vars\n}\n\nmodule.exports = function centralDirectory(source, options) {\n  var endDir = PullStream(),\n      records = PullStream(),\n      tailSize = (options && options.tailSize) || 80,\n      sourceSize,\n      crxHeader,\n      startOffset,\n      vars;\n\n  if (options && options.crx)\n    crxHeader = getCrxHeader(source);\n\n  return source.size()\n    .then(function(size) {\n      sourceSize = size;\n\n      source.stream(Math.max(0,size-tailSize))\n        .on('error', function (error) { endDir.emit('error', error) })\n        .pipe(endDir);\n\n      return endDir.pull(signature);\n    })\n    .then(function() {\n      return Promise.props({directory: endDir.pull(22), crxHeader: crxHeader});\n    })\n    .then(function(d) {\n      var data = d.directory;\n      startOffset = d.crxHeader && d.crxHeader.size || 0;\n\n      vars = binary.parse(data)\n        .word32lu('signature')\n        .word16lu('diskNumber')\n        .word16lu('diskStart')\n        .word16lu('numberOfRecordsOnDisk')\n        .word16lu('numberOfRecords')\n        .word32lu('sizeOfCentralDirectory')\n        .word32lu('offsetToStartOfCentralDirectory')\n        .word16lu('commentLength')\n        .vars;\n\n      // Is this zip file using zip64 format? Use same check as Go:\n      // https://github.com/golang/go/blob/master/src/archive/zip/reader.go#L503\n      // For zip64 files, need to find zip64 central directory locator header to extract\n      // relative offset for zip64 central directory record.\n      if (vars.numberOfRecords == 0xffff|| vars.numberOfRecords == 0xffff ||\n        vars.offsetToStartOfCentralDirectory == 0xffffffff) {\n\n        // Offset to zip64 CDL is 20 bytes before normal CDR\n        const zip64CDLSize = 20\n        const zip64CDLOffset = sourceSize - (tailSize - endDir.match + zip64CDLSize)\n        const zip64CDLStream = PullStream();\n\n        source.stream(zip64CDLOffset).pipe(zip64CDLStream);\n\n        return zip64CDLStream.pull(zip64CDLSize)\n          .then(function (d) { return getZip64CentralDirectory(source, d) })\n          .then(function (dir64record) {\n            vars = parseZip64DirRecord(dir64record)\n          })\n      } else {\n        vars.offsetToStartOfCentralDirectory += startOffset;\n      }\n    })\n    .then(function() {\n      source.stream(vars.offsetToStartOfCentralDirectory).pipe(records);\n\n      vars.extract = function(opts) {\n        if (!opts || !opts.path) throw new Error('PATH_MISSING');\n        return vars.files.then(function(files) {\n          return Promise.map(files, function(entry) {\n            if (entry.type == 'Directory') return;\n\n            // to avoid zip slip (writing outside of the destination), we resolve\n            // the target path, and make sure it's nested in the intended\n            // destination, or not extract it otherwise.\n            var extractPath = path.join(opts.path, entry.path);\n            if (extractPath.indexOf(opts.path) != 0) {\n              return;\n            }\n            var writer = opts.getWriter ? opts.getWriter({path: extractPath}) :  Writer({ path: extractPath });\n\n            return new Promise(function(resolve, reject) {\n              entry.stream(opts.password)\n                .on('error',reject)\n                .pipe(writer)\n                .on('close',resolve)\n                .on('error',reject);\n            });\n          }, opts.concurrency > 1 ? {concurrency: opts.concurrency || undefined} : undefined);\n        });\n      };\n\n      vars.files = Promise.mapSeries(Array(vars.numberOfRecords),function() {\n        return records.pull(46).then(function(data) {    \n          var vars = binary.parse(data)\n            .word32lu('signature')\n            .word16lu('versionMadeBy')\n            .word16lu('versionsNeededToExtract')\n            .word16lu('flags')\n            .word16lu('compressionMethod')\n            .word16lu('lastModifiedTime')\n            .word16lu('lastModifiedDate')\n            .word32lu('crc32')\n            .word32lu('compressedSize')\n            .word32lu('uncompressedSize')\n            .word16lu('fileNameLength')\n            .word16lu('extraFieldLength')\n            .word16lu('fileCommentLength')\n            .word16lu('diskNumber')\n            .word16lu('internalFileAttributes')\n            .word32lu('externalFileAttributes')\n            .word32lu('offsetToLocalFileHeader')\n            .vars;\n\n        vars.offsetToLocalFileHeader += startOffset;\n        vars.lastModifiedDateTime = parseDateTime(vars.lastModifiedDate, vars.lastModifiedTime);\n\n        return records.pull(vars.fileNameLength).then(function(fileNameBuffer) {\n          vars.pathBuffer = fileNameBuffer;\n          vars.path = fileNameBuffer.toString('utf8');\n          vars.isUnicode = vars.flags & 0x11;\n          return records.pull(vars.extraFieldLength);\n        })\n        .then(function(extraField) {\n          vars.extra = parseExtraField(extraField, vars);\n          return records.pull(vars.fileCommentLength);\n        })\n        .then(function(comment) {\n          vars.comment = comment;\n          vars.type = (vars.uncompressedSize === 0 && /[\\/\\\\]$/.test(vars.path)) ? 'Directory' : 'File';\n          vars.stream = function(_password) {\n            return unzip(source, vars.offsetToLocalFileHeader,_password, vars);\n          };\n          vars.buffer = function(_password) {\n            return BufferStream(vars.stream(_password));\n          };\n          return vars;\n        });\n      });\n    });\n\n    return Promise.props(vars);\n  });\n};\n"]},"metadata":{},"sourceType":"script"}