{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FirestoreDelete = void 0;\n\nconst clc = require(\"cli-color\");\n\nconst ProgressBar = require(\"progress\");\n\nconst apiv2 = require(\"../apiv2\");\n\nconst firestore = require(\"../gcp/firestore\");\n\nconst error_1 = require(\"../error\");\n\nconst logger_1 = require(\"../logger\");\n\nconst utils = require(\"../utils\");\n\nconst api_1 = require(\"../api\");\n\nconst MIN_ID = \"__id-9223372036854775808__\";\n\nclass FirestoreDelete {\n  constructor(project, path, options) {\n    this.project = project;\n    this.path = path || \"\";\n    this.recursive = Boolean(options.recursive);\n    this.shallow = Boolean(options.shallow);\n    this.allCollections = Boolean(options.allCollections);\n    this.readBatchSize = 7500;\n    this.maxPendingDeletes = 15;\n    this.deleteBatchSize = 250;\n    this.maxQueueSize = this.deleteBatchSize * this.maxPendingDeletes * 2;\n    this.path = this.path.replace(/(^\\/+|\\/+$)/g, \"\");\n    this.allDescendants = this.recursive;\n    this.root = \"projects/\" + project + \"/databases/(default)/documents\";\n    const segments = this.path.split(\"/\");\n    this.isDocumentPath = segments.length % 2 === 0;\n    this.isCollectionPath = !this.isDocumentPath;\n    this.parent = this.root;\n\n    if (this.isCollectionPath) {\n      segments.pop();\n    }\n\n    if (segments.length > 0) {\n      this.parent += \"/\" + segments.join(\"/\");\n    }\n\n    if (!options.allCollections) {\n      this.validateOptions();\n    }\n\n    this.apiClient = new apiv2.Client({\n      auth: true,\n      apiVersion: \"v1\",\n      urlPrefix: api_1.firestoreOriginOrEmulator\n    });\n  }\n\n  setDeleteBatchSize(size) {\n    this.deleteBatchSize = size;\n    this.maxQueueSize = this.deleteBatchSize * this.maxPendingDeletes * 2;\n  }\n\n  validateOptions() {\n    if (this.recursive && this.shallow) {\n      throw new error_1.FirebaseError(\"Cannot pass recursive and shallow options together.\");\n    }\n\n    if (this.isCollectionPath && !this.recursive && !this.shallow) {\n      throw new error_1.FirebaseError(\"Must pass recursive or shallow option when deleting a collection.\");\n    }\n\n    const pieces = this.path.split(\"/\");\n\n    if (pieces.length === 0) {\n      throw new error_1.FirebaseError(\"Path length must be greater than zero.\");\n    }\n\n    const hasEmptySegment = pieces.some(piece => {\n      return piece.length === 0;\n    });\n\n    if (hasEmptySegment) {\n      throw new error_1.FirebaseError(\"Path must not have any empty segments.\");\n    }\n  }\n\n  collectionDescendantsQuery(allDescendants, batchSize, startAfter) {\n    const nullChar = String.fromCharCode(0);\n    const startAt = this.root + \"/\" + this.path + \"/\" + MIN_ID;\n    const endAt = this.root + \"/\" + this.path + nullChar + \"/\" + MIN_ID;\n    const where = {\n      compositeFilter: {\n        op: \"AND\",\n        filters: [{\n          fieldFilter: {\n            field: {\n              fieldPath: \"__name__\"\n            },\n            op: \"GREATER_THAN_OR_EQUAL\",\n            value: {\n              referenceValue: startAt\n            }\n          }\n        }, {\n          fieldFilter: {\n            field: {\n              fieldPath: \"__name__\"\n            },\n            op: \"LESS_THAN\",\n            value: {\n              referenceValue: endAt\n            }\n          }\n        }]\n      }\n    };\n    const query = {\n      structuredQuery: {\n        where: where,\n        limit: batchSize,\n        from: [{\n          allDescendants: allDescendants\n        }],\n        select: {\n          fields: [{\n            fieldPath: \"__name__\"\n          }]\n        },\n        orderBy: [{\n          field: {\n            fieldPath: \"__name__\"\n          }\n        }]\n      }\n    };\n\n    if (startAfter) {\n      query.structuredQuery.startAt = {\n        values: [{\n          referenceValue: startAfter\n        }],\n        before: false\n      };\n    }\n\n    return query;\n  }\n\n  docDescendantsQuery(allDescendants, batchSize, startAfter) {\n    const query = {\n      structuredQuery: {\n        limit: batchSize,\n        from: [{\n          allDescendants: allDescendants\n        }],\n        select: {\n          fields: [{\n            fieldPath: \"__name__\"\n          }]\n        },\n        orderBy: [{\n          field: {\n            fieldPath: \"__name__\"\n          }\n        }]\n      }\n    };\n\n    if (startAfter) {\n      query.structuredQuery.startAt = {\n        values: [{\n          referenceValue: startAfter\n        }],\n        before: false\n      };\n    }\n\n    return query;\n  }\n\n  getDescendantBatch(allDescendants, batchSize, startAfter) {\n    const url = this.parent + \":runQuery\";\n    const body = this.isDocumentPath ? this.docDescendantsQuery(allDescendants, batchSize, startAfter) : this.collectionDescendantsQuery(allDescendants, batchSize, startAfter);\n    return this.apiClient.post(url, body).then(res => {\n      const docs = [];\n\n      for (const x of res.body) {\n        if (x.document) {\n          docs.push(x.document);\n        }\n      }\n\n      return docs;\n    });\n  }\n\n  recursiveBatchDelete() {\n    let queue = [];\n    let numDocsDeleted = 0;\n    let numPendingDeletes = 0;\n    let pagesRemaining = true;\n    let pageIncoming = false;\n    let lastDocName = undefined;\n    const retried = {};\n    const failures = [];\n    let fetchFailures = 0;\n\n    const queueLoop = () => {\n      if (queue.length === 0 && numPendingDeletes === 0 && !pagesRemaining) {\n        return true;\n      }\n\n      if (failures.length > 0) {\n        logger_1.logger.debug(\"Found \" + failures.length + \" failed operations, failing.\");\n        return true;\n      }\n\n      if (queue.length <= this.maxQueueSize && pagesRemaining && !pageIncoming) {\n        pageIncoming = true;\n        this.getDescendantBatch(this.allDescendants, this.readBatchSize, lastDocName).then(docs => {\n          fetchFailures = 0;\n          pageIncoming = false;\n\n          if (docs.length === 0) {\n            pagesRemaining = false;\n            return;\n          }\n\n          queue = queue.concat(docs);\n          lastDocName = docs[docs.length - 1].name;\n        }).catch(e => {\n          logger_1.logger.debug(\"Failed to fetch page after \" + lastDocName, e);\n          pageIncoming = false;\n          fetchFailures++;\n\n          if (fetchFailures >= 3) {\n            failures.push(\"Failed to fetch documents to delete >= 3 times.\");\n          }\n        });\n      }\n\n      if (numDocsDeleted === 0 && numPendingDeletes >= 1) {\n        return false;\n      }\n\n      if (numPendingDeletes > this.maxPendingDeletes) {\n        return false;\n      }\n\n      if (queue.length === 0) {\n        return false;\n      }\n\n      const toDelete = [];\n      const numToDelete = Math.min(this.deleteBatchSize, queue.length);\n\n      for (let i = 0; i < numToDelete; i++) {\n        const d = queue.shift();\n\n        if (d) {\n          toDelete.push(d);\n        }\n      }\n\n      numPendingDeletes++;\n      firestore.deleteDocuments(this.project, toDelete).then(numDeleted => {\n        FirestoreDelete.progressBar.tick(numDeleted);\n        numDocsDeleted += numDeleted;\n        numPendingDeletes--;\n      }).catch(e => {\n        if (e.status === 400 && e.message.includes(\"Transaction too big\") && this.deleteBatchSize >= 2) {\n          logger_1.logger.debug(\"Transaction too big error deleting doc batch\", e);\n          const newBatchSize = Math.floor(toDelete.length / 10);\n\n          if (newBatchSize < this.deleteBatchSize) {\n            utils.logLabeledWarning(\"firestore\", `delete transaction too large, reducing batch size from ${this.deleteBatchSize} to ${newBatchSize}`);\n            this.setDeleteBatchSize(newBatchSize);\n          }\n\n          queue.unshift(...toDelete);\n        } else if (e.status >= 500 && e.status < 600) {\n          logger_1.logger.debug(\"Server error deleting doc batch\", e);\n          toDelete.forEach(doc => {\n            if (retried[doc.name]) {\n              const message = `Failed to delete doc ${doc.name} multiple times.`;\n              logger_1.logger.debug(message);\n              failures.push(message);\n            } else {\n              retried[doc.name] = true;\n              queue.push(doc);\n            }\n          });\n        } else {\n          const docIds = toDelete.map(d => d.name).join(\", \");\n          const msg = `Fatal error deleting docs ${docIds}`;\n          logger_1.logger.debug(msg, e);\n          failures.push(msg);\n        }\n\n        numPendingDeletes--;\n      });\n      return false;\n    };\n\n    return new Promise((resolve, reject) => {\n      const intervalId = setInterval(() => {\n        if (queueLoop()) {\n          clearInterval(intervalId);\n\n          if (failures.length === 0) {\n            resolve();\n          } else {\n            const errorDescription = failures.join(\", \");\n            reject(new error_1.FirebaseError(`Deletion failed. Errors: ${errorDescription}.`, {\n              exit: 1\n            }));\n          }\n        }\n      }, 0);\n    });\n  }\n\n  deletePath() {\n    let initialDelete;\n\n    if (this.isDocumentPath) {\n      const doc = {\n        name: this.root + \"/\" + this.path\n      };\n      initialDelete = firestore.deleteDocument(doc).catch(err => {\n        logger_1.logger.debug(\"deletePath:initialDelete:error\", err);\n\n        if (this.allDescendants) {\n          return Promise.resolve();\n        }\n\n        return utils.reject(\"Unable to delete \" + clc.cyan(this.path));\n      });\n    } else {\n      initialDelete = Promise.resolve();\n    }\n\n    return initialDelete.then(() => {\n      return this.recursiveBatchDelete();\n    });\n  }\n\n  deleteDatabase() {\n    return firestore.listCollectionIds(this.project).catch(err => {\n      logger_1.logger.debug(\"deleteDatabase:listCollectionIds:error\", err);\n      return utils.reject(\"Unable to list collection IDs\");\n    }).then(collectionIds => {\n      const promises = [];\n      logger_1.logger.info(\"Deleting the following collections: \" + clc.cyan(collectionIds.join(\", \")));\n\n      for (let i = 0; i < collectionIds.length; i++) {\n        const collectionId = collectionIds[i];\n        const deleteOp = new FirestoreDelete(this.project, collectionId, {\n          recursive: true\n        });\n        promises.push(deleteOp.execute());\n      }\n\n      return Promise.all(promises);\n    });\n  }\n\n  checkHasChildren() {\n    return this.getDescendantBatch(true, 1).then(docs => {\n      return docs.length > 0;\n    });\n  }\n\n  execute() {\n    let verifyRecurseSafe;\n\n    if (this.isDocumentPath && !this.recursive && !this.shallow) {\n      verifyRecurseSafe = this.checkHasChildren().then(multiple => {\n        if (multiple) {\n          return utils.reject(\"Document has children, must specify -r or --shallow.\", {\n            exit: 1\n          });\n        }\n      });\n    } else {\n      verifyRecurseSafe = Promise.resolve();\n    }\n\n    return verifyRecurseSafe.then(() => {\n      return this.deletePath();\n    });\n  }\n\n}\n\nexports.FirestoreDelete = FirestoreDelete;\nFirestoreDelete.progressBar = new ProgressBar(\"Deleted :current docs (:rate docs/s)\\n\", {\n  total: Number.MAX_SAFE_INTEGER\n});","map":{"version":3,"sources":["/home/dev/Documentos/Projects/github-clone/node_modules/firebase-tools/lib/firestore/delete.js"],"names":["Object","defineProperty","exports","value","FirestoreDelete","clc","require","ProgressBar","apiv2","firestore","error_1","logger_1","utils","api_1","MIN_ID","constructor","project","path","options","recursive","Boolean","shallow","allCollections","readBatchSize","maxPendingDeletes","deleteBatchSize","maxQueueSize","replace","allDescendants","root","segments","split","isDocumentPath","length","isCollectionPath","parent","pop","join","validateOptions","apiClient","Client","auth","apiVersion","urlPrefix","firestoreOriginOrEmulator","setDeleteBatchSize","size","FirebaseError","pieces","hasEmptySegment","some","piece","collectionDescendantsQuery","batchSize","startAfter","nullChar","String","fromCharCode","startAt","endAt","where","compositeFilter","op","filters","fieldFilter","field","fieldPath","referenceValue","query","structuredQuery","limit","from","select","fields","orderBy","values","before","docDescendantsQuery","getDescendantBatch","url","body","post","then","res","docs","x","document","push","recursiveBatchDelete","queue","numDocsDeleted","numPendingDeletes","pagesRemaining","pageIncoming","lastDocName","undefined","retried","failures","fetchFailures","queueLoop","logger","debug","concat","name","catch","e","toDelete","numToDelete","Math","min","i","d","shift","deleteDocuments","numDeleted","progressBar","tick","status","message","includes","newBatchSize","floor","logLabeledWarning","unshift","forEach","doc","docIds","map","msg","Promise","resolve","reject","intervalId","setInterval","clearInterval","errorDescription","exit","deletePath","initialDelete","deleteDocument","err","cyan","deleteDatabase","listCollectionIds","collectionIds","promises","info","collectionId","deleteOp","execute","all","checkHasChildren","verifyRecurseSafe","multiple","total","Number","MAX_SAFE_INTEGER"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FirestoreDelete = void 0;\nconst clc = require(\"cli-color\");\nconst ProgressBar = require(\"progress\");\nconst apiv2 = require(\"../apiv2\");\nconst firestore = require(\"../gcp/firestore\");\nconst error_1 = require(\"../error\");\nconst logger_1 = require(\"../logger\");\nconst utils = require(\"../utils\");\nconst api_1 = require(\"../api\");\nconst MIN_ID = \"__id-9223372036854775808__\";\nclass FirestoreDelete {\n    constructor(project, path, options) {\n        this.project = project;\n        this.path = path || \"\";\n        this.recursive = Boolean(options.recursive);\n        this.shallow = Boolean(options.shallow);\n        this.allCollections = Boolean(options.allCollections);\n        this.readBatchSize = 7500;\n        this.maxPendingDeletes = 15;\n        this.deleteBatchSize = 250;\n        this.maxQueueSize = this.deleteBatchSize * this.maxPendingDeletes * 2;\n        this.path = this.path.replace(/(^\\/+|\\/+$)/g, \"\");\n        this.allDescendants = this.recursive;\n        this.root = \"projects/\" + project + \"/databases/(default)/documents\";\n        const segments = this.path.split(\"/\");\n        this.isDocumentPath = segments.length % 2 === 0;\n        this.isCollectionPath = !this.isDocumentPath;\n        this.parent = this.root;\n        if (this.isCollectionPath) {\n            segments.pop();\n        }\n        if (segments.length > 0) {\n            this.parent += \"/\" + segments.join(\"/\");\n        }\n        if (!options.allCollections) {\n            this.validateOptions();\n        }\n        this.apiClient = new apiv2.Client({\n            auth: true,\n            apiVersion: \"v1\",\n            urlPrefix: api_1.firestoreOriginOrEmulator,\n        });\n    }\n    setDeleteBatchSize(size) {\n        this.deleteBatchSize = size;\n        this.maxQueueSize = this.deleteBatchSize * this.maxPendingDeletes * 2;\n    }\n    validateOptions() {\n        if (this.recursive && this.shallow) {\n            throw new error_1.FirebaseError(\"Cannot pass recursive and shallow options together.\");\n        }\n        if (this.isCollectionPath && !this.recursive && !this.shallow) {\n            throw new error_1.FirebaseError(\"Must pass recursive or shallow option when deleting a collection.\");\n        }\n        const pieces = this.path.split(\"/\");\n        if (pieces.length === 0) {\n            throw new error_1.FirebaseError(\"Path length must be greater than zero.\");\n        }\n        const hasEmptySegment = pieces.some((piece) => {\n            return piece.length === 0;\n        });\n        if (hasEmptySegment) {\n            throw new error_1.FirebaseError(\"Path must not have any empty segments.\");\n        }\n    }\n    collectionDescendantsQuery(allDescendants, batchSize, startAfter) {\n        const nullChar = String.fromCharCode(0);\n        const startAt = this.root + \"/\" + this.path + \"/\" + MIN_ID;\n        const endAt = this.root + \"/\" + this.path + nullChar + \"/\" + MIN_ID;\n        const where = {\n            compositeFilter: {\n                op: \"AND\",\n                filters: [\n                    {\n                        fieldFilter: {\n                            field: {\n                                fieldPath: \"__name__\",\n                            },\n                            op: \"GREATER_THAN_OR_EQUAL\",\n                            value: {\n                                referenceValue: startAt,\n                            },\n                        },\n                    },\n                    {\n                        fieldFilter: {\n                            field: {\n                                fieldPath: \"__name__\",\n                            },\n                            op: \"LESS_THAN\",\n                            value: {\n                                referenceValue: endAt,\n                            },\n                        },\n                    },\n                ],\n            },\n        };\n        const query = {\n            structuredQuery: {\n                where: where,\n                limit: batchSize,\n                from: [\n                    {\n                        allDescendants: allDescendants,\n                    },\n                ],\n                select: {\n                    fields: [{ fieldPath: \"__name__\" }],\n                },\n                orderBy: [{ field: { fieldPath: \"__name__\" } }],\n            },\n        };\n        if (startAfter) {\n            query.structuredQuery.startAt = {\n                values: [{ referenceValue: startAfter }],\n                before: false,\n            };\n        }\n        return query;\n    }\n    docDescendantsQuery(allDescendants, batchSize, startAfter) {\n        const query = {\n            structuredQuery: {\n                limit: batchSize,\n                from: [\n                    {\n                        allDescendants: allDescendants,\n                    },\n                ],\n                select: {\n                    fields: [{ fieldPath: \"__name__\" }],\n                },\n                orderBy: [{ field: { fieldPath: \"__name__\" } }],\n            },\n        };\n        if (startAfter) {\n            query.structuredQuery.startAt = {\n                values: [{ referenceValue: startAfter }],\n                before: false,\n            };\n        }\n        return query;\n    }\n    getDescendantBatch(allDescendants, batchSize, startAfter) {\n        const url = this.parent + \":runQuery\";\n        const body = this.isDocumentPath\n            ? this.docDescendantsQuery(allDescendants, batchSize, startAfter)\n            : this.collectionDescendantsQuery(allDescendants, batchSize, startAfter);\n        return this.apiClient.post(url, body).then((res) => {\n            const docs = [];\n            for (const x of res.body) {\n                if (x.document) {\n                    docs.push(x.document);\n                }\n            }\n            return docs;\n        });\n    }\n    recursiveBatchDelete() {\n        let queue = [];\n        let numDocsDeleted = 0;\n        let numPendingDeletes = 0;\n        let pagesRemaining = true;\n        let pageIncoming = false;\n        let lastDocName = undefined;\n        const retried = {};\n        const failures = [];\n        let fetchFailures = 0;\n        const queueLoop = () => {\n            if (queue.length === 0 && numPendingDeletes === 0 && !pagesRemaining) {\n                return true;\n            }\n            if (failures.length > 0) {\n                logger_1.logger.debug(\"Found \" + failures.length + \" failed operations, failing.\");\n                return true;\n            }\n            if (queue.length <= this.maxQueueSize && pagesRemaining && !pageIncoming) {\n                pageIncoming = true;\n                this.getDescendantBatch(this.allDescendants, this.readBatchSize, lastDocName)\n                    .then((docs) => {\n                    fetchFailures = 0;\n                    pageIncoming = false;\n                    if (docs.length === 0) {\n                        pagesRemaining = false;\n                        return;\n                    }\n                    queue = queue.concat(docs);\n                    lastDocName = docs[docs.length - 1].name;\n                })\n                    .catch((e) => {\n                    logger_1.logger.debug(\"Failed to fetch page after \" + lastDocName, e);\n                    pageIncoming = false;\n                    fetchFailures++;\n                    if (fetchFailures >= 3) {\n                        failures.push(\"Failed to fetch documents to delete >= 3 times.\");\n                    }\n                });\n            }\n            if (numDocsDeleted === 0 && numPendingDeletes >= 1) {\n                return false;\n            }\n            if (numPendingDeletes > this.maxPendingDeletes) {\n                return false;\n            }\n            if (queue.length === 0) {\n                return false;\n            }\n            const toDelete = [];\n            const numToDelete = Math.min(this.deleteBatchSize, queue.length);\n            for (let i = 0; i < numToDelete; i++) {\n                const d = queue.shift();\n                if (d) {\n                    toDelete.push(d);\n                }\n            }\n            numPendingDeletes++;\n            firestore\n                .deleteDocuments(this.project, toDelete)\n                .then((numDeleted) => {\n                FirestoreDelete.progressBar.tick(numDeleted);\n                numDocsDeleted += numDeleted;\n                numPendingDeletes--;\n            })\n                .catch((e) => {\n                if (e.status === 400 &&\n                    e.message.includes(\"Transaction too big\") &&\n                    this.deleteBatchSize >= 2) {\n                    logger_1.logger.debug(\"Transaction too big error deleting doc batch\", e);\n                    const newBatchSize = Math.floor(toDelete.length / 10);\n                    if (newBatchSize < this.deleteBatchSize) {\n                        utils.logLabeledWarning(\"firestore\", `delete transaction too large, reducing batch size from ${this.deleteBatchSize} to ${newBatchSize}`);\n                        this.setDeleteBatchSize(newBatchSize);\n                    }\n                    queue.unshift(...toDelete);\n                }\n                else if (e.status >= 500 && e.status < 600) {\n                    logger_1.logger.debug(\"Server error deleting doc batch\", e);\n                    toDelete.forEach((doc) => {\n                        if (retried[doc.name]) {\n                            const message = `Failed to delete doc ${doc.name} multiple times.`;\n                            logger_1.logger.debug(message);\n                            failures.push(message);\n                        }\n                        else {\n                            retried[doc.name] = true;\n                            queue.push(doc);\n                        }\n                    });\n                }\n                else {\n                    const docIds = toDelete.map((d) => d.name).join(\", \");\n                    const msg = `Fatal error deleting docs ${docIds}`;\n                    logger_1.logger.debug(msg, e);\n                    failures.push(msg);\n                }\n                numPendingDeletes--;\n            });\n            return false;\n        };\n        return new Promise((resolve, reject) => {\n            const intervalId = setInterval(() => {\n                if (queueLoop()) {\n                    clearInterval(intervalId);\n                    if (failures.length === 0) {\n                        resolve();\n                    }\n                    else {\n                        const errorDescription = failures.join(\", \");\n                        reject(new error_1.FirebaseError(`Deletion failed. Errors: ${errorDescription}.`, { exit: 1 }));\n                    }\n                }\n            }, 0);\n        });\n    }\n    deletePath() {\n        let initialDelete;\n        if (this.isDocumentPath) {\n            const doc = { name: this.root + \"/\" + this.path };\n            initialDelete = firestore.deleteDocument(doc).catch((err) => {\n                logger_1.logger.debug(\"deletePath:initialDelete:error\", err);\n                if (this.allDescendants) {\n                    return Promise.resolve();\n                }\n                return utils.reject(\"Unable to delete \" + clc.cyan(this.path));\n            });\n        }\n        else {\n            initialDelete = Promise.resolve();\n        }\n        return initialDelete.then(() => {\n            return this.recursiveBatchDelete();\n        });\n    }\n    deleteDatabase() {\n        return firestore\n            .listCollectionIds(this.project)\n            .catch((err) => {\n            logger_1.logger.debug(\"deleteDatabase:listCollectionIds:error\", err);\n            return utils.reject(\"Unable to list collection IDs\");\n        })\n            .then((collectionIds) => {\n            const promises = [];\n            logger_1.logger.info(\"Deleting the following collections: \" + clc.cyan(collectionIds.join(\", \")));\n            for (let i = 0; i < collectionIds.length; i++) {\n                const collectionId = collectionIds[i];\n                const deleteOp = new FirestoreDelete(this.project, collectionId, {\n                    recursive: true,\n                });\n                promises.push(deleteOp.execute());\n            }\n            return Promise.all(promises);\n        });\n    }\n    checkHasChildren() {\n        return this.getDescendantBatch(true, 1).then((docs) => {\n            return docs.length > 0;\n        });\n    }\n    execute() {\n        let verifyRecurseSafe;\n        if (this.isDocumentPath && !this.recursive && !this.shallow) {\n            verifyRecurseSafe = this.checkHasChildren().then((multiple) => {\n                if (multiple) {\n                    return utils.reject(\"Document has children, must specify -r or --shallow.\", { exit: 1 });\n                }\n            });\n        }\n        else {\n            verifyRecurseSafe = Promise.resolve();\n        }\n        return verifyRecurseSafe.then(() => {\n            return this.deletePath();\n        });\n    }\n}\nexports.FirestoreDelete = FirestoreDelete;\nFirestoreDelete.progressBar = new ProgressBar(\"Deleted :current docs (:rate docs/s)\\n\", {\n    total: Number.MAX_SAFE_INTEGER,\n});\n"]},"metadata":{},"sourceType":"script"}