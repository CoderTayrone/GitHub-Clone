{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __exportStar = this && this.__exportStar || function (m, exports) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.compileApi = exports.writeHttpResult = exports.compileRunner = exports.compileApiInterface = exports.ValidationError = exports.HttpError = void 0;\n\nconst promise_breaker_1 = __importDefault(require(\"promise-breaker\"));\n\nconst pump_1 = __importDefault(require(\"pump\"));\n\nconst json_schema_ref_parser_1 = __importDefault(require(\"@apidevtools/json-schema-ref-parser\"));\n\nconst options_1 = require(\"./options\");\n\nconst oas3_1 = require(\"./oas3\");\n\nconst exegesisRunner_1 = __importDefault(require(\"./core/exegesisRunner\"));\n\nvar errors_1 = require(\"./errors\");\n\nObject.defineProperty(exports, \"HttpError\", {\n  enumerable: true,\n  get: function () {\n    return errors_1.HttpError;\n  }\n});\nObject.defineProperty(exports, \"ValidationError\", {\n  enumerable: true,\n  get: function () {\n    return errors_1.ValidationError;\n  }\n});\n\nconst PluginsManager_1 = __importDefault(require(\"./core/PluginsManager\")); // Export all our public types.\n\n\n__exportStar(require(\"./types\"), exports);\n/**\n * Reads a JSON or YAML file and bundles all $refs, resulting in a single\n * document with only internal refs.\n *\n * @param openApiDocFile - The file containing the document, or a JSON object.\n * @returns - Returns the bundled document\n */\n\n\nfunction bundle(openApiDocFile) {\n  const refParser = new json_schema_ref_parser_1.default();\n  return refParser.bundle(openApiDocFile, {\n    dereference: {\n      circular: false\n    }\n  });\n}\n\nfunction compileDependencies(openApiDoc, options) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const compiledOptions = options_1.compileOptions(options);\n    const bundledDoc = yield bundle(openApiDoc);\n    const plugins = new PluginsManager_1.default(bundledDoc, (options || {}).plugins || []);\n    yield plugins.preCompile({\n      apiDoc: bundledDoc,\n      options\n    });\n    const apiInterface = yield oas3_1.compile(bundledDoc, compiledOptions);\n    return {\n      compiledOptions,\n      apiInterface,\n      plugins\n    };\n  });\n}\n\nfunction compileApiInterface(openApiDoc, options, done) {\n  return promise_breaker_1.default.addCallback(done, () => __awaiter(this, void 0, void 0, function* () {\n    return (yield compileDependencies(openApiDoc, options)).apiInterface;\n  }));\n}\n\nexports.compileApiInterface = compileApiInterface;\n\nfunction compileRunner(openApiDoc, options, done) {\n  return promise_breaker_1.default.addCallback(done, () => __awaiter(this, void 0, void 0, function* () {\n    options = options || {};\n    const {\n      compiledOptions,\n      apiInterface,\n      plugins\n    } = yield compileDependencies(openApiDoc, options);\n    return exegesisRunner_1.default(apiInterface, {\n      autoHandleHttpErrors: compiledOptions.autoHandleHttpErrors,\n      plugins,\n      onResponseValidationError: compiledOptions.onResponseValidationError,\n      validateDefaultResponses: compiledOptions.validateDefaultResponses,\n      originalOptions: options\n    });\n  }));\n}\n\nexports.compileRunner = compileRunner;\n\nfunction writeHttpResult(httpResult, res, done) {\n  return promise_breaker_1.default.addCallback(done, () => __awaiter(this, void 0, void 0, function* () {\n    Object.keys(httpResult.headers).forEach(header => res.setHeader(header, httpResult.headers[header]));\n    res.statusCode = httpResult.status;\n\n    if (httpResult.body) {\n      const body = httpResult.body;\n      yield promise_breaker_1.default.call(done2 => pump_1.default(body, res, done2));\n    } else {\n      res.end();\n    }\n  }));\n}\n\nexports.writeHttpResult = writeHttpResult;\n\nfunction compileApi(openApiDoc, options, done) {\n  return promise_breaker_1.default.addCallback(done, () => __awaiter(this, void 0, void 0, function* () {\n    const runner = yield compileRunner(openApiDoc, options);\n    return function exegesisMiddleware(req, res, next) {\n      runner(req, res).then(result => {\n        let answer;\n\n        if (!result) {\n          if (next) {\n            next();\n          }\n        } else if (res.headersSent) {// Someone else has already written a response.  :(\n        } else if (result) {\n          answer = writeHttpResult(result, res);\n        } else {\n          if (next) {\n            next();\n          }\n        }\n\n        return answer;\n      }).catch(err => {\n        if (next) {\n          next(err);\n        } else {\n          res.statusCode = err.status || 500;\n          res.end('error');\n        }\n      });\n    };\n  }));\n}\n\nexports.compileApi = compileApi;","map":{"version":3,"sources":["../src/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.compileApi = exports.writeHttpResult = exports.compileRunner = exports.compileApiInterface = exports.ValidationError = exports.HttpError = void 0;\nconst promise_breaker_1 = __importDefault(require(\"promise-breaker\"));\nconst pump_1 = __importDefault(require(\"pump\"));\nconst json_schema_ref_parser_1 = __importDefault(require(\"@apidevtools/json-schema-ref-parser\"));\nconst options_1 = require(\"./options\");\nconst oas3_1 = require(\"./oas3\");\nconst exegesisRunner_1 = __importDefault(require(\"./core/exegesisRunner\"));\nvar errors_1 = require(\"./errors\");\nObject.defineProperty(exports, \"HttpError\", { enumerable: true, get: function () { return errors_1.HttpError; } });\nObject.defineProperty(exports, \"ValidationError\", { enumerable: true, get: function () { return errors_1.ValidationError; } });\nconst PluginsManager_1 = __importDefault(require(\"./core/PluginsManager\"));\n// Export all our public types.\n__exportStar(require(\"./types\"), exports);\n/**\n * Reads a JSON or YAML file and bundles all $refs, resulting in a single\n * document with only internal refs.\n *\n * @param openApiDocFile - The file containing the document, or a JSON object.\n * @returns - Returns the bundled document\n */\nfunction bundle(openApiDocFile) {\n    const refParser = new json_schema_ref_parser_1.default();\n    return refParser.bundle(openApiDocFile, { dereference: { circular: false } });\n}\nfunction compileDependencies(openApiDoc, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const compiledOptions = options_1.compileOptions(options);\n        const bundledDoc = yield bundle(openApiDoc);\n        const plugins = new PluginsManager_1.default(bundledDoc, (options || {}).plugins || []);\n        yield plugins.preCompile({ apiDoc: bundledDoc, options });\n        const apiInterface = yield oas3_1.compile(bundledDoc, compiledOptions);\n        return { compiledOptions, apiInterface, plugins };\n    });\n}\nfunction compileApiInterface(openApiDoc, options, done) {\n    return promise_breaker_1.default.addCallback(done, () => __awaiter(this, void 0, void 0, function* () {\n        return (yield compileDependencies(openApiDoc, options)).apiInterface;\n    }));\n}\nexports.compileApiInterface = compileApiInterface;\nfunction compileRunner(openApiDoc, options, done) {\n    return promise_breaker_1.default.addCallback(done, () => __awaiter(this, void 0, void 0, function* () {\n        options = options || {};\n        const { compiledOptions, apiInterface, plugins } = yield compileDependencies(openApiDoc, options);\n        return exegesisRunner_1.default(apiInterface, {\n            autoHandleHttpErrors: compiledOptions.autoHandleHttpErrors,\n            plugins,\n            onResponseValidationError: compiledOptions.onResponseValidationError,\n            validateDefaultResponses: compiledOptions.validateDefaultResponses,\n            originalOptions: options,\n        });\n    }));\n}\nexports.compileRunner = compileRunner;\nfunction writeHttpResult(httpResult, res, done) {\n    return promise_breaker_1.default.addCallback(done, () => __awaiter(this, void 0, void 0, function* () {\n        Object.keys(httpResult.headers).forEach((header) => res.setHeader(header, httpResult.headers[header]));\n        res.statusCode = httpResult.status;\n        if (httpResult.body) {\n            const body = httpResult.body;\n            yield promise_breaker_1.default.call((done2) => pump_1.default(body, res, done2));\n        }\n        else {\n            res.end();\n        }\n    }));\n}\nexports.writeHttpResult = writeHttpResult;\nfunction compileApi(openApiDoc, options, done) {\n    return promise_breaker_1.default.addCallback(done, () => __awaiter(this, void 0, void 0, function* () {\n        const runner = yield compileRunner(openApiDoc, options);\n        return function exegesisMiddleware(req, res, next) {\n            runner(req, res)\n                .then((result) => {\n                let answer;\n                if (!result) {\n                    if (next) {\n                        next();\n                    }\n                }\n                else if (res.headersSent) {\n                    // Someone else has already written a response.  :(\n                }\n                else if (result) {\n                    answer = writeHttpResult(result, res);\n                }\n                else {\n                    if (next) {\n                        next();\n                    }\n                }\n                return answer;\n            })\n                .catch((err) => {\n                if (next) {\n                    next(err);\n                }\n                else {\n                    res.statusCode = err.status || 500;\n                    res.end('error');\n                }\n            });\n        };\n    }));\n}\nexports.compileApi = compileApi;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}