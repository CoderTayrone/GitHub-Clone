{"ast":null,"code":";\n\n(function () {\n  'use strict';\n  /* global define */\n\n  var esprima;\n  var exportFn;\n  var toString = Object.prototype.toString;\n\n  if (typeof module === 'object' && typeof module.exports === 'object' && typeof require === 'function') {\n    // server side\n    esprima = require('esprima');\n\n    exportFn = function (redeyed) {\n      module.exports = redeyed;\n    };\n\n    bootstrap(esprima, exportFn);\n  } else if (typeof define === 'function' && define.amd) {\n    // client side\n    // amd\n    define(['esprima'], function (esprima) {\n      return bootstrap(esprima);\n    });\n  } else if (typeof window === 'object') {\n    // no amd -> attach to window if it exists\n    // Note that this requires 'esprima' to be defined on the window, so that script has to be loaded first\n    window.redeyed = bootstrap(window.esprima);\n  }\n\n  function bootstrap(esprima, exportFn) {\n    function isFunction(obj) {\n      return toString.call(obj) === '[object Function]';\n    }\n\n    function isString(obj) {\n      return toString.call(obj) === '[object String]';\n    }\n\n    function isObject(obj) {\n      return toString.call(obj) === '[object Object]';\n    }\n\n    function surroundWith(before, after) {\n      return function (s) {\n        return before + s + after;\n      };\n    }\n\n    function isNonCircular(key) {\n      return key !== '_parent';\n    }\n\n    function objectizeString(value) {\n      var vals = value.split(':');\n\n      if (vals.length === 0 || vals.length > 2) {\n        throw new Error('illegal string config: ' + value + '\\nShould be of format \"before:after\"');\n      }\n\n      if (vals.length === 1 || vals[1].length === 0) {\n        return vals.indexOf(':') < 0 ? {\n          _before: vals[0]\n        } : {\n          _after: vals[0]\n        };\n      } else {\n        return {\n          _before: vals[0],\n          _after: vals[1]\n        };\n      }\n    }\n\n    function objectize(node) {\n      // Converts 'bef:aft' to { _before: bef, _after: aft }\n      // and resolves undefined before/after from parent or root\n      function resolve(value, key) {\n        // resolve before/after from root or parent if it isn't present on the current node\n        if (!value._parent) return undefined; // Immediate parent\n\n        if (value._parent._default && value._parent._default[key]) return value._parent._default[key]; // Root\n\n        var root = value._parent._parent;\n        if (!root) return undefined;\n        return root._default ? root._default[key] : undefined;\n      }\n\n      function process(key) {\n        var value = node[key];\n        if (!value) return;\n        if (isFunction(value)) return; // normalize all strings to objects\n\n        if (isString(value)) {\n          node[key] = value = objectizeString(value);\n        }\n\n        value._parent = node;\n\n        if (isObject(value)) {\n          if (!value._before && !value._after) return objectize(value); // resolve missing _before or _after from parent(s)\n          // in case we only have either one on this node\n\n          value._before = value._before || resolve(value, '_before');\n          value._after = value._after || resolve(value, '_after');\n          return;\n        }\n\n        throw new Error('nodes need to be either {String}, {Object} or {Function}.' + value + ' is neither.');\n      } // Process _default ones first so children can resolve missing before/after from them\n\n\n      if (node._default) process('_default');\n      Object.keys(node).filter(function (key) {\n        return isNonCircular(key) && node.hasOwnProperty(key) && key !== '_before' && key !== '_after' && key !== '_default';\n      }).forEach(process);\n    }\n\n    function functionize(node) {\n      Object.keys(node).filter(function (key) {\n        return isNonCircular(key) && node.hasOwnProperty(key);\n      }).forEach(function (key) {\n        var value = node[key];\n        if (isFunction(value)) return;\n\n        if (isObject(value)) {\n          if (!value._before && !value._after) return functionize(value); // at this point before/after were \"inherited\" from the parent or root\n          // (see objectize)\n\n          var before = value._before || '';\n          var after = value._after || '';\n          node[key] = surroundWith(before, after);\n          return node[key];\n        }\n      });\n    }\n\n    function normalize(root) {\n      objectize(root);\n      functionize(root);\n    }\n\n    function mergeTokensAndComments(tokens, comments) {\n      var all = {};\n\n      function addToAllByRangeStart(t) {\n        all[t.range[0]] = t;\n      }\n\n      tokens.forEach(addToAllByRangeStart);\n      comments.forEach(addToAllByRangeStart); // keys are sorted automatically\n\n      return Object.keys(all).map(function (k) {\n        return all[k];\n      });\n    }\n\n    function redeyed(code, config, opts) {\n      opts = opts || {};\n      var parser = opts.parser || esprima;\n      var jsx = !!opts.jsx; // tokenizer doesn't support JSX at this point (esprima@4.0.0)\n      // therefore we need to generate the AST via the parser not only to\n      // avoid the tokenizer from erroring but also to get JSXIdentifier tokens\n\n      var buildAst = jsx || !!opts.buildAst;\n      var hashbang = '';\n      var ast;\n      var tokens;\n      var comments;\n      var lastSplitEnd = 0;\n      var splits = [];\n      var transformedCode;\n      var all;\n      var info; // Replace hashbang line with empty whitespaces to preserve token locations\n\n      if (code[0] === '#' && code[1] === '!') {\n        hashbang = code.substr(0, code.indexOf('\\n') + 1);\n        code = Array.apply(0, Array(hashbang.length)).join(' ') + '\\n' + code.substr(hashbang.length);\n      }\n\n      if (buildAst) {\n        ast = parser.parse(code, {\n          tokens: true,\n          comment: true,\n          range: true,\n          loc: true,\n          tolerant: true,\n          jsx: true\n        });\n        tokens = ast.tokens;\n        comments = ast.comments;\n      } else {\n        tokens = [];\n        comments = [];\n        parser.tokenize(code, {\n          range: true,\n          loc: true,\n          comment: true\n        }, function (token) {\n          if (token.type === 'LineComment') {\n            token.type = 'Line';\n            comments.push(token);\n          } else if (token.type === 'BlockComment') {\n            token.type = 'Block';\n            comments.push(token);\n          } else {\n            // Optimistically upgrade 'static' to a keyword\n            if (token.type === 'Identifier' && token.value === 'static') token.type = 'Keyword';\n            tokens.push(token);\n          }\n        });\n      }\n\n      normalize(config);\n\n      function tokenIndex(tokens, tkn, start) {\n        var current;\n        var rangeStart = tkn.range[0];\n\n        for (current = start; current < tokens.length; current++) {\n          if (tokens[current].range[0] === rangeStart) return current;\n        }\n\n        throw new Error('Token %s not found at or after index: %d', tkn, start);\n      }\n\n      function process(surround) {\n        var result;\n        var currentIndex;\n        var nextIndex;\n        var skip = 0;\n        var splitEnd;\n        result = surround(code.slice(start, end), info);\n\n        if (isObject(result)) {\n          splits.push(result.replacement);\n          currentIndex = info.tokenIndex;\n          nextIndex = tokenIndex(info.tokens, result.skipPastToken, currentIndex);\n          skip = nextIndex - currentIndex;\n          splitEnd = skip > 0 ? tokens[nextIndex - 1].range[1] : end;\n        } else {\n          splits.push(result);\n          splitEnd = end;\n        }\n\n        return {\n          skip: skip,\n          splitEnd: splitEnd\n        };\n      }\n\n      function addSplit(start, end, surround, info) {\n        var result;\n        var skip = 0;\n        if (start >= end) return;\n\n        if (surround) {\n          result = process(surround);\n          skip = result.skip;\n          lastSplitEnd = result.splitEnd;\n        } else {\n          splits.push(code.slice(start, end));\n          lastSplitEnd = end;\n        }\n\n        return skip;\n      }\n\n      all = mergeTokensAndComments(tokens, comments);\n\n      for (var tokenIdx = 0; tokenIdx < all.length; tokenIdx++) {\n        var token = all[tokenIdx];\n        var surroundForType = config[token.type];\n        var surround;\n        var start;\n        var end; // At least the type (e.g., 'Keyword') needs to be specified for the token to be surrounded\n\n        if (surroundForType) {\n          // root defaults are only taken into account while resolving before/after otherwise\n          // a root default would apply to everything, even if no type default was specified\n          surround = surroundForType && surroundForType.hasOwnProperty(token.value) && surroundForType[token.value] && isFunction(surroundForType[token.value]) ? surroundForType[token.value] : surroundForType._default;\n          start = token.range[0];\n          end = token.range[1];\n          addSplit(lastSplitEnd, start);\n          info = {\n            tokenIndex: tokenIdx,\n            tokens: all,\n            ast: ast,\n            code: code\n          };\n          tokenIdx += addSplit(start, end, surround, info);\n        }\n      }\n\n      if (lastSplitEnd < code.length) {\n        addSplit(lastSplitEnd, code.length);\n      }\n\n      if (!opts.nojoin) {\n        transformedCode = splits.join('');\n\n        if (hashbang.length > 0) {\n          transformedCode = hashbang + transformedCode.substr(hashbang.length);\n        }\n      }\n\n      return {\n        ast: ast,\n        tokens: tokens,\n        comments: comments,\n        splits: splits,\n        code: transformedCode\n      };\n    }\n\n    return exportFn ? exportFn(redeyed) : redeyed;\n  }\n})();","map":{"version":3,"sources":["/home/dev/Documentos/Projects/github-clone/node_modules/redeyed/redeyed.js"],"names":["esprima","exportFn","toString","Object","prototype","module","exports","require","redeyed","bootstrap","define","amd","window","isFunction","obj","call","isString","isObject","surroundWith","before","after","s","isNonCircular","key","objectizeString","value","vals","split","length","Error","indexOf","_before","_after","objectize","node","resolve","_parent","undefined","_default","root","process","keys","filter","hasOwnProperty","forEach","functionize","normalize","mergeTokensAndComments","tokens","comments","all","addToAllByRangeStart","t","range","map","k","code","config","opts","parser","jsx","buildAst","hashbang","ast","lastSplitEnd","splits","transformedCode","info","substr","Array","apply","join","parse","comment","loc","tolerant","tokenize","token","type","push","tokenIndex","tkn","start","current","rangeStart","surround","result","currentIndex","nextIndex","skip","splitEnd","slice","end","replacement","skipPastToken","addSplit","tokenIdx","surroundForType","nojoin"],"mappings":"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","sourcesContent":[";(function() {\n'use strict'\n/* global define */\n\nvar esprima\nvar exportFn\nvar toString = Object.prototype.toString\n\nif (typeof module === 'object' && typeof module.exports === 'object' && typeof require === 'function') {\n  // server side\n  esprima = require('esprima')\n  exportFn = function(redeyed) { module.exports = redeyed }\n  bootstrap(esprima, exportFn)\n} else if (typeof define === 'function' && define.amd) {\n  // client side\n  // amd\n  define(['esprima'], function(esprima) {\n      return bootstrap(esprima)\n  })\n} else if (typeof window === 'object') {\n  // no amd -> attach to window if it exists\n  // Note that this requires 'esprima' to be defined on the window, so that script has to be loaded first\n  window.redeyed = bootstrap(window.esprima)\n}\n\nfunction bootstrap(esprima, exportFn) {\n  function isFunction(obj) {\n    return toString.call(obj) === '[object Function]'\n  }\n\n  function isString(obj) {\n    return toString.call(obj) === '[object String]'\n  }\n\n  function isObject(obj) {\n    return toString.call(obj) === '[object Object]'\n  }\n\n  function surroundWith(before, after) {\n    return function(s) { return before + s + after }\n  }\n\n  function isNonCircular(key) {\n    return key !== '_parent'\n  }\n\n  function objectizeString(value) {\n    var vals = value.split(':')\n\n    if (vals.length === 0 || vals.length > 2)      {\n throw new Error(\n        'illegal string config: ' + value +\n        '\\nShould be of format \"before:after\"'\n      )\n}\n\n    if (vals.length === 1 || vals[1].length === 0) {\n      return vals.indexOf(':') < 0 ? { _before: vals[0] } : { _after: vals[0] }\n    } else {\n      return { _before: vals[0], _after: vals[1] }\n    }\n  }\n\n  function objectize(node) {\n    // Converts 'bef:aft' to { _before: bef, _after: aft }\n    // and resolves undefined before/after from parent or root\n\n    function resolve(value, key) {\n      // resolve before/after from root or parent if it isn't present on the current node\n      if (!value._parent) return undefined\n\n      // Immediate parent\n      if (value._parent._default && value._parent._default[key]) return value._parent._default[key]\n\n      // Root\n      var root = value._parent._parent\n      if (!root) return undefined\n\n      return root._default ? root._default[key] : undefined\n    }\n\n    function process(key) {\n      var value = node[key]\n\n      if (!value) return\n      if (isFunction(value)) return\n\n      // normalize all strings to objects\n      if (isString(value)) {\n        node[key] = value = objectizeString(value)\n      }\n\n      value._parent = node\n      if (isObject(value)) {\n        if (!value._before && !value._after) return objectize(value)\n\n        // resolve missing _before or _after from parent(s)\n        // in case we only have either one on this node\n        value._before =  value._before || resolve(value, '_before')\n        value._after  =  value._after  || resolve(value, '_after')\n\n        return\n      }\n\n      throw new Error('nodes need to be either {String}, {Object} or {Function}.' + value + ' is neither.')\n    }\n\n    // Process _default ones first so children can resolve missing before/after from them\n    if (node._default) process('_default')\n\n    Object.keys(node)\n      .filter(function(key) {\n        return isNonCircular(key)\n          && node.hasOwnProperty(key)\n          && key !== '_before'\n          && key !== '_after'\n          && key !== '_default'\n      })\n      .forEach(process)\n  }\n\n  function functionize(node) {\n    Object.keys(node)\n      .filter(function(key) {\n        return isNonCircular(key) && node.hasOwnProperty(key)\n      })\n      .forEach(function(key) {\n        var value = node[key]\n\n        if (isFunction(value)) return\n\n        if (isObject(value)) {\n          if (!value._before && !value._after) return functionize(value)\n\n          // at this point before/after were \"inherited\" from the parent or root\n          // (see objectize)\n          var before = value._before || ''\n          var after = value._after || ''\n\n          node[key] = surroundWith(before, after)\n          return node[key]\n        }\n      })\n  }\n\n  function normalize(root) {\n    objectize(root)\n    functionize(root)\n  }\n\n  function mergeTokensAndComments(tokens, comments) {\n    var all = {}\n\n    function addToAllByRangeStart(t) { all[ t.range[0] ] = t }\n\n    tokens.forEach(addToAllByRangeStart)\n    comments.forEach(addToAllByRangeStart)\n\n    // keys are sorted automatically\n    return Object.keys(all)\n      .map(function(k) { return all[k] })\n  }\n\n  function redeyed(code, config, opts) {\n    opts = opts || {}\n    var parser = opts.parser || esprima\n    var jsx = !!opts.jsx\n    // tokenizer doesn't support JSX at this point (esprima@4.0.0)\n    // therefore we need to generate the AST via the parser not only to\n    // avoid the tokenizer from erroring but also to get JSXIdentifier tokens\n    var buildAst = jsx || !!opts.buildAst\n\n    var hashbang =  ''\n    var ast\n    var tokens\n    var comments\n    var lastSplitEnd = 0\n    var splits = []\n    var transformedCode\n    var all\n    var info\n\n    // Replace hashbang line with empty whitespaces to preserve token locations\n    if (code[0] === '#' && code[1] === '!') {\n      hashbang = code.substr(0, code.indexOf('\\n') + 1)\n      code = Array.apply(0, Array(hashbang.length)).join(' ') + '\\n' + code.substr(hashbang.length)\n    }\n\n    if (buildAst) {\n      ast = parser.parse(code, { tokens: true, comment: true, range: true, loc: true, tolerant: true, jsx: true })\n      tokens = ast.tokens\n      comments = ast.comments\n    } else {\n      tokens = []\n      comments = []\n      parser.tokenize(code, { range: true, loc: true, comment: true }, function(token) {\n        if (token.type === 'LineComment') {\n          token.type = 'Line'\n          comments.push(token)\n        } else if (token.type === 'BlockComment') {\n          token.type = 'Block'\n          comments.push(token)\n        } else {\n          // Optimistically upgrade 'static' to a keyword\n          if (token.type === 'Identifier' && token.value === 'static') token.type = 'Keyword'\n          tokens.push(token)\n        }\n      })\n    }\n    normalize(config)\n\n    function tokenIndex(tokens, tkn, start) {\n      var current\n      var rangeStart = tkn.range[0]\n\n      for (current = start; current < tokens.length; current++) {\n        if (tokens[current].range[0] === rangeStart) return current\n      }\n\n      throw new Error('Token %s not found at or after index: %d', tkn, start)\n    }\n\n    function process(surround) {\n      var result\n      var currentIndex\n      var nextIndex\n      var skip = 0\n      var splitEnd\n\n      result = surround(code.slice(start, end), info)\n      if (isObject(result)) {\n        splits.push(result.replacement)\n\n        currentIndex =  info.tokenIndex\n        nextIndex    =  tokenIndex(info.tokens, result.skipPastToken, currentIndex)\n        skip         =  nextIndex - currentIndex\n        splitEnd     =  skip > 0 ? tokens[nextIndex - 1].range[1] : end\n      } else {\n        splits.push(result)\n        splitEnd = end\n      }\n\n      return { skip: skip, splitEnd: splitEnd }\n    }\n\n    function addSplit(start, end, surround, info) {\n      var result\n      var skip = 0\n\n      if (start >= end) return\n      if (surround) {\n        result       =  process(surround)\n        skip         =  result.skip\n        lastSplitEnd =  result.splitEnd\n      } else {\n        splits.push(code.slice(start, end))\n        lastSplitEnd = end\n      }\n\n      return skip\n    }\n\n    all = mergeTokensAndComments(tokens, comments)\n    for (var tokenIdx = 0; tokenIdx < all.length; tokenIdx++) {\n      var token = all[tokenIdx]\n      var surroundForType = config[token.type]\n      var surround\n      var start\n      var end\n\n      // At least the type (e.g., 'Keyword') needs to be specified for the token to be surrounded\n      if (surroundForType) {\n        // root defaults are only taken into account while resolving before/after otherwise\n        // a root default would apply to everything, even if no type default was specified\n        surround = surroundForType\n          && surroundForType.hasOwnProperty(token.value)\n          && surroundForType[token.value]\n          && isFunction(surroundForType[token.value])\n            ? surroundForType[token.value]\n            : surroundForType._default\n\n        start = token.range[0]\n        end = token.range[1]\n\n        addSplit(lastSplitEnd, start)\n        info = { tokenIndex: tokenIdx, tokens: all, ast: ast, code: code }\n        tokenIdx += addSplit(start, end, surround, info)\n      }\n    }\n\n    if (lastSplitEnd < code.length) {\n      addSplit(lastSplitEnd, code.length)\n    }\n\n  if (!opts.nojoin) {\n    transformedCode = splits.join('')\n    if (hashbang.length > 0) {\n      transformedCode = hashbang + transformedCode.substr(hashbang.length)\n    }\n  }\n\n    return {\n        ast      :  ast\n      , tokens   :  tokens\n      , comments :  comments\n      , splits   :  splits\n      , code     :  transformedCode\n    }\n  }\n\n  return exportFn ? exportFn(redeyed) : redeyed\n}\n})()\n"]},"metadata":{},"sourceType":"script"}