{"ast":null,"code":"/**\n * Archiver Core\n *\n * @ignore\n * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}\n * @copyright (c) 2012-2014 Chris Talkington, contributors.\n */\nvar fs = require('fs');\n\nvar glob = require('readdir-glob');\n\nvar async = require('async');\n\nvar path = require('path');\n\nvar util = require('archiver-utils');\n\nvar inherits = require('util').inherits;\n\nvar ArchiverError = require('./error');\n\nvar Transform = require('readable-stream').Transform;\n\nvar win32 = process.platform === 'win32';\n/**\n * @constructor\n * @param {String} format The archive format to use.\n * @param {(CoreOptions|TransformOptions)} options See also {@link ZipOptions} and {@link TarOptions}.\n */\n\nvar Archiver = function (format, options) {\n  if (!(this instanceof Archiver)) {\n    return new Archiver(format, options);\n  }\n\n  if (typeof format !== 'string') {\n    options = format;\n    format = 'zip';\n  }\n\n  options = this.options = util.defaults(options, {\n    highWaterMark: 1024 * 1024,\n    statConcurrency: 4\n  });\n  Transform.call(this, options);\n  this._format = false;\n  this._module = false;\n  this._pending = 0;\n  this._pointer = 0;\n  this._entriesCount = 0;\n  this._entriesProcessedCount = 0;\n  this._fsEntriesTotalBytes = 0;\n  this._fsEntriesProcessedBytes = 0;\n  this._queue = async.queue(this._onQueueTask.bind(this), 1);\n\n  this._queue.drain(this._onQueueDrain.bind(this));\n\n  this._statQueue = async.queue(this._onStatQueueTask.bind(this), options.statConcurrency);\n\n  this._statQueue.drain(this._onQueueDrain.bind(this));\n\n  this._state = {\n    aborted: false,\n    finalize: false,\n    finalizing: false,\n    finalized: false,\n    modulePiped: false\n  };\n  this._streams = [];\n};\n\ninherits(Archiver, Transform);\n/**\n * Internal logic for `abort`.\n *\n * @private\n * @return void\n */\n\nArchiver.prototype._abort = function () {\n  this._state.aborted = true;\n\n  this._queue.kill();\n\n  this._statQueue.kill();\n\n  if (this._queue.idle()) {\n    this._shutdown();\n  }\n};\n/**\n * Internal helper for appending files.\n *\n * @private\n * @param  {String} filepath The source filepath.\n * @param  {EntryData} data The entry data.\n * @return void\n */\n\n\nArchiver.prototype._append = function (filepath, data) {\n  data = data || {};\n  var task = {\n    source: null,\n    filepath: filepath\n  };\n\n  if (!data.name) {\n    data.name = filepath;\n  }\n\n  data.sourcePath = filepath;\n  task.data = data;\n  this._entriesCount++;\n\n  if (data.stats && data.stats instanceof fs.Stats) {\n    task = this._updateQueueTaskWithStats(task, data.stats);\n\n    if (task) {\n      if (data.stats.size) {\n        this._fsEntriesTotalBytes += data.stats.size;\n      }\n\n      this._queue.push(task);\n    }\n  } else {\n    this._statQueue.push(task);\n  }\n};\n/**\n * Internal logic for `finalize`.\n *\n * @private\n * @return void\n */\n\n\nArchiver.prototype._finalize = function () {\n  if (this._state.finalizing || this._state.finalized || this._state.aborted) {\n    return;\n  }\n\n  this._state.finalizing = true;\n\n  this._moduleFinalize();\n\n  this._state.finalizing = false;\n  this._state.finalized = true;\n};\n/**\n * Checks the various state variables to determine if we can `finalize`.\n *\n * @private\n * @return {Boolean}\n */\n\n\nArchiver.prototype._maybeFinalize = function () {\n  if (this._state.finalizing || this._state.finalized || this._state.aborted) {\n    return false;\n  }\n\n  if (this._state.finalize && this._pending === 0 && this._queue.idle() && this._statQueue.idle()) {\n    this._finalize();\n\n    return true;\n  }\n\n  return false;\n};\n/**\n * Appends an entry to the module.\n *\n * @private\n * @fires  Archiver#entry\n * @param  {(Buffer|Stream)} source\n * @param  {EntryData} data\n * @param  {Function} callback\n * @return void\n */\n\n\nArchiver.prototype._moduleAppend = function (source, data, callback) {\n  if (this._state.aborted) {\n    callback();\n    return;\n  }\n\n  this._module.append(source, data, function (err) {\n    this._task = null;\n\n    if (this._state.aborted) {\n      this._shutdown();\n\n      return;\n    }\n\n    if (err) {\n      this.emit('error', err);\n      setImmediate(callback);\n      return;\n    }\n    /**\n     * Fires when the entry's input has been processed and appended to the archive.\n     *\n     * @event Archiver#entry\n     * @type {EntryData}\n     */\n\n\n    this.emit('entry', data);\n    this._entriesProcessedCount++;\n\n    if (data.stats && data.stats.size) {\n      this._fsEntriesProcessedBytes += data.stats.size;\n    }\n    /**\n     * @event Archiver#progress\n     * @type {ProgressData}\n     */\n\n\n    this.emit('progress', {\n      entries: {\n        total: this._entriesCount,\n        processed: this._entriesProcessedCount\n      },\n      fs: {\n        totalBytes: this._fsEntriesTotalBytes,\n        processedBytes: this._fsEntriesProcessedBytes\n      }\n    });\n    setImmediate(callback);\n  }.bind(this));\n};\n/**\n * Finalizes the module.\n *\n * @private\n * @return void\n */\n\n\nArchiver.prototype._moduleFinalize = function () {\n  if (typeof this._module.finalize === 'function') {\n    this._module.finalize();\n  } else if (typeof this._module.end === 'function') {\n    this._module.end();\n  } else {\n    this.emit('error', new ArchiverError('NOENDMETHOD'));\n  }\n};\n/**\n * Pipes the module to our internal stream with error bubbling.\n *\n * @private\n * @return void\n */\n\n\nArchiver.prototype._modulePipe = function () {\n  this._module.on('error', this._onModuleError.bind(this));\n\n  this._module.pipe(this);\n\n  this._state.modulePiped = true;\n};\n/**\n * Determines if the current module supports a defined feature.\n *\n * @private\n * @param  {String} key\n * @return {Boolean}\n */\n\n\nArchiver.prototype._moduleSupports = function (key) {\n  if (!this._module.supports || !this._module.supports[key]) {\n    return false;\n  }\n\n  return this._module.supports[key];\n};\n/**\n * Unpipes the module from our internal stream.\n *\n * @private\n * @return void\n */\n\n\nArchiver.prototype._moduleUnpipe = function () {\n  this._module.unpipe(this);\n\n  this._state.modulePiped = false;\n};\n/**\n * Normalizes entry data with fallbacks for key properties.\n *\n * @private\n * @param  {Object} data\n * @param  {fs.Stats} stats\n * @return {Object}\n */\n\n\nArchiver.prototype._normalizeEntryData = function (data, stats) {\n  data = util.defaults(data, {\n    type: 'file',\n    name: null,\n    date: null,\n    mode: null,\n    prefix: null,\n    sourcePath: null,\n    stats: false\n  });\n\n  if (stats && data.stats === false) {\n    data.stats = stats;\n  }\n\n  var isDir = data.type === 'directory';\n\n  if (data.name) {\n    if (typeof data.prefix === 'string' && '' !== data.prefix) {\n      data.name = data.prefix + '/' + data.name;\n      data.prefix = null;\n    }\n\n    data.name = util.sanitizePath(data.name);\n\n    if (data.type !== 'symlink' && data.name.slice(-1) === '/') {\n      isDir = true;\n      data.type = 'directory';\n    } else if (isDir) {\n      data.name += '/';\n    }\n  } // 511 === 0777; 493 === 0755; 438 === 0666; 420 === 0644\n\n\n  if (typeof data.mode === 'number') {\n    if (win32) {\n      data.mode &= 511;\n    } else {\n      data.mode &= 4095;\n    }\n  } else if (data.stats && data.mode === null) {\n    if (win32) {\n      data.mode = data.stats.mode & 511;\n    } else {\n      data.mode = data.stats.mode & 4095;\n    } // stat isn't reliable on windows; force 0755 for dir\n\n\n    if (win32 && isDir) {\n      data.mode = 493;\n    }\n  } else if (data.mode === null) {\n    data.mode = isDir ? 493 : 420;\n  }\n\n  if (data.stats && data.date === null) {\n    data.date = data.stats.mtime;\n  } else {\n    data.date = util.dateify(data.date);\n  }\n\n  return data;\n};\n/**\n * Error listener that re-emits error on to our internal stream.\n *\n * @private\n * @param  {Error} err\n * @return void\n */\n\n\nArchiver.prototype._onModuleError = function (err) {\n  /**\n   * @event Archiver#error\n   * @type {ErrorData}\n   */\n  this.emit('error', err);\n};\n/**\n * Checks the various state variables after queue has drained to determine if\n * we need to `finalize`.\n *\n * @private\n * @return void\n */\n\n\nArchiver.prototype._onQueueDrain = function () {\n  if (this._state.finalizing || this._state.finalized || this._state.aborted) {\n    return;\n  }\n\n  if (this._state.finalize && this._pending === 0 && this._queue.idle() && this._statQueue.idle()) {\n    this._finalize();\n  }\n};\n/**\n * Appends each queue task to the module.\n *\n * @private\n * @param  {Object} task\n * @param  {Function} callback\n * @return void\n */\n\n\nArchiver.prototype._onQueueTask = function (task, callback) {\n  var fullCallback = () => {\n    if (task.data.callback) {\n      task.data.callback();\n    }\n\n    callback();\n  };\n\n  if (this._state.finalizing || this._state.finalized || this._state.aborted) {\n    fullCallback();\n    return;\n  }\n\n  this._task = task;\n\n  this._moduleAppend(task.source, task.data, fullCallback);\n};\n/**\n * Performs a file stat and reinjects the task back into the queue.\n *\n * @private\n * @param  {Object} task\n * @param  {Function} callback\n * @return void\n */\n\n\nArchiver.prototype._onStatQueueTask = function (task, callback) {\n  if (this._state.finalizing || this._state.finalized || this._state.aborted) {\n    callback();\n    return;\n  }\n\n  fs.lstat(task.filepath, function (err, stats) {\n    if (this._state.aborted) {\n      setImmediate(callback);\n      return;\n    }\n\n    if (err) {\n      this._entriesCount--;\n      /**\n       * @event Archiver#warning\n       * @type {ErrorData}\n       */\n\n      this.emit('warning', err);\n      setImmediate(callback);\n      return;\n    }\n\n    task = this._updateQueueTaskWithStats(task, stats);\n\n    if (task) {\n      if (stats.size) {\n        this._fsEntriesTotalBytes += stats.size;\n      }\n\n      this._queue.push(task);\n    }\n\n    setImmediate(callback);\n  }.bind(this));\n};\n/**\n * Unpipes the module and ends our internal stream.\n *\n * @private\n * @return void\n */\n\n\nArchiver.prototype._shutdown = function () {\n  this._moduleUnpipe();\n\n  this.end();\n};\n/**\n * Tracks the bytes emitted by our internal stream.\n *\n * @private\n * @param  {Buffer} chunk\n * @param  {String} encoding\n * @param  {Function} callback\n * @return void\n */\n\n\nArchiver.prototype._transform = function (chunk, encoding, callback) {\n  if (chunk) {\n    this._pointer += chunk.length;\n  }\n\n  callback(null, chunk);\n};\n/**\n * Updates and normalizes a queue task using stats data.\n *\n * @private\n * @param  {Object} task\n * @param  {fs.Stats} stats\n * @return {Object}\n */\n\n\nArchiver.prototype._updateQueueTaskWithStats = function (task, stats) {\n  if (stats.isFile()) {\n    task.data.type = 'file';\n    task.data.sourceType = 'stream';\n    task.source = util.lazyReadStream(task.filepath);\n  } else if (stats.isDirectory() && this._moduleSupports('directory')) {\n    task.data.name = util.trailingSlashIt(task.data.name);\n    task.data.type = 'directory';\n    task.data.sourcePath = util.trailingSlashIt(task.filepath);\n    task.data.sourceType = 'buffer';\n    task.source = Buffer.concat([]);\n  } else if (stats.isSymbolicLink() && this._moduleSupports('symlink')) {\n    var linkPath = fs.readlinkSync(task.filepath);\n    var dirName = path.dirname(task.filepath);\n    task.data.type = 'symlink';\n    task.data.linkname = path.relative(dirName, path.resolve(dirName, linkPath));\n    task.data.sourceType = 'buffer';\n    task.source = Buffer.concat([]);\n  } else {\n    if (stats.isDirectory()) {\n      this.emit('warning', new ArchiverError('DIRECTORYNOTSUPPORTED', task.data));\n    } else if (stats.isSymbolicLink()) {\n      this.emit('warning', new ArchiverError('SYMLINKNOTSUPPORTED', task.data));\n    } else {\n      this.emit('warning', new ArchiverError('ENTRYNOTSUPPORTED', task.data));\n    }\n\n    return null;\n  }\n\n  task.data = this._normalizeEntryData(task.data, stats);\n  return task;\n};\n/**\n * Aborts the archiving process, taking a best-effort approach, by:\n *\n * - removing any pending queue tasks\n * - allowing any active queue workers to finish\n * - detaching internal module pipes\n * - ending both sides of the Transform stream\n *\n * It will NOT drain any remaining sources.\n *\n * @return {this}\n */\n\n\nArchiver.prototype.abort = function () {\n  if (this._state.aborted || this._state.finalized) {\n    return this;\n  }\n\n  this._abort();\n\n  return this;\n};\n/**\n * Appends an input source (text string, buffer, or stream) to the instance.\n *\n * When the instance has received, processed, and emitted the input, the `entry`\n * event is fired.\n *\n * @fires  Archiver#entry\n * @param  {(Buffer|Stream|String)} source The input source.\n * @param  {EntryData} data See also {@link ZipEntryData} and {@link TarEntryData}.\n * @return {this}\n */\n\n\nArchiver.prototype.append = function (source, data) {\n  if (this._state.finalize || this._state.aborted) {\n    this.emit('error', new ArchiverError('QUEUECLOSED'));\n    return this;\n  }\n\n  data = this._normalizeEntryData(data);\n\n  if (typeof data.name !== 'string' || data.name.length === 0) {\n    this.emit('error', new ArchiverError('ENTRYNAMEREQUIRED'));\n    return this;\n  }\n\n  if (data.type === 'directory' && !this._moduleSupports('directory')) {\n    this.emit('error', new ArchiverError('DIRECTORYNOTSUPPORTED', {\n      name: data.name\n    }));\n    return this;\n  }\n\n  source = util.normalizeInputSource(source);\n\n  if (Buffer.isBuffer(source)) {\n    data.sourceType = 'buffer';\n  } else if (util.isStream(source)) {\n    data.sourceType = 'stream';\n  } else {\n    this.emit('error', new ArchiverError('INPUTSTEAMBUFFERREQUIRED', {\n      name: data.name\n    }));\n    return this;\n  }\n\n  this._entriesCount++;\n\n  this._queue.push({\n    data: data,\n    source: source\n  });\n\n  return this;\n};\n/**\n * Appends a directory and its files, recursively, given its dirpath.\n *\n * @param  {String} dirpath The source directory path.\n * @param  {String} destpath The destination path within the archive.\n * @param  {(EntryData|Function)} data See also [ZipEntryData]{@link ZipEntryData} and\n * [TarEntryData]{@link TarEntryData}.\n * @return {this}\n */\n\n\nArchiver.prototype.directory = function (dirpath, destpath, data) {\n  if (this._state.finalize || this._state.aborted) {\n    this.emit('error', new ArchiverError('QUEUECLOSED'));\n    return this;\n  }\n\n  if (typeof dirpath !== 'string' || dirpath.length === 0) {\n    this.emit('error', new ArchiverError('DIRECTORYDIRPATHREQUIRED'));\n    return this;\n  }\n\n  this._pending++;\n\n  if (destpath === false) {\n    destpath = '';\n  } else if (typeof destpath !== 'string') {\n    destpath = dirpath;\n  }\n\n  var dataFunction = false;\n\n  if (typeof data === 'function') {\n    dataFunction = data;\n    data = {};\n  } else if (typeof data !== 'object') {\n    data = {};\n  }\n\n  var globOptions = {\n    stat: true,\n    dot: true\n  };\n\n  function onGlobEnd() {\n    this._pending--;\n\n    this._maybeFinalize();\n  }\n\n  function onGlobError(err) {\n    this.emit('error', err);\n  }\n\n  function onGlobMatch(match) {\n    globber.pause();\n    var ignoreMatch = false;\n    var entryData = Object.assign({}, data);\n    entryData.name = match.relative;\n    entryData.prefix = destpath;\n    entryData.stats = match.stat;\n    entryData.callback = globber.resume.bind(globber);\n\n    try {\n      if (dataFunction) {\n        entryData = dataFunction(entryData);\n\n        if (entryData === false) {\n          ignoreMatch = true;\n        } else if (typeof entryData !== 'object') {\n          throw new ArchiverError('DIRECTORYFUNCTIONINVALIDDATA', {\n            dirpath: dirpath\n          });\n        }\n      }\n    } catch (e) {\n      this.emit('error', e);\n      return;\n    }\n\n    if (ignoreMatch) {\n      globber.resume();\n      return;\n    }\n\n    this._append(match.absolute, entryData);\n  }\n\n  var globber = glob(dirpath, globOptions);\n  globber.on('error', onGlobError.bind(this));\n  globber.on('match', onGlobMatch.bind(this));\n  globber.on('end', onGlobEnd.bind(this));\n  return this;\n};\n/**\n * Appends a file given its filepath using a\n * [lazystream]{@link https://github.com/jpommerening/node-lazystream} wrapper to\n * prevent issues with open file limits.\n *\n * When the instance has received, processed, and emitted the file, the `entry`\n * event is fired.\n *\n * @param  {String} filepath The source filepath.\n * @param  {EntryData} data See also [ZipEntryData]{@link ZipEntryData} and\n * [TarEntryData]{@link TarEntryData}.\n * @return {this}\n */\n\n\nArchiver.prototype.file = function (filepath, data) {\n  if (this._state.finalize || this._state.aborted) {\n    this.emit('error', new ArchiverError('QUEUECLOSED'));\n    return this;\n  }\n\n  if (typeof filepath !== 'string' || filepath.length === 0) {\n    this.emit('error', new ArchiverError('FILEFILEPATHREQUIRED'));\n    return this;\n  }\n\n  this._append(filepath, data);\n\n  return this;\n};\n/**\n * Appends multiple files that match a glob pattern.\n *\n * @param  {String} pattern The [glob pattern]{@link https://github.com/isaacs/minimatch} to match.\n * @param  {Object} options See [node-readdir-glob]{@link https://github.com/yqnn/node-readdir-glob#options}.\n * @param  {EntryData} data See also [ZipEntryData]{@link ZipEntryData} and\n * [TarEntryData]{@link TarEntryData}.\n * @return {this}\n */\n\n\nArchiver.prototype.glob = function (pattern, options, data) {\n  this._pending++;\n  options = util.defaults(options, {\n    stat: true,\n    pattern: pattern\n  });\n\n  function onGlobEnd() {\n    this._pending--;\n\n    this._maybeFinalize();\n  }\n\n  function onGlobError(err) {\n    this.emit('error', err);\n  }\n\n  function onGlobMatch(match) {\n    globber.pause();\n    var entryData = Object.assign({}, data);\n    entryData.callback = globber.resume.bind(globber);\n    entryData.stats = match.stat;\n    entryData.name = match.relative;\n\n    this._append(match.absolute, entryData);\n  }\n\n  var globber = glob(options.cwd || '.', options);\n  globber.on('error', onGlobError.bind(this));\n  globber.on('match', onGlobMatch.bind(this));\n  globber.on('end', onGlobEnd.bind(this));\n  return this;\n};\n/**\n * Finalizes the instance and prevents further appending to the archive\n * structure (queue will continue til drained).\n *\n * The `end`, `close` or `finish` events on the destination stream may fire\n * right after calling this method so you should set listeners beforehand to\n * properly detect stream completion.\n *\n * @return {Promise}\n */\n\n\nArchiver.prototype.finalize = function () {\n  if (this._state.aborted) {\n    var abortedError = new ArchiverError('ABORTED');\n    this.emit('error', abortedError);\n    return Promise.reject(abortedError);\n  }\n\n  if (this._state.finalize) {\n    var finalizingError = new ArchiverError('FINALIZING');\n    this.emit('error', finalizingError);\n    return Promise.reject(finalizingError);\n  }\n\n  this._state.finalize = true;\n\n  if (this._pending === 0 && this._queue.idle() && this._statQueue.idle()) {\n    this._finalize();\n  }\n\n  var self = this;\n  return new Promise(function (resolve, reject) {\n    var errored;\n\n    self._module.on('end', function () {\n      if (!errored) {\n        resolve();\n      }\n    });\n\n    self._module.on('error', function (err) {\n      errored = true;\n      reject(err);\n    });\n  });\n};\n/**\n * Sets the module format name used for archiving.\n *\n * @param {String} format The name of the format.\n * @return {this}\n */\n\n\nArchiver.prototype.setFormat = function (format) {\n  if (this._format) {\n    this.emit('error', new ArchiverError('FORMATSET'));\n    return this;\n  }\n\n  this._format = format;\n  return this;\n};\n/**\n * Sets the module used for archiving.\n *\n * @param {Function} module The function for archiver to interact with.\n * @return {this}\n */\n\n\nArchiver.prototype.setModule = function (module) {\n  if (this._state.aborted) {\n    this.emit('error', new ArchiverError('ABORTED'));\n    return this;\n  }\n\n  if (this._state.module) {\n    this.emit('error', new ArchiverError('MODULESET'));\n    return this;\n  }\n\n  this._module = module;\n\n  this._modulePipe();\n\n  return this;\n};\n/**\n * Appends a symlink to the instance.\n *\n * This does NOT interact with filesystem and is used for programmatically creating symlinks.\n *\n * @param  {String} filepath The symlink path (within archive).\n * @param  {String} target The target path (within archive).\n * @param  {Number} mode Sets the entry permissions.\n * @return {this}\n */\n\n\nArchiver.prototype.symlink = function (filepath, target, mode) {\n  if (this._state.finalize || this._state.aborted) {\n    this.emit('error', new ArchiverError('QUEUECLOSED'));\n    return this;\n  }\n\n  if (typeof filepath !== 'string' || filepath.length === 0) {\n    this.emit('error', new ArchiverError('SYMLINKFILEPATHREQUIRED'));\n    return this;\n  }\n\n  if (typeof target !== 'string' || target.length === 0) {\n    this.emit('error', new ArchiverError('SYMLINKTARGETREQUIRED', {\n      filepath: filepath\n    }));\n    return this;\n  }\n\n  if (!this._moduleSupports('symlink')) {\n    this.emit('error', new ArchiverError('SYMLINKNOTSUPPORTED', {\n      filepath: filepath\n    }));\n    return this;\n  }\n\n  var data = {};\n  data.type = 'symlink';\n  data.name = filepath.replace(/\\\\/g, '/');\n  data.linkname = target.replace(/\\\\/g, '/');\n  data.sourceType = 'buffer';\n\n  if (typeof mode === \"number\") {\n    data.mode = mode;\n  }\n\n  this._entriesCount++;\n\n  this._queue.push({\n    data: data,\n    source: Buffer.concat([])\n  });\n\n  return this;\n};\n/**\n * Returns the current length (in bytes) that has been emitted.\n *\n * @return {Number}\n */\n\n\nArchiver.prototype.pointer = function () {\n  return this._pointer;\n};\n/**\n * Middleware-like helper that has yet to be fully implemented.\n *\n * @private\n * @param  {Function} plugin\n * @return {this}\n */\n\n\nArchiver.prototype.use = function (plugin) {\n  this._streams.push(plugin);\n\n  return this;\n};\n\nmodule.exports = Archiver;\n/**\n * @typedef {Object} CoreOptions\n * @global\n * @property {Number} [statConcurrency=4] Sets the number of workers used to\n * process the internal fs stat queue.\n */\n\n/**\n * @typedef {Object} TransformOptions\n * @property {Boolean} [allowHalfOpen=true] If set to false, then the stream\n * will automatically end the readable side when the writable side ends and vice\n * versa.\n * @property {Boolean} [readableObjectMode=false] Sets objectMode for readable\n * side of the stream. Has no effect if objectMode is true.\n * @property {Boolean} [writableObjectMode=false] Sets objectMode for writable\n * side of the stream. Has no effect if objectMode is true.\n * @property {Boolean} [decodeStrings=true] Whether or not to decode strings\n * into Buffers before passing them to _write(). `Writable`\n * @property {String} [encoding=NULL] If specified, then buffers will be decoded\n * to strings using the specified encoding. `Readable`\n * @property {Number} [highWaterMark=16kb] The maximum number of bytes to store\n * in the internal buffer before ceasing to read from the underlying resource.\n * `Readable` `Writable`\n * @property {Boolean} [objectMode=false] Whether this stream should behave as a\n * stream of objects. Meaning that stream.read(n) returns a single value instead\n * of a Buffer of size n. `Readable` `Writable`\n */\n\n/**\n * @typedef {Object} EntryData\n * @property {String} name Sets the entry name including internal path.\n * @property {(String|Date)} [date=NOW()] Sets the entry date.\n * @property {Number} [mode=D:0755/F:0644] Sets the entry permissions.\n * @property {String} [prefix] Sets a path prefix for the entry name. Useful\n * when working with methods like `directory` or `glob`.\n * @property {fs.Stats} [stats] Sets the fs stat data for this entry allowing\n * for reduction of fs stat calls when stat data is already known.\n */\n\n/**\n * @typedef {Object} ErrorData\n * @property {String} message The message of the error.\n * @property {String} code The error code assigned to this error.\n * @property {String} data Additional data provided for reporting or debugging (where available).\n */\n\n/**\n * @typedef {Object} ProgressData\n * @property {Object} entries\n * @property {Number} entries.total Number of entries that have been appended.\n * @property {Number} entries.processed Number of entries that have been processed.\n * @property {Object} fs\n * @property {Number} fs.totalBytes Number of bytes that have been appended. Calculated asynchronously and might not be accurate: it growth while entries are added. (based on fs.Stats)\n * @property {Number} fs.processedBytes Number of bytes that have been processed. (based on fs.Stats)\n */","map":{"version":3,"sources":["/home/dev/Documentos/Projects/github-clone/node_modules/archiver/lib/core.js"],"names":["fs","require","glob","async","path","util","inherits","ArchiverError","Transform","win32","process","platform","Archiver","format","options","defaults","highWaterMark","statConcurrency","call","_format","_module","_pending","_pointer","_entriesCount","_entriesProcessedCount","_fsEntriesTotalBytes","_fsEntriesProcessedBytes","_queue","queue","_onQueueTask","bind","drain","_onQueueDrain","_statQueue","_onStatQueueTask","_state","aborted","finalize","finalizing","finalized","modulePiped","_streams","prototype","_abort","kill","idle","_shutdown","_append","filepath","data","task","source","name","sourcePath","stats","Stats","_updateQueueTaskWithStats","size","push","_finalize","_moduleFinalize","_maybeFinalize","_moduleAppend","callback","append","err","_task","emit","setImmediate","entries","total","processed","totalBytes","processedBytes","end","_modulePipe","on","_onModuleError","pipe","_moduleSupports","key","supports","_moduleUnpipe","unpipe","_normalizeEntryData","type","date","mode","prefix","isDir","sanitizePath","slice","mtime","dateify","fullCallback","lstat","_transform","chunk","encoding","length","isFile","sourceType","lazyReadStream","isDirectory","trailingSlashIt","Buffer","concat","isSymbolicLink","linkPath","readlinkSync","dirName","dirname","linkname","relative","resolve","abort","normalizeInputSource","isBuffer","isStream","directory","dirpath","destpath","dataFunction","globOptions","stat","dot","onGlobEnd","onGlobError","onGlobMatch","match","globber","pause","ignoreMatch","entryData","Object","assign","resume","e","absolute","file","pattern","cwd","abortedError","Promise","reject","finalizingError","self","errored","setFormat","setModule","module","symlink","target","replace","pointer","use","plugin","exports"],"mappings":"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","sourcesContent":["/**\n * Archiver Core\n *\n * @ignore\n * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}\n * @copyright (c) 2012-2014 Chris Talkington, contributors.\n */\nvar fs = require('fs');\nvar glob = require('readdir-glob');\nvar async = require('async');\nvar path = require('path');\nvar util = require('archiver-utils');\n\nvar inherits = require('util').inherits;\nvar ArchiverError = require('./error');\nvar Transform = require('readable-stream').Transform;\n\nvar win32 = process.platform === 'win32';\n\n/**\n * @constructor\n * @param {String} format The archive format to use.\n * @param {(CoreOptions|TransformOptions)} options See also {@link ZipOptions} and {@link TarOptions}.\n */\nvar Archiver = function(format, options) {\n  if (!(this instanceof Archiver)) {\n    return new Archiver(format, options);\n  }\n\n  if (typeof format !== 'string') {\n    options = format;\n    format = 'zip';\n  }\n\n  options = this.options = util.defaults(options, {\n    highWaterMark: 1024 * 1024,\n    statConcurrency: 4\n  });\n\n  Transform.call(this, options);\n\n  this._format = false;\n  this._module = false;\n  this._pending = 0;\n  this._pointer = 0;\n\n  this._entriesCount = 0;\n  this._entriesProcessedCount = 0;\n  this._fsEntriesTotalBytes = 0;\n  this._fsEntriesProcessedBytes = 0;\n\n  this._queue = async.queue(this._onQueueTask.bind(this), 1);\n  this._queue.drain(this._onQueueDrain.bind(this));\n\n  this._statQueue = async.queue(this._onStatQueueTask.bind(this), options.statConcurrency);\n  this._statQueue.drain(this._onQueueDrain.bind(this));\n\n  this._state = {\n    aborted: false,\n    finalize: false,\n    finalizing: false,\n    finalized: false,\n    modulePiped: false\n  };\n\n  this._streams = [];\n};\n\ninherits(Archiver, Transform);\n\n/**\n * Internal logic for `abort`.\n *\n * @private\n * @return void\n */\nArchiver.prototype._abort = function() {\n  this._state.aborted = true;\n  this._queue.kill();\n  this._statQueue.kill();\n\n  if (this._queue.idle()) {\n    this._shutdown();\n  }\n};\n\n/**\n * Internal helper for appending files.\n *\n * @private\n * @param  {String} filepath The source filepath.\n * @param  {EntryData} data The entry data.\n * @return void\n */\nArchiver.prototype._append = function(filepath, data) {\n  data = data || {};\n\n  var task = {\n    source: null,\n    filepath: filepath\n  };\n\n  if (!data.name) {\n    data.name = filepath;\n  }\n\n  data.sourcePath = filepath;\n  task.data = data;\n  this._entriesCount++;\n\n  if (data.stats && data.stats instanceof fs.Stats) {\n    task = this._updateQueueTaskWithStats(task, data.stats);\n    if (task) {\n      if (data.stats.size) {\n        this._fsEntriesTotalBytes += data.stats.size;\n      }\n\n      this._queue.push(task);\n    }\n  } else {\n    this._statQueue.push(task);\n  }\n};\n\n/**\n * Internal logic for `finalize`.\n *\n * @private\n * @return void\n */\nArchiver.prototype._finalize = function() {\n  if (this._state.finalizing || this._state.finalized || this._state.aborted) {\n    return;\n  }\n\n  this._state.finalizing = true;\n\n  this._moduleFinalize();\n\n  this._state.finalizing = false;\n  this._state.finalized = true;\n};\n\n/**\n * Checks the various state variables to determine if we can `finalize`.\n *\n * @private\n * @return {Boolean}\n */\nArchiver.prototype._maybeFinalize = function() {\n  if (this._state.finalizing || this._state.finalized || this._state.aborted) {\n    return false;\n  }\n\n  if (this._state.finalize && this._pending === 0 && this._queue.idle() && this._statQueue.idle()) {\n    this._finalize();\n    return true;\n  }\n\n  return false;\n};\n\n/**\n * Appends an entry to the module.\n *\n * @private\n * @fires  Archiver#entry\n * @param  {(Buffer|Stream)} source\n * @param  {EntryData} data\n * @param  {Function} callback\n * @return void\n */\nArchiver.prototype._moduleAppend = function(source, data, callback) {\n  if (this._state.aborted) {\n    callback();\n    return;\n  }\n\n  this._module.append(source, data, function(err) {\n    this._task = null;\n\n    if (this._state.aborted) {\n      this._shutdown();\n      return;\n    }\n\n    if (err) {\n      this.emit('error', err);\n      setImmediate(callback);\n      return;\n    }\n\n    /**\n     * Fires when the entry's input has been processed and appended to the archive.\n     *\n     * @event Archiver#entry\n     * @type {EntryData}\n     */\n    this.emit('entry', data);\n    this._entriesProcessedCount++;\n\n    if (data.stats && data.stats.size) {\n      this._fsEntriesProcessedBytes += data.stats.size;\n    }\n\n    /**\n     * @event Archiver#progress\n     * @type {ProgressData}\n     */\n    this.emit('progress', {\n      entries: {\n        total: this._entriesCount,\n        processed: this._entriesProcessedCount\n      },\n      fs: {\n        totalBytes: this._fsEntriesTotalBytes,\n        processedBytes: this._fsEntriesProcessedBytes\n      }\n    });\n\n    setImmediate(callback);\n  }.bind(this));\n};\n\n/**\n * Finalizes the module.\n *\n * @private\n * @return void\n */\nArchiver.prototype._moduleFinalize = function() {\n  if (typeof this._module.finalize === 'function') {\n    this._module.finalize();\n  } else if (typeof this._module.end === 'function') {\n    this._module.end();\n  } else {\n    this.emit('error', new ArchiverError('NOENDMETHOD'));\n  }\n};\n\n/**\n * Pipes the module to our internal stream with error bubbling.\n *\n * @private\n * @return void\n */\nArchiver.prototype._modulePipe = function() {\n  this._module.on('error', this._onModuleError.bind(this));\n  this._module.pipe(this);\n  this._state.modulePiped = true;\n};\n\n/**\n * Determines if the current module supports a defined feature.\n *\n * @private\n * @param  {String} key\n * @return {Boolean}\n */\nArchiver.prototype._moduleSupports = function(key) {\n  if (!this._module.supports || !this._module.supports[key]) {\n    return false;\n  }\n\n  return this._module.supports[key];\n};\n\n/**\n * Unpipes the module from our internal stream.\n *\n * @private\n * @return void\n */\nArchiver.prototype._moduleUnpipe = function() {\n  this._module.unpipe(this);\n  this._state.modulePiped = false;\n};\n\n/**\n * Normalizes entry data with fallbacks for key properties.\n *\n * @private\n * @param  {Object} data\n * @param  {fs.Stats} stats\n * @return {Object}\n */\nArchiver.prototype._normalizeEntryData = function(data, stats) {\n  data = util.defaults(data, {\n    type: 'file',\n    name: null,\n    date: null,\n    mode: null,\n    prefix: null,\n    sourcePath: null,\n    stats: false\n  });\n\n  if (stats && data.stats === false) {\n    data.stats = stats;\n  }\n\n  var isDir = data.type === 'directory';\n\n  if (data.name) {\n    if (typeof data.prefix === 'string' && '' !== data.prefix) {\n      data.name = data.prefix + '/' + data.name;\n      data.prefix = null;\n    }\n\n    data.name = util.sanitizePath(data.name);\n\n    if (data.type !== 'symlink' && data.name.slice(-1) === '/') {\n      isDir = true;\n      data.type = 'directory';\n    } else if (isDir) {\n      data.name += '/';\n    }\n  }\n\n  // 511 === 0777; 493 === 0755; 438 === 0666; 420 === 0644\n  if (typeof data.mode === 'number') {\n    if (win32) {\n      data.mode &= 511;\n    } else {\n      data.mode &= 4095\n    }\n  } else if (data.stats && data.mode === null) {\n    if (win32) {\n      data.mode = data.stats.mode & 511;\n    } else {\n      data.mode = data.stats.mode & 4095;\n    }\n\n    // stat isn't reliable on windows; force 0755 for dir\n    if (win32 && isDir) {\n      data.mode = 493;\n    }\n  } else if (data.mode === null) {\n    data.mode = isDir ? 493 : 420;\n  }\n\n  if (data.stats && data.date === null) {\n    data.date = data.stats.mtime;\n  } else {\n    data.date = util.dateify(data.date);\n  }\n\n  return data;\n};\n\n/**\n * Error listener that re-emits error on to our internal stream.\n *\n * @private\n * @param  {Error} err\n * @return void\n */\nArchiver.prototype._onModuleError = function(err) {\n  /**\n   * @event Archiver#error\n   * @type {ErrorData}\n   */\n  this.emit('error', err);\n};\n\n/**\n * Checks the various state variables after queue has drained to determine if\n * we need to `finalize`.\n *\n * @private\n * @return void\n */\nArchiver.prototype._onQueueDrain = function() {\n  if (this._state.finalizing || this._state.finalized || this._state.aborted) {\n    return;\n  }\n\n  if (this._state.finalize && this._pending === 0 && this._queue.idle() && this._statQueue.idle()) {\n    this._finalize();\n  }\n};\n\n/**\n * Appends each queue task to the module.\n *\n * @private\n * @param  {Object} task\n * @param  {Function} callback\n * @return void\n */\nArchiver.prototype._onQueueTask = function(task, callback) {\n  var fullCallback = () => {\n    if(task.data.callback) {\n      task.data.callback();\n    }\n    callback();\n  }\n\n  if (this._state.finalizing || this._state.finalized || this._state.aborted) {\n    fullCallback();\n    return;\n  }\n\n  this._task = task;\n  this._moduleAppend(task.source, task.data, fullCallback);\n};\n\n/**\n * Performs a file stat and reinjects the task back into the queue.\n *\n * @private\n * @param  {Object} task\n * @param  {Function} callback\n * @return void\n */\nArchiver.prototype._onStatQueueTask = function(task, callback) {\n  if (this._state.finalizing || this._state.finalized || this._state.aborted) {\n    callback();\n    return;\n  }\n\n  fs.lstat(task.filepath, function(err, stats) {\n    if (this._state.aborted) {\n      setImmediate(callback);\n      return;\n    }\n\n    if (err) {\n      this._entriesCount--;\n\n      /**\n       * @event Archiver#warning\n       * @type {ErrorData}\n       */\n      this.emit('warning', err);\n      setImmediate(callback);\n      return;\n    }\n\n    task = this._updateQueueTaskWithStats(task, stats);\n\n    if (task) {\n      if (stats.size) {\n        this._fsEntriesTotalBytes += stats.size;\n      }\n\n      this._queue.push(task);\n    }\n\n    setImmediate(callback);\n  }.bind(this));\n};\n\n/**\n * Unpipes the module and ends our internal stream.\n *\n * @private\n * @return void\n */\nArchiver.prototype._shutdown = function() {\n  this._moduleUnpipe();\n  this.end();\n};\n\n/**\n * Tracks the bytes emitted by our internal stream.\n *\n * @private\n * @param  {Buffer} chunk\n * @param  {String} encoding\n * @param  {Function} callback\n * @return void\n */\nArchiver.prototype._transform = function(chunk, encoding, callback) {\n  if (chunk) {\n    this._pointer += chunk.length;\n  }\n\n  callback(null, chunk);\n};\n\n/**\n * Updates and normalizes a queue task using stats data.\n *\n * @private\n * @param  {Object} task\n * @param  {fs.Stats} stats\n * @return {Object}\n */\nArchiver.prototype._updateQueueTaskWithStats = function(task, stats) {\n  if (stats.isFile()) {\n    task.data.type = 'file';\n    task.data.sourceType = 'stream';\n    task.source = util.lazyReadStream(task.filepath);\n  } else if (stats.isDirectory() && this._moduleSupports('directory')) {\n    task.data.name = util.trailingSlashIt(task.data.name);\n    task.data.type = 'directory';\n    task.data.sourcePath = util.trailingSlashIt(task.filepath);\n    task.data.sourceType = 'buffer';\n    task.source = Buffer.concat([]);\n  } else if (stats.isSymbolicLink() && this._moduleSupports('symlink')) {\n    var linkPath = fs.readlinkSync(task.filepath);\n    var dirName = path.dirname(task.filepath);\n    task.data.type = 'symlink';\n    task.data.linkname = path.relative(dirName, path.resolve(dirName, linkPath));\n    task.data.sourceType = 'buffer';\n    task.source = Buffer.concat([]);\n  } else {\n    if (stats.isDirectory()) {\n      this.emit('warning', new ArchiverError('DIRECTORYNOTSUPPORTED', task.data));\n    } else if (stats.isSymbolicLink()) {\n      this.emit('warning', new ArchiverError('SYMLINKNOTSUPPORTED', task.data));\n    } else {\n      this.emit('warning', new ArchiverError('ENTRYNOTSUPPORTED', task.data));\n    }\n\n    return null;\n  }\n\n  task.data = this._normalizeEntryData(task.data, stats);\n\n  return task;\n};\n\n/**\n * Aborts the archiving process, taking a best-effort approach, by:\n *\n * - removing any pending queue tasks\n * - allowing any active queue workers to finish\n * - detaching internal module pipes\n * - ending both sides of the Transform stream\n *\n * It will NOT drain any remaining sources.\n *\n * @return {this}\n */\nArchiver.prototype.abort = function() {\n  if (this._state.aborted || this._state.finalized) {\n    return this;\n  }\n\n  this._abort();\n\n  return this;\n};\n\n/**\n * Appends an input source (text string, buffer, or stream) to the instance.\n *\n * When the instance has received, processed, and emitted the input, the `entry`\n * event is fired.\n *\n * @fires  Archiver#entry\n * @param  {(Buffer|Stream|String)} source The input source.\n * @param  {EntryData} data See also {@link ZipEntryData} and {@link TarEntryData}.\n * @return {this}\n */\nArchiver.prototype.append = function(source, data) {\n  if (this._state.finalize || this._state.aborted) {\n    this.emit('error', new ArchiverError('QUEUECLOSED'));\n    return this;\n  }\n\n  data = this._normalizeEntryData(data);\n\n  if (typeof data.name !== 'string' || data.name.length === 0) {\n    this.emit('error', new ArchiverError('ENTRYNAMEREQUIRED'));\n    return this;\n  }\n\n  if (data.type === 'directory' && !this._moduleSupports('directory')) {\n    this.emit('error', new ArchiverError('DIRECTORYNOTSUPPORTED', { name: data.name }));\n    return this;\n  }\n\n  source = util.normalizeInputSource(source);\n\n  if (Buffer.isBuffer(source)) {\n    data.sourceType = 'buffer';\n  } else if (util.isStream(source)) {\n    data.sourceType = 'stream';\n  } else {\n    this.emit('error', new ArchiverError('INPUTSTEAMBUFFERREQUIRED', { name: data.name }));\n    return this;\n  }\n\n  this._entriesCount++;\n  this._queue.push({\n    data: data,\n    source: source\n  });\n\n  return this;\n};\n\n/**\n * Appends a directory and its files, recursively, given its dirpath.\n *\n * @param  {String} dirpath The source directory path.\n * @param  {String} destpath The destination path within the archive.\n * @param  {(EntryData|Function)} data See also [ZipEntryData]{@link ZipEntryData} and\n * [TarEntryData]{@link TarEntryData}.\n * @return {this}\n */\nArchiver.prototype.directory = function(dirpath, destpath, data) {\n  if (this._state.finalize || this._state.aborted) {\n    this.emit('error', new ArchiverError('QUEUECLOSED'));\n    return this;\n  }\n\n  if (typeof dirpath !== 'string' || dirpath.length === 0) {\n    this.emit('error', new ArchiverError('DIRECTORYDIRPATHREQUIRED'));\n    return this;\n  }\n\n  this._pending++;\n\n  if (destpath === false) {\n    destpath = '';\n  } else if (typeof destpath !== 'string'){\n    destpath = dirpath;\n  }\n\n  var dataFunction = false;\n  if (typeof data === 'function') {\n    dataFunction = data;\n    data = {};\n  } else if (typeof data !== 'object') {\n    data = {};\n  }\n\n  var globOptions = {\n    stat: true,\n    dot: true\n  };\n\n  function onGlobEnd() {\n    this._pending--;\n    this._maybeFinalize();\n  }\n\n  function onGlobError(err) {\n    this.emit('error', err);\n  }\n\n  function onGlobMatch(match){\n    globber.pause();\n\n    var ignoreMatch = false;\n    var entryData = Object.assign({}, data);\n    entryData.name = match.relative;\n    entryData.prefix = destpath;\n    entryData.stats = match.stat;\n    entryData.callback = globber.resume.bind(globber);\n\n    try {\n      if (dataFunction) {\n        entryData = dataFunction(entryData);\n\n        if (entryData === false) {\n          ignoreMatch = true;\n        } else if (typeof entryData !== 'object') {\n          throw new ArchiverError('DIRECTORYFUNCTIONINVALIDDATA', { dirpath: dirpath });\n        }\n      }\n    } catch(e) {\n      this.emit('error', e);\n      return;\n    }\n\n    if (ignoreMatch) {\n      globber.resume();\n      return;\n    }\n\n    this._append(match.absolute, entryData);\n  }\n\n  var globber = glob(dirpath, globOptions);\n  globber.on('error', onGlobError.bind(this));\n  globber.on('match', onGlobMatch.bind(this));\n  globber.on('end', onGlobEnd.bind(this));\n\n  return this;\n};\n\n/**\n * Appends a file given its filepath using a\n * [lazystream]{@link https://github.com/jpommerening/node-lazystream} wrapper to\n * prevent issues with open file limits.\n *\n * When the instance has received, processed, and emitted the file, the `entry`\n * event is fired.\n *\n * @param  {String} filepath The source filepath.\n * @param  {EntryData} data See also [ZipEntryData]{@link ZipEntryData} and\n * [TarEntryData]{@link TarEntryData}.\n * @return {this}\n */\nArchiver.prototype.file = function(filepath, data) {\n  if (this._state.finalize || this._state.aborted) {\n    this.emit('error', new ArchiverError('QUEUECLOSED'));\n    return this;\n  }\n\n  if (typeof filepath !== 'string' || filepath.length === 0) {\n    this.emit('error', new ArchiverError('FILEFILEPATHREQUIRED'));\n    return this;\n  }\n\n  this._append(filepath, data);\n\n  return this;\n};\n\n/**\n * Appends multiple files that match a glob pattern.\n *\n * @param  {String} pattern The [glob pattern]{@link https://github.com/isaacs/minimatch} to match.\n * @param  {Object} options See [node-readdir-glob]{@link https://github.com/yqnn/node-readdir-glob#options}.\n * @param  {EntryData} data See also [ZipEntryData]{@link ZipEntryData} and\n * [TarEntryData]{@link TarEntryData}.\n * @return {this}\n */\nArchiver.prototype.glob = function(pattern, options, data) {\n  this._pending++;\n\n  options = util.defaults(options, {\n    stat: true,\n    pattern: pattern\n  });\n\n  function onGlobEnd() {\n    this._pending--;\n    this._maybeFinalize();\n  }\n\n  function onGlobError(err) {\n    this.emit('error', err);\n  }\n\n  function onGlobMatch(match){\n    globber.pause();\n    var entryData = Object.assign({}, data);\n    entryData.callback = globber.resume.bind(globber);\n    entryData.stats = match.stat;\n    entryData.name = match.relative;\n\n    this._append(match.absolute, entryData);\n  }\n\n  var globber = glob(options.cwd || '.', options);\n  globber.on('error', onGlobError.bind(this));\n  globber.on('match', onGlobMatch.bind(this));\n  globber.on('end', onGlobEnd.bind(this));\n\n  return this;\n};\n\n/**\n * Finalizes the instance and prevents further appending to the archive\n * structure (queue will continue til drained).\n *\n * The `end`, `close` or `finish` events on the destination stream may fire\n * right after calling this method so you should set listeners beforehand to\n * properly detect stream completion.\n *\n * @return {Promise}\n */\nArchiver.prototype.finalize = function() {\n  if (this._state.aborted) {\n    var abortedError = new ArchiverError('ABORTED');\n    this.emit('error', abortedError);\n    return Promise.reject(abortedError);\n  }\n\n  if (this._state.finalize) {\n    var finalizingError = new ArchiverError('FINALIZING');\n    this.emit('error', finalizingError);\n    return Promise.reject(finalizingError);\n  }\n\n  this._state.finalize = true;\n\n  if (this._pending === 0 && this._queue.idle() && this._statQueue.idle()) {\n    this._finalize();\n  }\n\n  var self = this;\n\n  return new Promise(function(resolve, reject) {\n    var errored;\n\n    self._module.on('end', function() {\n      if (!errored) {\n        resolve();\n      }\n    })\n\n    self._module.on('error', function(err) {\n      errored = true;\n      reject(err);\n    })\n  })\n};\n\n/**\n * Sets the module format name used for archiving.\n *\n * @param {String} format The name of the format.\n * @return {this}\n */\nArchiver.prototype.setFormat = function(format) {\n  if (this._format) {\n    this.emit('error', new ArchiverError('FORMATSET'));\n    return this;\n  }\n\n  this._format = format;\n\n  return this;\n};\n\n/**\n * Sets the module used for archiving.\n *\n * @param {Function} module The function for archiver to interact with.\n * @return {this}\n */\nArchiver.prototype.setModule = function(module) {\n  if (this._state.aborted) {\n    this.emit('error', new ArchiverError('ABORTED'));\n    return this;\n  }\n\n  if (this._state.module) {\n    this.emit('error', new ArchiverError('MODULESET'));\n    return this;\n  }\n\n  this._module = module;\n  this._modulePipe();\n\n  return this;\n};\n\n/**\n * Appends a symlink to the instance.\n *\n * This does NOT interact with filesystem and is used for programmatically creating symlinks.\n *\n * @param  {String} filepath The symlink path (within archive).\n * @param  {String} target The target path (within archive).\n * @param  {Number} mode Sets the entry permissions.\n * @return {this}\n */\nArchiver.prototype.symlink = function(filepath, target, mode) {\n  if (this._state.finalize || this._state.aborted) {\n    this.emit('error', new ArchiverError('QUEUECLOSED'));\n    return this;\n  }\n\n  if (typeof filepath !== 'string' || filepath.length === 0) {\n    this.emit('error', new ArchiverError('SYMLINKFILEPATHREQUIRED'));\n    return this;\n  }\n\n  if (typeof target !== 'string' || target.length === 0) {\n    this.emit('error', new ArchiverError('SYMLINKTARGETREQUIRED', { filepath: filepath }));\n    return this;\n  }\n\n  if (!this._moduleSupports('symlink')) {\n    this.emit('error', new ArchiverError('SYMLINKNOTSUPPORTED', { filepath: filepath }));\n    return this;\n  }\n\n  var data = {};\n  data.type = 'symlink';\n  data.name = filepath.replace(/\\\\/g, '/');\n  data.linkname = target.replace(/\\\\/g, '/');\n  data.sourceType = 'buffer';\n\n  if (typeof mode === \"number\") {\n    data.mode = mode;\n  }\n\n  this._entriesCount++;\n  this._queue.push({\n    data: data,\n    source: Buffer.concat([])\n  });\n\n  return this;\n};\n\n/**\n * Returns the current length (in bytes) that has been emitted.\n *\n * @return {Number}\n */\nArchiver.prototype.pointer = function() {\n  return this._pointer;\n};\n\n/**\n * Middleware-like helper that has yet to be fully implemented.\n *\n * @private\n * @param  {Function} plugin\n * @return {this}\n */\nArchiver.prototype.use = function(plugin) {\n  this._streams.push(plugin);\n  return this;\n};\n\nmodule.exports = Archiver;\n\n/**\n * @typedef {Object} CoreOptions\n * @global\n * @property {Number} [statConcurrency=4] Sets the number of workers used to\n * process the internal fs stat queue.\n */\n\n/**\n * @typedef {Object} TransformOptions\n * @property {Boolean} [allowHalfOpen=true] If set to false, then the stream\n * will automatically end the readable side when the writable side ends and vice\n * versa.\n * @property {Boolean} [readableObjectMode=false] Sets objectMode for readable\n * side of the stream. Has no effect if objectMode is true.\n * @property {Boolean} [writableObjectMode=false] Sets objectMode for writable\n * side of the stream. Has no effect if objectMode is true.\n * @property {Boolean} [decodeStrings=true] Whether or not to decode strings\n * into Buffers before passing them to _write(). `Writable`\n * @property {String} [encoding=NULL] If specified, then buffers will be decoded\n * to strings using the specified encoding. `Readable`\n * @property {Number} [highWaterMark=16kb] The maximum number of bytes to store\n * in the internal buffer before ceasing to read from the underlying resource.\n * `Readable` `Writable`\n * @property {Boolean} [objectMode=false] Whether this stream should behave as a\n * stream of objects. Meaning that stream.read(n) returns a single value instead\n * of a Buffer of size n. `Readable` `Writable`\n */\n\n/**\n * @typedef {Object} EntryData\n * @property {String} name Sets the entry name including internal path.\n * @property {(String|Date)} [date=NOW()] Sets the entry date.\n * @property {Number} [mode=D:0755/F:0644] Sets the entry permissions.\n * @property {String} [prefix] Sets a path prefix for the entry name. Useful\n * when working with methods like `directory` or `glob`.\n * @property {fs.Stats} [stats] Sets the fs stat data for this entry allowing\n * for reduction of fs stat calls when stat data is already known.\n */\n\n/**\n * @typedef {Object} ErrorData\n * @property {String} message The message of the error.\n * @property {String} code The error code assigned to this error.\n * @property {String} data Additional data provided for reporting or debugging (where available).\n */\n\n/**\n * @typedef {Object} ProgressData\n * @property {Object} entries\n * @property {Number} entries.total Number of entries that have been appended.\n * @property {Number} entries.processed Number of entries that have been processed.\n * @property {Object} fs\n * @property {Number} fs.totalBytes Number of bytes that have been appended. Calculated asynchronously and might not be accurate: it growth while entries are added. (based on fs.Stats)\n * @property {Number} fs.processedBytes Number of bytes that have been processed. (based on fs.Stats)\n */\n"]},"metadata":{},"sourceType":"script"}