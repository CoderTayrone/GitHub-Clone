{"ast":null,"code":"module.exports = collect;\n\nfunction collect(stream) {\n  if (stream._collected) return;\n  if (stream._paused) return stream.on('resume', collect.bind(null, stream));\n  stream._collected = true;\n  stream.pause();\n  stream.on('data', save);\n  stream.on('end', save);\n  var buf = [];\n\n  function save(b) {\n    if (typeof b === 'string') b = new Buffer(b);\n    if (Buffer.isBuffer(b) && !b.length) return;\n    buf.push(b);\n  }\n\n  stream.on('entry', saveEntry);\n  var entryBuffer = [];\n\n  function saveEntry(e) {\n    collect(e);\n    entryBuffer.push(e);\n  }\n\n  stream.on('proxy', proxyPause);\n\n  function proxyPause(p) {\n    p.pause();\n  } // replace the pipe method with a new version that will\n  // unlock the buffered stuff.  if you just call .pipe()\n  // without a destination, then it'll re-play the events.\n\n\n  stream.pipe = function (orig) {\n    return function (dest) {\n      // console.error(' === open the pipes', dest && dest.path)\n      // let the entries flow through one at a time.\n      // Once they're all done, then we can resume completely.\n      var e = 0;\n\n      (function unblockEntry() {\n        var entry = entryBuffer[e++]; // console.error(\" ==== unblock entry\", entry && entry.path)\n\n        if (!entry) return resume();\n        entry.on('end', unblockEntry);\n        if (dest) dest.add(entry);else stream.emit('entry', entry);\n      })();\n\n      function resume() {\n        stream.removeListener('entry', saveEntry);\n        stream.removeListener('data', save);\n        stream.removeListener('end', save);\n        stream.pipe = orig;\n        if (dest) stream.pipe(dest);\n        buf.forEach(function (b) {\n          if (b) stream.emit('data', b);else stream.emit('end');\n        });\n        stream.resume();\n      }\n\n      return dest;\n    };\n  }(stream.pipe);\n}","map":{"version":3,"sources":["/home/dev/Documentos/Projects/github-clone/node_modules/fstream/lib/collect.js"],"names":["module","exports","collect","stream","_collected","_paused","on","bind","pause","save","buf","b","Buffer","isBuffer","length","push","saveEntry","entryBuffer","e","proxyPause","p","pipe","orig","dest","unblockEntry","entry","resume","add","emit","removeListener","forEach"],"mappings":"AAAAA,MAAM,CAACC,OAAP,GAAiBC,OAAjB;;AAEA,SAASA,OAAT,CAAkBC,MAAlB,EAA0B;AACxB,MAAIA,MAAM,CAACC,UAAX,EAAuB;AAEvB,MAAID,MAAM,CAACE,OAAX,EAAoB,OAAOF,MAAM,CAACG,EAAP,CAAU,QAAV,EAAoBJ,OAAO,CAACK,IAAR,CAAa,IAAb,EAAmBJ,MAAnB,CAApB,CAAP;AAEpBA,EAAAA,MAAM,CAACC,UAAP,GAAoB,IAApB;AACAD,EAAAA,MAAM,CAACK,KAAP;AAEAL,EAAAA,MAAM,CAACG,EAAP,CAAU,MAAV,EAAkBG,IAAlB;AACAN,EAAAA,MAAM,CAACG,EAAP,CAAU,KAAV,EAAiBG,IAAjB;AACA,MAAIC,GAAG,GAAG,EAAV;;AACA,WAASD,IAAT,CAAeE,CAAf,EAAkB;AAChB,QAAI,OAAOA,CAAP,KAAa,QAAjB,EAA2BA,CAAC,GAAG,IAAIC,MAAJ,CAAWD,CAAX,CAAJ;AAC3B,QAAIC,MAAM,CAACC,QAAP,CAAgBF,CAAhB,KAAsB,CAACA,CAAC,CAACG,MAA7B,EAAqC;AACrCJ,IAAAA,GAAG,CAACK,IAAJ,CAASJ,CAAT;AACD;;AAEDR,EAAAA,MAAM,CAACG,EAAP,CAAU,OAAV,EAAmBU,SAAnB;AACA,MAAIC,WAAW,GAAG,EAAlB;;AACA,WAASD,SAAT,CAAoBE,CAApB,EAAuB;AACrBhB,IAAAA,OAAO,CAACgB,CAAD,CAAP;AACAD,IAAAA,WAAW,CAACF,IAAZ,CAAiBG,CAAjB;AACD;;AAEDf,EAAAA,MAAM,CAACG,EAAP,CAAU,OAAV,EAAmBa,UAAnB;;AACA,WAASA,UAAT,CAAqBC,CAArB,EAAwB;AACtBA,IAAAA,CAAC,CAACZ,KAAF;AACD,GA3BuB,CA6BxB;AACA;AACA;;;AACAL,EAAAA,MAAM,CAACkB,IAAP,GAAe,UAAUC,IAAV,EAAgB;AAC7B,WAAO,UAAUC,IAAV,EAAgB;AACrB;AAEA;AACA;AACA,UAAIL,CAAC,GAAG,CAAR;;AACC,OAAC,SAASM,YAAT,GAAyB;AACzB,YAAIC,KAAK,GAAGR,WAAW,CAACC,CAAC,EAAF,CAAvB,CADyB,CAEzB;;AACA,YAAI,CAACO,KAAL,EAAY,OAAOC,MAAM,EAAb;AACZD,QAAAA,KAAK,CAACnB,EAAN,CAAS,KAAT,EAAgBkB,YAAhB;AACA,YAAID,IAAJ,EAAUA,IAAI,CAACI,GAAL,CAASF,KAAT,EAAV,KACKtB,MAAM,CAACyB,IAAP,CAAY,OAAZ,EAAqBH,KAArB;AACN,OAPA;;AASD,eAASC,MAAT,GAAmB;AACjBvB,QAAAA,MAAM,CAAC0B,cAAP,CAAsB,OAAtB,EAA+Bb,SAA/B;AACAb,QAAAA,MAAM,CAAC0B,cAAP,CAAsB,MAAtB,EAA8BpB,IAA9B;AACAN,QAAAA,MAAM,CAAC0B,cAAP,CAAsB,KAAtB,EAA6BpB,IAA7B;AAEAN,QAAAA,MAAM,CAACkB,IAAP,GAAcC,IAAd;AACA,YAAIC,IAAJ,EAAUpB,MAAM,CAACkB,IAAP,CAAYE,IAAZ;AAEVb,QAAAA,GAAG,CAACoB,OAAJ,CAAY,UAAUnB,CAAV,EAAa;AACvB,cAAIA,CAAJ,EAAOR,MAAM,CAACyB,IAAP,CAAY,MAAZ,EAAoBjB,CAApB,EAAP,KACKR,MAAM,CAACyB,IAAP,CAAY,KAAZ;AACN,SAHD;AAKAzB,QAAAA,MAAM,CAACuB,MAAP;AACD;;AAED,aAAOH,IAAP;AACD,KAhCD;AAiCD,GAlCa,CAkCXpB,MAAM,CAACkB,IAlCI,CAAd;AAmCD","sourcesContent":["module.exports = collect\n\nfunction collect (stream) {\n  if (stream._collected) return\n\n  if (stream._paused) return stream.on('resume', collect.bind(null, stream))\n\n  stream._collected = true\n  stream.pause()\n\n  stream.on('data', save)\n  stream.on('end', save)\n  var buf = []\n  function save (b) {\n    if (typeof b === 'string') b = new Buffer(b)\n    if (Buffer.isBuffer(b) && !b.length) return\n    buf.push(b)\n  }\n\n  stream.on('entry', saveEntry)\n  var entryBuffer = []\n  function saveEntry (e) {\n    collect(e)\n    entryBuffer.push(e)\n  }\n\n  stream.on('proxy', proxyPause)\n  function proxyPause (p) {\n    p.pause()\n  }\n\n  // replace the pipe method with a new version that will\n  // unlock the buffered stuff.  if you just call .pipe()\n  // without a destination, then it'll re-play the events.\n  stream.pipe = (function (orig) {\n    return function (dest) {\n      // console.error(' === open the pipes', dest && dest.path)\n\n      // let the entries flow through one at a time.\n      // Once they're all done, then we can resume completely.\n      var e = 0\n      ;(function unblockEntry () {\n        var entry = entryBuffer[e++]\n        // console.error(\" ==== unblock entry\", entry && entry.path)\n        if (!entry) return resume()\n        entry.on('end', unblockEntry)\n        if (dest) dest.add(entry)\n        else stream.emit('entry', entry)\n      })()\n\n      function resume () {\n        stream.removeListener('entry', saveEntry)\n        stream.removeListener('data', save)\n        stream.removeListener('end', save)\n\n        stream.pipe = orig\n        if (dest) stream.pipe(dest)\n\n        buf.forEach(function (b) {\n          if (b) stream.emit('data', b)\n          else stream.emit('end')\n        })\n\n        stream.resume()\n      }\n\n      return dest\n    }\n  })(stream.pipe)\n}\n"]},"metadata":{},"sourceType":"script"}