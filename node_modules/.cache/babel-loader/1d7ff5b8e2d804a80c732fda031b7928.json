{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodePtrInit = exports.pickDecoder = exports.looksLikeFragment = exports.unsetValueAtPath = exports.setValueAtPath = exports.compilePointerDereference = exports.toArrayIndexReference = exports.decodeRelativePointer = exports.encodeUriFragmentIdentifier = exports.decodeUriFragmentIdentifier = exports.encodePointer = exports.decodePointer = exports.encodePointerSegments = exports.decodePointerSegments = exports.encodeFragmentSegments = exports.decodeFragmentSegments = exports.replace = void 0;\n\nfunction replace(source, find, repl) {\n  let res = '';\n  let rem = source;\n  let beg = 0;\n  let end = -1;\n\n  while ((end = rem.indexOf(find)) > -1) {\n    res += source.substring(beg, beg + end) + repl;\n    rem = rem.substring(end + find.length, rem.length);\n    beg += end + find.length;\n  }\n\n  if (rem.length > 0) {\n    res += source.substring(source.length - rem.length, source.length);\n  }\n\n  return res;\n}\n\nexports.replace = replace;\n\nfunction decodeFragmentSegments(segments) {\n  let i = -1;\n  const len = segments.length;\n  const res = new Array(len);\n\n  while (++i < len) {\n    if (typeof segments[i] === 'string') {\n      res[i] = replace(replace(decodeURIComponent(segments[i]), '~1', '/'), '~0', '~');\n    } else {\n      res[i] = segments[i];\n    }\n  }\n\n  return res;\n}\n\nexports.decodeFragmentSegments = decodeFragmentSegments;\n\nfunction encodeFragmentSegments(segments) {\n  let i = -1;\n  const len = segments.length;\n  const res = new Array(len);\n\n  while (++i < len) {\n    if (typeof segments[i] === 'string') {\n      res[i] = encodeURIComponent(replace(replace(segments[i], '~', '~0'), '/', '~1'));\n    } else {\n      res[i] = segments[i];\n    }\n  }\n\n  return res;\n}\n\nexports.encodeFragmentSegments = encodeFragmentSegments;\n\nfunction decodePointerSegments(segments) {\n  let i = -1;\n  const len = segments.length;\n  const res = new Array(len);\n\n  while (++i < len) {\n    if (typeof segments[i] === 'string') {\n      res[i] = replace(replace(segments[i], '~1', '/'), '~0', '~');\n    } else {\n      res[i] = segments[i];\n    }\n  }\n\n  return res;\n}\n\nexports.decodePointerSegments = decodePointerSegments;\n\nfunction encodePointerSegments(segments) {\n  let i = -1;\n  const len = segments.length;\n  const res = new Array(len);\n\n  while (++i < len) {\n    if (typeof segments[i] === 'string') {\n      res[i] = replace(replace(segments[i], '~', '~0'), '/', '~1');\n    } else {\n      res[i] = segments[i];\n    }\n  }\n\n  return res;\n}\n\nexports.encodePointerSegments = encodePointerSegments;\n\nfunction decodePointer(ptr) {\n  if (typeof ptr !== 'string') {\n    throw new TypeError('Invalid type: JSON Pointers are represented as strings.');\n  }\n\n  if (ptr.length === 0) {\n    return [];\n  }\n\n  if (ptr[0] !== '/') {\n    throw new ReferenceError('Invalid JSON Pointer syntax. Non-empty pointer must begin with a solidus `/`.');\n  }\n\n  return decodePointerSegments(ptr.substring(1).split('/'));\n}\n\nexports.decodePointer = decodePointer;\n\nfunction encodePointer(path) {\n  if (!path || path && !Array.isArray(path)) {\n    throw new TypeError('Invalid type: path must be an array of segments.');\n  }\n\n  if (path.length === 0) {\n    return '';\n  }\n\n  return '/'.concat(encodePointerSegments(path).join('/'));\n}\n\nexports.encodePointer = encodePointer;\n\nfunction decodeUriFragmentIdentifier(ptr) {\n  if (typeof ptr !== 'string') {\n    throw new TypeError('Invalid type: JSON Pointers are represented as strings.');\n  }\n\n  if (ptr.length === 0 || ptr[0] !== '#') {\n    throw new ReferenceError('Invalid JSON Pointer syntax; URI fragment identifiers must begin with a hash.');\n  }\n\n  if (ptr.length === 1) {\n    return [];\n  }\n\n  if (ptr[1] !== '/') {\n    throw new ReferenceError('Invalid JSON Pointer syntax.');\n  }\n\n  return decodeFragmentSegments(ptr.substring(2).split('/'));\n}\n\nexports.decodeUriFragmentIdentifier = decodeUriFragmentIdentifier;\n\nfunction encodeUriFragmentIdentifier(path) {\n  if (!path || path && !Array.isArray(path)) {\n    throw new TypeError('Invalid type: path must be an array of segments.');\n  }\n\n  if (path.length === 0) {\n    return '#';\n  }\n\n  return '#/'.concat(encodeFragmentSegments(path).join('/'));\n}\n\nexports.encodeUriFragmentIdentifier = encodeUriFragmentIdentifier;\nconst InvalidRelativePointerError = 'Invalid Relative JSON Pointer syntax. Relative pointer must begin with a non-negative integer, followed by either the number sign (#), or a JSON Pointer.';\n\nfunction decodeRelativePointer(ptr) {\n  if (typeof ptr !== 'string') {\n    throw new TypeError('Invalid type: Relative JSON Pointers are represented as strings.');\n  }\n\n  if (ptr.length === 0) {\n    throw new ReferenceError(InvalidRelativePointerError);\n  }\n\n  const segments = ptr.split('/');\n  let first = segments[0];\n\n  if (first[first.length - 1] == '#') {\n    if (segments.length > 1) {\n      throw new ReferenceError(InvalidRelativePointerError);\n    }\n\n    first = first.substr(0, first.length - 1);\n  }\n\n  let i = -1;\n  const len = first.length;\n\n  while (++i < len) {\n    if (first[i] < '0' || first[i] > '9') {\n      throw new ReferenceError(InvalidRelativePointerError);\n    }\n  }\n\n  const path = decodePointerSegments(segments.slice(1));\n  path.unshift(segments[0]);\n  return path;\n}\n\nexports.decodeRelativePointer = decodeRelativePointer;\n\nfunction toArrayIndexReference(arr, idx) {\n  if (typeof idx === 'number') return idx;\n  const len = idx.length;\n  if (!len) return -1;\n  let cursor = 0;\n\n  if (len === 1 && idx[0] === '-') {\n    if (!Array.isArray(arr)) {\n      return 0;\n    }\n\n    return arr.length;\n  }\n\n  while (++cursor < len) {\n    if (idx[cursor] < '0' || idx[cursor] > '9') {\n      return -1;\n    }\n  }\n\n  return parseInt(idx, 10);\n}\n\nexports.toArrayIndexReference = toArrayIndexReference;\n\nfunction compilePointerDereference(path) {\n  let body = \"if (typeof(it) !== 'undefined'\";\n\n  if (path.length === 0) {\n    return it => it;\n  }\n\n  body = path.reduce((body, _, i) => {\n    return body + \"\\n\\t&& it !== null && typeof((it = it['\" + replace(replace(path[i] + '', '\\\\', '\\\\\\\\'), \"'\", \"\\\\'\") + \"'])) !== 'undefined'\";\n  }, \"if (typeof(it) !== 'undefined'\");\n  body = body + ') {\\n\\treturn it;\\n }';\n  return new Function('it', body);\n}\n\nexports.compilePointerDereference = compilePointerDereference;\n\nfunction setValueAtPath(target, val, path, force = false) {\n  if (path.length === 0) {\n    throw new Error('Cannot set the root object; assign it directly.');\n  }\n\n  if (typeof target === 'undefined') {\n    throw new TypeError('Cannot set values on undefined');\n  }\n\n  let it = target;\n  const len = path.length;\n  const end = path.length - 1;\n  let step;\n  let cursor = -1;\n  let rem;\n  let p;\n\n  while (++cursor < len) {\n    step = path[cursor];\n\n    if (step === '__proto__' || step === 'constructor' || step === 'prototype') {\n      throw new Error('Attempted prototype pollution disallowed.');\n    }\n\n    if (Array.isArray(it)) {\n      if (step === '-' && cursor === end) {\n        it.push(val);\n        return undefined;\n      }\n\n      p = toArrayIndexReference(it, step);\n\n      if (it.length > p) {\n        if (cursor === end) {\n          rem = it[p];\n          it[p] = val;\n          break;\n        }\n\n        it = it[p];\n      } else if (cursor === end && p === it.length) {\n        if (force) {\n          it.push(val);\n          return undefined;\n        }\n      } else if (force) {\n        it = it[p] = cursor === end ? val : {};\n      }\n    } else {\n      if (typeof it[step] === 'undefined') {\n        if (force) {\n          if (cursor === end) {\n            it[step] = val;\n            return undefined;\n          }\n\n          if (toArrayIndexReference(it[step], path[cursor + 1]) !== -1) {\n            it = it[step] = [];\n            continue;\n          }\n\n          it = it[step] = {};\n          continue;\n        }\n\n        return undefined;\n      }\n\n      if (cursor === end) {\n        rem = it[step];\n        it[step] = val;\n        break;\n      }\n\n      it = it[step];\n    }\n  }\n\n  return rem;\n}\n\nexports.setValueAtPath = setValueAtPath;\n\nfunction unsetValueAtPath(target, path) {\n  if (path.length === 0) {\n    throw new Error('Cannot unset the root object; assign it directly.');\n  }\n\n  if (typeof target === 'undefined') {\n    throw new TypeError('Cannot unset values on undefined');\n  }\n\n  let it = target;\n  const len = path.length;\n  const end = path.length - 1;\n  let step;\n  let cursor = -1;\n  let rem;\n  let p;\n\n  while (++cursor < len) {\n    step = path[cursor];\n\n    if (Array.isArray(it)) {\n      p = toArrayIndexReference(it, step);\n      if (p >= it.length) return undefined;\n\n      if (cursor === end) {\n        rem = it[p];\n        delete it[p];\n        break;\n      }\n\n      it = it[p];\n    } else {\n      if (typeof it[step] === 'undefined') {\n        return undefined;\n      }\n\n      if (cursor === end) {\n        rem = it[step];\n        delete it[step];\n        break;\n      }\n\n      it = it[step];\n    }\n  }\n\n  return rem;\n}\n\nexports.unsetValueAtPath = unsetValueAtPath;\n\nfunction looksLikeFragment(ptr) {\n  return (ptr === null || ptr === void 0 ? void 0 : ptr.length) > 0 && ptr[0] === '#';\n}\n\nexports.looksLikeFragment = looksLikeFragment;\n\nfunction pickDecoder(ptr) {\n  return looksLikeFragment(ptr) ? decodeUriFragmentIdentifier : decodePointer;\n}\n\nexports.pickDecoder = pickDecoder;\n\nfunction decodePtrInit(ptr) {\n  return Array.isArray(ptr) ? ptr.slice(0) : pickDecoder(ptr)(ptr);\n}\n\nexports.decodePtrInit = decodePtrInit;","map":{"version":3,"sources":["../src/util.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decodePtrInit = exports.pickDecoder = exports.looksLikeFragment = exports.unsetValueAtPath = exports.setValueAtPath = exports.compilePointerDereference = exports.toArrayIndexReference = exports.decodeRelativePointer = exports.encodeUriFragmentIdentifier = exports.decodeUriFragmentIdentifier = exports.encodePointer = exports.decodePointer = exports.encodePointerSegments = exports.decodePointerSegments = exports.encodeFragmentSegments = exports.decodeFragmentSegments = exports.replace = void 0;\nfunction replace(source, find, repl) {\n    let res = '';\n    let rem = source;\n    let beg = 0;\n    let end = -1;\n    while ((end = rem.indexOf(find)) > -1) {\n        res += source.substring(beg, beg + end) + repl;\n        rem = rem.substring(end + find.length, rem.length);\n        beg += end + find.length;\n    }\n    if (rem.length > 0) {\n        res += source.substring(source.length - rem.length, source.length);\n    }\n    return res;\n}\nexports.replace = replace;\nfunction decodeFragmentSegments(segments) {\n    let i = -1;\n    const len = segments.length;\n    const res = new Array(len);\n    while (++i < len) {\n        if (typeof segments[i] === 'string') {\n            res[i] = replace(replace(decodeURIComponent(segments[i]), '~1', '/'), '~0', '~');\n        }\n        else {\n            res[i] = segments[i];\n        }\n    }\n    return res;\n}\nexports.decodeFragmentSegments = decodeFragmentSegments;\nfunction encodeFragmentSegments(segments) {\n    let i = -1;\n    const len = segments.length;\n    const res = new Array(len);\n    while (++i < len) {\n        if (typeof segments[i] === 'string') {\n            res[i] = encodeURIComponent(replace(replace(segments[i], '~', '~0'), '/', '~1'));\n        }\n        else {\n            res[i] = segments[i];\n        }\n    }\n    return res;\n}\nexports.encodeFragmentSegments = encodeFragmentSegments;\nfunction decodePointerSegments(segments) {\n    let i = -1;\n    const len = segments.length;\n    const res = new Array(len);\n    while (++i < len) {\n        if (typeof segments[i] === 'string') {\n            res[i] = replace(replace(segments[i], '~1', '/'), '~0', '~');\n        }\n        else {\n            res[i] = segments[i];\n        }\n    }\n    return res;\n}\nexports.decodePointerSegments = decodePointerSegments;\nfunction encodePointerSegments(segments) {\n    let i = -1;\n    const len = segments.length;\n    const res = new Array(len);\n    while (++i < len) {\n        if (typeof segments[i] === 'string') {\n            res[i] = replace(replace(segments[i], '~', '~0'), '/', '~1');\n        }\n        else {\n            res[i] = segments[i];\n        }\n    }\n    return res;\n}\nexports.encodePointerSegments = encodePointerSegments;\nfunction decodePointer(ptr) {\n    if (typeof ptr !== 'string') {\n        throw new TypeError('Invalid type: JSON Pointers are represented as strings.');\n    }\n    if (ptr.length === 0) {\n        return [];\n    }\n    if (ptr[0] !== '/') {\n        throw new ReferenceError('Invalid JSON Pointer syntax. Non-empty pointer must begin with a solidus `/`.');\n    }\n    return decodePointerSegments(ptr.substring(1).split('/'));\n}\nexports.decodePointer = decodePointer;\nfunction encodePointer(path) {\n    if (!path || (path && !Array.isArray(path))) {\n        throw new TypeError('Invalid type: path must be an array of segments.');\n    }\n    if (path.length === 0) {\n        return '';\n    }\n    return '/'.concat(encodePointerSegments(path).join('/'));\n}\nexports.encodePointer = encodePointer;\nfunction decodeUriFragmentIdentifier(ptr) {\n    if (typeof ptr !== 'string') {\n        throw new TypeError('Invalid type: JSON Pointers are represented as strings.');\n    }\n    if (ptr.length === 0 || ptr[0] !== '#') {\n        throw new ReferenceError('Invalid JSON Pointer syntax; URI fragment identifiers must begin with a hash.');\n    }\n    if (ptr.length === 1) {\n        return [];\n    }\n    if (ptr[1] !== '/') {\n        throw new ReferenceError('Invalid JSON Pointer syntax.');\n    }\n    return decodeFragmentSegments(ptr.substring(2).split('/'));\n}\nexports.decodeUriFragmentIdentifier = decodeUriFragmentIdentifier;\nfunction encodeUriFragmentIdentifier(path) {\n    if (!path || (path && !Array.isArray(path))) {\n        throw new TypeError('Invalid type: path must be an array of segments.');\n    }\n    if (path.length === 0) {\n        return '#';\n    }\n    return '#/'.concat(encodeFragmentSegments(path).join('/'));\n}\nexports.encodeUriFragmentIdentifier = encodeUriFragmentIdentifier;\nconst InvalidRelativePointerError = 'Invalid Relative JSON Pointer syntax. Relative pointer must begin with a non-negative integer, followed by either the number sign (#), or a JSON Pointer.';\nfunction decodeRelativePointer(ptr) {\n    if (typeof ptr !== 'string') {\n        throw new TypeError('Invalid type: Relative JSON Pointers are represented as strings.');\n    }\n    if (ptr.length === 0) {\n        throw new ReferenceError(InvalidRelativePointerError);\n    }\n    const segments = ptr.split('/');\n    let first = segments[0];\n    if (first[first.length - 1] == '#') {\n        if (segments.length > 1) {\n            throw new ReferenceError(InvalidRelativePointerError);\n        }\n        first = first.substr(0, first.length - 1);\n    }\n    let i = -1;\n    const len = first.length;\n    while (++i < len) {\n        if (first[i] < '0' || first[i] > '9') {\n            throw new ReferenceError(InvalidRelativePointerError);\n        }\n    }\n    const path = decodePointerSegments(segments.slice(1));\n    path.unshift(segments[0]);\n    return path;\n}\nexports.decodeRelativePointer = decodeRelativePointer;\nfunction toArrayIndexReference(arr, idx) {\n    if (typeof idx === 'number')\n        return idx;\n    const len = idx.length;\n    if (!len)\n        return -1;\n    let cursor = 0;\n    if (len === 1 && idx[0] === '-') {\n        if (!Array.isArray(arr)) {\n            return 0;\n        }\n        return arr.length;\n    }\n    while (++cursor < len) {\n        if (idx[cursor] < '0' || idx[cursor] > '9') {\n            return -1;\n        }\n    }\n    return parseInt(idx, 10);\n}\nexports.toArrayIndexReference = toArrayIndexReference;\nfunction compilePointerDereference(path) {\n    let body = \"if (typeof(it) !== 'undefined'\";\n    if (path.length === 0) {\n        return (it) => it;\n    }\n    body = path.reduce((body, _, i) => {\n        return (body +\n            \"\\n\\t&& it !== null && typeof((it = it['\" +\n            replace(replace(path[i] + '', '\\\\', '\\\\\\\\'), \"'\", \"\\\\'\") +\n            \"'])) !== 'undefined'\");\n    }, \"if (typeof(it) !== 'undefined'\");\n    body = body + ') {\\n\\treturn it;\\n }';\n    return new Function('it', body);\n}\nexports.compilePointerDereference = compilePointerDereference;\nfunction setValueAtPath(target, val, path, force = false) {\n    if (path.length === 0) {\n        throw new Error('Cannot set the root object; assign it directly.');\n    }\n    if (typeof target === 'undefined') {\n        throw new TypeError('Cannot set values on undefined');\n    }\n    let it = target;\n    const len = path.length;\n    const end = path.length - 1;\n    let step;\n    let cursor = -1;\n    let rem;\n    let p;\n    while (++cursor < len) {\n        step = path[cursor];\n        if (step === '__proto__' ||\n            step === 'constructor' ||\n            step === 'prototype') {\n            throw new Error('Attempted prototype pollution disallowed.');\n        }\n        if (Array.isArray(it)) {\n            if (step === '-' && cursor === end) {\n                it.push(val);\n                return undefined;\n            }\n            p = toArrayIndexReference(it, step);\n            if (it.length > p) {\n                if (cursor === end) {\n                    rem = it[p];\n                    it[p] = val;\n                    break;\n                }\n                it = it[p];\n            }\n            else if (cursor === end && p === it.length) {\n                if (force) {\n                    it.push(val);\n                    return undefined;\n                }\n            }\n            else if (force) {\n                it = it[p] = cursor === end ? val : {};\n            }\n        }\n        else {\n            if (typeof it[step] === 'undefined') {\n                if (force) {\n                    if (cursor === end) {\n                        it[step] = val;\n                        return undefined;\n                    }\n                    if (toArrayIndexReference(it[step], path[cursor + 1]) !== -1) {\n                        it = it[step] = [];\n                        continue;\n                    }\n                    it = it[step] = {};\n                    continue;\n                }\n                return undefined;\n            }\n            if (cursor === end) {\n                rem = it[step];\n                it[step] = val;\n                break;\n            }\n            it = it[step];\n        }\n    }\n    return rem;\n}\nexports.setValueAtPath = setValueAtPath;\nfunction unsetValueAtPath(target, path) {\n    if (path.length === 0) {\n        throw new Error('Cannot unset the root object; assign it directly.');\n    }\n    if (typeof target === 'undefined') {\n        throw new TypeError('Cannot unset values on undefined');\n    }\n    let it = target;\n    const len = path.length;\n    const end = path.length - 1;\n    let step;\n    let cursor = -1;\n    let rem;\n    let p;\n    while (++cursor < len) {\n        step = path[cursor];\n        if (Array.isArray(it)) {\n            p = toArrayIndexReference(it, step);\n            if (p >= it.length)\n                return undefined;\n            if (cursor === end) {\n                rem = it[p];\n                delete it[p];\n                break;\n            }\n            it = it[p];\n        }\n        else {\n            if (typeof it[step] === 'undefined') {\n                return undefined;\n            }\n            if (cursor === end) {\n                rem = it[step];\n                delete it[step];\n                break;\n            }\n            it = it[step];\n        }\n    }\n    return rem;\n}\nexports.unsetValueAtPath = unsetValueAtPath;\nfunction looksLikeFragment(ptr) {\n    return (ptr === null || ptr === void 0 ? void 0 : ptr.length) > 0 && ptr[0] === '#';\n}\nexports.looksLikeFragment = looksLikeFragment;\nfunction pickDecoder(ptr) {\n    return looksLikeFragment(ptr) ? decodeUriFragmentIdentifier : decodePointer;\n}\nexports.pickDecoder = pickDecoder;\nfunction decodePtrInit(ptr) {\n    return Array.isArray(ptr)\n        ? ptr.slice(0)\n        : pickDecoder(ptr)(ptr);\n}\nexports.decodePtrInit = decodePtrInit;\n//# sourceMappingURL=util.js.map"]},"metadata":{},"sourceType":"script"}