{"ast":null,"code":"\"use strict\";\n\nconst _ = require(\"lodash\");\n\nconst archiver = require(\"archiver\");\n\nconst filesize = require(\"filesize\");\n\nconst fs = require(\"fs\");\n\nconst path = require(\"path\");\n\nconst tar = require(\"tar\");\n\nconst tmp = require(\"tmp\");\n\nconst {\n  listFiles\n} = require(\"./listFiles\");\n\nconst {\n  FirebaseError\n} = require(\"./error\");\n\nconst fsAsync = require(\"./fsAsync\");\n\nconst {\n  logger\n} = require(\"./logger\");\n\nconst utils = require(\"./utils\");\n\nconst archiveDirectory = (sourceDirectory, options) => {\n  options = options || {};\n  let postfix = \".tar.gz\";\n\n  if (options.type === \"zip\") {\n    postfix = \".zip\";\n  }\n\n  const tempFile = tmp.fileSync({\n    prefix: \"firebase-archive-\",\n    postfix\n  });\n\n  if (!options.ignore) {\n    options.ignore = [];\n  }\n\n  let makeArchive;\n\n  if (options.type === \"zip\") {\n    makeArchive = _zipDirectory(sourceDirectory, tempFile, options);\n  } else {\n    makeArchive = _tarDirectory(sourceDirectory, tempFile, options);\n  }\n\n  return makeArchive.then(archive => {\n    logger.debug(`Archived ${filesize(archive.size)} in ${sourceDirectory}.`);\n    return archive;\n  }).catch(err => {\n    if (err instanceof FirebaseError) {\n      throw err;\n    }\n\n    return utils.reject(\"Failed to create archive.\", {\n      original: err\n    });\n  });\n};\n\nconst _tarDirectory = (sourceDirectory, tempFile, options) => {\n  const allFiles = listFiles(sourceDirectory, options.ignore);\n\n  try {\n    fs.statSync(sourceDirectory);\n  } catch (err) {\n    if (err.code === \"ENOENT\") {\n      return utils.reject(`Could not read directory \"${sourceDirectory}\"`);\n    }\n\n    throw err;\n  }\n\n  if (!allFiles.length) {\n    return utils.reject(`Cannot create a tar archive with 0 files from directory \"${sourceDirectory}\"`);\n  }\n\n  return tar.create({\n    gzip: true,\n    file: tempFile.name,\n    cwd: sourceDirectory,\n    follow: true,\n    noDirRecurse: true,\n    portable: true\n  }, allFiles).then(() => {\n    const stats = fs.statSync(tempFile.name);\n    return {\n      file: tempFile.name,\n      stream: fs.createReadStream(tempFile.name),\n      manifest: allFiles,\n      size: stats.size,\n      source: sourceDirectory\n    };\n  });\n};\n\nconst _zipDirectory = (sourceDirectory, tempFile, options) => {\n  const archiveFileStream = fs.createWriteStream(tempFile.name, {\n    flags: \"w\",\n    encoding: \"binary\"\n  });\n  const archive = archiver(\"zip\");\n\n  const archiveDone = _pipeAsync(archive, archiveFileStream);\n\n  const allFiles = [];\n  return fsAsync.readdirRecursive({\n    path: sourceDirectory,\n    ignore: options.ignore\n  }).catch(err => {\n    if (err.code === \"ENOENT\") {\n      return utils.reject(`Could not read directory \"${sourceDirectory}\"`, {\n        original: err\n      });\n    }\n\n    throw err;\n  }).then(function (files) {\n    _.forEach(files, function (file) {\n      const name = path.relative(sourceDirectory, file.name);\n      allFiles.push(name);\n      archive.file(file.name, {\n        name,\n        mode: file.mode\n      });\n    });\n\n    archive.finalize();\n    return archiveDone;\n  }).then(() => {\n    const stats = fs.statSync(tempFile.name);\n    return {\n      file: tempFile.name,\n      stream: fs.createReadStream(tempFile.name),\n      manifest: allFiles,\n      size: stats.size,\n      source: sourceDirectory\n    };\n  });\n};\n\nconst _pipeAsync = function (from, to) {\n  return new Promise(function (resolve, reject) {\n    to.on(\"finish\", resolve);\n    to.on(\"error\", reject);\n    from.pipe(to);\n  });\n};\n\nmodule.exports = {\n  archiveDirectory\n};","map":{"version":3,"sources":["/home/dev/Documentos/Projects/github-clone/node_modules/firebase-tools/lib/archiveDirectory.js"],"names":["_","require","archiver","filesize","fs","path","tar","tmp","listFiles","FirebaseError","fsAsync","logger","utils","archiveDirectory","sourceDirectory","options","postfix","type","tempFile","fileSync","prefix","ignore","makeArchive","_zipDirectory","_tarDirectory","then","archive","debug","size","catch","err","reject","original","allFiles","statSync","code","length","create","gzip","file","name","cwd","follow","noDirRecurse","portable","stats","stream","createReadStream","manifest","source","archiveFileStream","createWriteStream","flags","encoding","archiveDone","_pipeAsync","readdirRecursive","files","forEach","relative","push","mode","finalize","from","to","Promise","resolve","on","pipe","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\nconst _ = require(\"lodash\");\nconst archiver = require(\"archiver\");\nconst filesize = require(\"filesize\");\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst tar = require(\"tar\");\nconst tmp = require(\"tmp\");\nconst { listFiles } = require(\"./listFiles\");\nconst { FirebaseError } = require(\"./error\");\nconst fsAsync = require(\"./fsAsync\");\nconst { logger } = require(\"./logger\");\nconst utils = require(\"./utils\");\nconst archiveDirectory = (sourceDirectory, options) => {\n    options = options || {};\n    let postfix = \".tar.gz\";\n    if (options.type === \"zip\") {\n        postfix = \".zip\";\n    }\n    const tempFile = tmp.fileSync({\n        prefix: \"firebase-archive-\",\n        postfix,\n    });\n    if (!options.ignore) {\n        options.ignore = [];\n    }\n    let makeArchive;\n    if (options.type === \"zip\") {\n        makeArchive = _zipDirectory(sourceDirectory, tempFile, options);\n    }\n    else {\n        makeArchive = _tarDirectory(sourceDirectory, tempFile, options);\n    }\n    return makeArchive\n        .then((archive) => {\n        logger.debug(`Archived ${filesize(archive.size)} in ${sourceDirectory}.`);\n        return archive;\n    })\n        .catch((err) => {\n        if (err instanceof FirebaseError) {\n            throw err;\n        }\n        return utils.reject(\"Failed to create archive.\", {\n            original: err,\n        });\n    });\n};\nconst _tarDirectory = (sourceDirectory, tempFile, options) => {\n    const allFiles = listFiles(sourceDirectory, options.ignore);\n    try {\n        fs.statSync(sourceDirectory);\n    }\n    catch (err) {\n        if (err.code === \"ENOENT\") {\n            return utils.reject(`Could not read directory \"${sourceDirectory}\"`);\n        }\n        throw err;\n    }\n    if (!allFiles.length) {\n        return utils.reject(`Cannot create a tar archive with 0 files from directory \"${sourceDirectory}\"`);\n    }\n    return tar\n        .create({\n        gzip: true,\n        file: tempFile.name,\n        cwd: sourceDirectory,\n        follow: true,\n        noDirRecurse: true,\n        portable: true,\n    }, allFiles)\n        .then(() => {\n        const stats = fs.statSync(tempFile.name);\n        return {\n            file: tempFile.name,\n            stream: fs.createReadStream(tempFile.name),\n            manifest: allFiles,\n            size: stats.size,\n            source: sourceDirectory,\n        };\n    });\n};\nconst _zipDirectory = (sourceDirectory, tempFile, options) => {\n    const archiveFileStream = fs.createWriteStream(tempFile.name, {\n        flags: \"w\",\n        encoding: \"binary\",\n    });\n    const archive = archiver(\"zip\");\n    const archiveDone = _pipeAsync(archive, archiveFileStream);\n    const allFiles = [];\n    return fsAsync\n        .readdirRecursive({ path: sourceDirectory, ignore: options.ignore })\n        .catch((err) => {\n        if (err.code === \"ENOENT\") {\n            return utils.reject(`Could not read directory \"${sourceDirectory}\"`, { original: err });\n        }\n        throw err;\n    })\n        .then(function (files) {\n        _.forEach(files, function (file) {\n            const name = path.relative(sourceDirectory, file.name);\n            allFiles.push(name);\n            archive.file(file.name, {\n                name,\n                mode: file.mode,\n            });\n        });\n        archive.finalize();\n        return archiveDone;\n    })\n        .then(() => {\n        const stats = fs.statSync(tempFile.name);\n        return {\n            file: tempFile.name,\n            stream: fs.createReadStream(tempFile.name),\n            manifest: allFiles,\n            size: stats.size,\n            source: sourceDirectory,\n        };\n    });\n};\nconst _pipeAsync = function (from, to) {\n    return new Promise(function (resolve, reject) {\n        to.on(\"finish\", resolve);\n        to.on(\"error\", reject);\n        from.pipe(to);\n    });\n};\nmodule.exports = {\n    archiveDirectory,\n};\n"]},"metadata":{},"sourceType":"script"}