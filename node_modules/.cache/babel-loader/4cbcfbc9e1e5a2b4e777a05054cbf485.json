{"ast":null,"code":"'use strict';\n\nvar through = require('through2');\n\nmodule.exports = function (opts, cb) {\n  if (typeof opts === 'function') {\n    cb = opts;\n    opts = {};\n  }\n\n  opts = opts || {};\n  if (typeof cb === 'function') opts.cb = cb;\n  opts.delimiter = opts.delimiter || ',';\n  opts.newline = opts.newline || '\\n';\n  opts.quote = opts.quote || '\"';\n  opts.empty = opts.hasOwnProperty('empty') ? opts.empty : '';\n  opts.objectMode = opts.objectMode || false;\n  opts.hasColumns = opts.columns || false; // state\n\n  var state = {\n    body: [],\n    lineNo: 0,\n    _isQuoted: false,\n    _prev: [],\n    _newlineDetected: false,\n    _line: [],\n    _field: '',\n    _columns: []\n  };\n  return createParser(opts, state).on('error', function (err) {\n    if (opts.cb) cb(err);\n  });\n};\n\nfunction createParser(opts, state) {\n  function emitLine(parser) {\n    state._line.push(state._field);\n\n    var line = {};\n\n    if (opts.hasColumns) {\n      if (state.lineNo === 0) {\n        state._columns = state._line;\n        state.lineNo += 1;\n        reset();\n        return;\n      }\n\n      state._columns.forEach(function (column, i) {\n        line[column] = state._line[i];\n      });\n\n      state._line = line;\n    } // buffer\n\n\n    if (opts.cb) state.body.push(state._line); // emit the parsed line as an array if in object mode\n    // or as a stringified array (default)\n\n    if (opts.objectMode) {\n      parser.push(state._line);\n    } else {\n      parser.push(JSON.stringify(state._line) + '\\n');\n    }\n\n    state.lineNo += 1; // reset state\n\n    reset();\n  }\n\n  function queue(char) {\n    state._prev.unshift(char);\n\n    while (state._prev.length > 3) state._prev.pop();\n  }\n\n  function reset() {\n    state._prev = [];\n    state._field = '';\n    state._line = [];\n    state._isQuoted = false;\n  }\n\n  return through(opts, function parse(chunk, enc, cb) {\n    var data = chunk.toString();\n    var c;\n\n    for (var i = 0; i < data.length; i++) {\n      c = data.charAt(i); // we have a line break\n\n      if (!state._isQuoted && state._newlineDetected) {\n        state._newlineDetected = false;\n        emitLine(this); // crlf\n\n        if (c === opts.newline[1]) {\n          queue(c);\n          continue;\n        }\n      } // are the last two chars quotes?\n\n\n      if (state._isQuoted && state._prev[0] === opts.quote && state._prev[1] === opts.quote) {\n        state._field += opts.quote;\n        state._prev = [];\n      } // skip over quote\n\n\n      if (c === opts.quote) {\n        queue(c);\n        continue;\n      } // once we hit a regular char, check if quoting applies\n      // xx\"[c]\n\n\n      if (c !== opts.quote && state._prev[0] === opts.quote && state._prev[1] !== opts.quote) {\n        state._isQuoted = !state._isQuoted;\n      } // \"\"\"[c]\n\n\n      if (c !== opts.quote && state._prev[0] === opts.quote && state._prev[1] === opts.quote && state._prev[2] === opts.quote) {\n        state._isQuoted = !state._isQuoted;\n        state._field += opts.quote;\n      } // x\"\"[c]\n\n\n      if (state._field && c !== opts.quote && state._prev[0] === opts.quote && state._prev[1] === opts.quote && state._prev[2] !== opts.quote) {\n        state._field += opts.quote;\n      } // delimiter\n\n\n      if (!state._isQuoted && c === opts.delimiter) {\n        if (state._field === '') state._field = opts.empty;\n\n        state._line.push(state._field);\n\n        state._field = '';\n        queue(c);\n        continue;\n      } // newline\n\n\n      if (!state._isQuoted && (c === opts.newline || c === opts.newline[0])) {\n        state._newlineDetected = true;\n        queue(c);\n        continue;\n      }\n\n      queue(c); // append current char to _field string\n\n      state._field += c;\n    }\n\n    cb();\n  }, function flush(fn) {\n    // flush last line\n    try {\n      if (state._line.length || state._field) emitLine(this);\n      if (opts.cb) opts.cb(null, state.body);\n      fn();\n    } catch (err) {\n      fn(err);\n    }\n  });\n}","map":{"version":3,"sources":["/home/dev/Documentos/Projects/github-clone/node_modules/csv-streamify/csv-streamify.js"],"names":["through","require","module","exports","opts","cb","delimiter","newline","quote","empty","hasOwnProperty","objectMode","hasColumns","columns","state","body","lineNo","_isQuoted","_prev","_newlineDetected","_line","_field","_columns","createParser","on","err","emitLine","parser","push","line","reset","forEach","column","i","JSON","stringify","queue","char","unshift","length","pop","parse","chunk","enc","data","toString","c","charAt","flush","fn"],"mappings":"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","sourcesContent":["'use strict'\n\nvar through = require('through2')\n\nmodule.exports = function (opts, cb) {\n  if (typeof opts === 'function') {\n    cb = opts\n    opts = {}\n  }\n  opts = opts || {}\n  if (typeof cb === 'function') opts.cb = cb\n\n  opts.delimiter = opts.delimiter || ','\n  opts.newline = opts.newline || '\\n'\n  opts.quote = opts.quote || '\"'\n  opts.empty = opts.hasOwnProperty('empty') ? opts.empty : ''\n  opts.objectMode = opts.objectMode || false\n  opts.hasColumns = opts.columns || false\n\n  // state\n  var state = {\n    body: [],\n    lineNo: 0,\n    _isQuoted: false,\n    _prev: [],\n    _newlineDetected: false,\n    _line: [],\n    _field: '',\n    _columns: []\n  }\n\n  return createParser(opts, state).on('error', function (err) {\n    if (opts.cb) cb(err)\n  })\n}\n\nfunction createParser (opts, state) {\n  function emitLine (parser) {\n    state._line.push(state._field)\n    var line = {}\n\n    if (opts.hasColumns) {\n      if (state.lineNo === 0) {\n        state._columns = state._line\n        state.lineNo += 1\n        reset()\n        return\n      }\n      state._columns.forEach(function (column, i) {\n        line[column] = state._line[i]\n      })\n      state._line = line\n    }\n\n    // buffer\n    if (opts.cb) state.body.push(state._line)\n\n    // emit the parsed line as an array if in object mode\n    // or as a stringified array (default)\n    if (opts.objectMode) {\n      parser.push(state._line)\n    } else {\n      parser.push(JSON.stringify(state._line) + '\\n')\n    }\n\n    state.lineNo += 1\n\n    // reset state\n    reset()\n  }\n\n  function queue (char) {\n    state._prev.unshift(char)\n    while (state._prev.length > 3) state._prev.pop()\n  }\n\n  function reset () {\n    state._prev = []\n    state._field = ''\n    state._line = []\n    state._isQuoted = false\n  }\n\n  return through(opts, function parse (chunk, enc, cb) {\n    var data = chunk.toString()\n    var c\n\n    for (var i = 0; i < data.length; i++) {\n      c = data.charAt(i)\n\n      // we have a line break\n      if (!state._isQuoted && state._newlineDetected) {\n        state._newlineDetected = false\n        emitLine(this)\n        // crlf\n        if (c === opts.newline[1]) {\n          queue(c)\n          continue\n        }\n      }\n\n      // are the last two chars quotes?\n      if (state._isQuoted && state._prev[0] === opts.quote && state._prev[1] === opts.quote) {\n        state._field += opts.quote\n        state._prev = []\n      }\n\n      // skip over quote\n      if (c === opts.quote) {\n        queue(c)\n        continue\n      }\n\n      // once we hit a regular char, check if quoting applies\n\n      // xx\"[c]\n      if (c !== opts.quote && state._prev[0] === opts.quote &&\n          state._prev[1] !== opts.quote) {\n        state._isQuoted = !state._isQuoted\n      }\n\n      // \"\"\"[c]\n      if (c !== opts.quote && state._prev[0] === opts.quote &&\n          state._prev[1] === opts.quote && state._prev[2] === opts.quote) {\n        state._isQuoted = !state._isQuoted\n        state._field += opts.quote\n      }\n\n      // x\"\"[c]\n      if (state._field && c !== opts.quote &&\n          state._prev[0] === opts.quote &&\n          state._prev[1] === opts.quote &&\n          state._prev[2] !== opts.quote) {\n        state._field += opts.quote\n      }\n\n      // delimiter\n      if (!state._isQuoted && c === opts.delimiter) {\n        if (state._field === '') state._field = opts.empty\n        state._line.push(state._field)\n        state._field = ''\n        queue(c)\n        continue\n      }\n\n      // newline\n      if (!state._isQuoted && (c === opts.newline || c === opts.newline[0])) {\n        state._newlineDetected = true\n        queue(c)\n        continue\n      }\n\n      queue(c)\n      // append current char to _field string\n      state._field += c\n    }\n    cb()\n  }, function flush (fn) {\n    // flush last line\n    try {\n      if (state._line.length || state._field) emitLine(this)\n      if (opts.cb) opts.cb(null, state.body)\n      fn()\n    } catch (err) {\n      fn(err)\n    }\n  })\n}\n"]},"metadata":{},"sourceType":"script"}