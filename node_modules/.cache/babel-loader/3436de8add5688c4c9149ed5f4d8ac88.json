{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __exportStar = this && this.__exportStar || function (m, exports) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseQueryParameters = exports.parseParameterGroup = exports.generateParser = void 0;\n\nconst lodash_1 = __importDefault(require(\"lodash\"));\n\nconst querystring_1 = __importDefault(require(\"querystring\"));\n\nconst qs_1 = __importDefault(require(\"qs\"));\n\nconst errors_1 = require(\"../../errors\");\n\nconst delimitedParser_1 = require(\"./delimitedParser\");\n\nconst structuredParser_1 = require(\"./structuredParser\");\n\nconst simpleStringParser_1 = require(\"./simpleStringParser\");\n\nconst pathStyleParser_1 = require(\"./pathStyleParser\");\n\n__exportStar(require(\"./types\"), exports);\n\nfunction isMediaTypeParameterDescriptor(descriptor) {\n  return descriptor && descriptor.contentType && descriptor.parser;\n}\n\nfunction generateParser(parameterDescriptor) {\n  let answer;\n\n  if (isMediaTypeParameterDescriptor(parameterDescriptor)) {\n    answer = generateMediaTypeParser(parameterDescriptor);\n  } else {\n    answer = generateStyleParser(parameterDescriptor);\n  }\n\n  return answer;\n}\n\nexports.generateParser = generateParser;\n\nfunction generateMediaTypeParser(parameterDescriptor) {\n  // request and response are here for application/x-www-form-urlencoded.\n  let answer = (location, values) => {\n    try {\n      let value = values[location.name];\n\n      if (value === undefined || value === null) {\n        return value;\n      }\n\n      if (parameterDescriptor.uriEncoded) {\n        if (Array.isArray(value)) {\n          value = value.map(decodeURIComponent);\n        } else {\n          value = decodeURIComponent(value);\n        }\n      }\n\n      if (Array.isArray(value)) {\n        return value.map(v => parameterDescriptor.parser.parseString(v));\n      } else {\n        return parameterDescriptor.parser.parseString(value);\n      }\n    } catch (err) {\n      throw new errors_1.ValidationError({\n        message: `Error parsing parameter ${location.name} of ` + `type ${parameterDescriptor.contentType}: ${err.message}`,\n        location\n      });\n    }\n  };\n\n  if (parameterDescriptor.schema && parameterDescriptor.schema.default) {\n    answer = setDefault(answer, parameterDescriptor.schema.default);\n  }\n\n  return answer;\n}\n\nfunction generateStyleParser(descriptor) {\n  const {\n    schema,\n    explode\n  } = descriptor;\n  let answer;\n\n  switch (descriptor.style) {\n    case 'simple':\n      answer = toStructuredParser(simpleStringParser_1.getSimpleStringParser(schema, explode));\n      break;\n\n    case 'form':\n      answer = structuredParser_1.generateStructuredParser(schema, explode);\n      break;\n\n    case 'matrix':\n      answer = pathStyleParser_1.generatePathStyleParser(schema, explode);\n      break;\n\n    case 'spaceDelimited':\n      answer = delimitedParser_1.spaceDelimitedParser;\n      break;\n\n    case 'pipeDelimited':\n      answer = delimitedParser_1.pipeDelimitedParser;\n      break;\n\n    case 'deepObject':\n      answer = deepObjectParser;\n      break;\n\n    default:\n      throw new Error(`Don't know how to parse parameters with style ${descriptor.style}`);\n  }\n\n  if ('default' in descriptor.schema) {\n    answer = setDefault(answer, descriptor.schema.default);\n  }\n\n  return answer;\n}\n\nfunction setDefault(parser, def) {\n  return function addDefault(location, rawParamValues, rawValue, parserContext) {\n    const answer = parser(location, rawParamValues, rawValue, parserContext);\n\n    if (answer !== undefined) {\n      return answer;\n    } else {\n      return lodash_1.default.cloneDeep(def);\n    }\n  };\n}\n\nfunction toStructuredParser(parser) {\n  return (location, rawParamValues) => {\n    const value = rawParamValues[location.name];\n\n    if (Array.isArray(value)) {\n      return value.map(parser);\n    } else {\n      return parser(value);\n    }\n  };\n}\n\nfunction deepObjectParser(location, _rawParamValues, rawValue, parserContext) {\n  if (!parserContext.qsParsed) {\n    parserContext.qsParsed = qs_1.default.parse(rawValue);\n  }\n\n  const qsParsed = parserContext.qsParsed;\n  return qsParsed[location.name];\n}\n\nfunction _parseParameterGroup(params, rawValues, rawQueryString) {\n  const parserContext = {};\n  return params.reduce((result, {\n    location,\n    parser\n  }) => {\n    result[location.name] = parser(location, rawValues, rawQueryString, parserContext);\n    return result;\n  }, {});\n}\n\nfunction parseParameterGroup(params, rawValues) {\n  return _parseParameterGroup(params, rawValues, '');\n}\n\nexports.parseParameterGroup = parseParameterGroup;\n\nfunction parseQueryParameters(params, query) {\n  const rawValues = querystring_1.default.parse(query || '', '&', '=', {\n    decodeURIComponent: val => val\n  });\n  return _parseParameterGroup(params, rawValues, query || '');\n}\n\nexports.parseQueryParameters = parseQueryParameters;","map":{"version":3,"sources":["../../../src/oas3/parameterParsers/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseQueryParameters = exports.parseParameterGroup = exports.generateParser = void 0;\nconst lodash_1 = __importDefault(require(\"lodash\"));\nconst querystring_1 = __importDefault(require(\"querystring\"));\nconst qs_1 = __importDefault(require(\"qs\"));\nconst errors_1 = require(\"../../errors\");\nconst delimitedParser_1 = require(\"./delimitedParser\");\nconst structuredParser_1 = require(\"./structuredParser\");\nconst simpleStringParser_1 = require(\"./simpleStringParser\");\nconst pathStyleParser_1 = require(\"./pathStyleParser\");\n__exportStar(require(\"./types\"), exports);\nfunction isMediaTypeParameterDescriptor(descriptor) {\n    return descriptor && descriptor.contentType && descriptor.parser;\n}\nfunction generateParser(parameterDescriptor) {\n    let answer;\n    if (isMediaTypeParameterDescriptor(parameterDescriptor)) {\n        answer = generateMediaTypeParser(parameterDescriptor);\n    }\n    else {\n        answer = generateStyleParser(parameterDescriptor);\n    }\n    return answer;\n}\nexports.generateParser = generateParser;\nfunction generateMediaTypeParser(parameterDescriptor) {\n    // request and response are here for application/x-www-form-urlencoded.\n    let answer = (location, values) => {\n        try {\n            let value = values[location.name];\n            if (value === undefined || value === null) {\n                return value;\n            }\n            if (parameterDescriptor.uriEncoded) {\n                if (Array.isArray(value)) {\n                    value = value.map(decodeURIComponent);\n                }\n                else {\n                    value = decodeURIComponent(value);\n                }\n            }\n            if (Array.isArray(value)) {\n                return value.map((v) => parameterDescriptor.parser.parseString(v));\n            }\n            else {\n                return parameterDescriptor.parser.parseString(value);\n            }\n        }\n        catch (err) {\n            throw new errors_1.ValidationError({\n                message: `Error parsing parameter ${location.name} of ` +\n                    `type ${parameterDescriptor.contentType}: ${err.message}`,\n                location,\n            });\n        }\n    };\n    if (parameterDescriptor.schema && parameterDescriptor.schema.default) {\n        answer = setDefault(answer, parameterDescriptor.schema.default);\n    }\n    return answer;\n}\nfunction generateStyleParser(descriptor) {\n    const { schema, explode } = descriptor;\n    let answer;\n    switch (descriptor.style) {\n        case 'simple':\n            answer = toStructuredParser(simpleStringParser_1.getSimpleStringParser(schema, explode));\n            break;\n        case 'form':\n            answer = structuredParser_1.generateStructuredParser(schema, explode);\n            break;\n        case 'matrix':\n            answer = pathStyleParser_1.generatePathStyleParser(schema, explode);\n            break;\n        case 'spaceDelimited':\n            answer = delimitedParser_1.spaceDelimitedParser;\n            break;\n        case 'pipeDelimited':\n            answer = delimitedParser_1.pipeDelimitedParser;\n            break;\n        case 'deepObject':\n            answer = deepObjectParser;\n            break;\n        default:\n            throw new Error(`Don't know how to parse parameters with style ${descriptor.style}`);\n    }\n    if ('default' in descriptor.schema) {\n        answer = setDefault(answer, descriptor.schema.default);\n    }\n    return answer;\n}\nfunction setDefault(parser, def) {\n    return function addDefault(location, rawParamValues, rawValue, parserContext) {\n        const answer = parser(location, rawParamValues, rawValue, parserContext);\n        if (answer !== undefined) {\n            return answer;\n        }\n        else {\n            return lodash_1.default.cloneDeep(def);\n        }\n    };\n}\nfunction toStructuredParser(parser) {\n    return (location, rawParamValues) => {\n        const value = rawParamValues[location.name];\n        if (Array.isArray(value)) {\n            return value.map(parser);\n        }\n        else {\n            return parser(value);\n        }\n    };\n}\nfunction deepObjectParser(location, _rawParamValues, rawValue, parserContext) {\n    if (!parserContext.qsParsed) {\n        parserContext.qsParsed = qs_1.default.parse(rawValue);\n    }\n    const qsParsed = parserContext.qsParsed;\n    return qsParsed[location.name];\n}\nfunction _parseParameterGroup(params, rawValues, rawQueryString) {\n    const parserContext = {};\n    return params.reduce((result, { location, parser }) => {\n        result[location.name] = parser(location, rawValues, rawQueryString, parserContext);\n        return result;\n    }, {});\n}\nfunction parseParameterGroup(params, rawValues) {\n    return _parseParameterGroup(params, rawValues, '');\n}\nexports.parseParameterGroup = parseParameterGroup;\nfunction parseQueryParameters(params, query) {\n    const rawValues = querystring_1.default.parse(query || '', '&', '=', {\n        decodeURIComponent: (val) => val,\n    });\n    return _parseParameterGroup(params, rawValues, query || '');\n}\nexports.parseQueryParameters = parseQueryParameters;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}