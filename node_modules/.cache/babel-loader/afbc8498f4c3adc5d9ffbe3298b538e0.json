{"ast":null,"code":"module.exports = readdirGlob;\n\nconst fs = require('fs');\n\nconst {\n  EventEmitter\n} = require('events');\n\nconst {\n  Minimatch\n} = require('minimatch');\n\nconst {\n  resolve\n} = require('path');\n\nfunction readdir(dir, strict) {\n  return new Promise((resolve, reject) => {\n    fs.readdir(dir, {\n      withFileTypes: true\n    }, (err, files) => {\n      if (err) {\n        switch (err.code) {\n          case 'ENOTDIR':\n            // Not a directory\n            if (strict) {\n              reject(err);\n            } else {\n              resolve([]);\n            }\n\n            break;\n\n          case 'ENOTSUP': // Operation not supported\n\n          case 'ENOENT': // No such file or directory\n\n          case 'ENAMETOOLONG': // Filename too long\n\n          case 'UNKNOWN':\n            resolve([]);\n            break;\n\n          case 'ELOOP': // Too many levels of symbolic links\n\n          default:\n            reject(err);\n            break;\n        }\n      } else {\n        resolve(files);\n      }\n    });\n  });\n}\n\nfunction stat(file, followSyslinks) {\n  return new Promise((resolve, reject) => {\n    const statFunc = followSyslinks ? fs.stat : fs.lstat;\n    statFunc(file, (err, stats) => {\n      if (err) {\n        switch (err.code) {\n          case 'ENOENT':\n            if (followSyslinks) {\n              // Fallback to lstat to handle broken links as files\n              resolve(stat(file, false));\n            } else {\n              resolve(null);\n            }\n\n            break;\n\n          default:\n            resolve(null);\n            break;\n        }\n      } else {\n        resolve(stats);\n      }\n    });\n  });\n}\n\nasync function* exploreWalkAsync(dir, path, followSyslinks, useStat, shouldSkip, strict) {\n  let files = await readdir(path + dir, strict);\n\n  for (const file of files) {\n    let name = file.name;\n\n    if (name === undefined) {\n      // undefined file.name means the `withFileTypes` options is not supported by node\n      // we have to call the stat function to know if file is directory or not.\n      name = file;\n      useStat = true;\n    }\n\n    const filename = dir + '/' + name;\n    const relative = filename.slice(1); // Remove the leading /\n\n    const absolute = path + '/' + relative;\n    let stats = null;\n\n    if (useStat || followSyslinks) {\n      stats = await stat(absolute, followSyslinks);\n    }\n\n    if (!stats && file.name !== undefined) {\n      stats = file;\n    }\n\n    if (stats === null) {\n      stats = {\n        isDirectory: () => false\n      };\n    }\n\n    if (stats.isDirectory()) {\n      if (!shouldSkip(relative)) {\n        yield {\n          relative,\n          absolute,\n          stats\n        };\n        yield* exploreWalkAsync(filename, path, followSyslinks, useStat, shouldSkip, false);\n      }\n    } else {\n      yield {\n        relative,\n        absolute,\n        stats\n      };\n    }\n  }\n}\n\nasync function* explore(path, followSyslinks, useStat, shouldSkip) {\n  yield* exploreWalkAsync('', path, followSyslinks, useStat, shouldSkip, true);\n}\n\nfunction readOptions(options) {\n  return {\n    pattern: options.pattern,\n    dot: !!options.dot,\n    noglobstar: !!options.noglobstar,\n    matchBase: !!options.matchBase,\n    nocase: !!options.nocase,\n    ignore: options.ignore,\n    skip: options.skip,\n    follow: !!options.follow,\n    stat: !!options.stat,\n    nodir: !!options.nodir,\n    mark: !!options.mark,\n    silent: !!options.silent,\n    absolute: !!options.absolute\n  };\n}\n\nclass ReaddirGlob extends EventEmitter {\n  constructor(cwd, options, cb) {\n    super();\n\n    if (typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    this.options = readOptions(options || {});\n    this.matchers = [];\n\n    if (this.options.pattern) {\n      const matchers = Array.isArray(this.options.pattern) ? this.options.pattern : [this.options.pattern];\n      this.matchers = matchers.map(m => new Minimatch(m, {\n        dot: this.options.dot,\n        noglobstar: this.options.noglobstar,\n        matchBase: this.options.matchBase,\n        nocase: this.options.nocase\n      }));\n    }\n\n    this.ignoreMatchers = [];\n\n    if (this.options.ignore) {\n      const ignorePatterns = Array.isArray(this.options.ignore) ? this.options.ignore : [this.options.ignore];\n      this.ignoreMatchers = ignorePatterns.map(ignore => new Minimatch(ignore, {\n        dot: true\n      }));\n    }\n\n    this.skipMatchers = [];\n\n    if (this.options.skip) {\n      const skipPatterns = Array.isArray(this.options.skip) ? this.options.skip : [this.options.skip];\n      this.skipMatchers = skipPatterns.map(skip => new Minimatch(skip, {\n        dot: true\n      }));\n    }\n\n    this.iterator = explore(resolve(cwd || '.'), this.options.follow, this.options.stat, this._shouldSkipDirectory.bind(this));\n    this.paused = false;\n    this.inactive = false;\n    this.aborted = false;\n\n    if (cb) {\n      this._matches = [];\n      this.on('match', match => this._matches.push(this.options.absolute ? match.absolute : match.relative));\n      this.on('error', err => cb(err));\n      this.on('end', () => cb(null, this._matches));\n    }\n\n    setTimeout(() => this._next(), 0);\n  }\n\n  _shouldSkipDirectory(relative) {\n    //console.log(relative, this.skipMatchers.some(m => m.match(relative)));\n    return this.skipMatchers.some(m => m.match(relative));\n  }\n\n  _fileMatches(relative, isDirectory) {\n    const file = relative + (isDirectory ? '/' : '');\n    return (this.matchers.length === 0 || this.matchers.some(m => m.match(file))) && !this.ignoreMatchers.some(m => m.match(file)) && (!this.options.nodir || !isDirectory);\n  }\n\n  _next() {\n    if (!this.paused && !this.aborted) {\n      this.iterator.next().then(obj => {\n        if (!obj.done) {\n          const isDirectory = obj.value.stats.isDirectory();\n\n          if (this._fileMatches(obj.value.relative, isDirectory)) {\n            let relative = obj.value.relative;\n            let absolute = obj.value.absolute;\n\n            if (this.options.mark && isDirectory) {\n              relative += '/';\n              absolute += '/';\n            }\n\n            if (this.options.stat) {\n              this.emit('match', {\n                relative,\n                absolute,\n                stat: obj.value.stats\n              });\n            } else {\n              this.emit('match', {\n                relative,\n                absolute\n              });\n            }\n          }\n\n          this._next(this.iterator);\n        } else {\n          this.emit('end');\n        }\n      }).catch(err => {\n        this.abort();\n        this.emit('error', err);\n\n        if (!err.code && !this.options.silent) {\n          console.error(err);\n        }\n      });\n    } else {\n      this.inactive = true;\n    }\n  }\n\n  abort() {\n    this.aborted = true;\n  }\n\n  pause() {\n    this.paused = true;\n  }\n\n  resume() {\n    this.paused = false;\n\n    if (this.inactive) {\n      this.inactive = false;\n\n      this._next();\n    }\n  }\n\n}\n\nfunction readdirGlob(pattern, options, cb) {\n  return new ReaddirGlob(pattern, options, cb);\n}\n\nreaddirGlob.ReaddirGlob = ReaddirGlob;","map":{"version":3,"sources":["/home/dev/Documentos/Projects/github-clone/node_modules/readdir-glob/index.js"],"names":["module","exports","readdirGlob","fs","require","EventEmitter","Minimatch","resolve","readdir","dir","strict","Promise","reject","withFileTypes","err","files","code","stat","file","followSyslinks","statFunc","lstat","stats","exploreWalkAsync","path","useStat","shouldSkip","name","undefined","filename","relative","slice","absolute","isDirectory","explore","readOptions","options","pattern","dot","noglobstar","matchBase","nocase","ignore","skip","follow","nodir","mark","silent","ReaddirGlob","constructor","cwd","cb","matchers","Array","isArray","map","m","ignoreMatchers","ignorePatterns","skipMatchers","skipPatterns","iterator","_shouldSkipDirectory","bind","paused","inactive","aborted","_matches","on","match","push","setTimeout","_next","some","_fileMatches","length","next","then","obj","done","value","emit","catch","abort","console","error","pause","resume"],"mappings":"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","sourcesContent":["module.exports = readdirGlob;\n\nconst fs = require('fs');\nconst { EventEmitter } = require('events');\nconst { Minimatch } = require('minimatch');\nconst { resolve } = require('path');\n\nfunction readdir(dir, strict) {\n  return new Promise((resolve, reject) => {\n    fs.readdir(dir, {withFileTypes: true} ,(err, files) => {\n      if(err) {\n        switch (err.code) {\n          case 'ENOTDIR':      // Not a directory\n            if(strict) {\n              reject(err);\n            } else {\n              resolve([]);\n            }\n            break;\n          case 'ENOTSUP':      // Operation not supported\n          case 'ENOENT':       // No such file or directory\n          case 'ENAMETOOLONG': // Filename too long\n          case 'UNKNOWN':\n            resolve([]);\n            break;\n          case 'ELOOP':        // Too many levels of symbolic links\n          default:\n            reject(err);\n            break;\n        }\n      } else {\n        resolve(files);\n      }\n    });\n  });\n}\nfunction stat(file, followSyslinks) {\n  return new Promise((resolve, reject) => {\n    const statFunc = followSyslinks ? fs.stat : fs.lstat;\n    statFunc(file, (err, stats) => {\n      if(err) {\n        switch (err.code) {\n          case 'ENOENT':\n            if(followSyslinks) {\n              // Fallback to lstat to handle broken links as files\n              resolve(stat(file, false)); \n            } else {\n              resolve(null);\n            }\n            break;\n          default:\n            resolve(null);\n            break;\n        }\n      } else {\n        resolve(stats);\n      }\n    });\n  });\n}\n\nasync function* exploreWalkAsync(dir, path, followSyslinks, useStat, shouldSkip, strict) {\n  let files = await readdir(path + dir, strict);\n  for(const file of files) {\n    let name = file.name;\n    if(name === undefined) {\n      // undefined file.name means the `withFileTypes` options is not supported by node\n      // we have to call the stat function to know if file is directory or not.\n      name = file;\n      useStat = true;\n    }\n    const filename = dir + '/' + name;\n    const relative = filename.slice(1); // Remove the leading /\n    const absolute = path + '/' + relative;\n    let stats = null;\n    if(useStat || followSyslinks) {\n      stats = await stat(absolute, followSyslinks);\n    }\n    if(!stats && file.name !== undefined) {\n      stats = file;\n    }\n    if(stats === null) {\n      stats = { isDirectory: () => false };\n    }\n\n    if(stats.isDirectory()) {\n      if(!shouldSkip(relative)) {\n        yield {relative, absolute, stats};\n        yield* exploreWalkAsync(filename, path, followSyslinks, useStat, shouldSkip, false);\n      }\n    } else {\n      yield {relative, absolute, stats};\n    }\n  }\n}\nasync function* explore(path, followSyslinks, useStat, shouldSkip) {\n  yield* exploreWalkAsync('', path, followSyslinks, useStat, shouldSkip, true);\n}\n\n\nfunction readOptions(options) {\n  return {\n    pattern: options.pattern,\n    dot: !!options.dot,\n    noglobstar: !!options.noglobstar,\n    matchBase: !!options.matchBase,\n    nocase: !!options.nocase,\n    ignore: options.ignore,\n    skip: options.skip,\n\n    follow: !!options.follow,\n    stat: !!options.stat,\n    nodir: !!options.nodir,\n    mark: !!options.mark,\n    silent: !!options.silent,\n    absolute: !!options.absolute\n  };\n}\n\nclass ReaddirGlob extends EventEmitter {\n  constructor(cwd, options, cb) {\n    super();\n    if(typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    this.options = readOptions(options || {});\n  \n    this.matchers = [];\n    if(this.options.pattern) {\n      const matchers = Array.isArray(this.options.pattern) ? this.options.pattern : [this.options.pattern];\n      this.matchers = matchers.map( m =>\n        new Minimatch(m, {\n          dot: this.options.dot,\n          noglobstar:this.options.noglobstar,\n          matchBase:this.options.matchBase,\n          nocase:this.options.nocase\n        })\n      );\n    }\n  \n    this.ignoreMatchers = [];\n    if(this.options.ignore) {\n      const ignorePatterns = Array.isArray(this.options.ignore) ? this.options.ignore : [this.options.ignore];\n      this.ignoreMatchers = ignorePatterns.map( ignore =>\n        new Minimatch(ignore, {dot: true})\n      );\n    }\n  \n    this.skipMatchers = [];\n    if(this.options.skip) {\n      const skipPatterns = Array.isArray(this.options.skip) ? this.options.skip : [this.options.skip];\n      this.skipMatchers = skipPatterns.map( skip =>\n        new Minimatch(skip, {dot: true})\n      );\n    }\n\n    this.iterator = explore(resolve(cwd || '.'), this.options.follow, this.options.stat, this._shouldSkipDirectory.bind(this));\n    this.paused = false;\n    this.inactive = false;\n    this.aborted = false;\n  \n    if(cb) {\n      this._matches = []; \n      this.on('match', match => this._matches.push(this.options.absolute ? match.absolute : match.relative));\n      this.on('error', err => cb(err));\n      this.on('end', () => cb(null, this._matches));\n    }\n\n    setTimeout( () => this._next(), 0);\n  }\n\n  _shouldSkipDirectory(relative) {\n    //console.log(relative, this.skipMatchers.some(m => m.match(relative)));\n    return this.skipMatchers.some(m => m.match(relative));\n  }\n\n  _fileMatches(relative, isDirectory) {\n    const file = relative + (isDirectory ? '/' : '');\n    return (this.matchers.length === 0 || this.matchers.some(m => m.match(file)))\n      && !this.ignoreMatchers.some(m => m.match(file))\n      && (!this.options.nodir || !isDirectory);\n  }\n\n  _next() {\n    if(!this.paused && !this.aborted) {\n      this.iterator.next()\n      .then((obj)=> {\n        if(!obj.done) {\n          const isDirectory = obj.value.stats.isDirectory();\n          if(this._fileMatches(obj.value.relative, isDirectory )) {\n            let relative = obj.value.relative;\n            let absolute = obj.value.absolute;\n            if(this.options.mark && isDirectory) {\n              relative += '/';\n              absolute += '/';\n            }\n            if(this.options.stat) {\n              this.emit('match', {relative, absolute, stat:obj.value.stats});\n            } else {\n              this.emit('match', {relative, absolute});\n            }\n          }\n          this._next(this.iterator);\n        } else {\n          this.emit('end');\n        }\n      })\n      .catch((err) => {\n        this.abort();\n        this.emit('error', err);\n        if(!err.code && !this.options.silent) {\n          console.error(err);\n        }\n      });\n    } else {\n      this.inactive = true;\n    }\n  }\n\n  abort() {\n    this.aborted = true;\n  }\n\n  pause() {\n    this.paused = true;\n  }\n\n  resume() {\n    this.paused = false;\n    if(this.inactive) {\n      this.inactive = false;\n      this._next();\n    }\n  }\n}\n\n\nfunction readdirGlob(pattern, options, cb) {\n  return new ReaddirGlob(pattern, options, cb);\n}\nreaddirGlob.ReaddirGlob = ReaddirGlob;"]},"metadata":{},"sourceType":"script"}