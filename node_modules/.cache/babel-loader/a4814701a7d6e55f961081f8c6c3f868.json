{"ast":null,"code":"var Stream = require('stream');\n\nvar Promise = require('bluebird');\n\nvar util = require('util');\n\nvar Buffer = require('./Buffer');\n\nvar strFunction = 'function'; // Backwards compatibility for node versions < 8\n\nif (!Stream.Writable || !Stream.Writable.prototype.destroy) Stream = require('readable-stream');\n\nfunction PullStream() {\n  if (!(this instanceof PullStream)) return new PullStream();\n  Stream.Duplex.call(this, {\n    decodeStrings: false,\n    objectMode: true\n  });\n  this.buffer = Buffer.from('');\n  var self = this;\n  self.on('finish', function () {\n    self.finished = true;\n    self.emit('chunk', false);\n  });\n}\n\nutil.inherits(PullStream, Stream.Duplex);\n\nPullStream.prototype._write = function (chunk, e, cb) {\n  this.buffer = Buffer.concat([this.buffer, chunk]);\n  this.cb = cb;\n  this.emit('chunk');\n}; // The `eof` parameter is interpreted as `file_length` if the type is number\n// otherwise (i.e. buffer) it is interpreted as a pattern signaling end of stream\n\n\nPullStream.prototype.stream = function (eof, includeEof) {\n  var p = Stream.PassThrough();\n  var done,\n      self = this;\n\n  function cb() {\n    if (typeof self.cb === strFunction) {\n      var callback = self.cb;\n      self.cb = undefined;\n      return callback();\n    }\n  }\n\n  function pull() {\n    var packet;\n\n    if (self.buffer && self.buffer.length) {\n      if (typeof eof === 'number') {\n        packet = self.buffer.slice(0, eof);\n        self.buffer = self.buffer.slice(eof);\n        eof -= packet.length;\n        done = !eof;\n      } else {\n        var match = self.buffer.indexOf(eof);\n\n        if (match !== -1) {\n          // store signature match byte offset to allow us to reference\n          // this for zip64 offset\n          self.match = match;\n          if (includeEof) match = match + eof.length;\n          packet = self.buffer.slice(0, match);\n          self.buffer = self.buffer.slice(match);\n          done = true;\n        } else {\n          var len = self.buffer.length - eof.length;\n\n          if (len <= 0) {\n            cb();\n          } else {\n            packet = self.buffer.slice(0, len);\n            self.buffer = self.buffer.slice(len);\n          }\n        }\n      }\n\n      if (packet) p.write(packet, function () {\n        if (self.buffer.length === 0 || eof.length && self.buffer.length <= eof.length) cb();\n      });\n    }\n\n    if (!done) {\n      if (self.finished && !this.__ended) {\n        self.removeListener('chunk', pull);\n        self.emit('error', new Error('FILE_ENDED'));\n        this.__ended = true;\n        return;\n      }\n    } else {\n      self.removeListener('chunk', pull);\n      p.end();\n    }\n  }\n\n  self.on('chunk', pull);\n  pull();\n  return p;\n};\n\nPullStream.prototype.pull = function (eof, includeEof) {\n  if (eof === 0) return Promise.resolve(''); // If we already have the required data in buffer\n  // we can resolve the request immediately\n\n  if (!isNaN(eof) && this.buffer.length > eof) {\n    var data = this.buffer.slice(0, eof);\n    this.buffer = this.buffer.slice(eof);\n    return Promise.resolve(data);\n  } // Otherwise we stream until we have it\n\n\n  var buffer = Buffer.from(''),\n      self = this;\n  var concatStream = Stream.Transform();\n\n  concatStream._transform = function (d, e, cb) {\n    buffer = Buffer.concat([buffer, d]);\n    cb();\n  };\n\n  var rejectHandler;\n  var pullStreamRejectHandler;\n  return new Promise(function (resolve, reject) {\n    rejectHandler = reject;\n\n    pullStreamRejectHandler = function (e) {\n      self.__emittedError = e;\n      reject(e);\n    };\n\n    if (self.finished) return reject(new Error('FILE_ENDED'));\n    self.once('error', pullStreamRejectHandler); // reject any errors from pullstream itself\n\n    self.stream(eof, includeEof).on('error', reject).pipe(concatStream).on('finish', function () {\n      resolve(buffer);\n    }).on('error', reject);\n  }).finally(function () {\n    self.removeListener('error', rejectHandler);\n    self.removeListener('error', pullStreamRejectHandler);\n  });\n};\n\nPullStream.prototype._read = function () {};\n\nmodule.exports = PullStream;","map":{"version":3,"sources":["/home/dev/Documentos/Projects/github-clone/node_modules/unzipper/lib/PullStream.js"],"names":["Stream","require","Promise","util","Buffer","strFunction","Writable","prototype","destroy","PullStream","Duplex","call","decodeStrings","objectMode","buffer","from","self","on","finished","emit","inherits","_write","chunk","e","cb","concat","stream","eof","includeEof","p","PassThrough","done","callback","undefined","pull","packet","length","slice","match","indexOf","len","write","__ended","removeListener","Error","end","resolve","isNaN","data","concatStream","Transform","_transform","d","rejectHandler","pullStreamRejectHandler","reject","__emittedError","once","pipe","finally","_read","module","exports"],"mappings":"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","sourcesContent":["var Stream = require('stream');\nvar Promise = require('bluebird');\nvar util = require('util');\nvar Buffer = require('./Buffer');\nvar strFunction = 'function';\n\n// Backwards compatibility for node versions < 8\nif (!Stream.Writable || !Stream.Writable.prototype.destroy)\n  Stream = require('readable-stream');\n\nfunction PullStream() {\n  if (!(this instanceof PullStream))\n    return new PullStream();\n\n  Stream.Duplex.call(this,{decodeStrings:false, objectMode:true});\n  this.buffer = Buffer.from('');\n  var self = this;\n  self.on('finish',function() {\n    self.finished = true;\n    self.emit('chunk',false);\n  });\n}\n\nutil.inherits(PullStream,Stream.Duplex);\n\nPullStream.prototype._write = function(chunk,e,cb) {\n  this.buffer = Buffer.concat([this.buffer,chunk]);\n  this.cb = cb;\n  this.emit('chunk');\n};\n\n\n// The `eof` parameter is interpreted as `file_length` if the type is number\n// otherwise (i.e. buffer) it is interpreted as a pattern signaling end of stream\nPullStream.prototype.stream = function(eof,includeEof) {\n  var p = Stream.PassThrough();\n  var done,self= this;\n\n  function cb() {\n    if (typeof self.cb === strFunction) {\n      var callback = self.cb;\n      self.cb = undefined;\n      return callback();\n    }\n  }\n\n  function pull() {\n    var packet;\n    if (self.buffer && self.buffer.length) {\n      if (typeof eof === 'number') {\n        packet = self.buffer.slice(0,eof);\n        self.buffer = self.buffer.slice(eof);\n        eof -= packet.length;\n        done = !eof;\n      } else {\n        var match = self.buffer.indexOf(eof);\n        if (match !== -1) {\n          // store signature match byte offset to allow us to reference\n          // this for zip64 offset\n          self.match = match\n          if (includeEof) match = match + eof.length;\n          packet = self.buffer.slice(0,match);\n          self.buffer = self.buffer.slice(match);\n          done = true;\n        } else {\n          var len = self.buffer.length - eof.length;\n          if (len <= 0) {\n            cb();\n          } else {\n            packet = self.buffer.slice(0,len);\n            self.buffer = self.buffer.slice(len);\n          }\n        }\n      }\n      if (packet) p.write(packet,function() {\n        if (self.buffer.length === 0 || (eof.length && self.buffer.length <= eof.length)) cb();\n      });\n    }\n    \n    if (!done) {\n      if (self.finished && !this.__ended) {\n        self.removeListener('chunk',pull);\n        self.emit('error', new Error('FILE_ENDED'));\n        this.__ended = true;\n        return;\n      }\n      \n    } else {\n      self.removeListener('chunk',pull);\n      p.end();\n    }\n  }\n\n  self.on('chunk',pull);\n  pull();\n  return p;\n};\n\nPullStream.prototype.pull = function(eof,includeEof) {\n  if (eof === 0) return Promise.resolve('');\n\n  // If we already have the required data in buffer\n  // we can resolve the request immediately\n  if (!isNaN(eof) && this.buffer.length > eof) {\n    var data = this.buffer.slice(0,eof);\n    this.buffer = this.buffer.slice(eof);\n    return Promise.resolve(data);\n  }\n\n  // Otherwise we stream until we have it\n  var buffer = Buffer.from(''),\n      self = this;\n\n  var concatStream = Stream.Transform();\n  concatStream._transform = function(d,e,cb) {\n    buffer = Buffer.concat([buffer,d]);\n    cb();\n  };\n  \n  var rejectHandler;\n  var pullStreamRejectHandler;\n  return new Promise(function(resolve,reject) {\n    rejectHandler = reject;\n    pullStreamRejectHandler = function(e) {\n      self.__emittedError = e;\n      reject(e);\n    }\n    if (self.finished)\n      return reject(new Error('FILE_ENDED'));\n    self.once('error',pullStreamRejectHandler);  // reject any errors from pullstream itself\n    self.stream(eof,includeEof)\n      .on('error',reject)\n      .pipe(concatStream)\n      .on('finish',function() {resolve(buffer);})\n      .on('error',reject);\n  })\n  .finally(function() {\n    self.removeListener('error',rejectHandler);\n    self.removeListener('error',pullStreamRejectHandler);\n  });\n};\n\nPullStream.prototype._read = function(){};\n\nmodule.exports = PullStream;\n"]},"metadata":{},"sourceType":"script"}