{"ast":null,"code":"'use strict';\n\nvar _ = require('lodash');\n\nvar chalk = require('chalk');\n/**\n * The paginator keeps track of a pointer index in a list and returns\n * a subset of the choices if the list is too long.\n */\n\n\nclass Paginator {\n  constructor(screen) {\n    this.pointer = 0;\n    this.lastIndex = 0;\n    this.screen = screen;\n  }\n\n  paginate(output, active, pageSize) {\n    pageSize = pageSize || 7;\n    var middleOfList = Math.floor(pageSize / 2);\n    var lines = output.split('\\n');\n\n    if (this.screen) {\n      lines = this.screen.breakLines(lines);\n      active = _.sum(lines.map(lineParts => lineParts.length).splice(0, active));\n      lines = _.flatten(lines);\n    } // Make sure there's enough lines to paginate\n\n\n    if (lines.length <= pageSize) {\n      return output;\n    } // Move the pointer only when the user go down and limit it to the middle of the list\n\n\n    if (this.pointer < middleOfList && this.lastIndex < active && active - this.lastIndex < pageSize) {\n      this.pointer = Math.min(middleOfList, this.pointer + active - this.lastIndex);\n    }\n\n    this.lastIndex = active; // Duplicate the lines so it give an infinite list look\n\n    var infinite = _.flatten([lines, lines, lines]);\n\n    var topIndex = Math.max(0, active + lines.length - this.pointer);\n    var section = infinite.splice(topIndex, pageSize).join('\\n');\n    return section + '\\n' + chalk.dim('(Move up and down to reveal more choices)');\n  }\n\n}\n\nmodule.exports = Paginator;","map":{"version":3,"sources":["/home/dev/Documentos/Projects/github-clone/node_modules/inquirer/lib/utils/paginator.js"],"names":["_","require","chalk","Paginator","constructor","screen","pointer","lastIndex","paginate","output","active","pageSize","middleOfList","Math","floor","lines","split","breakLines","sum","map","lineParts","length","splice","flatten","min","infinite","topIndex","max","section","join","dim","module","exports"],"mappings":"AAAA;;AAEA,IAAIA,CAAC,GAAGC,OAAO,CAAC,QAAD,CAAf;;AACA,IAAIC,KAAK,GAAGD,OAAO,CAAC,OAAD,CAAnB;AAEA;AACA;AACA;AACA;;;AAEA,MAAME,SAAN,CAAgB;AACdC,EAAAA,WAAW,CAACC,MAAD,EAAS;AAClB,SAAKC,OAAL,GAAe,CAAf;AACA,SAAKC,SAAL,GAAiB,CAAjB;AACA,SAAKF,MAAL,GAAcA,MAAd;AACD;;AAEDG,EAAAA,QAAQ,CAACC,MAAD,EAASC,MAAT,EAAiBC,QAAjB,EAA2B;AACjCA,IAAAA,QAAQ,GAAGA,QAAQ,IAAI,CAAvB;AACA,QAAIC,YAAY,GAAGC,IAAI,CAACC,KAAL,CAAWH,QAAQ,GAAG,CAAtB,CAAnB;AACA,QAAII,KAAK,GAAGN,MAAM,CAACO,KAAP,CAAa,IAAb,CAAZ;;AAEA,QAAI,KAAKX,MAAT,EAAiB;AACfU,MAAAA,KAAK,GAAG,KAAKV,MAAL,CAAYY,UAAZ,CAAuBF,KAAvB,CAAR;AACAL,MAAAA,MAAM,GAAGV,CAAC,CAACkB,GAAF,CAAMH,KAAK,CAACI,GAAN,CAAUC,SAAS,IAAIA,SAAS,CAACC,MAAjC,EAAyCC,MAAzC,CAAgD,CAAhD,EAAmDZ,MAAnD,CAAN,CAAT;AACAK,MAAAA,KAAK,GAAGf,CAAC,CAACuB,OAAF,CAAUR,KAAV,CAAR;AACD,KATgC,CAWjC;;;AACA,QAAIA,KAAK,CAACM,MAAN,IAAgBV,QAApB,EAA8B;AAC5B,aAAOF,MAAP;AACD,KAdgC,CAgBjC;;;AACA,QACE,KAAKH,OAAL,GAAeM,YAAf,IACA,KAAKL,SAAL,GAAiBG,MADjB,IAEAA,MAAM,GAAG,KAAKH,SAAd,GAA0BI,QAH5B,EAIE;AACA,WAAKL,OAAL,GAAeO,IAAI,CAACW,GAAL,CAASZ,YAAT,EAAuB,KAAKN,OAAL,GAAeI,MAAf,GAAwB,KAAKH,SAApD,CAAf;AACD;;AAED,SAAKA,SAAL,GAAiBG,MAAjB,CAzBiC,CA2BjC;;AACA,QAAIe,QAAQ,GAAGzB,CAAC,CAACuB,OAAF,CAAU,CAACR,KAAD,EAAQA,KAAR,EAAeA,KAAf,CAAV,CAAf;;AACA,QAAIW,QAAQ,GAAGb,IAAI,CAACc,GAAL,CAAS,CAAT,EAAYjB,MAAM,GAAGK,KAAK,CAACM,MAAf,GAAwB,KAAKf,OAAzC,CAAf;AAEA,QAAIsB,OAAO,GAAGH,QAAQ,CAACH,MAAT,CAAgBI,QAAhB,EAA0Bf,QAA1B,EAAoCkB,IAApC,CAAyC,IAAzC,CAAd;AACA,WAAOD,OAAO,GAAG,IAAV,GAAiB1B,KAAK,CAAC4B,GAAN,CAAU,2CAAV,CAAxB;AACD;;AAxCa;;AA2ChBC,MAAM,CAACC,OAAP,GAAiB7B,SAAjB","sourcesContent":["'use strict';\n\nvar _ = require('lodash');\nvar chalk = require('chalk');\n\n/**\n * The paginator keeps track of a pointer index in a list and returns\n * a subset of the choices if the list is too long.\n */\n\nclass Paginator {\n  constructor(screen) {\n    this.pointer = 0;\n    this.lastIndex = 0;\n    this.screen = screen;\n  }\n\n  paginate(output, active, pageSize) {\n    pageSize = pageSize || 7;\n    var middleOfList = Math.floor(pageSize / 2);\n    var lines = output.split('\\n');\n\n    if (this.screen) {\n      lines = this.screen.breakLines(lines);\n      active = _.sum(lines.map(lineParts => lineParts.length).splice(0, active));\n      lines = _.flatten(lines);\n    }\n\n    // Make sure there's enough lines to paginate\n    if (lines.length <= pageSize) {\n      return output;\n    }\n\n    // Move the pointer only when the user go down and limit it to the middle of the list\n    if (\n      this.pointer < middleOfList &&\n      this.lastIndex < active &&\n      active - this.lastIndex < pageSize\n    ) {\n      this.pointer = Math.min(middleOfList, this.pointer + active - this.lastIndex);\n    }\n\n    this.lastIndex = active;\n\n    // Duplicate the lines so it give an infinite list look\n    var infinite = _.flatten([lines, lines, lines]);\n    var topIndex = Math.max(0, active + lines.length - this.pointer);\n\n    var section = infinite.splice(topIndex, pageSize).join('\\n');\n    return section + '\\n' + chalk.dim('(Move up and down to reveal more choices)');\n  }\n}\n\nmodule.exports = Paginator;\n"]},"metadata":{},"sourceType":"script"}