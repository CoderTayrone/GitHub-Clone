{"ast":null,"code":"\"use strict\";\n/**\n * Returns the given plugins as an array, rather than an object map.\n * All other methods in this module expect an array of plugins rather than an object map.\n *\n * @param  {object} plugins - A map of plugin objects\n * @return {object[]}\n */\n\nexports.all = function (plugins) {\n  return Object.keys(plugins).filter(key => {\n    return typeof plugins[key] === \"object\";\n  }).map(key => {\n    plugins[key].name = key;\n    return plugins[key];\n  });\n};\n/**\n * Filters the given plugins, returning only the ones return `true` for the given method.\n *\n * @param  {object[]} plugins - An array of plugin objects\n * @param  {string}   method  - The name of the filter method to invoke for each plugin\n * @param  {object}   file    - A file info object, which will be passed to each method\n * @return {object[]}\n */\n\n\nexports.filter = function (plugins, method, file) {\n  return plugins.filter(plugin => {\n    return !!getResult(plugin, method, file);\n  });\n};\n/**\n * Sorts the given plugins, in place, by their `order` property.\n *\n * @param {object[]} plugins - An array of plugin objects\n * @returns {object[]}\n */\n\n\nexports.sort = function (plugins) {\n  for (let plugin of plugins) {\n    plugin.order = plugin.order || Number.MAX_SAFE_INTEGER;\n  }\n\n  return plugins.sort((a, b) => {\n    return a.order - b.order;\n  });\n};\n/**\n * Runs the specified method of the given plugins, in order, until one of them returns a successful result.\n * Each method can return a synchronous value, a Promise, or call an error-first callback.\n * If the promise resolves successfully, or the callback is called without an error, then the result\n * is immediately returned and no further plugins are called.\n * If the promise rejects, or the callback is called with an error, then the next plugin is called.\n * If ALL plugins fail, then the last error is thrown.\n *\n * @param {object[]}  plugins - An array of plugin objects\n * @param {string}    method  - The name of the method to invoke for each plugin\n * @param {object}    file    - A file info object, which will be passed to each method\n * @returns {Promise}\n */\n\n\nexports.run = function (plugins, method, file, $refs) {\n  let plugin,\n      lastError,\n      index = 0;\n  return new Promise((resolve, reject) => {\n    runNextPlugin();\n\n    function runNextPlugin() {\n      plugin = plugins[index++];\n\n      if (!plugin) {\n        // There are no more functions, so re-throw the last error\n        return reject(lastError);\n      }\n\n      try {\n        // console.log('  %s', plugin.name);\n        let result = getResult(plugin, method, file, callback, $refs);\n\n        if (result && typeof result.then === \"function\") {\n          // A promise was returned\n          result.then(onSuccess, onError);\n        } else if (result !== undefined) {\n          // A synchronous result was returned\n          onSuccess(result);\n        } else if (index === plugins.length) {\n          throw new Error(\"No promise has been returned or callback has been called.\");\n        }\n      } catch (e) {\n        onError(e);\n      }\n    }\n\n    function callback(err, result) {\n      if (err) {\n        onError(err);\n      } else {\n        onSuccess(result);\n      }\n    }\n\n    function onSuccess(result) {\n      // console.log('    success');\n      resolve({\n        plugin,\n        result\n      });\n    }\n\n    function onError(error) {\n      // console.log('    %s', err.message || err);\n      lastError = {\n        plugin,\n        error\n      };\n      runNextPlugin();\n    }\n  });\n};\n/**\n * Returns the value of the given property.\n * If the property is a function, then the result of the function is returned.\n * If the value is a RegExp, then it will be tested against the file URL.\n * If the value is an aray, then it will be compared against the file extension.\n *\n * @param   {object}   obj        - The object whose property/method is called\n * @param   {string}   prop       - The name of the property/method to invoke\n * @param   {object}   file       - A file info object, which will be passed to the method\n * @param   {function} [callback] - A callback function, which will be passed to the method\n * @returns {*}\n */\n\n\nfunction getResult(obj, prop, file, callback, $refs) {\n  let value = obj[prop];\n\n  if (typeof value === \"function\") {\n    return value.apply(obj, [file, callback, $refs]);\n  }\n\n  if (!callback) {\n    // The synchronous plugin functions (canParse and canRead)\n    // allow a \"shorthand\" syntax, where the user can match\n    // files by RegExp or by file extension.\n    if (value instanceof RegExp) {\n      return value.test(file.url);\n    } else if (typeof value === \"string\") {\n      return value === file.extension;\n    } else if (Array.isArray(value)) {\n      return value.indexOf(file.extension) !== -1;\n    }\n  }\n\n  return value;\n}","map":{"version":3,"sources":["/home/dev/Documentos/Projects/github-clone/node_modules/@apidevtools/json-schema-ref-parser/lib/util/plugins.js"],"names":["exports","all","plugins","Object","keys","filter","key","map","name","method","file","plugin","getResult","sort","order","Number","MAX_SAFE_INTEGER","a","b","run","$refs","lastError","index","Promise","resolve","reject","runNextPlugin","result","callback","then","onSuccess","onError","undefined","length","Error","e","err","error","obj","prop","value","apply","RegExp","test","url","extension","Array","isArray","indexOf"],"mappings":"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","sourcesContent":["\"use strict\";\n\n/**\n * Returns the given plugins as an array, rather than an object map.\n * All other methods in this module expect an array of plugins rather than an object map.\n *\n * @param  {object} plugins - A map of plugin objects\n * @return {object[]}\n */\nexports.all = function (plugins) {\n  return Object.keys(plugins)\n    .filter((key) => {\n      return typeof plugins[key] === \"object\";\n    })\n    .map((key) => {\n      plugins[key].name = key;\n      return plugins[key];\n    });\n};\n\n/**\n * Filters the given plugins, returning only the ones return `true` for the given method.\n *\n * @param  {object[]} plugins - An array of plugin objects\n * @param  {string}   method  - The name of the filter method to invoke for each plugin\n * @param  {object}   file    - A file info object, which will be passed to each method\n * @return {object[]}\n */\nexports.filter = function (plugins, method, file) {\n  return plugins\n    .filter((plugin) => {\n      return !!getResult(plugin, method, file);\n    });\n};\n\n/**\n * Sorts the given plugins, in place, by their `order` property.\n *\n * @param {object[]} plugins - An array of plugin objects\n * @returns {object[]}\n */\nexports.sort = function (plugins) {\n  for (let plugin of plugins) {\n    plugin.order = plugin.order || Number.MAX_SAFE_INTEGER;\n  }\n\n  return plugins.sort((a, b) => { return a.order - b.order; });\n};\n\n/**\n * Runs the specified method of the given plugins, in order, until one of them returns a successful result.\n * Each method can return a synchronous value, a Promise, or call an error-first callback.\n * If the promise resolves successfully, or the callback is called without an error, then the result\n * is immediately returned and no further plugins are called.\n * If the promise rejects, or the callback is called with an error, then the next plugin is called.\n * If ALL plugins fail, then the last error is thrown.\n *\n * @param {object[]}  plugins - An array of plugin objects\n * @param {string}    method  - The name of the method to invoke for each plugin\n * @param {object}    file    - A file info object, which will be passed to each method\n * @returns {Promise}\n */\nexports.run = function (plugins, method, file, $refs) {\n  let plugin, lastError, index = 0;\n\n  return new Promise(((resolve, reject) => {\n    runNextPlugin();\n\n    function runNextPlugin () {\n      plugin = plugins[index++];\n      if (!plugin) {\n        // There are no more functions, so re-throw the last error\n        return reject(lastError);\n      }\n\n      try {\n        // console.log('  %s', plugin.name);\n        let result = getResult(plugin, method, file, callback, $refs);\n        if (result && typeof result.then === \"function\") {\n          // A promise was returned\n          result.then(onSuccess, onError);\n        }\n        else if (result !== undefined) {\n          // A synchronous result was returned\n          onSuccess(result);\n        }\n        else if (index === plugins.length) {\n          throw new Error(\"No promise has been returned or callback has been called.\");\n        }\n      }\n      catch (e) {\n        onError(e);\n      }\n    }\n\n    function callback (err, result) {\n      if (err) {\n        onError(err);\n      }\n      else {\n        onSuccess(result);\n      }\n    }\n\n    function onSuccess (result) {\n      // console.log('    success');\n      resolve({\n        plugin,\n        result\n      });\n    }\n\n    function onError (error) {\n      // console.log('    %s', err.message || err);\n      lastError = {\n        plugin,\n        error,\n      };\n      runNextPlugin();\n    }\n  }));\n};\n\n/**\n * Returns the value of the given property.\n * If the property is a function, then the result of the function is returned.\n * If the value is a RegExp, then it will be tested against the file URL.\n * If the value is an aray, then it will be compared against the file extension.\n *\n * @param   {object}   obj        - The object whose property/method is called\n * @param   {string}   prop       - The name of the property/method to invoke\n * @param   {object}   file       - A file info object, which will be passed to the method\n * @param   {function} [callback] - A callback function, which will be passed to the method\n * @returns {*}\n */\nfunction getResult (obj, prop, file, callback, $refs) {\n  let value = obj[prop];\n\n  if (typeof value === \"function\") {\n    return value.apply(obj, [file, callback, $refs]);\n  }\n\n  if (!callback) {\n    // The synchronous plugin functions (canParse and canRead)\n    // allow a \"shorthand\" syntax, where the user can match\n    // files by RegExp or by file extension.\n    if (value instanceof RegExp) {\n      return value.test(file.url);\n    }\n    else if (typeof value === \"string\") {\n      return value === file.extension;\n    }\n    else if (Array.isArray(value)) {\n      return value.indexOf(file.extension) !== -1;\n    }\n  }\n\n  return value;\n}\n"]},"metadata":{},"sourceType":"script"}