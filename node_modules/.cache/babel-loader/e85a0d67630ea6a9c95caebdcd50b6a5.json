{"ast":null,"code":"/* eslint-disable no-unused-vars */\n\"use strict\";\n\nconst $Refs = require(\"./refs\");\n\nconst _parse = require(\"./parse\");\n\nconst normalizeArgs = require(\"./normalize-args\");\n\nconst resolveExternal = require(\"./resolve-external\");\n\nconst _bundle = require(\"./bundle\");\n\nconst _dereference = require(\"./dereference\");\n\nconst url = require(\"./util/url\");\n\nconst {\n  JSONParserError,\n  InvalidPointerError,\n  MissingPointerError,\n  ResolverError,\n  ParserError,\n  UnmatchedParserError,\n  UnmatchedResolverError,\n  isHandledError,\n  JSONParserErrorGroup\n} = require(\"./util/errors\");\n\nconst maybe = require(\"call-me-maybe\");\n\nconst {\n  ono\n} = require(\"@jsdevtools/ono\");\n\nmodule.exports = $RefParser;\nmodule.exports.default = $RefParser;\nmodule.exports.JSONParserError = JSONParserError;\nmodule.exports.InvalidPointerError = InvalidPointerError;\nmodule.exports.MissingPointerError = MissingPointerError;\nmodule.exports.ResolverError = ResolverError;\nmodule.exports.ParserError = ParserError;\nmodule.exports.UnmatchedParserError = UnmatchedParserError;\nmodule.exports.UnmatchedResolverError = UnmatchedResolverError;\n/**\n * This class parses a JSON schema, builds a map of its JSON references and their resolved values,\n * and provides methods for traversing, manipulating, and dereferencing those references.\n *\n * @constructor\n */\n\nfunction $RefParser() {\n  /**\n   * The parsed (and possibly dereferenced) JSON schema object\n   *\n   * @type {object}\n   * @readonly\n   */\n  this.schema = null;\n  /**\n   * The resolved JSON references\n   *\n   * @type {$Refs}\n   * @readonly\n   */\n\n  this.$refs = new $Refs();\n}\n/**\n * Parses the given JSON schema.\n * This method does not resolve any JSON references.\n * It just reads a single file in JSON or YAML format, and parse it as a JavaScript object.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed\n * @param {function} [callback] - An error-first callback. The second parameter is the parsed JSON schema object.\n * @returns {Promise} - The returned promise resolves with the parsed JSON schema object.\n */\n\n\n$RefParser.parse = function parse(path, schema, options, callback) {\n  let Class = this; // eslint-disable-line consistent-this\n\n  let instance = new Class();\n  return instance.parse.apply(instance, arguments);\n};\n/**\n * Parses the given JSON schema.\n * This method does not resolve any JSON references.\n * It just reads a single file in JSON or YAML format, and parse it as a JavaScript object.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed\n * @param {function} [callback] - An error-first callback. The second parameter is the parsed JSON schema object.\n * @returns {Promise} - The returned promise resolves with the parsed JSON schema object.\n */\n\n\n$RefParser.prototype.parse = async function parse(path, schema, options, callback) {\n  let args = normalizeArgs(arguments);\n  let promise;\n\n  if (!args.path && !args.schema) {\n    let err = ono(`Expected a file path, URL, or object. Got ${args.path || args.schema}`);\n    return maybe(args.callback, Promise.reject(err));\n  } // Reset everything\n\n\n  this.schema = null;\n  this.$refs = new $Refs(); // If the path is a filesystem path, then convert it to a URL.\n  // NOTE: According to the JSON Reference spec, these should already be URLs,\n  // but, in practice, many people use local filesystem paths instead.\n  // So we're being generous here and doing the conversion automatically.\n  // This is not intended to be a 100% bulletproof solution.\n  // If it doesn't work for your use-case, then use a URL instead.\n\n  let pathType = \"http\";\n\n  if (url.isFileSystemPath(args.path)) {\n    args.path = url.fromFileSystemPath(args.path);\n    pathType = \"file\";\n  } // Resolve the absolute path of the schema\n\n\n  args.path = url.resolve(url.cwd(), args.path);\n\n  if (args.schema && typeof args.schema === \"object\") {\n    // A schema object was passed-in.\n    // So immediately add a new $Ref with the schema object as its value\n    let $ref = this.$refs._add(args.path);\n\n    $ref.value = args.schema;\n    $ref.pathType = pathType;\n    promise = Promise.resolve(args.schema);\n  } else {\n    // Parse the schema file/url\n    promise = _parse(args.path, this.$refs, args.options);\n  }\n\n  let me = this;\n\n  try {\n    let result = await promise;\n\n    if (result !== null && typeof result === \"object\" && !Buffer.isBuffer(result)) {\n      me.schema = result;\n      return maybe(args.callback, Promise.resolve(me.schema));\n    } else if (args.options.continueOnError) {\n      me.schema = null; // it's already set to null at line 79, but let's set it again for the sake of readability\n\n      return maybe(args.callback, Promise.resolve(me.schema));\n    } else {\n      throw ono.syntax(`\"${me.$refs._root$Ref.path || result}\" is not a valid JSON Schema`);\n    }\n  } catch (err) {\n    if (!args.options.continueOnError || !isHandledError(err)) {\n      return maybe(args.callback, Promise.reject(err));\n    }\n\n    if (this.$refs._$refs[url.stripHash(args.path)]) {\n      this.$refs._$refs[url.stripHash(args.path)].addError(err);\n    }\n\n    return maybe(args.callback, Promise.resolve(null));\n  }\n};\n/**\n * Parses the given JSON schema and resolves any JSON references, including references in\n * externally-referenced files.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed and resolved\n * @param {function} [callback]\n * - An error-first callback. The second parameter is a {@link $Refs} object containing the resolved JSON references\n *\n * @returns {Promise}\n * The returned promise resolves with a {@link $Refs} object containing the resolved JSON references\n */\n\n\n$RefParser.resolve = function resolve(path, schema, options, callback) {\n  let Class = this; // eslint-disable-line consistent-this\n\n  let instance = new Class();\n  return instance.resolve.apply(instance, arguments);\n};\n/**\n * Parses the given JSON schema and resolves any JSON references, including references in\n * externally-referenced files.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed and resolved\n * @param {function} [callback]\n * - An error-first callback. The second parameter is a {@link $Refs} object containing the resolved JSON references\n *\n * @returns {Promise}\n * The returned promise resolves with a {@link $Refs} object containing the resolved JSON references\n */\n\n\n$RefParser.prototype.resolve = async function resolve(path, schema, options, callback) {\n  let me = this;\n  let args = normalizeArgs(arguments);\n\n  try {\n    await this.parse(args.path, args.schema, args.options);\n    await resolveExternal(me, args.options);\n    finalize(me);\n    return maybe(args.callback, Promise.resolve(me.$refs));\n  } catch (err) {\n    return maybe(args.callback, Promise.reject(err));\n  }\n};\n/**\n * Parses the given JSON schema, resolves any JSON references, and bundles all external references\n * into the main JSON schema. This produces a JSON schema that only has *internal* references,\n * not any *external* references.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed, resolved, and dereferenced\n * @param {function} [callback] - An error-first callback. The second parameter is the bundled JSON schema object\n * @returns {Promise} - The returned promise resolves with the bundled JSON schema object.\n */\n\n\n$RefParser.bundle = function bundle(path, schema, options, callback) {\n  let Class = this; // eslint-disable-line consistent-this\n\n  let instance = new Class();\n  return instance.bundle.apply(instance, arguments);\n};\n/**\n * Parses the given JSON schema, resolves any JSON references, and bundles all external references\n * into the main JSON schema. This produces a JSON schema that only has *internal* references,\n * not any *external* references.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed, resolved, and dereferenced\n * @param {function} [callback] - An error-first callback. The second parameter is the bundled JSON schema object\n * @returns {Promise} - The returned promise resolves with the bundled JSON schema object.\n */\n\n\n$RefParser.prototype.bundle = async function bundle(path, schema, options, callback) {\n  let me = this;\n  let args = normalizeArgs(arguments);\n\n  try {\n    await this.resolve(args.path, args.schema, args.options);\n\n    _bundle(me, args.options);\n\n    finalize(me);\n    return maybe(args.callback, Promise.resolve(me.schema));\n  } catch (err) {\n    return maybe(args.callback, Promise.reject(err));\n  }\n};\n/**\n * Parses the given JSON schema, resolves any JSON references, and dereferences the JSON schema.\n * That is, all JSON references are replaced with their resolved values.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed, resolved, and dereferenced\n * @param {function} [callback] - An error-first callback. The second parameter is the dereferenced JSON schema object\n * @returns {Promise} - The returned promise resolves with the dereferenced JSON schema object.\n */\n\n\n$RefParser.dereference = function dereference(path, schema, options, callback) {\n  let Class = this; // eslint-disable-line consistent-this\n\n  let instance = new Class();\n  return instance.dereference.apply(instance, arguments);\n};\n/**\n * Parses the given JSON schema, resolves any JSON references, and dereferences the JSON schema.\n * That is, all JSON references are replaced with their resolved values.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed, resolved, and dereferenced\n * @param {function} [callback] - An error-first callback. The second parameter is the dereferenced JSON schema object\n * @returns {Promise} - The returned promise resolves with the dereferenced JSON schema object.\n */\n\n\n$RefParser.prototype.dereference = async function dereference(path, schema, options, callback) {\n  let me = this;\n  let args = normalizeArgs(arguments);\n\n  try {\n    await this.resolve(args.path, args.schema, args.options);\n\n    _dereference(me, args.options);\n\n    finalize(me);\n    return maybe(args.callback, Promise.resolve(me.schema));\n  } catch (err) {\n    return maybe(args.callback, Promise.reject(err));\n  }\n};\n\nfunction finalize(parser) {\n  const errors = JSONParserErrorGroup.getParserErrors(parser);\n\n  if (errors.length > 0) {\n    throw new JSONParserErrorGroup(parser);\n  }\n}","map":{"version":3,"sources":["/home/dev/Documentos/Projects/github-clone/node_modules/@apidevtools/json-schema-ref-parser/lib/index.js"],"names":["$Refs","require","_parse","normalizeArgs","resolveExternal","_bundle","_dereference","url","JSONParserError","InvalidPointerError","MissingPointerError","ResolverError","ParserError","UnmatchedParserError","UnmatchedResolverError","isHandledError","JSONParserErrorGroup","maybe","ono","module","exports","$RefParser","default","schema","$refs","parse","path","options","callback","Class","instance","apply","arguments","prototype","args","promise","err","Promise","reject","pathType","isFileSystemPath","fromFileSystemPath","resolve","cwd","$ref","_add","value","me","result","Buffer","isBuffer","continueOnError","syntax","_root$Ref","_$refs","stripHash","addError","finalize","bundle","dereference","parser","errors","getParserErrors","length"],"mappings":"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","sourcesContent":["/* eslint-disable no-unused-vars */\n\"use strict\";\n\nconst $Refs = require(\"./refs\");\nconst _parse = require(\"./parse\");\nconst normalizeArgs = require(\"./normalize-args\");\nconst resolveExternal = require(\"./resolve-external\");\nconst _bundle = require(\"./bundle\");\nconst _dereference = require(\"./dereference\");\nconst url = require(\"./util/url\");\nconst { JSONParserError, InvalidPointerError, MissingPointerError, ResolverError, ParserError, UnmatchedParserError, UnmatchedResolverError, isHandledError, JSONParserErrorGroup } = require(\"./util/errors\");\nconst maybe = require(\"call-me-maybe\");\nconst { ono } = require(\"@jsdevtools/ono\");\n\nmodule.exports = $RefParser;\nmodule.exports.default = $RefParser;\nmodule.exports.JSONParserError = JSONParserError;\nmodule.exports.InvalidPointerError = InvalidPointerError;\nmodule.exports.MissingPointerError = MissingPointerError;\nmodule.exports.ResolverError = ResolverError;\nmodule.exports.ParserError = ParserError;\nmodule.exports.UnmatchedParserError = UnmatchedParserError;\nmodule.exports.UnmatchedResolverError = UnmatchedResolverError;\n\n/**\n * This class parses a JSON schema, builds a map of its JSON references and their resolved values,\n * and provides methods for traversing, manipulating, and dereferencing those references.\n *\n * @constructor\n */\nfunction $RefParser () {\n  /**\n   * The parsed (and possibly dereferenced) JSON schema object\n   *\n   * @type {object}\n   * @readonly\n   */\n  this.schema = null;\n\n  /**\n   * The resolved JSON references\n   *\n   * @type {$Refs}\n   * @readonly\n   */\n  this.$refs = new $Refs();\n}\n\n/**\n * Parses the given JSON schema.\n * This method does not resolve any JSON references.\n * It just reads a single file in JSON or YAML format, and parse it as a JavaScript object.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed\n * @param {function} [callback] - An error-first callback. The second parameter is the parsed JSON schema object.\n * @returns {Promise} - The returned promise resolves with the parsed JSON schema object.\n */\n$RefParser.parse = function parse (path, schema, options, callback) {\n  let Class = this; // eslint-disable-line consistent-this\n  let instance = new Class();\n  return instance.parse.apply(instance, arguments);\n};\n\n/**\n * Parses the given JSON schema.\n * This method does not resolve any JSON references.\n * It just reads a single file in JSON or YAML format, and parse it as a JavaScript object.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed\n * @param {function} [callback] - An error-first callback. The second parameter is the parsed JSON schema object.\n * @returns {Promise} - The returned promise resolves with the parsed JSON schema object.\n */\n$RefParser.prototype.parse = async function parse (path, schema, options, callback) {\n  let args = normalizeArgs(arguments);\n  let promise;\n\n  if (!args.path && !args.schema) {\n    let err = ono(`Expected a file path, URL, or object. Got ${args.path || args.schema}`);\n    return maybe(args.callback, Promise.reject(err));\n  }\n\n  // Reset everything\n  this.schema = null;\n  this.$refs = new $Refs();\n\n  // If the path is a filesystem path, then convert it to a URL.\n  // NOTE: According to the JSON Reference spec, these should already be URLs,\n  // but, in practice, many people use local filesystem paths instead.\n  // So we're being generous here and doing the conversion automatically.\n  // This is not intended to be a 100% bulletproof solution.\n  // If it doesn't work for your use-case, then use a URL instead.\n  let pathType = \"http\";\n  if (url.isFileSystemPath(args.path)) {\n    args.path = url.fromFileSystemPath(args.path);\n    pathType = \"file\";\n  }\n\n  // Resolve the absolute path of the schema\n  args.path = url.resolve(url.cwd(), args.path);\n\n  if (args.schema && typeof args.schema === \"object\") {\n    // A schema object was passed-in.\n    // So immediately add a new $Ref with the schema object as its value\n    let $ref = this.$refs._add(args.path);\n    $ref.value = args.schema;\n    $ref.pathType = pathType;\n    promise = Promise.resolve(args.schema);\n  }\n  else {\n    // Parse the schema file/url\n    promise = _parse(args.path, this.$refs, args.options);\n  }\n\n  let me = this;\n  try {\n    let result = await promise;\n\n    if (result !== null && typeof result === \"object\" && !Buffer.isBuffer(result)) {\n      me.schema = result;\n      return maybe(args.callback, Promise.resolve(me.schema));\n    }\n    else if (args.options.continueOnError) {\n      me.schema = null; // it's already set to null at line 79, but let's set it again for the sake of readability\n      return maybe(args.callback, Promise.resolve(me.schema));\n    }\n    else {\n      throw ono.syntax(`\"${me.$refs._root$Ref.path || result}\" is not a valid JSON Schema`);\n    }\n  }\n  catch (err) {\n    if (!args.options.continueOnError || !isHandledError(err)) {\n      return maybe(args.callback, Promise.reject(err));\n    }\n\n    if (this.$refs._$refs[url.stripHash(args.path)]) {\n      this.$refs._$refs[url.stripHash(args.path)].addError(err);\n    }\n\n    return maybe(args.callback, Promise.resolve(null));\n  }\n};\n\n/**\n * Parses the given JSON schema and resolves any JSON references, including references in\n * externally-referenced files.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed and resolved\n * @param {function} [callback]\n * - An error-first callback. The second parameter is a {@link $Refs} object containing the resolved JSON references\n *\n * @returns {Promise}\n * The returned promise resolves with a {@link $Refs} object containing the resolved JSON references\n */\n$RefParser.resolve = function resolve (path, schema, options, callback) {\n  let Class = this; // eslint-disable-line consistent-this\n  let instance = new Class();\n  return instance.resolve.apply(instance, arguments);\n};\n\n/**\n * Parses the given JSON schema and resolves any JSON references, including references in\n * externally-referenced files.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed and resolved\n * @param {function} [callback]\n * - An error-first callback. The second parameter is a {@link $Refs} object containing the resolved JSON references\n *\n * @returns {Promise}\n * The returned promise resolves with a {@link $Refs} object containing the resolved JSON references\n */\n$RefParser.prototype.resolve = async function resolve (path, schema, options, callback) {\n  let me = this;\n  let args = normalizeArgs(arguments);\n\n  try {\n    await this.parse(args.path, args.schema, args.options);\n    await resolveExternal(me, args.options);\n    finalize(me);\n    return maybe(args.callback, Promise.resolve(me.$refs));\n  }\n  catch (err) {\n    return maybe(args.callback, Promise.reject(err));\n  }\n};\n\n/**\n * Parses the given JSON schema, resolves any JSON references, and bundles all external references\n * into the main JSON schema. This produces a JSON schema that only has *internal* references,\n * not any *external* references.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed, resolved, and dereferenced\n * @param {function} [callback] - An error-first callback. The second parameter is the bundled JSON schema object\n * @returns {Promise} - The returned promise resolves with the bundled JSON schema object.\n */\n$RefParser.bundle = function bundle (path, schema, options, callback) {\n  let Class = this; // eslint-disable-line consistent-this\n  let instance = new Class();\n  return instance.bundle.apply(instance, arguments);\n};\n\n/**\n * Parses the given JSON schema, resolves any JSON references, and bundles all external references\n * into the main JSON schema. This produces a JSON schema that only has *internal* references,\n * not any *external* references.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed, resolved, and dereferenced\n * @param {function} [callback] - An error-first callback. The second parameter is the bundled JSON schema object\n * @returns {Promise} - The returned promise resolves with the bundled JSON schema object.\n */\n$RefParser.prototype.bundle = async function bundle (path, schema, options, callback) {\n  let me = this;\n  let args = normalizeArgs(arguments);\n\n  try {\n    await this.resolve(args.path, args.schema, args.options);\n    _bundle(me, args.options);\n    finalize(me);\n    return maybe(args.callback, Promise.resolve(me.schema));\n  }\n  catch (err) {\n    return maybe(args.callback, Promise.reject(err));\n  }\n};\n\n/**\n * Parses the given JSON schema, resolves any JSON references, and dereferences the JSON schema.\n * That is, all JSON references are replaced with their resolved values.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed, resolved, and dereferenced\n * @param {function} [callback] - An error-first callback. The second parameter is the dereferenced JSON schema object\n * @returns {Promise} - The returned promise resolves with the dereferenced JSON schema object.\n */\n$RefParser.dereference = function dereference (path, schema, options, callback) {\n  let Class = this; // eslint-disable-line consistent-this\n  let instance = new Class();\n  return instance.dereference.apply(instance, arguments);\n};\n\n/**\n * Parses the given JSON schema, resolves any JSON references, and dereferences the JSON schema.\n * That is, all JSON references are replaced with their resolved values.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed, resolved, and dereferenced\n * @param {function} [callback] - An error-first callback. The second parameter is the dereferenced JSON schema object\n * @returns {Promise} - The returned promise resolves with the dereferenced JSON schema object.\n */\n$RefParser.prototype.dereference = async function dereference (path, schema, options, callback) {\n  let me = this;\n  let args = normalizeArgs(arguments);\n\n  try {\n    await this.resolve(args.path, args.schema, args.options);\n    _dereference(me, args.options);\n    finalize(me);\n    return maybe(args.callback, Promise.resolve(me.schema));\n  }\n  catch (err) {\n    return maybe(args.callback, Promise.reject(err));\n  }\n};\n\nfunction finalize (parser) {\n  const errors = JSONParserErrorGroup.getParserErrors(parser);\n  if (errors.length > 0) {\n    throw new JSONParserErrorGroup(parser);\n  }\n}\n"]},"metadata":{},"sourceType":"script"}