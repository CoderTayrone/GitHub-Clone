{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.generatePathStyleParser = void 0;\n\nconst querystring_1 = __importDefault(require(\"querystring\"));\n\nconst structuredParser_1 = require(\"./structuredParser\");\n\nfunction parsePathParameter(location, value, structuredParser) {\n  if (value.startsWith(';')) {\n    value = value.slice(1);\n  }\n\n  const queryParsedValue = querystring_1.default.parse(value, ';', '=', {\n    decodeURIComponent: val => val\n  });\n  return structuredParser(location, queryParsedValue, value, {});\n}\n\nfunction generatePathStyleParser(schema, explode) {\n  const structuredParser = structuredParser_1.generateStructuredParser(schema, explode);\n  return function pathStyleParser(location, rawParamValues) {\n    const value = rawParamValues[location.name];\n    let answer;\n\n    if (value === null || value === undefined) {\n      answer = value;\n    } else if (Array.isArray(value)) {\n      // This will never happen, since \"matrix\" parameters are only\n      // allowed in the path, and no one is going to define some\n      // crazy path like \"/foo/{bar}/{bar}\".\n      answer = value.map(v => parsePathParameter(location, v, structuredParser));\n    } else {\n      answer = parsePathParameter(location, value, structuredParser);\n    }\n\n    return answer;\n  };\n}\n\nexports.generatePathStyleParser = generatePathStyleParser;","map":{"version":3,"sources":["../../../src/oas3/parameterParsers/pathStyleParser.ts"],"names":[],"mappings":";;;;;;;;;;;;;AAAA,MAAA,aAAA,GAAA,eAAA,CAAA,OAAA,CAAA,aAAA,CAAA,CAAA;;AAGA,MAAA,kBAAA,GAAA,OAAA,CAAA,oBAAA,CAAA;;AAGA,SAAS,kBAAT,CACI,QADJ,EAEI,KAFJ,EAGI,gBAHJ,EAGqC;AAEjC,MAAI,KAAK,CAAC,UAAN,CAAiB,GAAjB,CAAJ,EAA2B;AACvB,IAAA,KAAK,GAAG,KAAK,CAAC,KAAN,CAAY,CAAZ,CAAR;AACH;;AACD,QAAM,gBAAgB,GAAG,aAAA,CAAA,OAAA,CAAY,KAAZ,CAAkB,KAAlB,EAAyB,GAAzB,EAA8B,GAA9B,EAAmC;AACxD,IAAA,kBAAkB,EAAG,GAAD,IAAiB;AADmB,GAAnC,CAAzB;AAGA,SAAO,gBAAgB,CAAC,QAAD,EAAW,gBAAX,EAA6B,KAA7B,EAAoC,EAApC,CAAvB;AACH;;AAED,SAAgB,uBAAhB,CAAwC,MAAxC,EAAqD,OAArD,EAAqE;AACjE,QAAM,gBAAgB,GAAG,kBAAA,CAAA,wBAAA,CAAyB,MAAzB,EAAiC,OAAjC,CAAzB;AAEA,SAAO,SAAS,eAAT,CAAyB,QAAzB,EAAsD,cAAtD,EAA+E;AAClF,UAAM,KAAK,GAAG,cAAc,CAAC,QAAQ,CAAC,IAAV,CAA5B;AACA,QAAI,MAAJ;;AACA,QAAI,KAAK,KAAK,IAAV,IAAkB,KAAK,KAAK,SAAhC,EAA2C;AACvC,MAAA,MAAM,GAAG,KAAT;AACH,KAFD,MAEO,IAAI,KAAK,CAAC,OAAN,CAAc,KAAd,CAAJ,EAA0B;AAC7B;AACA;AACA;AACA,MAAA,MAAM,GAAG,KAAK,CAAC,GAAN,CAAW,CAAD,IAAO,kBAAkB,CAAC,QAAD,EAAW,CAAX,EAAc,gBAAd,CAAnC,CAAT;AACH,KALM,MAKA;AACH,MAAA,MAAM,GAAG,kBAAkB,CAAC,QAAD,EAAW,KAAX,EAAkB,gBAAlB,CAA3B;AACH;;AAED,WAAO,MAAP;AACH,GAfD;AAgBH;;AAnBD,OAAA,CAAA,uBAAA,GAAA,uBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.generatePathStyleParser = void 0;\nconst querystring_1 = __importDefault(require(\"querystring\"));\nconst structuredParser_1 = require(\"./structuredParser\");\nfunction parsePathParameter(location, value, structuredParser) {\n    if (value.startsWith(';')) {\n        value = value.slice(1);\n    }\n    const queryParsedValue = querystring_1.default.parse(value, ';', '=', {\n        decodeURIComponent: (val) => val,\n    });\n    return structuredParser(location, queryParsedValue, value, {});\n}\nfunction generatePathStyleParser(schema, explode) {\n    const structuredParser = structuredParser_1.generateStructuredParser(schema, explode);\n    return function pathStyleParser(location, rawParamValues) {\n        const value = rawParamValues[location.name];\n        let answer;\n        if (value === null || value === undefined) {\n            answer = value;\n        }\n        else if (Array.isArray(value)) {\n            // This will never happen, since \"matrix\" parameters are only\n            // allowed in the path, and no one is going to define some\n            // crazy path like \"/foo/{bar}/{bar}\".\n            answer = value.map((v) => parsePathParameter(location, v, structuredParser));\n        }\n        else {\n            answer = parsePathParameter(location, value, structuredParser);\n        }\n        return answer;\n    };\n}\nexports.generatePathStyleParser = generatePathStyleParser;\n//# sourceMappingURL=pathStyleParser.js.map"]},"metadata":{},"sourceType":"script"}