{"ast":null,"code":"import { addInspectMethod } from \"./isomorphic.node\";\nimport { isLazyStack, isWritableStack, joinStacks, lazyJoinStacks } from \"./stack\";\nimport { getDeepKeys, toJSON } from \"./to-json\";\nconst protectedProps = [\"name\", \"message\", \"stack\"];\n/**\n * Extends the new error with the properties of the original error and the `props` object.\n *\n * @param newError - The error object to extend\n * @param originalError - The original error object, if any\n * @param props - Additional properties to add, if any\n */\n\nexport function extendError(error, originalError, props) {\n  let onoError = error;\n  extendStack(onoError, originalError); // Copy properties from the original error\n\n  if (originalError && typeof originalError === \"object\") {\n    mergeErrors(onoError, originalError);\n  } // The default `toJSON` method doesn't output props like `name`, `message`, `stack`, etc.\n  // So replace it with one that outputs every property of the error.\n\n\n  onoError.toJSON = toJSON; // On Node.js, add support for the `util.inspect()` method\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n\n  if (addInspectMethod) {\n    addInspectMethod(onoError);\n  } // Finally, copy custom properties that were specified by the user.\n  // These props OVERWRITE any previous props\n\n\n  if (props && typeof props === \"object\") {\n    Object.assign(onoError, props);\n  }\n\n  return onoError;\n}\n/**\n * Extend the error stack to include its cause\n */\n\nfunction extendStack(newError, originalError) {\n  let stackProp = Object.getOwnPropertyDescriptor(newError, \"stack\");\n\n  if (isLazyStack(stackProp)) {\n    lazyJoinStacks(stackProp, newError, originalError);\n  } else if (isWritableStack(stackProp)) {\n    newError.stack = joinStacks(newError, originalError);\n  }\n}\n/**\n * Merges properties of the original error with the new error.\n *\n * @param newError - The error object to extend\n * @param originalError - The original error object, if any\n */\n\n\nfunction mergeErrors(newError, originalError) {\n  // Get the original error's keys\n  // NOTE: We specifically exclude properties that we have already set on the new error.\n  // This is _especially_ important for the `stack` property, because this property has\n  // a lazy getter in some environments\n  let keys = getDeepKeys(originalError, protectedProps); // HACK: We have to cast the errors to `any` so we can use symbol indexers.\n  // see https://github.com/Microsoft/TypeScript/issues/1863\n\n  let _newError = newError;\n  let _originalError = originalError;\n\n  for (let key of keys) {\n    if (_newError[key] === undefined) {\n      try {\n        _newError[key] = _originalError[key];\n      } catch (e) {// This property is read-only, so it can't be copied\n      }\n    }\n  }\n}","map":{"version":3,"sources":["../src/extend-error.ts"],"names":[],"mappings":"AAAA,SAAS,gBAAT,QAAiC,mBAAjC;AACA,SAAS,WAAT,EAAsB,eAAtB,EAAuC,UAAvC,EAAmD,cAAnD,QAAyE,SAAzE;AACA,SAAS,WAAT,EAAsB,MAAtB,QAAoC,WAApC;AAGA,MAAM,cAAc,GAA2B,CAAC,MAAD,EAAS,SAAT,EAAoB,OAApB,CAA/C;AAEA;;;;;;AAMG;;AACH,OAAM,SAAU,WAAV,CAAkF,KAAlF,EAA4F,aAA5F,EAA+G,KAA/G,EAAwH;AAC5H,MAAI,QAAQ,GAAG,KAAf;AAEA,EAAA,WAAW,CAAC,QAAD,EAAW,aAAX,CAAX,CAH4H,CAK5H;;AACA,MAAI,aAAa,IAAI,OAAO,aAAP,KAAyB,QAA9C,EAAwD;AACtD,IAAA,WAAW,CAAC,QAAD,EAAW,aAAX,CAAX;AACD,GAR2H,CAU5H;AACA;;;AACA,EAAA,QAAQ,CAAC,MAAT,GAAkB,MAAlB,CAZ4H,CAc5H;AACA;;AACA,MAAI,gBAAJ,EAAsB;AACpB,IAAA,gBAAgB,CAAC,QAAD,CAAhB;AACD,GAlB2H,CAoB5H;AACA;;;AACA,MAAI,KAAK,IAAI,OAAO,KAAP,KAAiB,QAA9B,EAAwC;AACtC,IAAA,MAAM,CAAC,MAAP,CAAc,QAAd,EAAwB,KAAxB;AACD;;AAED,SAAO,QAAP;AACD;AAED;;AAEG;;AACH,SAAS,WAAT,CAAqB,QAArB,EAA0C,aAA1C,EAAmE;AACjE,MAAI,SAAS,GAAG,MAAM,CAAC,wBAAP,CAAgC,QAAhC,EAA0C,OAA1C,CAAhB;;AAEA,MAAI,WAAW,CAAC,SAAD,CAAf,EAA4B;AAC1B,IAAA,cAAc,CAAC,SAAD,EAAY,QAAZ,EAAsB,aAAtB,CAAd;AACD,GAFD,MAGK,IAAI,eAAe,CAAC,SAAD,CAAnB,EAAgC;AACnC,IAAA,QAAQ,CAAC,KAAT,GAAiB,UAAU,CAAC,QAAD,EAAW,aAAX,CAA3B;AACD;AACF;AAED;;;;;AAKG;;;AACH,SAAS,WAAT,CAAqB,QAArB,EAA0C,aAA1C,EAAkE;AAChE;AACA;AACA;AACA;AACA,MAAI,IAAI,GAAG,WAAW,CAAC,aAAD,EAAgB,cAAhB,CAAtB,CALgE,CAOhE;AACA;;AACA,MAAI,SAAS,GAAG,QAAhB;AACA,MAAI,cAAc,GAAG,aAArB;;AAEA,OAAK,IAAI,GAAT,IAAgB,IAAhB,EAAsB;AACpB,QAAI,SAAS,CAAC,GAAD,CAAT,KAAmB,SAAvB,EAAkC;AAChC,UAAI;AACF,QAAA,SAAS,CAAC,GAAD,CAAT,GAAiB,cAAc,CAAC,GAAD,CAA/B;AACD,OAFD,CAGA,OAAO,CAAP,EAAU,CACR;AACD;AACF;AACF;AACF","sourceRoot":"","sourcesContent":["import { addInspectMethod } from \"./isomorphic.node\";\nimport { isLazyStack, isWritableStack, joinStacks, lazyJoinStacks } from \"./stack\";\nimport { getDeepKeys, toJSON } from \"./to-json\";\nconst protectedProps = [\"name\", \"message\", \"stack\"];\n/**\n * Extends the new error with the properties of the original error and the `props` object.\n *\n * @param newError - The error object to extend\n * @param originalError - The original error object, if any\n * @param props - Additional properties to add, if any\n */\nexport function extendError(error, originalError, props) {\n    let onoError = error;\n    extendStack(onoError, originalError);\n    // Copy properties from the original error\n    if (originalError && typeof originalError === \"object\") {\n        mergeErrors(onoError, originalError);\n    }\n    // The default `toJSON` method doesn't output props like `name`, `message`, `stack`, etc.\n    // So replace it with one that outputs every property of the error.\n    onoError.toJSON = toJSON;\n    // On Node.js, add support for the `util.inspect()` method\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (addInspectMethod) {\n        addInspectMethod(onoError);\n    }\n    // Finally, copy custom properties that were specified by the user.\n    // These props OVERWRITE any previous props\n    if (props && typeof props === \"object\") {\n        Object.assign(onoError, props);\n    }\n    return onoError;\n}\n/**\n * Extend the error stack to include its cause\n */\nfunction extendStack(newError, originalError) {\n    let stackProp = Object.getOwnPropertyDescriptor(newError, \"stack\");\n    if (isLazyStack(stackProp)) {\n        lazyJoinStacks(stackProp, newError, originalError);\n    }\n    else if (isWritableStack(stackProp)) {\n        newError.stack = joinStacks(newError, originalError);\n    }\n}\n/**\n * Merges properties of the original error with the new error.\n *\n * @param newError - The error object to extend\n * @param originalError - The original error object, if any\n */\nfunction mergeErrors(newError, originalError) {\n    // Get the original error's keys\n    // NOTE: We specifically exclude properties that we have already set on the new error.\n    // This is _especially_ important for the `stack` property, because this property has\n    // a lazy getter in some environments\n    let keys = getDeepKeys(originalError, protectedProps);\n    // HACK: We have to cast the errors to `any` so we can use symbol indexers.\n    // see https://github.com/Microsoft/TypeScript/issues/1863\n    let _newError = newError;\n    let _originalError = originalError;\n    for (let key of keys) {\n        if (_newError[key] === undefined) {\n            try {\n                _newError[key] = _originalError[key];\n            }\n            catch (e) {\n                // This property is read-only, so it can't be copied\n            }\n        }\n    }\n}\n//# sourceMappingURL=extend-error.js.map"]},"metadata":{},"sourceType":"module"}