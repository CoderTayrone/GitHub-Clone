{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.confirmInstallInstance = exports.getSourceOrigin = exports.isLocalOrURLPath = exports.isLocalPath = exports.isUrlPath = exports.instanceIdExists = exports.promptForRepeatInstance = exports.promptForOfficialExtension = exports.confirmExtensionVersion = exports.getExtensionSourceFromName = exports.createSourceFromLocation = exports.publishExtensionVersionFromLocalSource = exports.ensureExtensionsApiEnabled = exports.promptForValidInstanceId = exports.validateSpec = exports.validateCommandLineParams = exports.populateDefaultParams = exports.substituteParams = exports.getFirebaseProjectParams = exports.getDBInstanceFromURL = exports.resourceTypeToNiceName = exports.AUTOPOULATED_PARAM_PLACEHOLDERS = exports.EXTENSIONS_BUCKET_NAME = exports.URL_REGEX = exports.logPrefix = exports.SourceOrigin = exports.SpecParamType = void 0;\n\nconst _ = require(\"lodash\");\n\nconst clc = require(\"cli-color\");\n\nconst ora = require(\"ora\");\n\nconst semver = require(\"semver\");\n\nconst marked = require(\"marked\");\n\nconst TerminalRenderer = require(\"marked-terminal\");\n\nmarked.setOptions({\n  renderer: new TerminalRenderer()\n});\n\nconst api_1 = require(\"../api\");\n\nconst archiveDirectory_1 = require(\"../archiveDirectory\");\n\nconst utils_1 = require(\"./utils\");\n\nconst functionsConfig_1 = require(\"../functionsConfig\");\n\nconst resolveSource_1 = require(\"./resolveSource\");\n\nconst error_1 = require(\"../error\");\n\nconst askUserForParam_1 = require(\"./askUserForParam\");\n\nconst ensureApiEnabled_1 = require(\"../ensureApiEnabled\");\n\nconst storage_1 = require(\"../gcp/storage\");\n\nconst projectUtils_1 = require(\"../projectUtils\");\n\nconst extensionsApi_1 = require(\"./extensionsApi\");\n\nconst localHelper_1 = require(\"./localHelper\");\n\nconst prompt_1 = require(\"../prompt\");\n\nconst logger_1 = require(\"../logger\");\n\nconst utils_2 = require(\"../utils\");\n\nconst changelog_1 = require(\"./changelog\");\n\nvar SpecParamType;\n\n(function (SpecParamType) {\n  SpecParamType[\"SELECT\"] = \"select\";\n  SpecParamType[\"MULTISELECT\"] = \"multiSelect\";\n  SpecParamType[\"STRING\"] = \"string\";\n  SpecParamType[\"SELECTRESOURCE\"] = \"selectResource\";\n})(SpecParamType = exports.SpecParamType || (exports.SpecParamType = {}));\n\nvar SourceOrigin;\n\n(function (SourceOrigin) {\n  SourceOrigin[\"OFFICIAL_EXTENSION\"] = \"official extension\";\n  SourceOrigin[\"LOCAL\"] = \"unpublished extension (local source)\";\n  SourceOrigin[\"PUBLISHED_EXTENSION\"] = \"published extension\";\n  SourceOrigin[\"PUBLISHED_EXTENSION_VERSION\"] = \"specific version of a published extension\";\n  SourceOrigin[\"URL\"] = \"unpublished extension (URL source)\";\n  SourceOrigin[\"OFFICIAL_EXTENSION_VERSION\"] = \"specific version of an official extension\";\n})(SourceOrigin = exports.SourceOrigin || (exports.SourceOrigin = {}));\n\nexports.logPrefix = \"extensions\";\nconst VALID_LICENSES = [\"apache-2.0\"];\nexports.URL_REGEX = /^https:/;\nexports.EXTENSIONS_BUCKET_NAME = utils_2.envOverride(\"FIREBASE_EXTENSIONS_UPLOAD_BUCKET\", \"firebase-ext-eap-uploads\");\nconst AUTOPOPULATED_PARAM_NAMES = [\"PROJECT_ID\", \"STORAGE_BUCKET\", \"EXT_INSTANCE_ID\", \"DATABASE_INSTANCE\", \"DATABASE_URL\"];\nexports.AUTOPOULATED_PARAM_PLACEHOLDERS = {\n  PROJECT_ID: \"project-id\",\n  STORAGE_BUCKET: \"project-id.appspot.com\",\n  EXT_INSTANCE_ID: \"extension-id\",\n  DATABASE_INSTANCE: \"project-id-default-rtdb\",\n  DATABASE_URL: \"https://project-id-default-rtdb.firebaseio.com\"\n};\nexports.resourceTypeToNiceName = {\n  \"firebaseextensions.v1beta.function\": \"Cloud Function\"\n};\n\nfunction getDBInstanceFromURL(databaseUrl = \"\") {\n  const instanceRegex = new RegExp(\"(?:https://)(.*)(?:.firebaseio.com)\");\n  const matches = databaseUrl.match(instanceRegex);\n\n  if (matches && matches.length > 1) {\n    return matches[1];\n  }\n\n  return \"\";\n}\n\nexports.getDBInstanceFromURL = getDBInstanceFromURL;\n\nasync function getFirebaseProjectParams(projectId) {\n  const body = await functionsConfig_1.getFirebaseConfig({\n    project: projectId\n  });\n  const FIREBASE_CONFIG = JSON.stringify({\n    projectId: body.projectId,\n    databaseURL: body.databaseURL,\n    storageBucket: body.storageBucket\n  });\n  return {\n    PROJECT_ID: body.projectId,\n    DATABASE_URL: body.databaseURL,\n    STORAGE_BUCKET: body.storageBucket,\n    FIREBASE_CONFIG,\n    DATABASE_INSTANCE: getDBInstanceFromURL(body.databaseURL)\n  };\n}\n\nexports.getFirebaseProjectParams = getFirebaseProjectParams;\n\nfunction substituteParams(original, params) {\n  const startingString = JSON.stringify(original);\n\n  const applySubstitution = (str, paramVal, paramKey) => {\n    const exp1 = new RegExp(\"\\\\$\\\\{\" + paramKey + \"\\\\}\", \"g\");\n    const exp2 = new RegExp(\"\\\\$\\\\{param:\" + paramKey + \"\\\\}\", \"g\");\n    const regexes = [exp1, exp2];\n\n    const substituteRegexMatches = (unsubstituted, regex) => {\n      return unsubstituted.replace(regex, paramVal);\n    };\n\n    return _.reduce(regexes, substituteRegexMatches, str);\n  };\n\n  return JSON.parse(_.reduce(params, applySubstitution, startingString));\n}\n\nexports.substituteParams = substituteParams;\n\nfunction populateDefaultParams(paramVars, paramSpecs) {\n  const newParams = paramVars;\n\n  for (const param of paramSpecs) {\n    if (!paramVars[param.param]) {\n      if (param.default != undefined) {\n        newParams[param.param] = param.default;\n      } else if (param.required) {\n        throw new error_1.FirebaseError(`${param.param} has not been set in the given params file` + \" and there is no default available. Please set this variable before installing again.\");\n      }\n    }\n  }\n\n  return newParams;\n}\n\nexports.populateDefaultParams = populateDefaultParams;\n\nfunction validateCommandLineParams(envVars, paramSpec) {\n  const paramNames = paramSpec.map(p => p.param);\n  const misnamedParams = Object.keys(envVars).filter(key => {\n    return !paramNames.includes(key) && !AUTOPOPULATED_PARAM_NAMES.includes(key);\n  });\n\n  if (misnamedParams.length) {\n    logger_1.logger.warn(\"Warning: The following params were specified in your env file but do not exist in the extension spec: \" + `${misnamedParams.join(\", \")}.`);\n  }\n\n  let allParamsValid = true;\n\n  for (const param of paramSpec) {\n    if (!askUserForParam_1.checkResponse(envVars[param.param], param)) {\n      allParamsValid = false;\n    }\n  }\n\n  if (!allParamsValid) {\n    throw new error_1.FirebaseError(`Some param values are not valid. Please check your params file.`);\n  }\n}\n\nexports.validateCommandLineParams = validateCommandLineParams;\n\nfunction validateSpec(spec) {\n  const errors = [];\n\n  if (!spec.name) {\n    errors.push(\"extension.yaml is missing required field: name\");\n  }\n\n  if (!spec.specVersion) {\n    errors.push(\"extension.yaml is missing required field: specVersion\");\n  }\n\n  if (!spec.version) {\n    errors.push(\"extension.yaml is missing required field: version\");\n  }\n\n  if (!spec.license) {\n    errors.push(\"extension.yaml is missing required field: license\");\n  } else {\n    const formattedLicense = String(spec.license).toLocaleLowerCase();\n\n    if (!VALID_LICENSES.includes(formattedLicense)) {\n      errors.push(`license field in extension.yaml is invalid. Valid value(s): ${VALID_LICENSES.join(\", \")}`);\n    }\n  }\n\n  if (!spec.resources) {\n    errors.push(\"Resources field must contain at least one resource\");\n  } else {\n    for (const resource of spec.resources) {\n      if (!resource.name) {\n        errors.push(\"Resource is missing required field: name\");\n      }\n\n      if (!resource.type) {\n        errors.push(`Resource${resource.name ? ` ${resource.name}` : \"\"} is missing required field: type`);\n      }\n    }\n  }\n\n  for (const api of spec.apis || []) {\n    if (!api.apiName) {\n      errors.push(\"API is missing required field: apiName\");\n    }\n  }\n\n  for (const role of spec.roles || []) {\n    if (!role.role) {\n      errors.push(\"Role is missing required field: role\");\n    }\n  }\n\n  for (const param of spec.params || []) {\n    if (!param.param) {\n      errors.push(\"Param is missing required field: param\");\n    }\n\n    if (!param.label) {\n      errors.push(`Param${param.param ? ` ${param.param}` : \"\"} is missing required field: label`);\n    }\n\n    if (param.type && !_.includes(SpecParamType, param.type)) {\n      errors.push(`Invalid type ${param.type} for param${param.param ? ` ${param.param}` : \"\"}. Valid types are ${_.values(SpecParamType).join(\", \")}`);\n    }\n\n    if (!param.type || param.type == SpecParamType.STRING) {\n      if (param.options) {\n        errors.push(`Param${param.param ? ` ${param.param}` : \"\"} cannot have options because it is type STRING`);\n      }\n    }\n\n    if (param.type && (param.type == SpecParamType.SELECT || param.type == SpecParamType.MULTISELECT)) {\n      if (param.validationRegex) {\n        errors.push(`Param${param.param ? ` ${param.param}` : \"\"} cannot have validationRegex because it is type ${param.type}`);\n      }\n\n      if (!param.options) {\n        errors.push(`Param${param.param ? ` ${param.param}` : \"\"} requires options because it is type ${param.type}`);\n      }\n\n      for (const opt of param.options || []) {\n        if (opt.value == undefined) {\n          errors.push(`Option for param${param.param ? ` ${param.param}` : \"\"} is missing required field: value`);\n        }\n      }\n    }\n\n    if (param.type && param.type == SpecParamType.SELECTRESOURCE) {\n      if (!param.resourceType) {\n        errors.push(`Param${param.param ? ` ${param.param}` : \"\"} must have resourceType because it is type ${param.type}`);\n      }\n    }\n  }\n\n  if (errors.length) {\n    const formatted = errors.map(error => `  - ${error}`);\n    const message = `The extension.yaml has the following errors: \\n${formatted.join(\"\\n\")}`;\n    throw new error_1.FirebaseError(message);\n  }\n}\n\nexports.validateSpec = validateSpec;\n\nasync function promptForValidInstanceId(instanceId) {\n  let instanceIdIsValid = false;\n  let newInstanceId = \"\";\n  const instanceIdRegex = /^[a-z][a-z\\d\\-]*[a-z\\d]$/;\n\n  while (!instanceIdIsValid) {\n    newInstanceId = await prompt_1.promptOnce({\n      type: \"input\",\n      default: instanceId,\n      message: `Please enter a new name for this instance:`\n    });\n\n    if (newInstanceId.length <= 6 || 45 <= newInstanceId.length) {\n      logger_1.logger.info(\"Invalid instance ID. Instance ID must be between 6 and 45 characters.\");\n    } else if (!instanceIdRegex.test(newInstanceId)) {\n      logger_1.logger.info(\"Invalid instance ID. Instance ID must start with a lowercase letter, \" + \"end with a lowercase letter or number, and only contain lowercase letters, numbers, or -\");\n    } else {\n      instanceIdIsValid = true;\n    }\n  }\n\n  return newInstanceId;\n}\n\nexports.promptForValidInstanceId = promptForValidInstanceId;\n\nasync function ensureExtensionsApiEnabled(options) {\n  const projectId = projectUtils_1.needProjectId(options);\n  return await ensureApiEnabled_1.ensure(projectId, \"firebaseextensions.googleapis.com\", \"extensions\", options.markdown);\n}\n\nexports.ensureExtensionsApiEnabled = ensureExtensionsApiEnabled;\n\nasync function archiveAndUploadSource(extPath, bucketName) {\n  const zippedSource = await archiveDirectory_1.archiveDirectory(extPath, {\n    type: \"zip\",\n    ignore: [\"node_modules\", \".git\"]\n  });\n  const res = await storage_1.uploadObject(zippedSource, bucketName);\n  return `/${res.bucket}/${res.object}`;\n}\n\nasync function publishExtensionVersionFromLocalSource(publisherId, extensionId, rootDirectory) {\n  const extensionSpec = await localHelper_1.getLocalExtensionSpec(rootDirectory);\n\n  if (extensionSpec.name != extensionId) {\n    throw new error_1.FirebaseError(`Extension ID '${clc.bold(extensionId)}' does not match the name in extension.yaml '${clc.bold(extensionSpec.name)}'.`);\n  }\n\n  const subbedSpec = JSON.parse(JSON.stringify(extensionSpec));\n  subbedSpec.params = substituteParams(extensionSpec.params || [], exports.AUTOPOULATED_PARAM_PLACEHOLDERS);\n  validateSpec(subbedSpec);\n  let extension;\n\n  try {\n    extension = await extensionsApi_1.getExtension(`${publisherId}/${extensionId}`);\n  } catch (err) {}\n\n  let notes;\n\n  try {\n    const changes = changelog_1.getLocalChangelog(rootDirectory);\n    notes = changes[extensionSpec.version];\n  } catch (err) {\n    throw new error_1.FirebaseError(\"No CHANGELOG.md file found. \" + \"Please create one and add an entry for this version. \" + marked(\"See https://firebase.google.com/docs/extensions/alpha/create-user-docs#writing-changelog for more details.\"));\n  }\n\n  if (!notes && extension) {\n    throw new error_1.FirebaseError(`No entry for version ${extensionSpec.version} found in CHANGELOG.md. ` + \"Please add one so users know what has changed in this version. \" + marked(\"See https://firebase.google.com/docs/extensions/alpha/create-user-docs#writing-changelog for more details.\"));\n  }\n\n  const consent = await confirmExtensionVersion(publisherId, extensionId, extensionSpec.version, notes);\n\n  if (!consent) {\n    return;\n  }\n\n  if (extension && extension.latestVersion && semver.lt(extensionSpec.version, extension.latestVersion)) {\n    throw new error_1.FirebaseError(`The version you are trying to publish (${clc.bold(extensionSpec.version)}) is lower than the current version (${clc.bold(extension.latestVersion)}) for the extension '${clc.bold(`${publisherId}/${extensionId}`)}'. Please make sure this version is greater than the current version (${clc.bold(extension.latestVersion)}) inside of extension.yaml.\\n`);\n  } else if (extension && extension.latestVersion && semver.eq(extensionSpec.version, extension.latestVersion)) {\n    throw new error_1.FirebaseError(`The version you are trying to publish (${clc.bold(extensionSpec.version)}) already exists for the extension '${clc.bold(`${publisherId}/${extensionId}`)}'. Please increment the version inside of extension.yaml.\\n`);\n  }\n\n  const ref = `${publisherId}/${extensionId}@${extensionSpec.version}`;\n  let packageUri;\n  let objectPath = \"\";\n  const uploadSpinner = ora.default(\" Archiving and uploading extension source code\");\n\n  try {\n    uploadSpinner.start();\n    objectPath = await archiveAndUploadSource(rootDirectory, exports.EXTENSIONS_BUCKET_NAME);\n    uploadSpinner.succeed(\" Uploaded extension source code\");\n    packageUri = api_1.storageOrigin + objectPath + \"?alt=media\";\n  } catch (err) {\n    uploadSpinner.fail();\n    throw err;\n  }\n\n  const publishSpinner = ora.default(`Publishing ${clc.bold(ref)}`);\n  let res;\n\n  try {\n    publishSpinner.start();\n    res = await extensionsApi_1.publishExtensionVersion(ref, packageUri);\n    publishSpinner.succeed(` Successfully published ${clc.bold(ref)}`);\n  } catch (err) {\n    publishSpinner.fail();\n\n    if (err.status == 404) {\n      throw new error_1.FirebaseError(marked(`Couldn't find publisher ID '${clc.bold(publisherId)}'. Please ensure that you have registered this ID. To register as a publisher, you can check out the [Firebase documentation](https://firebase.google.com/docs/extensions/alpha/share#register_as_an_extensions_publisher) for step-by-step instructions.`));\n    }\n\n    throw err;\n  }\n\n  await deleteUploadedSource(objectPath);\n  return res;\n}\n\nexports.publishExtensionVersionFromLocalSource = publishExtensionVersionFromLocalSource;\n\nasync function createSourceFromLocation(projectId, sourceUri) {\n  let packageUri;\n  let extensionRoot;\n  let objectPath = \"\";\n\n  if (!exports.URL_REGEX.test(sourceUri)) {\n    const uploadSpinner = ora.default(\" Archiving and uploading extension source code\");\n\n    try {\n      uploadSpinner.start();\n      objectPath = await archiveAndUploadSource(sourceUri, exports.EXTENSIONS_BUCKET_NAME);\n      uploadSpinner.succeed(\" Uploaded extension source code\");\n      packageUri = api_1.storageOrigin + objectPath + \"?alt=media\";\n      extensionRoot = \"/\";\n    } catch (err) {\n      uploadSpinner.fail();\n      throw err;\n    }\n  } else {\n    [packageUri, extensionRoot] = sourceUri.split(\"#\");\n  }\n\n  const res = await extensionsApi_1.createSource(projectId, packageUri, extensionRoot);\n  logger_1.logger.debug(\"Created new Extension Source %s\", res.name);\n  await deleteUploadedSource(objectPath);\n  return res;\n}\n\nexports.createSourceFromLocation = createSourceFromLocation;\n\nasync function deleteUploadedSource(objectPath) {\n  if (objectPath.length) {\n    try {\n      await storage_1.deleteObject(objectPath);\n      logger_1.logger.debug(\"Cleaned up uploaded source archive\");\n    } catch (err) {\n      logger_1.logger.debug(\"Unable to clean up uploaded source archive\");\n    }\n  }\n}\n\nasync function getExtensionSourceFromName(extensionName) {\n  const officialExtensionRegex = /^[a-zA-Z\\-]+[0-9@.]*$/;\n  const existingSourceRegex = /projects\\/.+\\/sources\\/.+/;\n\n  if (officialExtensionRegex.test(extensionName)) {\n    const [name, version] = extensionName.split(\"@\");\n    const registryEntry = await resolveSource_1.resolveRegistryEntry(name);\n    const sourceUrl = resolveSource_1.resolveSourceUrl(registryEntry, name, version);\n    return await extensionsApi_1.getSource(sourceUrl);\n  } else if (existingSourceRegex.test(extensionName)) {\n    logger_1.logger.info(`Fetching the source \"${extensionName}\"...`);\n    return await extensionsApi_1.getSource(extensionName);\n  }\n\n  throw new error_1.FirebaseError(`Could not find an extension named '${extensionName}'. `);\n}\n\nexports.getExtensionSourceFromName = getExtensionSourceFromName;\n\nasync function confirmExtensionVersion(publisherId, extensionId, versionId, releaseNotes) {\n  const releaseNotesMessage = releaseNotes ? ` Release notes for this version:\\n${marked(releaseNotes)}\\n` : \"\\n\";\n  const message = `You are about to publish version ${clc.green(versionId)} of ${clc.green(`${publisherId}/${extensionId}`)} to Firebase's registry of extensions.${releaseNotesMessage}` + \"Once an extension version is published, it cannot be changed. If you wish to make changes after publishing, you will need to publish a new version.\\n\\n\" + \"Do you wish to continue?\";\n  return await prompt_1.promptOnce({\n    type: \"confirm\",\n    message,\n    default: false\n  });\n}\n\nexports.confirmExtensionVersion = confirmExtensionVersion;\n\nasync function promptForOfficialExtension(message) {\n  const officialExts = await resolveSource_1.getExtensionRegistry(true);\n  return await prompt_1.promptOnce({\n    name: \"input\",\n    type: \"list\",\n    message,\n    choices: utils_1.convertOfficialExtensionsToList(officialExts),\n    pageSize: _.size(officialExts)\n  });\n}\n\nexports.promptForOfficialExtension = promptForOfficialExtension;\n\nasync function promptForRepeatInstance(projectName, extensionName) {\n  const message = `An extension with the ID '${clc.bold(extensionName)}' already exists in the project '${clc.bold(projectName)}'.\\n` + `Do you want to proceed with installing another instance of extension '${clc.bold(extensionName)}' in this project?`;\n  return await prompt_1.promptOnce({\n    type: \"confirm\",\n    message\n  });\n}\n\nexports.promptForRepeatInstance = promptForRepeatInstance;\n\nasync function instanceIdExists(projectId, instanceId) {\n  const instanceRes = await extensionsApi_1.getInstance(projectId, instanceId, {\n    resolveOnHTTPError: true\n  });\n\n  if (instanceRes.error) {\n    if (_.get(instanceRes, \"error.code\") === 404) {\n      return false;\n    }\n\n    const msg = \"Unexpected error when checking if instance ID exists: \" + _.get(instanceRes, \"error.message\");\n\n    throw new error_1.FirebaseError(msg, {\n      original: instanceRes.error\n    });\n  }\n\n  return true;\n}\n\nexports.instanceIdExists = instanceIdExists;\n\nfunction isUrlPath(extInstallPath) {\n  return exports.URL_REGEX.test(extInstallPath);\n}\n\nexports.isUrlPath = isUrlPath;\n\nfunction isLocalPath(extInstallPath) {\n  const trimmedPath = extInstallPath.trim();\n  return trimmedPath.startsWith(\"~/\") || trimmedPath.startsWith(\"./\") || trimmedPath.startsWith(\"../\") || trimmedPath.startsWith(\"/\") || [\".\", \"..\"].includes(trimmedPath);\n}\n\nexports.isLocalPath = isLocalPath;\n\nfunction isLocalOrURLPath(extInstallPath) {\n  return isLocalPath(extInstallPath) || isUrlPath(extInstallPath);\n}\n\nexports.isLocalOrURLPath = isLocalOrURLPath;\n\nfunction getSourceOrigin(sourceOrVersion) {\n  if (isLocalPath(sourceOrVersion)) {\n    return SourceOrigin.LOCAL;\n  }\n\n  if (isUrlPath(sourceOrVersion)) {\n    return SourceOrigin.URL;\n  }\n\n  if (sourceOrVersion.includes(\"/\")) {\n    let ref;\n\n    try {\n      ref = extensionsApi_1.parseRef(sourceOrVersion);\n    } catch (err) {}\n\n    if (ref && ref.publisherId && ref.extensionId && !ref.version) {\n      return SourceOrigin.PUBLISHED_EXTENSION;\n    } else if (ref && ref.publisherId && ref.extensionId && ref.version) {\n      return SourceOrigin.PUBLISHED_EXTENSION_VERSION;\n    }\n  }\n\n  throw new error_1.FirebaseError(`Could not find source '${clc.bold(sourceOrVersion)}'. Check to make sure the source is correct, and then please try again.`);\n}\n\nexports.getSourceOrigin = getSourceOrigin;\n\nasync function confirmInstallInstance(defaultOption) {\n  const message = `Would you like to continue installing this extension?`;\n  return await prompt_1.promptOnce({\n    type: \"confirm\",\n    message,\n    default: defaultOption\n  });\n}\n\nexports.confirmInstallInstance = confirmInstallInstance;","map":{"version":3,"sources":["/home/dev/Documentos/Projects/github-clone/node_modules/firebase-tools/lib/extensions/extensionsHelper.js"],"names":["Object","defineProperty","exports","value","confirmInstallInstance","getSourceOrigin","isLocalOrURLPath","isLocalPath","isUrlPath","instanceIdExists","promptForRepeatInstance","promptForOfficialExtension","confirmExtensionVersion","getExtensionSourceFromName","createSourceFromLocation","publishExtensionVersionFromLocalSource","ensureExtensionsApiEnabled","promptForValidInstanceId","validateSpec","validateCommandLineParams","populateDefaultParams","substituteParams","getFirebaseProjectParams","getDBInstanceFromURL","resourceTypeToNiceName","AUTOPOULATED_PARAM_PLACEHOLDERS","EXTENSIONS_BUCKET_NAME","URL_REGEX","logPrefix","SourceOrigin","SpecParamType","_","require","clc","ora","semver","marked","TerminalRenderer","setOptions","renderer","api_1","archiveDirectory_1","utils_1","functionsConfig_1","resolveSource_1","error_1","askUserForParam_1","ensureApiEnabled_1","storage_1","projectUtils_1","extensionsApi_1","localHelper_1","prompt_1","logger_1","utils_2","changelog_1","VALID_LICENSES","envOverride","AUTOPOPULATED_PARAM_NAMES","PROJECT_ID","STORAGE_BUCKET","EXT_INSTANCE_ID","DATABASE_INSTANCE","DATABASE_URL","databaseUrl","instanceRegex","RegExp","matches","match","length","projectId","body","getFirebaseConfig","project","FIREBASE_CONFIG","JSON","stringify","databaseURL","storageBucket","original","params","startingString","applySubstitution","str","paramVal","paramKey","exp1","exp2","regexes","substituteRegexMatches","unsubstituted","regex","replace","reduce","parse","paramVars","paramSpecs","newParams","param","default","undefined","required","FirebaseError","envVars","paramSpec","paramNames","map","p","misnamedParams","keys","filter","key","includes","logger","warn","join","allParamsValid","checkResponse","spec","errors","name","push","specVersion","version","license","formattedLicense","String","toLocaleLowerCase","resources","resource","type","api","apis","apiName","role","roles","label","values","STRING","options","SELECT","MULTISELECT","validationRegex","opt","SELECTRESOURCE","resourceType","formatted","error","message","instanceId","instanceIdIsValid","newInstanceId","instanceIdRegex","promptOnce","info","test","needProjectId","ensure","markdown","archiveAndUploadSource","extPath","bucketName","zippedSource","archiveDirectory","ignore","res","uploadObject","bucket","object","publisherId","extensionId","rootDirectory","extensionSpec","getLocalExtensionSpec","bold","subbedSpec","extension","getExtension","err","notes","changes","getLocalChangelog","consent","latestVersion","lt","eq","ref","packageUri","objectPath","uploadSpinner","start","succeed","storageOrigin","fail","publishSpinner","publishExtensionVersion","status","deleteUploadedSource","sourceUri","extensionRoot","split","createSource","debug","deleteObject","extensionName","officialExtensionRegex","existingSourceRegex","registryEntry","resolveRegistryEntry","sourceUrl","resolveSourceUrl","getSource","versionId","releaseNotes","releaseNotesMessage","green","officialExts","getExtensionRegistry","choices","convertOfficialExtensionsToList","pageSize","size","projectName","instanceRes","getInstance","resolveOnHTTPError","get","msg","extInstallPath","trimmedPath","trim","startsWith","sourceOrVersion","LOCAL","URL","parseRef","PUBLISHED_EXTENSION","PUBLISHED_EXTENSION_VERSION","defaultOption"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.confirmInstallInstance = exports.getSourceOrigin = exports.isLocalOrURLPath = exports.isLocalPath = exports.isUrlPath = exports.instanceIdExists = exports.promptForRepeatInstance = exports.promptForOfficialExtension = exports.confirmExtensionVersion = exports.getExtensionSourceFromName = exports.createSourceFromLocation = exports.publishExtensionVersionFromLocalSource = exports.ensureExtensionsApiEnabled = exports.promptForValidInstanceId = exports.validateSpec = exports.validateCommandLineParams = exports.populateDefaultParams = exports.substituteParams = exports.getFirebaseProjectParams = exports.getDBInstanceFromURL = exports.resourceTypeToNiceName = exports.AUTOPOULATED_PARAM_PLACEHOLDERS = exports.EXTENSIONS_BUCKET_NAME = exports.URL_REGEX = exports.logPrefix = exports.SourceOrigin = exports.SpecParamType = void 0;\nconst _ = require(\"lodash\");\nconst clc = require(\"cli-color\");\nconst ora = require(\"ora\");\nconst semver = require(\"semver\");\nconst marked = require(\"marked\");\nconst TerminalRenderer = require(\"marked-terminal\");\nmarked.setOptions({\n    renderer: new TerminalRenderer(),\n});\nconst api_1 = require(\"../api\");\nconst archiveDirectory_1 = require(\"../archiveDirectory\");\nconst utils_1 = require(\"./utils\");\nconst functionsConfig_1 = require(\"../functionsConfig\");\nconst resolveSource_1 = require(\"./resolveSource\");\nconst error_1 = require(\"../error\");\nconst askUserForParam_1 = require(\"./askUserForParam\");\nconst ensureApiEnabled_1 = require(\"../ensureApiEnabled\");\nconst storage_1 = require(\"../gcp/storage\");\nconst projectUtils_1 = require(\"../projectUtils\");\nconst extensionsApi_1 = require(\"./extensionsApi\");\nconst localHelper_1 = require(\"./localHelper\");\nconst prompt_1 = require(\"../prompt\");\nconst logger_1 = require(\"../logger\");\nconst utils_2 = require(\"../utils\");\nconst changelog_1 = require(\"./changelog\");\nvar SpecParamType;\n(function (SpecParamType) {\n    SpecParamType[\"SELECT\"] = \"select\";\n    SpecParamType[\"MULTISELECT\"] = \"multiSelect\";\n    SpecParamType[\"STRING\"] = \"string\";\n    SpecParamType[\"SELECTRESOURCE\"] = \"selectResource\";\n})(SpecParamType = exports.SpecParamType || (exports.SpecParamType = {}));\nvar SourceOrigin;\n(function (SourceOrigin) {\n    SourceOrigin[\"OFFICIAL_EXTENSION\"] = \"official extension\";\n    SourceOrigin[\"LOCAL\"] = \"unpublished extension (local source)\";\n    SourceOrigin[\"PUBLISHED_EXTENSION\"] = \"published extension\";\n    SourceOrigin[\"PUBLISHED_EXTENSION_VERSION\"] = \"specific version of a published extension\";\n    SourceOrigin[\"URL\"] = \"unpublished extension (URL source)\";\n    SourceOrigin[\"OFFICIAL_EXTENSION_VERSION\"] = \"specific version of an official extension\";\n})(SourceOrigin = exports.SourceOrigin || (exports.SourceOrigin = {}));\nexports.logPrefix = \"extensions\";\nconst VALID_LICENSES = [\"apache-2.0\"];\nexports.URL_REGEX = /^https:/;\nexports.EXTENSIONS_BUCKET_NAME = utils_2.envOverride(\"FIREBASE_EXTENSIONS_UPLOAD_BUCKET\", \"firebase-ext-eap-uploads\");\nconst AUTOPOPULATED_PARAM_NAMES = [\n    \"PROJECT_ID\",\n    \"STORAGE_BUCKET\",\n    \"EXT_INSTANCE_ID\",\n    \"DATABASE_INSTANCE\",\n    \"DATABASE_URL\",\n];\nexports.AUTOPOULATED_PARAM_PLACEHOLDERS = {\n    PROJECT_ID: \"project-id\",\n    STORAGE_BUCKET: \"project-id.appspot.com\",\n    EXT_INSTANCE_ID: \"extension-id\",\n    DATABASE_INSTANCE: \"project-id-default-rtdb\",\n    DATABASE_URL: \"https://project-id-default-rtdb.firebaseio.com\",\n};\nexports.resourceTypeToNiceName = {\n    \"firebaseextensions.v1beta.function\": \"Cloud Function\",\n};\nfunction getDBInstanceFromURL(databaseUrl = \"\") {\n    const instanceRegex = new RegExp(\"(?:https://)(.*)(?:.firebaseio.com)\");\n    const matches = databaseUrl.match(instanceRegex);\n    if (matches && matches.length > 1) {\n        return matches[1];\n    }\n    return \"\";\n}\nexports.getDBInstanceFromURL = getDBInstanceFromURL;\nasync function getFirebaseProjectParams(projectId) {\n    const body = await functionsConfig_1.getFirebaseConfig({ project: projectId });\n    const FIREBASE_CONFIG = JSON.stringify({\n        projectId: body.projectId,\n        databaseURL: body.databaseURL,\n        storageBucket: body.storageBucket,\n    });\n    return {\n        PROJECT_ID: body.projectId,\n        DATABASE_URL: body.databaseURL,\n        STORAGE_BUCKET: body.storageBucket,\n        FIREBASE_CONFIG,\n        DATABASE_INSTANCE: getDBInstanceFromURL(body.databaseURL),\n    };\n}\nexports.getFirebaseProjectParams = getFirebaseProjectParams;\nfunction substituteParams(original, params) {\n    const startingString = JSON.stringify(original);\n    const applySubstitution = (str, paramVal, paramKey) => {\n        const exp1 = new RegExp(\"\\\\$\\\\{\" + paramKey + \"\\\\}\", \"g\");\n        const exp2 = new RegExp(\"\\\\$\\\\{param:\" + paramKey + \"\\\\}\", \"g\");\n        const regexes = [exp1, exp2];\n        const substituteRegexMatches = (unsubstituted, regex) => {\n            return unsubstituted.replace(regex, paramVal);\n        };\n        return _.reduce(regexes, substituteRegexMatches, str);\n    };\n    return JSON.parse(_.reduce(params, applySubstitution, startingString));\n}\nexports.substituteParams = substituteParams;\nfunction populateDefaultParams(paramVars, paramSpecs) {\n    const newParams = paramVars;\n    for (const param of paramSpecs) {\n        if (!paramVars[param.param]) {\n            if (param.default != undefined) {\n                newParams[param.param] = param.default;\n            }\n            else if (param.required) {\n                throw new error_1.FirebaseError(`${param.param} has not been set in the given params file` +\n                    \" and there is no default available. Please set this variable before installing again.\");\n            }\n        }\n    }\n    return newParams;\n}\nexports.populateDefaultParams = populateDefaultParams;\nfunction validateCommandLineParams(envVars, paramSpec) {\n    const paramNames = paramSpec.map((p) => p.param);\n    const misnamedParams = Object.keys(envVars).filter((key) => {\n        return !paramNames.includes(key) && !AUTOPOPULATED_PARAM_NAMES.includes(key);\n    });\n    if (misnamedParams.length) {\n        logger_1.logger.warn(\"Warning: The following params were specified in your env file but do not exist in the extension spec: \" +\n            `${misnamedParams.join(\", \")}.`);\n    }\n    let allParamsValid = true;\n    for (const param of paramSpec) {\n        if (!askUserForParam_1.checkResponse(envVars[param.param], param)) {\n            allParamsValid = false;\n        }\n    }\n    if (!allParamsValid) {\n        throw new error_1.FirebaseError(`Some param values are not valid. Please check your params file.`);\n    }\n}\nexports.validateCommandLineParams = validateCommandLineParams;\nfunction validateSpec(spec) {\n    const errors = [];\n    if (!spec.name) {\n        errors.push(\"extension.yaml is missing required field: name\");\n    }\n    if (!spec.specVersion) {\n        errors.push(\"extension.yaml is missing required field: specVersion\");\n    }\n    if (!spec.version) {\n        errors.push(\"extension.yaml is missing required field: version\");\n    }\n    if (!spec.license) {\n        errors.push(\"extension.yaml is missing required field: license\");\n    }\n    else {\n        const formattedLicense = String(spec.license).toLocaleLowerCase();\n        if (!VALID_LICENSES.includes(formattedLicense)) {\n            errors.push(`license field in extension.yaml is invalid. Valid value(s): ${VALID_LICENSES.join(\", \")}`);\n        }\n    }\n    if (!spec.resources) {\n        errors.push(\"Resources field must contain at least one resource\");\n    }\n    else {\n        for (const resource of spec.resources) {\n            if (!resource.name) {\n                errors.push(\"Resource is missing required field: name\");\n            }\n            if (!resource.type) {\n                errors.push(`Resource${resource.name ? ` ${resource.name}` : \"\"} is missing required field: type`);\n            }\n        }\n    }\n    for (const api of spec.apis || []) {\n        if (!api.apiName) {\n            errors.push(\"API is missing required field: apiName\");\n        }\n    }\n    for (const role of spec.roles || []) {\n        if (!role.role) {\n            errors.push(\"Role is missing required field: role\");\n        }\n    }\n    for (const param of spec.params || []) {\n        if (!param.param) {\n            errors.push(\"Param is missing required field: param\");\n        }\n        if (!param.label) {\n            errors.push(`Param${param.param ? ` ${param.param}` : \"\"} is missing required field: label`);\n        }\n        if (param.type && !_.includes(SpecParamType, param.type)) {\n            errors.push(`Invalid type ${param.type} for param${param.param ? ` ${param.param}` : \"\"}. Valid types are ${_.values(SpecParamType).join(\", \")}`);\n        }\n        if (!param.type || param.type == SpecParamType.STRING) {\n            if (param.options) {\n                errors.push(`Param${param.param ? ` ${param.param}` : \"\"} cannot have options because it is type STRING`);\n            }\n        }\n        if (param.type &&\n            (param.type == SpecParamType.SELECT || param.type == SpecParamType.MULTISELECT)) {\n            if (param.validationRegex) {\n                errors.push(`Param${param.param ? ` ${param.param}` : \"\"} cannot have validationRegex because it is type ${param.type}`);\n            }\n            if (!param.options) {\n                errors.push(`Param${param.param ? ` ${param.param}` : \"\"} requires options because it is type ${param.type}`);\n            }\n            for (const opt of param.options || []) {\n                if (opt.value == undefined) {\n                    errors.push(`Option for param${param.param ? ` ${param.param}` : \"\"} is missing required field: value`);\n                }\n            }\n        }\n        if (param.type && param.type == SpecParamType.SELECTRESOURCE) {\n            if (!param.resourceType) {\n                errors.push(`Param${param.param ? ` ${param.param}` : \"\"} must have resourceType because it is type ${param.type}`);\n            }\n        }\n    }\n    if (errors.length) {\n        const formatted = errors.map((error) => `  - ${error}`);\n        const message = `The extension.yaml has the following errors: \\n${formatted.join(\"\\n\")}`;\n        throw new error_1.FirebaseError(message);\n    }\n}\nexports.validateSpec = validateSpec;\nasync function promptForValidInstanceId(instanceId) {\n    let instanceIdIsValid = false;\n    let newInstanceId = \"\";\n    const instanceIdRegex = /^[a-z][a-z\\d\\-]*[a-z\\d]$/;\n    while (!instanceIdIsValid) {\n        newInstanceId = await prompt_1.promptOnce({\n            type: \"input\",\n            default: instanceId,\n            message: `Please enter a new name for this instance:`,\n        });\n        if (newInstanceId.length <= 6 || 45 <= newInstanceId.length) {\n            logger_1.logger.info(\"Invalid instance ID. Instance ID must be between 6 and 45 characters.\");\n        }\n        else if (!instanceIdRegex.test(newInstanceId)) {\n            logger_1.logger.info(\"Invalid instance ID. Instance ID must start with a lowercase letter, \" +\n                \"end with a lowercase letter or number, and only contain lowercase letters, numbers, or -\");\n        }\n        else {\n            instanceIdIsValid = true;\n        }\n    }\n    return newInstanceId;\n}\nexports.promptForValidInstanceId = promptForValidInstanceId;\nasync function ensureExtensionsApiEnabled(options) {\n    const projectId = projectUtils_1.needProjectId(options);\n    return await ensureApiEnabled_1.ensure(projectId, \"firebaseextensions.googleapis.com\", \"extensions\", options.markdown);\n}\nexports.ensureExtensionsApiEnabled = ensureExtensionsApiEnabled;\nasync function archiveAndUploadSource(extPath, bucketName) {\n    const zippedSource = await archiveDirectory_1.archiveDirectory(extPath, {\n        type: \"zip\",\n        ignore: [\"node_modules\", \".git\"],\n    });\n    const res = await storage_1.uploadObject(zippedSource, bucketName);\n    return `/${res.bucket}/${res.object}`;\n}\nasync function publishExtensionVersionFromLocalSource(publisherId, extensionId, rootDirectory) {\n    const extensionSpec = await localHelper_1.getLocalExtensionSpec(rootDirectory);\n    if (extensionSpec.name != extensionId) {\n        throw new error_1.FirebaseError(`Extension ID '${clc.bold(extensionId)}' does not match the name in extension.yaml '${clc.bold(extensionSpec.name)}'.`);\n    }\n    const subbedSpec = JSON.parse(JSON.stringify(extensionSpec));\n    subbedSpec.params = substituteParams(extensionSpec.params || [], exports.AUTOPOULATED_PARAM_PLACEHOLDERS);\n    validateSpec(subbedSpec);\n    let extension;\n    try {\n        extension = await extensionsApi_1.getExtension(`${publisherId}/${extensionId}`);\n    }\n    catch (err) {\n    }\n    let notes;\n    try {\n        const changes = changelog_1.getLocalChangelog(rootDirectory);\n        notes = changes[extensionSpec.version];\n    }\n    catch (err) {\n        throw new error_1.FirebaseError(\"No CHANGELOG.md file found. \" +\n            \"Please create one and add an entry for this version. \" +\n            marked(\"See https://firebase.google.com/docs/extensions/alpha/create-user-docs#writing-changelog for more details.\"));\n    }\n    if (!notes && extension) {\n        throw new error_1.FirebaseError(`No entry for version ${extensionSpec.version} found in CHANGELOG.md. ` +\n            \"Please add one so users know what has changed in this version. \" +\n            marked(\"See https://firebase.google.com/docs/extensions/alpha/create-user-docs#writing-changelog for more details.\"));\n    }\n    const consent = await confirmExtensionVersion(publisherId, extensionId, extensionSpec.version, notes);\n    if (!consent) {\n        return;\n    }\n    if (extension &&\n        extension.latestVersion &&\n        semver.lt(extensionSpec.version, extension.latestVersion)) {\n        throw new error_1.FirebaseError(`The version you are trying to publish (${clc.bold(extensionSpec.version)}) is lower than the current version (${clc.bold(extension.latestVersion)}) for the extension '${clc.bold(`${publisherId}/${extensionId}`)}'. Please make sure this version is greater than the current version (${clc.bold(extension.latestVersion)}) inside of extension.yaml.\\n`);\n    }\n    else if (extension &&\n        extension.latestVersion &&\n        semver.eq(extensionSpec.version, extension.latestVersion)) {\n        throw new error_1.FirebaseError(`The version you are trying to publish (${clc.bold(extensionSpec.version)}) already exists for the extension '${clc.bold(`${publisherId}/${extensionId}`)}'. Please increment the version inside of extension.yaml.\\n`);\n    }\n    const ref = `${publisherId}/${extensionId}@${extensionSpec.version}`;\n    let packageUri;\n    let objectPath = \"\";\n    const uploadSpinner = ora.default(\" Archiving and uploading extension source code\");\n    try {\n        uploadSpinner.start();\n        objectPath = await archiveAndUploadSource(rootDirectory, exports.EXTENSIONS_BUCKET_NAME);\n        uploadSpinner.succeed(\" Uploaded extension source code\");\n        packageUri = api_1.storageOrigin + objectPath + \"?alt=media\";\n    }\n    catch (err) {\n        uploadSpinner.fail();\n        throw err;\n    }\n    const publishSpinner = ora.default(`Publishing ${clc.bold(ref)}`);\n    let res;\n    try {\n        publishSpinner.start();\n        res = await extensionsApi_1.publishExtensionVersion(ref, packageUri);\n        publishSpinner.succeed(` Successfully published ${clc.bold(ref)}`);\n    }\n    catch (err) {\n        publishSpinner.fail();\n        if (err.status == 404) {\n            throw new error_1.FirebaseError(marked(`Couldn't find publisher ID '${clc.bold(publisherId)}'. Please ensure that you have registered this ID. To register as a publisher, you can check out the [Firebase documentation](https://firebase.google.com/docs/extensions/alpha/share#register_as_an_extensions_publisher) for step-by-step instructions.`));\n        }\n        throw err;\n    }\n    await deleteUploadedSource(objectPath);\n    return res;\n}\nexports.publishExtensionVersionFromLocalSource = publishExtensionVersionFromLocalSource;\nasync function createSourceFromLocation(projectId, sourceUri) {\n    let packageUri;\n    let extensionRoot;\n    let objectPath = \"\";\n    if (!exports.URL_REGEX.test(sourceUri)) {\n        const uploadSpinner = ora.default(\" Archiving and uploading extension source code\");\n        try {\n            uploadSpinner.start();\n            objectPath = await archiveAndUploadSource(sourceUri, exports.EXTENSIONS_BUCKET_NAME);\n            uploadSpinner.succeed(\" Uploaded extension source code\");\n            packageUri = api_1.storageOrigin + objectPath + \"?alt=media\";\n            extensionRoot = \"/\";\n        }\n        catch (err) {\n            uploadSpinner.fail();\n            throw err;\n        }\n    }\n    else {\n        [packageUri, extensionRoot] = sourceUri.split(\"#\");\n    }\n    const res = await extensionsApi_1.createSource(projectId, packageUri, extensionRoot);\n    logger_1.logger.debug(\"Created new Extension Source %s\", res.name);\n    await deleteUploadedSource(objectPath);\n    return res;\n}\nexports.createSourceFromLocation = createSourceFromLocation;\nasync function deleteUploadedSource(objectPath) {\n    if (objectPath.length) {\n        try {\n            await storage_1.deleteObject(objectPath);\n            logger_1.logger.debug(\"Cleaned up uploaded source archive\");\n        }\n        catch (err) {\n            logger_1.logger.debug(\"Unable to clean up uploaded source archive\");\n        }\n    }\n}\nasync function getExtensionSourceFromName(extensionName) {\n    const officialExtensionRegex = /^[a-zA-Z\\-]+[0-9@.]*$/;\n    const existingSourceRegex = /projects\\/.+\\/sources\\/.+/;\n    if (officialExtensionRegex.test(extensionName)) {\n        const [name, version] = extensionName.split(\"@\");\n        const registryEntry = await resolveSource_1.resolveRegistryEntry(name);\n        const sourceUrl = resolveSource_1.resolveSourceUrl(registryEntry, name, version);\n        return await extensionsApi_1.getSource(sourceUrl);\n    }\n    else if (existingSourceRegex.test(extensionName)) {\n        logger_1.logger.info(`Fetching the source \"${extensionName}\"...`);\n        return await extensionsApi_1.getSource(extensionName);\n    }\n    throw new error_1.FirebaseError(`Could not find an extension named '${extensionName}'. `);\n}\nexports.getExtensionSourceFromName = getExtensionSourceFromName;\nasync function confirmExtensionVersion(publisherId, extensionId, versionId, releaseNotes) {\n    const releaseNotesMessage = releaseNotes\n        ? ` Release notes for this version:\\n${marked(releaseNotes)}\\n`\n        : \"\\n\";\n    const message = `You are about to publish version ${clc.green(versionId)} of ${clc.green(`${publisherId}/${extensionId}`)} to Firebase's registry of extensions.${releaseNotesMessage}` +\n        \"Once an extension version is published, it cannot be changed. If you wish to make changes after publishing, you will need to publish a new version.\\n\\n\" +\n        \"Do you wish to continue?\";\n    return await prompt_1.promptOnce({\n        type: \"confirm\",\n        message,\n        default: false,\n    });\n}\nexports.confirmExtensionVersion = confirmExtensionVersion;\nasync function promptForOfficialExtension(message) {\n    const officialExts = await resolveSource_1.getExtensionRegistry(true);\n    return await prompt_1.promptOnce({\n        name: \"input\",\n        type: \"list\",\n        message,\n        choices: utils_1.convertOfficialExtensionsToList(officialExts),\n        pageSize: _.size(officialExts),\n    });\n}\nexports.promptForOfficialExtension = promptForOfficialExtension;\nasync function promptForRepeatInstance(projectName, extensionName) {\n    const message = `An extension with the ID '${clc.bold(extensionName)}' already exists in the project '${clc.bold(projectName)}'.\\n` +\n        `Do you want to proceed with installing another instance of extension '${clc.bold(extensionName)}' in this project?`;\n    return await prompt_1.promptOnce({\n        type: \"confirm\",\n        message,\n    });\n}\nexports.promptForRepeatInstance = promptForRepeatInstance;\nasync function instanceIdExists(projectId, instanceId) {\n    const instanceRes = await extensionsApi_1.getInstance(projectId, instanceId, {\n        resolveOnHTTPError: true,\n    });\n    if (instanceRes.error) {\n        if (_.get(instanceRes, \"error.code\") === 404) {\n            return false;\n        }\n        const msg = \"Unexpected error when checking if instance ID exists: \" +\n            _.get(instanceRes, \"error.message\");\n        throw new error_1.FirebaseError(msg, {\n            original: instanceRes.error,\n        });\n    }\n    return true;\n}\nexports.instanceIdExists = instanceIdExists;\nfunction isUrlPath(extInstallPath) {\n    return exports.URL_REGEX.test(extInstallPath);\n}\nexports.isUrlPath = isUrlPath;\nfunction isLocalPath(extInstallPath) {\n    const trimmedPath = extInstallPath.trim();\n    return (trimmedPath.startsWith(\"~/\") ||\n        trimmedPath.startsWith(\"./\") ||\n        trimmedPath.startsWith(\"../\") ||\n        trimmedPath.startsWith(\"/\") ||\n        [\".\", \"..\"].includes(trimmedPath));\n}\nexports.isLocalPath = isLocalPath;\nfunction isLocalOrURLPath(extInstallPath) {\n    return isLocalPath(extInstallPath) || isUrlPath(extInstallPath);\n}\nexports.isLocalOrURLPath = isLocalOrURLPath;\nfunction getSourceOrigin(sourceOrVersion) {\n    if (isLocalPath(sourceOrVersion)) {\n        return SourceOrigin.LOCAL;\n    }\n    if (isUrlPath(sourceOrVersion)) {\n        return SourceOrigin.URL;\n    }\n    if (sourceOrVersion.includes(\"/\")) {\n        let ref;\n        try {\n            ref = extensionsApi_1.parseRef(sourceOrVersion);\n        }\n        catch (err) {\n        }\n        if (ref && ref.publisherId && ref.extensionId && !ref.version) {\n            return SourceOrigin.PUBLISHED_EXTENSION;\n        }\n        else if (ref && ref.publisherId && ref.extensionId && ref.version) {\n            return SourceOrigin.PUBLISHED_EXTENSION_VERSION;\n        }\n    }\n    throw new error_1.FirebaseError(`Could not find source '${clc.bold(sourceOrVersion)}'. Check to make sure the source is correct, and then please try again.`);\n}\nexports.getSourceOrigin = getSourceOrigin;\nasync function confirmInstallInstance(defaultOption) {\n    const message = `Would you like to continue installing this extension?`;\n    return await prompt_1.promptOnce({\n        type: \"confirm\",\n        message,\n        default: defaultOption,\n    });\n}\nexports.confirmInstallInstance = confirmInstallInstance;\n"]},"metadata":{},"sourceType":"script"}