{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst mime_1 = require(\"../utils/mime\");\n\nconst validators_1 = require(\"./Schema/validators\");\n\nconst typeUtils_1 = require(\"../utils/typeUtils\");\n\nclass Responses {\n  constructor(context, response) {\n    this.context = context;\n    this._hasResponses = false;\n    this._responseValidators = new mime_1.MimeTypeRegistry();\n    this._location = {\n      in: 'response',\n      name: 'body',\n      docPath: this.context.jsonPointer\n    };\n\n    if (response.content) {\n      for (const mimeType of Object.keys(response.content)) {\n        this._hasResponses = true;\n        const mediaTypeObject = response.content[mimeType];\n        let validator;\n\n        if (mediaTypeObject.schema) {\n          const schemaContext = context.childContext(['content', mimeType, 'schema']);\n          validator = validators_1.generateResponseValidator(schemaContext, this._location, true // Responses are always required.\n          );\n        } else {\n          validator = () => ({\n            errors: null,\n            value: undefined\n          });\n        }\n\n        this._responseValidators.set(mimeType, validator);\n      }\n    }\n  }\n\n  validateResponse(statusCode, headers, body) {\n    const contentType = headers['content-type'];\n\n    if (!contentType) {\n      if (body) {\n        return [{\n          location: this._location,\n          message: `Response for ${statusCode} is missing content-type.`\n        }];\n      } else if (this._hasResponses) {\n        return [{\n          location: this._location,\n          message: `Response for ${statusCode} expects body.`\n        }];\n      } else {\n        return null;\n      }\n    } else if (typeof contentType !== 'string') {\n      return [{\n        location: this._location,\n        message: `Invalid content type for ${statusCode} response: ${contentType}`\n      }];\n    } else {\n      const validator = this._responseValidators.get(contentType);\n\n      const isJson = contentType.startsWith('application/json');\n\n      if (body === null || body === undefined) {\n        return [{\n          location: this._location,\n          message: `Missing response body for ${statusCode}.`\n        }];\n      } else if (!validator) {\n        return [{\n          location: this._location,\n          message: `Unexpected content-type for ${statusCode} response: ${contentType}.`\n        }];\n      } else if (isJson) {\n        if (body instanceof Buffer || typeUtils_1.isReadable(body)) {\n          // Can't validate this.\n          return null;\n        }\n\n        try {\n          let jsonData;\n\n          if (typeof body === 'string') {\n            if (body.trim() === '') {\n              jsonData = undefined;\n            } else {\n              jsonData = JSON.parse(body);\n            }\n          } else {\n            jsonData = body;\n          }\n\n          return validator(jsonData).errors;\n        } catch (err) {\n          return [{\n            location: this._location,\n            message: `Could not parse content as JSON.`\n          }];\n        }\n      } else if (typeof body === 'string' || body instanceof Buffer || typeUtils_1.isReadable(body)) {\n        // Can't validate this.\n        return null;\n      } else {\n        return validator(body).errors;\n      }\n    }\n  }\n\n}\n\nexports.default = Responses;","map":{"version":3,"sources":["../../src/oas3/Response.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst mime_1 = require(\"../utils/mime\");\nconst validators_1 = require(\"./Schema/validators\");\nconst typeUtils_1 = require(\"../utils/typeUtils\");\nclass Responses {\n    constructor(context, response) {\n        this.context = context;\n        this._hasResponses = false;\n        this._responseValidators = new mime_1.MimeTypeRegistry();\n        this._location = {\n            in: 'response',\n            name: 'body',\n            docPath: this.context.jsonPointer,\n        };\n        if (response.content) {\n            for (const mimeType of Object.keys(response.content)) {\n                this._hasResponses = true;\n                const mediaTypeObject = response.content[mimeType];\n                let validator;\n                if (mediaTypeObject.schema) {\n                    const schemaContext = context.childContext(['content', mimeType, 'schema']);\n                    validator = validators_1.generateResponseValidator(schemaContext, this._location, true // Responses are always required.\n                    );\n                }\n                else {\n                    validator = () => ({ errors: null, value: undefined });\n                }\n                this._responseValidators.set(mimeType, validator);\n            }\n        }\n    }\n    validateResponse(statusCode, headers, body) {\n        const contentType = headers['content-type'];\n        if (!contentType) {\n            if (body) {\n                return [\n                    {\n                        location: this._location,\n                        message: `Response for ${statusCode} is missing content-type.`,\n                    },\n                ];\n            }\n            else if (this._hasResponses) {\n                return [\n                    {\n                        location: this._location,\n                        message: `Response for ${statusCode} expects body.`,\n                    },\n                ];\n            }\n            else {\n                return null;\n            }\n        }\n        else if (typeof contentType !== 'string') {\n            return [\n                {\n                    location: this._location,\n                    message: `Invalid content type for ${statusCode} response: ${contentType}`,\n                },\n            ];\n        }\n        else {\n            const validator = this._responseValidators.get(contentType);\n            const isJson = contentType.startsWith('application/json');\n            if (body === null || body === undefined) {\n                return [\n                    {\n                        location: this._location,\n                        message: `Missing response body for ${statusCode}.`,\n                    },\n                ];\n            }\n            else if (!validator) {\n                return [\n                    {\n                        location: this._location,\n                        message: `Unexpected content-type for ${statusCode} response: ${contentType}.`,\n                    },\n                ];\n            }\n            else if (isJson) {\n                if (body instanceof Buffer || typeUtils_1.isReadable(body)) {\n                    // Can't validate this.\n                    return null;\n                }\n                try {\n                    let jsonData;\n                    if (typeof body === 'string') {\n                        if (body.trim() === '') {\n                            jsonData = undefined;\n                        }\n                        else {\n                            jsonData = JSON.parse(body);\n                        }\n                    }\n                    else {\n                        jsonData = body;\n                    }\n                    return validator(jsonData).errors;\n                }\n                catch (err) {\n                    return [\n                        {\n                            location: this._location,\n                            message: `Could not parse content as JSON.`,\n                        },\n                    ];\n                }\n            }\n            else if (typeof body === 'string' || body instanceof Buffer || typeUtils_1.isReadable(body)) {\n                // Can't validate this.\n                return null;\n            }\n            else {\n                return validator(body).errors;\n            }\n        }\n    }\n}\nexports.default = Responses;\n//# sourceMappingURL=Response.js.map"]},"metadata":{},"sourceType":"script"}