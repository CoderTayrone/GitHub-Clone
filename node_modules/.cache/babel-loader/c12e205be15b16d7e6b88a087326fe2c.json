{"ast":null,"code":"\"use strict\";\n\nconst {\n  ono\n} = require(\"@jsdevtools/ono\");\n\nconst $Ref = require(\"./ref\");\n\nconst url = require(\"./util/url\");\n\nmodule.exports = $Refs;\n/**\n * This class is a map of JSON references and their resolved values.\n */\n\nfunction $Refs() {\n  /**\n   * Indicates whether the schema contains any circular references.\n   *\n   * @type {boolean}\n   */\n  this.circular = false;\n  /**\n   * A map of paths/urls to {@link $Ref} objects\n   *\n   * @type {object}\n   * @protected\n   */\n\n  this._$refs = {};\n  /**\n   * The {@link $Ref} object that is the root of the JSON schema.\n   *\n   * @type {$Ref}\n   * @protected\n   */\n\n  this._root$Ref = null;\n}\n/**\n * Returns the paths of all the files/URLs that are referenced by the JSON schema,\n * including the schema itself.\n *\n * @param {...string|string[]} [types] - Only return paths of the given types (\"file\", \"http\", etc.)\n * @returns {string[]}\n */\n\n\n$Refs.prototype.paths = function (types) {\n  // eslint-disable-line no-unused-vars\n  let paths = getPaths(this._$refs, arguments);\n  return paths.map(path => {\n    return path.decoded;\n  });\n};\n/**\n * Returns the map of JSON references and their resolved values.\n *\n * @param {...string|string[]} [types] - Only return references of the given types (\"file\", \"http\", etc.)\n * @returns {object}\n */\n\n\n$Refs.prototype.values = function (types) {\n  // eslint-disable-line no-unused-vars\n  let $refs = this._$refs;\n  let paths = getPaths($refs, arguments);\n  return paths.reduce((obj, path) => {\n    obj[path.decoded] = $refs[path.encoded].value;\n    return obj;\n  }, {});\n};\n/**\n * Returns a POJO (plain old JavaScript object) for serialization as JSON.\n *\n * @returns {object}\n */\n\n\n$Refs.prototype.toJSON = $Refs.prototype.values;\n/**\n * Determines whether the given JSON reference exists.\n *\n * @param {string} path - The path being resolved, optionally with a JSON pointer in the hash\n * @param {$RefParserOptions} [options]\n * @returns {boolean}\n */\n\n$Refs.prototype.exists = function (path, options) {\n  try {\n    this._resolve(path, \"\", options);\n\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n/**\n * Resolves the given JSON reference and returns the resolved value.\n *\n * @param {string} path - The path being resolved, with a JSON pointer in the hash\n * @param {$RefParserOptions} [options]\n * @returns {*} - Returns the resolved value\n */\n\n\n$Refs.prototype.get = function (path, options) {\n  return this._resolve(path, \"\", options).value;\n};\n/**\n * Sets the value of a nested property within this {@link $Ref#value}.\n * If the property, or any of its parents don't exist, they will be created.\n *\n * @param {string} path - The path of the property to set, optionally with a JSON pointer in the hash\n * @param {*} value - The value to assign\n */\n\n\n$Refs.prototype.set = function (path, value) {\n  let absPath = url.resolve(this._root$Ref.path, path);\n  let withoutHash = url.stripHash(absPath);\n  let $ref = this._$refs[withoutHash];\n\n  if (!$ref) {\n    throw ono(`Error resolving $ref pointer \"${path}\". \\n\"${withoutHash}\" not found.`);\n  }\n\n  $ref.set(absPath, value);\n};\n/**\n * Creates a new {@link $Ref} object and adds it to this {@link $Refs} object.\n *\n * @param {string} path  - The file path or URL of the referenced file\n */\n\n\n$Refs.prototype._add = function (path) {\n  let withoutHash = url.stripHash(path);\n  let $ref = new $Ref();\n  $ref.path = withoutHash;\n  $ref.$refs = this;\n  this._$refs[withoutHash] = $ref;\n  this._root$Ref = this._root$Ref || $ref;\n  return $ref;\n};\n/**\n * Resolves the given JSON reference.\n *\n * @param {string} path - The path being resolved, optionally with a JSON pointer in the hash\n * @param {string} pathFromRoot - The path of `obj` from the schema root\n * @param {$RefParserOptions} [options]\n * @returns {Pointer}\n * @protected\n */\n\n\n$Refs.prototype._resolve = function (path, pathFromRoot, options) {\n  let absPath = url.resolve(this._root$Ref.path, path);\n  let withoutHash = url.stripHash(absPath);\n  let $ref = this._$refs[withoutHash];\n\n  if (!$ref) {\n    throw ono(`Error resolving $ref pointer \"${path}\". \\n\"${withoutHash}\" not found.`);\n  }\n\n  return $ref.resolve(absPath, options, path, pathFromRoot);\n};\n/**\n * Returns the specified {@link $Ref} object, or undefined.\n *\n * @param {string} path - The path being resolved, optionally with a JSON pointer in the hash\n * @returns {$Ref|undefined}\n * @protected\n */\n\n\n$Refs.prototype._get$Ref = function (path) {\n  path = url.resolve(this._root$Ref.path, path);\n  let withoutHash = url.stripHash(path);\n  return this._$refs[withoutHash];\n};\n/**\n * Returns the encoded and decoded paths keys of the given object.\n *\n * @param {object} $refs - The object whose keys are URL-encoded paths\n * @param {...string|string[]} [types] - Only return paths of the given types (\"file\", \"http\", etc.)\n * @returns {object[]}\n */\n\n\nfunction getPaths($refs, types) {\n  let paths = Object.keys($refs); // Filter the paths by type\n\n  types = Array.isArray(types[0]) ? types[0] : Array.prototype.slice.call(types);\n\n  if (types.length > 0 && types[0]) {\n    paths = paths.filter(key => {\n      return types.indexOf($refs[key].pathType) !== -1;\n    });\n  } // Decode local filesystem paths\n\n\n  return paths.map(path => {\n    return {\n      encoded: path,\n      decoded: $refs[path].pathType === \"file\" ? url.toFileSystemPath(path, true) : path\n    };\n  });\n}","map":{"version":3,"sources":["/home/dev/Documentos/Projects/github-clone/node_modules/@apidevtools/json-schema-ref-parser/lib/refs.js"],"names":["ono","require","$Ref","url","module","exports","$Refs","circular","_$refs","_root$Ref","prototype","paths","types","getPaths","arguments","map","path","decoded","values","$refs","reduce","obj","encoded","value","toJSON","exists","options","_resolve","e","get","set","absPath","resolve","withoutHash","stripHash","$ref","_add","pathFromRoot","_get$Ref","Object","keys","Array","isArray","slice","call","length","filter","key","indexOf","pathType","toFileSystemPath"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst { ono } = require(\"@jsdevtools/ono\");\nconst $Ref = require(\"./ref\");\nconst url = require(\"./util/url\");\n\nmodule.exports = $Refs;\n\n/**\n * This class is a map of JSON references and their resolved values.\n */\nfunction $Refs () {\n  /**\n   * Indicates whether the schema contains any circular references.\n   *\n   * @type {boolean}\n   */\n  this.circular = false;\n\n  /**\n   * A map of paths/urls to {@link $Ref} objects\n   *\n   * @type {object}\n   * @protected\n   */\n  this._$refs = {};\n\n  /**\n   * The {@link $Ref} object that is the root of the JSON schema.\n   *\n   * @type {$Ref}\n   * @protected\n   */\n  this._root$Ref = null;\n}\n\n/**\n * Returns the paths of all the files/URLs that are referenced by the JSON schema,\n * including the schema itself.\n *\n * @param {...string|string[]} [types] - Only return paths of the given types (\"file\", \"http\", etc.)\n * @returns {string[]}\n */\n$Refs.prototype.paths = function (types) {    // eslint-disable-line no-unused-vars\n  let paths = getPaths(this._$refs, arguments);\n  return paths.map((path) => {\n    return path.decoded;\n  });\n};\n\n/**\n * Returns the map of JSON references and their resolved values.\n *\n * @param {...string|string[]} [types] - Only return references of the given types (\"file\", \"http\", etc.)\n * @returns {object}\n */\n$Refs.prototype.values = function (types) {   // eslint-disable-line no-unused-vars\n  let $refs = this._$refs;\n  let paths = getPaths($refs, arguments);\n  return paths.reduce((obj, path) => {\n    obj[path.decoded] = $refs[path.encoded].value;\n    return obj;\n  }, {});\n};\n\n/**\n * Returns a POJO (plain old JavaScript object) for serialization as JSON.\n *\n * @returns {object}\n */\n$Refs.prototype.toJSON = $Refs.prototype.values;\n\n/**\n * Determines whether the given JSON reference exists.\n *\n * @param {string} path - The path being resolved, optionally with a JSON pointer in the hash\n * @param {$RefParserOptions} [options]\n * @returns {boolean}\n */\n$Refs.prototype.exists = function (path, options) {\n  try {\n    this._resolve(path, \"\", options);\n    return true;\n  }\n  catch (e) {\n    return false;\n  }\n};\n\n/**\n * Resolves the given JSON reference and returns the resolved value.\n *\n * @param {string} path - The path being resolved, with a JSON pointer in the hash\n * @param {$RefParserOptions} [options]\n * @returns {*} - Returns the resolved value\n */\n$Refs.prototype.get = function (path, options) {\n  return this._resolve(path, \"\", options).value;\n};\n\n/**\n * Sets the value of a nested property within this {@link $Ref#value}.\n * If the property, or any of its parents don't exist, they will be created.\n *\n * @param {string} path - The path of the property to set, optionally with a JSON pointer in the hash\n * @param {*} value - The value to assign\n */\n$Refs.prototype.set = function (path, value) {\n  let absPath = url.resolve(this._root$Ref.path, path);\n  let withoutHash = url.stripHash(absPath);\n  let $ref = this._$refs[withoutHash];\n\n  if (!$ref) {\n    throw ono(`Error resolving $ref pointer \"${path}\". \\n\"${withoutHash}\" not found.`);\n  }\n\n  $ref.set(absPath, value);\n};\n\n/**\n * Creates a new {@link $Ref} object and adds it to this {@link $Refs} object.\n *\n * @param {string} path  - The file path or URL of the referenced file\n */\n$Refs.prototype._add = function (path) {\n  let withoutHash = url.stripHash(path);\n\n  let $ref = new $Ref();\n  $ref.path = withoutHash;\n  $ref.$refs = this;\n\n  this._$refs[withoutHash] = $ref;\n  this._root$Ref = this._root$Ref || $ref;\n\n  return $ref;\n};\n\n/**\n * Resolves the given JSON reference.\n *\n * @param {string} path - The path being resolved, optionally with a JSON pointer in the hash\n * @param {string} pathFromRoot - The path of `obj` from the schema root\n * @param {$RefParserOptions} [options]\n * @returns {Pointer}\n * @protected\n */\n$Refs.prototype._resolve = function (path, pathFromRoot, options) {\n  let absPath = url.resolve(this._root$Ref.path, path);\n  let withoutHash = url.stripHash(absPath);\n  let $ref = this._$refs[withoutHash];\n\n  if (!$ref) {\n    throw ono(`Error resolving $ref pointer \"${path}\". \\n\"${withoutHash}\" not found.`);\n  }\n\n  return $ref.resolve(absPath, options, path, pathFromRoot);\n};\n\n/**\n * Returns the specified {@link $Ref} object, or undefined.\n *\n * @param {string} path - The path being resolved, optionally with a JSON pointer in the hash\n * @returns {$Ref|undefined}\n * @protected\n */\n$Refs.prototype._get$Ref = function (path) {\n  path = url.resolve(this._root$Ref.path, path);\n  let withoutHash = url.stripHash(path);\n  return this._$refs[withoutHash];\n};\n\n/**\n * Returns the encoded and decoded paths keys of the given object.\n *\n * @param {object} $refs - The object whose keys are URL-encoded paths\n * @param {...string|string[]} [types] - Only return paths of the given types (\"file\", \"http\", etc.)\n * @returns {object[]}\n */\nfunction getPaths ($refs, types) {\n  let paths = Object.keys($refs);\n\n  // Filter the paths by type\n  types = Array.isArray(types[0]) ? types[0] : Array.prototype.slice.call(types);\n  if (types.length > 0 && types[0]) {\n    paths = paths.filter((key) => {\n      return types.indexOf($refs[key].pathType) !== -1;\n    });\n  }\n\n  // Decode local filesystem paths\n  return paths.map((path) => {\n    return {\n      encoded: path,\n      decoded: $refs[path].pathType === \"file\" ? url.toFileSystemPath(path, true) : path\n    };\n  });\n}\n"]},"metadata":{},"sourceType":"script"}