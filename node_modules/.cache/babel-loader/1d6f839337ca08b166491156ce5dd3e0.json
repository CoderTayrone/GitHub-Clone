{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst PathResolver_1 = require(\"./Paths/PathResolver\");\n\nconst FULL_URL_RE = /^(.*?):\\/\\/([^/]*?)(?:\\/(.*))?$/; // e.g. https://foo.bar/v1\n\nconst ABSOLUTE_URL_RE = /^(\\/.*)$/; // e.g. /v1\n\nfunction generateServerParser(oaServer) {\n  // Strip trailing '/'.\n  const serverUrl = oaServer.url.endsWith('/') ? oaServer.url.slice(0, oaServer.url.length - 1) : oaServer.url;\n  let result;\n  let match;\n\n  if (serverUrl === '') {\n    result = (_host, pathname) => ({\n      oaServer,\n      pathnameRest: pathname,\n      serverParams: Object.create(null),\n      baseUrl: ''\n    });\n  } else if (match = FULL_URL_RE.exec(serverUrl)) {\n    const hostname = match[2];\n    const basepath = match[3] || '';\n    const {\n      parser: hostnameAcceptFunction\n    } = PathResolver_1.compileTemplatePath(hostname);\n    let basepathAcceptFunction;\n\n    if (basepath) {\n      basepathAcceptFunction = PathResolver_1.compileTemplatePath('/' + basepath, {\n        openEnded: true\n      }).parser;\n    } else {\n      basepathAcceptFunction = () => ({\n        matched: '',\n        rawPathParams: Object.create(null)\n      });\n    }\n\n    result = (host, pathname) => {\n      const hostMatch = hostnameAcceptFunction(host);\n      const pathMatch = basepathAcceptFunction(pathname);\n\n      if (hostMatch && pathMatch) {\n        return {\n          oaServer,\n          pathnameRest: pathname.slice(pathMatch.matched.length),\n          serverParams: Object.assign({}, hostMatch.rawPathParams, pathMatch.rawPathParams),\n          baseUrl: pathMatch.matched\n        };\n      } else {\n        return null;\n      }\n    };\n  } else if (match = ABSOLUTE_URL_RE.exec(serverUrl)) {\n    const basepath = match[1];\n    const {\n      parser: basepathParser\n    } = PathResolver_1.compileTemplatePath(basepath, {\n      openEnded: true\n    });\n\n    result = (_host, pathname) => {\n      const pathMatch = basepathParser(pathname);\n\n      if (pathMatch) {\n        return {\n          oaServer,\n          serverParams: pathMatch.rawPathParams,\n          pathnameRest: pathname.slice(pathMatch.matched.length),\n          baseUrl: pathMatch.matched\n        };\n      } else {\n        return null;\n      }\n    };\n  } else {\n    // TODO: deal with relative URLs.\n    throw new Error(`Don't know how to deal with server URL ${oaServer.url}`);\n  }\n\n  return result;\n}\n\nclass Servers {\n  constructor(servers) {\n    servers = servers || [{\n      url: '/'\n    }];\n    this._servers = servers.map(server => generateServerParser(server));\n  }\n  /**\n   * Resolve the `server` that's being accessed.\n   *\n   * @param host - The hostname to match.\n   * @param pathname - The URL pathname to match.\n   * @returns If a matching `server` is found, returns a\n   * `ResolvedServer` object.  Returns `null` if no match was found.\n   */\n\n\n  resolveServer(host, pathname) {\n    for (const server of this._servers) {\n      const result = server(host, pathname);\n\n      if (result) {\n        return result;\n      }\n    }\n\n    return null;\n  }\n\n}\n\nexports.default = Servers;","map":{"version":3,"sources":["../../src/oas3/Servers.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst PathResolver_1 = require(\"./Paths/PathResolver\");\nconst FULL_URL_RE = /^(.*?):\\/\\/([^/]*?)(?:\\/(.*))?$/; // e.g. https://foo.bar/v1\nconst ABSOLUTE_URL_RE = /^(\\/.*)$/; // e.g. /v1\nfunction generateServerParser(oaServer) {\n    // Strip trailing '/'.\n    const serverUrl = oaServer.url.endsWith('/')\n        ? oaServer.url.slice(0, oaServer.url.length - 1)\n        : oaServer.url;\n    let result;\n    let match;\n    if (serverUrl === '') {\n        result = (_host, pathname) => ({\n            oaServer,\n            pathnameRest: pathname,\n            serverParams: Object.create(null),\n            baseUrl: '',\n        });\n    }\n    else if ((match = FULL_URL_RE.exec(serverUrl))) {\n        const hostname = match[2];\n        const basepath = match[3] || '';\n        const { parser: hostnameAcceptFunction } = PathResolver_1.compileTemplatePath(hostname);\n        let basepathAcceptFunction;\n        if (basepath) {\n            basepathAcceptFunction = PathResolver_1.compileTemplatePath('/' + basepath, { openEnded: true })\n                .parser;\n        }\n        else {\n            basepathAcceptFunction = () => ({\n                matched: '',\n                rawPathParams: Object.create(null),\n            });\n        }\n        result = (host, pathname) => {\n            const hostMatch = hostnameAcceptFunction(host);\n            const pathMatch = basepathAcceptFunction(pathname);\n            if (hostMatch && pathMatch) {\n                return {\n                    oaServer,\n                    pathnameRest: pathname.slice(pathMatch.matched.length),\n                    serverParams: Object.assign({}, hostMatch.rawPathParams, pathMatch.rawPathParams),\n                    baseUrl: pathMatch.matched,\n                };\n            }\n            else {\n                return null;\n            }\n        };\n    }\n    else if ((match = ABSOLUTE_URL_RE.exec(serverUrl))) {\n        const basepath = match[1];\n        const { parser: basepathParser } = PathResolver_1.compileTemplatePath(basepath, { openEnded: true });\n        result = (_host, pathname) => {\n            const pathMatch = basepathParser(pathname);\n            if (pathMatch) {\n                return {\n                    oaServer,\n                    serverParams: pathMatch.rawPathParams,\n                    pathnameRest: pathname.slice(pathMatch.matched.length),\n                    baseUrl: pathMatch.matched,\n                };\n            }\n            else {\n                return null;\n            }\n        };\n    }\n    else {\n        // TODO: deal with relative URLs.\n        throw new Error(`Don't know how to deal with server URL ${oaServer.url}`);\n    }\n    return result;\n}\nclass Servers {\n    constructor(servers) {\n        servers = servers || [{ url: '/' }];\n        this._servers = servers.map((server) => generateServerParser(server));\n    }\n    /**\n     * Resolve the `server` that's being accessed.\n     *\n     * @param host - The hostname to match.\n     * @param pathname - The URL pathname to match.\n     * @returns If a matching `server` is found, returns a\n     * `ResolvedServer` object.  Returns `null` if no match was found.\n     */\n    resolveServer(host, pathname) {\n        for (const server of this._servers) {\n            const result = server(host, pathname);\n            if (result) {\n                return result;\n            }\n        }\n        return null;\n    }\n}\nexports.default = Servers;\n//# sourceMappingURL=Servers.js.map"]},"metadata":{},"sourceType":"script"}