{"ast":null,"code":"\"use strict\";\n\nconst $Ref = require(\"./ref\");\n\nconst Pointer = require(\"./pointer\");\n\nconst url = require(\"./util/url\");\n\nmodule.exports = bundle;\n/**\n * Bundles all external JSON references into the main JSON schema, thus resulting in a schema that\n * only has *internal* references, not any *external* references.\n * This method mutates the JSON schema object, adding new references and re-mapping existing ones.\n *\n * @param {$RefParser} parser\n * @param {$RefParserOptions} options\n */\n\nfunction bundle(parser, options) {\n  // console.log('Bundling $ref pointers in %s', parser.$refs._root$Ref.path);\n  // Build an inventory of all $ref pointers in the JSON Schema\n  let inventory = [];\n  crawl(parser, \"schema\", parser.$refs._root$Ref.path + \"#\", \"#\", 0, inventory, parser.$refs, options); // Remap all $ref pointers\n\n  remap(inventory);\n}\n/**\n * Recursively crawls the given value, and inventories all JSON references.\n *\n * @param {object} parent - The object containing the value to crawl. If the value is not an object or array, it will be ignored.\n * @param {string} key - The property key of `parent` to be crawled\n * @param {string} path - The full path of the property being crawled, possibly with a JSON Pointer in the hash\n * @param {string} pathFromRoot - The path of the property being crawled, from the schema root\n * @param {object[]} inventory - An array of already-inventoried $ref pointers\n * @param {$Refs} $refs\n * @param {$RefParserOptions} options\n */\n\n\nfunction crawl(parent, key, path, pathFromRoot, indirections, inventory, $refs, options) {\n  let obj = key === null ? parent : parent[key];\n\n  if (obj && typeof obj === \"object\" && !ArrayBuffer.isView(obj)) {\n    if ($Ref.isAllowed$Ref(obj)) {\n      inventory$Ref(parent, key, path, pathFromRoot, indirections, inventory, $refs, options);\n    } else {\n      // Crawl the object in a specific order that's optimized for bundling.\n      // This is important because it determines how `pathFromRoot` gets built,\n      // which later determines which keys get dereferenced and which ones get remapped\n      let keys = Object.keys(obj).sort((a, b) => {\n        // Most people will expect references to be bundled into the the \"definitions\" property,\n        // so we always crawl that property first, if it exists.\n        if (a === \"definitions\") {\n          return -1;\n        } else if (b === \"definitions\") {\n          return 1;\n        } else {\n          // Otherwise, crawl the keys based on their length.\n          // This produces the shortest possible bundled references\n          return a.length - b.length;\n        }\n      }); // eslint-disable-next-line no-shadow\n\n      for (let key of keys) {\n        let keyPath = Pointer.join(path, key);\n        let keyPathFromRoot = Pointer.join(pathFromRoot, key);\n        let value = obj[key];\n\n        if ($Ref.isAllowed$Ref(value)) {\n          inventory$Ref(obj, key, path, keyPathFromRoot, indirections, inventory, $refs, options);\n        } else {\n          crawl(obj, key, keyPath, keyPathFromRoot, indirections, inventory, $refs, options);\n        }\n      }\n    }\n  }\n}\n/**\n * Inventories the given JSON Reference (i.e. records detailed information about it so we can\n * optimize all $refs in the schema), and then crawls the resolved value.\n *\n * @param {object} $refParent - The object that contains a JSON Reference as one of its keys\n * @param {string} $refKey - The key in `$refParent` that is a JSON Reference\n * @param {string} path - The full path of the JSON Reference at `$refKey`, possibly with a JSON Pointer in the hash\n * @param {string} pathFromRoot - The path of the JSON Reference at `$refKey`, from the schema root\n * @param {object[]} inventory - An array of already-inventoried $ref pointers\n * @param {$Refs} $refs\n * @param {$RefParserOptions} options\n */\n\n\nfunction inventory$Ref($refParent, $refKey, path, pathFromRoot, indirections, inventory, $refs, options) {\n  let $ref = $refKey === null ? $refParent : $refParent[$refKey];\n  let $refPath = url.resolve(path, $ref.$ref);\n\n  let pointer = $refs._resolve($refPath, pathFromRoot, options);\n\n  if (pointer === null) {\n    return;\n  }\n\n  let depth = Pointer.parse(pathFromRoot).length;\n  let file = url.stripHash(pointer.path);\n  let hash = url.getHash(pointer.path);\n  let external = file !== $refs._root$Ref.path;\n  let extended = $Ref.isExtended$Ref($ref);\n  indirections += pointer.indirections;\n  let existingEntry = findInInventory(inventory, $refParent, $refKey);\n\n  if (existingEntry) {\n    // This $Ref has already been inventoried, so we don't need to process it again\n    if (depth < existingEntry.depth || indirections < existingEntry.indirections) {\n      removeFromInventory(inventory, existingEntry);\n    } else {\n      return;\n    }\n  }\n\n  inventory.push({\n    $ref,\n    // The JSON Reference (e.g. {$ref: string})\n    parent: $refParent,\n    // The object that contains this $ref pointer\n    key: $refKey,\n    // The key in `parent` that is the $ref pointer\n    pathFromRoot,\n    // The path to the $ref pointer, from the JSON Schema root\n    depth,\n    // How far from the JSON Schema root is this $ref pointer?\n    file,\n    // The file that the $ref pointer resolves to\n    hash,\n    // The hash within `file` that the $ref pointer resolves to\n    value: pointer.value,\n    // The resolved value of the $ref pointer\n    circular: pointer.circular,\n    // Is this $ref pointer DIRECTLY circular? (i.e. it references itself)\n    extended,\n    // Does this $ref extend its resolved value? (i.e. it has extra properties, in addition to \"$ref\")\n    external,\n    // Does this $ref pointer point to a file other than the main JSON Schema file?\n    indirections // The number of indirect references that were traversed to resolve the value\n\n  }); // Recursively crawl the resolved value\n\n  if (!existingEntry) {\n    crawl(pointer.value, null, pointer.path, pathFromRoot, indirections + 1, inventory, $refs, options);\n  }\n}\n/**\n * Re-maps every $ref pointer, so that they're all relative to the root of the JSON Schema.\n * Each referenced value is dereferenced EXACTLY ONCE.  All subsequent references to the same\n * value are re-mapped to point to the first reference.\n *\n * @example:\n *  {\n *    first: { $ref: somefile.json#/some/part },\n *    second: { $ref: somefile.json#/another/part },\n *    third: { $ref: somefile.json },\n *    fourth: { $ref: somefile.json#/some/part/sub/part }\n *  }\n *\n * In this example, there are four references to the same file, but since the third reference points\n * to the ENTIRE file, that's the only one we need to dereference.  The other three can just be\n * remapped to point inside the third one.\n *\n * On the other hand, if the third reference DIDN'T exist, then the first and second would both need\n * to be dereferenced, since they point to different parts of the file. The fourth reference does NOT\n * need to be dereferenced, because it can be remapped to point inside the first one.\n *\n * @param {object[]} inventory\n */\n\n\nfunction remap(inventory) {\n  // Group & sort all the $ref pointers, so they're in the order that we need to dereference/remap them\n  inventory.sort((a, b) => {\n    if (a.file !== b.file) {\n      // Group all the $refs that point to the same file\n      return a.file < b.file ? -1 : +1;\n    } else if (a.hash !== b.hash) {\n      // Group all the $refs that point to the same part of the file\n      return a.hash < b.hash ? -1 : +1;\n    } else if (a.circular !== b.circular) {\n      // If the $ref points to itself, then sort it higher than other $refs that point to this $ref\n      return a.circular ? -1 : +1;\n    } else if (a.extended !== b.extended) {\n      // If the $ref extends the resolved value, then sort it lower than other $refs that don't extend the value\n      return a.extended ? +1 : -1;\n    } else if (a.indirections !== b.indirections) {\n      // Sort direct references higher than indirect references\n      return a.indirections - b.indirections;\n    } else if (a.depth !== b.depth) {\n      // Sort $refs by how close they are to the JSON Schema root\n      return a.depth - b.depth;\n    } else {\n      // Determine how far each $ref is from the \"definitions\" property.\n      // Most people will expect references to be bundled into the the \"definitions\" property if possible.\n      let aDefinitionsIndex = a.pathFromRoot.lastIndexOf(\"/definitions\");\n      let bDefinitionsIndex = b.pathFromRoot.lastIndexOf(\"/definitions\");\n\n      if (aDefinitionsIndex !== bDefinitionsIndex) {\n        // Give higher priority to the $ref that's closer to the \"definitions\" property\n        return bDefinitionsIndex - aDefinitionsIndex;\n      } else {\n        // All else is equal, so use the shorter path, which will produce the shortest possible reference\n        return a.pathFromRoot.length - b.pathFromRoot.length;\n      }\n    }\n  });\n  let file, hash, pathFromRoot;\n\n  for (let entry of inventory) {\n    // console.log('Re-mapping $ref pointer \"%s\" at %s', entry.$ref.$ref, entry.pathFromRoot);\n    if (!entry.external) {\n      // This $ref already resolves to the main JSON Schema file\n      entry.$ref.$ref = entry.hash;\n    } else if (entry.file === file && entry.hash === hash) {\n      // This $ref points to the same value as the prevous $ref, so remap it to the same path\n      entry.$ref.$ref = pathFromRoot;\n    } else if (entry.file === file && entry.hash.indexOf(hash + \"/\") === 0) {\n      // This $ref points to a sub-value of the prevous $ref, so remap it beneath that path\n      entry.$ref.$ref = Pointer.join(pathFromRoot, Pointer.parse(entry.hash.replace(hash, \"#\")));\n    } else {\n      // We've moved to a new file or new hash\n      file = entry.file;\n      hash = entry.hash;\n      pathFromRoot = entry.pathFromRoot; // This is the first $ref to point to this value, so dereference the value.\n      // Any other $refs that point to the same value will point to this $ref instead\n\n      entry.$ref = entry.parent[entry.key] = $Ref.dereference(entry.$ref, entry.value);\n\n      if (entry.circular) {\n        // This $ref points to itself\n        entry.$ref.$ref = entry.pathFromRoot;\n      }\n    } // console.log('    new value: %s', (entry.$ref && entry.$ref.$ref) ? entry.$ref.$ref : '[object Object]');\n\n  }\n}\n/**\n * TODO\n */\n\n\nfunction findInInventory(inventory, $refParent, $refKey) {\n  for (let i = 0; i < inventory.length; i++) {\n    let existingEntry = inventory[i];\n\n    if (existingEntry.parent === $refParent && existingEntry.key === $refKey) {\n      return existingEntry;\n    }\n  }\n}\n\nfunction removeFromInventory(inventory, entry) {\n  let index = inventory.indexOf(entry);\n  inventory.splice(index, 1);\n}","map":{"version":3,"sources":["/home/dev/Documentos/Projects/github-clone/node_modules/@apidevtools/json-schema-ref-parser/lib/bundle.js"],"names":["$Ref","require","Pointer","url","module","exports","bundle","parser","options","inventory","crawl","$refs","_root$Ref","path","remap","parent","key","pathFromRoot","indirections","obj","ArrayBuffer","isView","isAllowed$Ref","inventory$Ref","keys","Object","sort","a","b","length","keyPath","join","keyPathFromRoot","value","$refParent","$refKey","$ref","$refPath","resolve","pointer","_resolve","depth","parse","file","stripHash","hash","getHash","external","extended","isExtended$Ref","existingEntry","findInInventory","removeFromInventory","push","circular","aDefinitionsIndex","lastIndexOf","bDefinitionsIndex","entry","indexOf","replace","dereference","i","index","splice"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst $Ref = require(\"./ref\");\nconst Pointer = require(\"./pointer\");\nconst url = require(\"./util/url\");\n\nmodule.exports = bundle;\n\n/**\n * Bundles all external JSON references into the main JSON schema, thus resulting in a schema that\n * only has *internal* references, not any *external* references.\n * This method mutates the JSON schema object, adding new references and re-mapping existing ones.\n *\n * @param {$RefParser} parser\n * @param {$RefParserOptions} options\n */\nfunction bundle (parser, options) {\n  // console.log('Bundling $ref pointers in %s', parser.$refs._root$Ref.path);\n\n  // Build an inventory of all $ref pointers in the JSON Schema\n  let inventory = [];\n  crawl(parser, \"schema\", parser.$refs._root$Ref.path + \"#\", \"#\", 0, inventory, parser.$refs, options);\n\n  // Remap all $ref pointers\n  remap(inventory);\n}\n\n/**\n * Recursively crawls the given value, and inventories all JSON references.\n *\n * @param {object} parent - The object containing the value to crawl. If the value is not an object or array, it will be ignored.\n * @param {string} key - The property key of `parent` to be crawled\n * @param {string} path - The full path of the property being crawled, possibly with a JSON Pointer in the hash\n * @param {string} pathFromRoot - The path of the property being crawled, from the schema root\n * @param {object[]} inventory - An array of already-inventoried $ref pointers\n * @param {$Refs} $refs\n * @param {$RefParserOptions} options\n */\nfunction crawl (parent, key, path, pathFromRoot, indirections, inventory, $refs, options) {\n  let obj = key === null ? parent : parent[key];\n\n  if (obj && typeof obj === \"object\" && !ArrayBuffer.isView(obj)) {\n    if ($Ref.isAllowed$Ref(obj)) {\n      inventory$Ref(parent, key, path, pathFromRoot, indirections, inventory, $refs, options);\n    }\n    else {\n      // Crawl the object in a specific order that's optimized for bundling.\n      // This is important because it determines how `pathFromRoot` gets built,\n      // which later determines which keys get dereferenced and which ones get remapped\n      let keys = Object.keys(obj)\n        .sort((a, b) => {\n          // Most people will expect references to be bundled into the the \"definitions\" property,\n          // so we always crawl that property first, if it exists.\n          if (a === \"definitions\") {\n            return -1;\n          }\n          else if (b === \"definitions\") {\n            return 1;\n          }\n          else {\n            // Otherwise, crawl the keys based on their length.\n            // This produces the shortest possible bundled references\n            return a.length - b.length;\n          }\n        });\n\n      // eslint-disable-next-line no-shadow\n      for (let key of keys) {\n        let keyPath = Pointer.join(path, key);\n        let keyPathFromRoot = Pointer.join(pathFromRoot, key);\n        let value = obj[key];\n\n        if ($Ref.isAllowed$Ref(value)) {\n          inventory$Ref(obj, key, path, keyPathFromRoot, indirections, inventory, $refs, options);\n        }\n        else {\n          crawl(obj, key, keyPath, keyPathFromRoot, indirections, inventory, $refs, options);\n        }\n      }\n    }\n  }\n}\n\n/**\n * Inventories the given JSON Reference (i.e. records detailed information about it so we can\n * optimize all $refs in the schema), and then crawls the resolved value.\n *\n * @param {object} $refParent - The object that contains a JSON Reference as one of its keys\n * @param {string} $refKey - The key in `$refParent` that is a JSON Reference\n * @param {string} path - The full path of the JSON Reference at `$refKey`, possibly with a JSON Pointer in the hash\n * @param {string} pathFromRoot - The path of the JSON Reference at `$refKey`, from the schema root\n * @param {object[]} inventory - An array of already-inventoried $ref pointers\n * @param {$Refs} $refs\n * @param {$RefParserOptions} options\n */\nfunction inventory$Ref ($refParent, $refKey, path, pathFromRoot, indirections, inventory, $refs, options) {\n  let $ref = $refKey === null ? $refParent : $refParent[$refKey];\n  let $refPath = url.resolve(path, $ref.$ref);\n  let pointer = $refs._resolve($refPath, pathFromRoot, options);\n  if (pointer === null) {\n    return;\n  }\n\n  let depth = Pointer.parse(pathFromRoot).length;\n  let file = url.stripHash(pointer.path);\n  let hash = url.getHash(pointer.path);\n  let external = file !== $refs._root$Ref.path;\n  let extended = $Ref.isExtended$Ref($ref);\n  indirections += pointer.indirections;\n\n  let existingEntry = findInInventory(inventory, $refParent, $refKey);\n  if (existingEntry) {\n    // This $Ref has already been inventoried, so we don't need to process it again\n    if (depth < existingEntry.depth || indirections < existingEntry.indirections) {\n      removeFromInventory(inventory, existingEntry);\n    }\n    else {\n      return;\n    }\n  }\n\n  inventory.push({\n    $ref,                   // The JSON Reference (e.g. {$ref: string})\n    parent: $refParent,           // The object that contains this $ref pointer\n    key: $refKey,                 // The key in `parent` that is the $ref pointer\n    pathFromRoot,   // The path to the $ref pointer, from the JSON Schema root\n    depth,                 // How far from the JSON Schema root is this $ref pointer?\n    file,                   // The file that the $ref pointer resolves to\n    hash,                   // The hash within `file` that the $ref pointer resolves to\n    value: pointer.value,         // The resolved value of the $ref pointer\n    circular: pointer.circular,   // Is this $ref pointer DIRECTLY circular? (i.e. it references itself)\n    extended,           // Does this $ref extend its resolved value? (i.e. it has extra properties, in addition to \"$ref\")\n    external,           // Does this $ref pointer point to a file other than the main JSON Schema file?\n    indirections,   // The number of indirect references that were traversed to resolve the value\n  });\n\n  // Recursively crawl the resolved value\n  if (!existingEntry) {\n    crawl(pointer.value, null, pointer.path, pathFromRoot, indirections + 1, inventory, $refs, options);\n  }\n}\n\n/**\n * Re-maps every $ref pointer, so that they're all relative to the root of the JSON Schema.\n * Each referenced value is dereferenced EXACTLY ONCE.  All subsequent references to the same\n * value are re-mapped to point to the first reference.\n *\n * @example:\n *  {\n *    first: { $ref: somefile.json#/some/part },\n *    second: { $ref: somefile.json#/another/part },\n *    third: { $ref: somefile.json },\n *    fourth: { $ref: somefile.json#/some/part/sub/part }\n *  }\n *\n * In this example, there are four references to the same file, but since the third reference points\n * to the ENTIRE file, that's the only one we need to dereference.  The other three can just be\n * remapped to point inside the third one.\n *\n * On the other hand, if the third reference DIDN'T exist, then the first and second would both need\n * to be dereferenced, since they point to different parts of the file. The fourth reference does NOT\n * need to be dereferenced, because it can be remapped to point inside the first one.\n *\n * @param {object[]} inventory\n */\nfunction remap (inventory) {\n  // Group & sort all the $ref pointers, so they're in the order that we need to dereference/remap them\n  inventory.sort((a, b) => {\n    if (a.file !== b.file) {\n      // Group all the $refs that point to the same file\n      return a.file < b.file ? -1 : +1;\n    }\n    else if (a.hash !== b.hash) {\n      // Group all the $refs that point to the same part of the file\n      return a.hash < b.hash ? -1 : +1;\n    }\n    else if (a.circular !== b.circular) {\n      // If the $ref points to itself, then sort it higher than other $refs that point to this $ref\n      return a.circular ? -1 : +1;\n    }\n    else if (a.extended !== b.extended) {\n      // If the $ref extends the resolved value, then sort it lower than other $refs that don't extend the value\n      return a.extended ? +1 : -1;\n    }\n    else if (a.indirections !== b.indirections) {\n      // Sort direct references higher than indirect references\n      return a.indirections - b.indirections;\n    }\n    else if (a.depth !== b.depth) {\n      // Sort $refs by how close they are to the JSON Schema root\n      return a.depth - b.depth;\n    }\n    else {\n      // Determine how far each $ref is from the \"definitions\" property.\n      // Most people will expect references to be bundled into the the \"definitions\" property if possible.\n      let aDefinitionsIndex = a.pathFromRoot.lastIndexOf(\"/definitions\");\n      let bDefinitionsIndex = b.pathFromRoot.lastIndexOf(\"/definitions\");\n\n      if (aDefinitionsIndex !== bDefinitionsIndex) {\n        // Give higher priority to the $ref that's closer to the \"definitions\" property\n        return bDefinitionsIndex - aDefinitionsIndex;\n      }\n      else {\n        // All else is equal, so use the shorter path, which will produce the shortest possible reference\n        return a.pathFromRoot.length - b.pathFromRoot.length;\n      }\n    }\n  });\n\n  let file, hash, pathFromRoot;\n  for (let entry of inventory) {\n    // console.log('Re-mapping $ref pointer \"%s\" at %s', entry.$ref.$ref, entry.pathFromRoot);\n\n    if (!entry.external) {\n      // This $ref already resolves to the main JSON Schema file\n      entry.$ref.$ref = entry.hash;\n    }\n    else if (entry.file === file && entry.hash === hash) {\n      // This $ref points to the same value as the prevous $ref, so remap it to the same path\n      entry.$ref.$ref = pathFromRoot;\n    }\n    else if (entry.file === file && entry.hash.indexOf(hash + \"/\") === 0) {\n      // This $ref points to a sub-value of the prevous $ref, so remap it beneath that path\n      entry.$ref.$ref = Pointer.join(pathFromRoot, Pointer.parse(entry.hash.replace(hash, \"#\")));\n    }\n    else {\n      // We've moved to a new file or new hash\n      file = entry.file;\n      hash = entry.hash;\n      pathFromRoot = entry.pathFromRoot;\n\n      // This is the first $ref to point to this value, so dereference the value.\n      // Any other $refs that point to the same value will point to this $ref instead\n      entry.$ref = entry.parent[entry.key] = $Ref.dereference(entry.$ref, entry.value);\n\n      if (entry.circular) {\n        // This $ref points to itself\n        entry.$ref.$ref = entry.pathFromRoot;\n      }\n    }\n\n    // console.log('    new value: %s', (entry.$ref && entry.$ref.$ref) ? entry.$ref.$ref : '[object Object]');\n  }\n}\n\n/**\n * TODO\n */\nfunction findInInventory (inventory, $refParent, $refKey) {\n  for (let i = 0; i < inventory.length; i++) {\n    let existingEntry = inventory[i];\n    if (existingEntry.parent === $refParent && existingEntry.key === $refKey) {\n      return existingEntry;\n    }\n  }\n}\n\nfunction removeFromInventory (inventory, entry) {\n  let index = inventory.indexOf(entry);\n  inventory.splice(index, 1);\n}\n"]},"metadata":{},"sourceType":"script"}