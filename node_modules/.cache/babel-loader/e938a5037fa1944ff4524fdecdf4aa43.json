{"ast":null,"code":"var Promise = require('bluebird');\n\nvar Decrypt = require('../Decrypt');\n\nvar PullStream = require('../PullStream');\n\nvar Stream = require('stream');\n\nvar binary = require('binary');\n\nvar zlib = require('zlib');\n\nvar parseExtraField = require('../parseExtraField');\n\nvar Buffer = require('../Buffer');\n\nvar parseDateTime = require('../parseDateTime'); // Backwards compatibility for node versions < 8\n\n\nif (!Stream.Writable || !Stream.Writable.prototype.destroy) Stream = require('readable-stream');\n\nmodule.exports = function unzip(source, offset, _password, directoryVars) {\n  var file = PullStream(),\n      entry = Stream.PassThrough();\n  var req = source.stream(offset);\n  req.pipe(file).on('error', function (e) {\n    entry.emit('error', e);\n  });\n  entry.vars = file.pull(30).then(function (data) {\n    var vars = binary.parse(data).word32lu('signature').word16lu('versionsNeededToExtract').word16lu('flags').word16lu('compressionMethod').word16lu('lastModifiedTime').word16lu('lastModifiedDate').word32lu('crc32').word32lu('compressedSize').word32lu('uncompressedSize').word16lu('fileNameLength').word16lu('extraFieldLength').vars;\n    vars.lastModifiedDateTime = parseDateTime(vars.lastModifiedDate, vars.lastModifiedTime);\n    return file.pull(vars.fileNameLength).then(function (fileName) {\n      vars.fileName = fileName.toString('utf8');\n      return file.pull(vars.extraFieldLength);\n    }).then(function (extraField) {\n      var checkEncryption;\n      vars.extra = parseExtraField(extraField, vars); // Ignore logal file header vars if the directory vars are available\n\n      if (directoryVars && directoryVars.compressedSize) vars = directoryVars;\n      if (vars.flags & 0x01) checkEncryption = file.pull(12).then(function (header) {\n        if (!_password) throw new Error('MISSING_PASSWORD');\n        var decrypt = Decrypt();\n        String(_password).split('').forEach(function (d) {\n          decrypt.update(d);\n        });\n\n        for (var i = 0; i < header.length; i++) header[i] = decrypt.decryptByte(header[i]);\n\n        vars.decrypt = decrypt;\n        vars.compressedSize -= 12;\n        var check = vars.flags & 0x8 ? vars.lastModifiedTime >> 8 & 0xff : vars.crc32 >> 24 & 0xff;\n        if (header[11] !== check) throw new Error('BAD_PASSWORD');\n        return vars;\n      });\n      return Promise.resolve(checkEncryption).then(function () {\n        entry.emit('vars', vars);\n        return vars;\n      });\n    });\n  });\n  entry.vars.then(function (vars) {\n    var fileSizeKnown = !(vars.flags & 0x08) || vars.compressedSize > 0,\n        eof;\n    var inflater = vars.compressionMethod ? zlib.createInflateRaw() : Stream.PassThrough();\n\n    if (fileSizeKnown) {\n      entry.size = vars.uncompressedSize;\n      eof = vars.compressedSize;\n    } else {\n      eof = Buffer.alloc(4);\n      eof.writeUInt32LE(0x08074b50, 0);\n    }\n\n    var stream = file.stream(eof);\n    if (vars.decrypt) stream = stream.pipe(vars.decrypt.stream());\n    stream.pipe(inflater).on('error', function (err) {\n      entry.emit('error', err);\n    }).pipe(entry).on('finish', function () {\n      if (req.abort) req.abort();else if (req.close) req.close();else if (req.push) req.push();else console.log('warning - unable to close stream');\n    });\n  }).catch(function (e) {\n    entry.emit('error', e);\n  });\n  return entry;\n};","map":{"version":3,"sources":["/home/dev/Documentos/Projects/github-clone/node_modules/unzipper/lib/Open/unzip.js"],"names":["Promise","require","Decrypt","PullStream","Stream","binary","zlib","parseExtraField","Buffer","parseDateTime","Writable","prototype","destroy","module","exports","unzip","source","offset","_password","directoryVars","file","entry","PassThrough","req","stream","pipe","on","e","emit","vars","pull","then","data","parse","word32lu","word16lu","lastModifiedDateTime","lastModifiedDate","lastModifiedTime","fileNameLength","fileName","toString","extraFieldLength","extraField","checkEncryption","extra","compressedSize","flags","header","Error","decrypt","String","split","forEach","d","update","i","length","decryptByte","check","crc32","resolve","fileSizeKnown","eof","inflater","compressionMethod","createInflateRaw","size","uncompressedSize","alloc","writeUInt32LE","err","abort","close","push","console","log","catch"],"mappings":"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","sourcesContent":["var Promise = require('bluebird');\nvar Decrypt = require('../Decrypt');\nvar PullStream = require('../PullStream');\nvar Stream = require('stream');\nvar binary = require('binary');\nvar zlib = require('zlib');\nvar parseExtraField = require('../parseExtraField');\nvar Buffer = require('../Buffer');\nvar parseDateTime = require('../parseDateTime');\n\n// Backwards compatibility for node versions < 8\nif (!Stream.Writable || !Stream.Writable.prototype.destroy)\n  Stream = require('readable-stream');\n\nmodule.exports = function unzip(source,offset,_password, directoryVars) {\n  var file = PullStream(),\n      entry = Stream.PassThrough();\n\n  var req = source.stream(offset);\n  req.pipe(file).on('error', function(e) {\n    entry.emit('error', e);\n  });\n\n  entry.vars = file.pull(30)\n    .then(function(data) {\n      var vars = binary.parse(data)\n        .word32lu('signature')\n        .word16lu('versionsNeededToExtract')\n        .word16lu('flags')\n        .word16lu('compressionMethod')\n        .word16lu('lastModifiedTime')\n        .word16lu('lastModifiedDate')\n        .word32lu('crc32')\n        .word32lu('compressedSize')\n        .word32lu('uncompressedSize')\n        .word16lu('fileNameLength')\n        .word16lu('extraFieldLength')\n        .vars;\n\n      vars.lastModifiedDateTime = parseDateTime(vars.lastModifiedDate, vars.lastModifiedTime);\n\n      return file.pull(vars.fileNameLength)\n        .then(function(fileName) {\n          vars.fileName = fileName.toString('utf8');\n          return file.pull(vars.extraFieldLength);\n        })\n        .then(function(extraField) {\n          var checkEncryption;\n          vars.extra = parseExtraField(extraField, vars);\n          // Ignore logal file header vars if the directory vars are available\n          if (directoryVars && directoryVars.compressedSize) vars = directoryVars;\n\n          if (vars.flags & 0x01) checkEncryption = file.pull(12)\n            .then(function(header) {\n              if (!_password)\n                throw new Error('MISSING_PASSWORD');\n\n              var decrypt = Decrypt();\n\n              String(_password).split('').forEach(function(d) {\n                decrypt.update(d);\n              });\n\n              for (var i=0; i < header.length; i++)\n                header[i] = decrypt.decryptByte(header[i]);\n\n              vars.decrypt = decrypt;\n              vars.compressedSize -= 12;\n\n              var check = (vars.flags & 0x8) ? (vars.lastModifiedTime >> 8) & 0xff : (vars.crc32 >> 24) & 0xff;\n              if (header[11] !== check)\n                throw new Error('BAD_PASSWORD');\n\n              return vars;\n            });\n\n          return Promise.resolve(checkEncryption)\n            .then(function() {\n              entry.emit('vars',vars);\n              return vars;\n            });\n        });\n    });\n\n    entry.vars.then(function(vars) {\n      var fileSizeKnown = !(vars.flags & 0x08) || vars.compressedSize > 0,\n          eof;\n\n      var inflater = vars.compressionMethod ? zlib.createInflateRaw() : Stream.PassThrough();\n\n      if (fileSizeKnown) {\n        entry.size = vars.uncompressedSize;\n        eof = vars.compressedSize;\n      } else {\n        eof = Buffer.alloc(4);\n        eof.writeUInt32LE(0x08074b50, 0);\n      }\n\n      var stream = file.stream(eof);\n\n      if (vars.decrypt)\n        stream = stream.pipe(vars.decrypt.stream());\n\n      stream\n        .pipe(inflater)\n        .on('error',function(err) { entry.emit('error',err);})\n        .pipe(entry)\n        .on('finish', function() {\n          if (req.abort)\n            req.abort();\n          else if (req.close)\n            req.close();\n          else if (req.push)\n            req.push();\n          else\n            console.log('warning - unable to close stream');\n        });\n    })\n    .catch(function(e) {\n      entry.emit('error',e);\n    });\n\n  return entry;\n};\n"]},"metadata":{},"sourceType":"script"}