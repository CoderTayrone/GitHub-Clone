{"ast":null,"code":"var fs = require('fs'),\n    Path = require('path'),\n    jph = require('json-parse-helpfulerror');\n/**\n * Default options.\n *\n * @type {Object}\n */\n\n\nexports.options = {\n  // merge all passed/found config files, see `cjson.extend`\n  merge: false,\n  // allows you to do some string replacements, see `cjson.replace`.\n  replace: null,\n  // freeze config recursively, see `cjson.freeze`\n  freeze: false,\n  // you can use any other extension for your config files, f.e. *.cjson\n  ext: '.json',\n  // you can use any parser you want. the default uses JSON.parse for maximum\n  // speed, if it throws it uses uses an alternative parser to give more\n  // helpful errors\n  parse: jph.parse\n};\n/**\n * Remove single and multilie comments. Make sure to\n * leave them inside of strings.\n *\n * @param {String} json file.\n * @return {String} json without comments.\n */\n\nexports.decomment = function (str) {\n  var i,\n      curChar,\n      nextChar,\n      inString = false,\n      inComment = false,\n      newStr = '';\n\n  for (i = 0; i < str.length; ++i) {\n    curChar = str.charAt(i);\n    nextChar = str.charAt(i + 1); // it's either closing or opening inString and it is not escaped\n\n    if (!inComment && curChar === '\"' && str.charAt(i - 1) !== '\\\\') {\n      inString = !inString;\n    } // we are not inside of a string\n\n\n    if (!inString) {\n      // singleline comment start\n      if (!inComment && curChar + nextChar === '//') {\n        ++i;\n        inComment = 1; // singleline comment end\n      } else if (inComment === 1 && curChar === '\\n') {\n        inComment = false; // multiline comment start\n      } else if (!inComment && curChar + nextChar === '/*') {\n        ++i;\n        inComment = 2;\n        curChar = ''; // multiline comment end\n      } else if (inComment === 2 && curChar + nextChar === '*/') {\n        ++i;\n        inComment = false;\n        curChar = '';\n      }\n\n      if (inComment) {\n        curChar = '';\n      }\n    }\n\n    newStr += curChar;\n  }\n\n  return newStr;\n};\n/**\n * Decomment the string and parse json.\n *\n * @param {String} json.\n * @param {Function} [reviver] will be called for every key and value at every\n *     level of the final result.\n * @return {Object} parsed json object.\n */\n\n\nexports.parse = function (str, reviver) {\n  return exports.options.parse(exports.decomment(str), reviver);\n};\n/**\n * Replace templates with data. {{toReplace}}\n *\n * @param {String} json.\n * @param {Object} data data hash.\n * @return {String} json string with replaced data.\n */\n\n\nexports.replace = function (str, data) {\n  return str.replace(/\\{\\{([^}]+)\\}\\}/g, function (match, search) {\n    return data[search] ? data[search] : match;\n  });\n};\n/**\n * Merge objects to the first one\n *\n * @param {Boolean|Object} deep if set true, deep merge will be done.\n * @param {Object} obj1 any object.\n * @param {Object} obj2 any object.\n * @return {Object} target merged object.\n */\n\n\nexports.extend = function () {\n  var toString = Object.prototype.toString,\n      obj = '[object Object]';\n  return function extend(deep, obj1, obj2\n  /*, obj1, obj2, obj3 */\n  ) {\n    // take first argument, if its not a boolean\n    var args = arguments,\n        i = deep === true ? 1 : 0,\n        key,\n        target = args[i];\n\n    for (++i; i < args.length; ++i) {\n      for (key in args[i]) {\n        if (deep === true && target[key] && // if not doing this check you may end in\n        // endless loop if using deep option\n        toString.call(args[i][key]) === obj && toString.call(target[key]) === obj) {\n          // create a copy of target object to avoid subobjects changes\n          target[key] = extend(deep, {}, target[key]);\n          extend(deep, target[key], args[i][key]);\n        } else {\n          target[key] = args[i][key];\n        }\n      }\n    }\n\n    return target;\n  };\n}();\n/**\n * Freeze the object recursively.\n *\n * @param {Object} obj.\n * @return {Object}\n */\n\n\nexports.freeze = function freeze(obj) {\n  var key;\n\n  if (obj instanceof Object) {\n    for (key in obj) {\n      freeze(obj[key]);\n    }\n\n    Object.freeze(obj);\n  }\n};\n/**\n * Load and parse a config file/files.\n *\n * @param {String|Array} path absolute path/paths to the file/files or dir.\n * @param {Object|Boolean} [options] if true, extend all jsons to the first one,\n *     it can be also object {merge: true, replace: {key: 'value'}}\n * @return {Object} conf parsed json object.\n */\n\n\nexports.load = function load(path, options) {\n  var data, paths, conf;\n\n  if (options === true) {\n    options = {\n      merge: true\n    };\n  }\n\n  options = exports.extend({}, exports.options, options);\n\n  if (Array.isArray(path)) {\n    conf = {};\n    path.forEach(function (path) {\n      var data = load(path, options),\n          filename;\n\n      if (options.merge) {\n        exports.extend(true, conf, data);\n      } else {\n        filename = Path.basename(path, options.ext);\n        conf[filename] = data;\n      }\n    });\n    return conf;\n  }\n\n  if (fs.statSync(path).isDirectory()) {\n    paths = [];\n    fs.readdirSync(path).forEach(function (filename) {\n      var file = Path.join(path, filename);\n\n      if (Path.extname(file) == options.ext && fs.statSync(file).isFile()) {\n        paths.push(file);\n      }\n    });\n    return load(paths, options);\n  }\n\n  data = fs.readFileSync(path, 'utf-8'); // replace BOM Character\n\n  data = data.replace(/\\ufeff/g, '');\n\n  if (options.replace) {\n    data = exports.replace(data, options.replace);\n  }\n\n  try {\n    data = exports.parse(data);\n  } catch (err) {\n    err.message += '\\nFile: \"' + path + '\"';\n    throw err;\n  }\n\n  if (options.freeze) {\n    exports.freeze(data);\n  }\n\n  return data;\n};","map":{"version":3,"sources":["/home/dev/Documentos/Projects/github-clone/node_modules/cjson/index.js"],"names":["fs","require","Path","jph","exports","options","merge","replace","freeze","ext","parse","decomment","str","i","curChar","nextChar","inString","inComment","newStr","length","charAt","reviver","data","match","search","extend","toString","Object","prototype","obj","deep","obj1","obj2","args","arguments","key","target","call","load","path","paths","conf","Array","isArray","forEach","filename","basename","statSync","isDirectory","readdirSync","file","join","extname","isFile","push","readFileSync","err","message"],"mappings":"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","sourcesContent":["var fs = require('fs'),\n    Path = require('path'),\n    jph = require('json-parse-helpfulerror');\n\n/**\n * Default options.\n *\n * @type {Object}\n */\nexports.options = {\n    // merge all passed/found config files, see `cjson.extend`\n    merge: false,\n    // allows you to do some string replacements, see `cjson.replace`.\n    replace: null,\n    // freeze config recursively, see `cjson.freeze`\n    freeze: false,\n    // you can use any other extension for your config files, f.e. *.cjson\n    ext: '.json',\n    // you can use any parser you want. the default uses JSON.parse for maximum\n    // speed, if it throws it uses uses an alternative parser to give more\n    // helpful errors\n    parse: jph.parse\n}\n\n/**\n * Remove single and multilie comments. Make sure to\n * leave them inside of strings.\n *\n * @param {String} json file.\n * @return {String} json without comments.\n */\nexports.decomment = function(str) {\n    var i,\n        curChar, nextChar,\n        inString = false,\n        inComment = false,\n        newStr = '';\n\n    for (i = 0; i < str.length; ++i) {\n        curChar = str.charAt(i);\n        nextChar = str.charAt(i + 1);\n\n        // it's either closing or opening inString and it is not escaped\n        if (!inComment && curChar === '\"' && str.charAt(i - 1) !== '\\\\') {\n            inString = !inString;\n        }\n\n        // we are not inside of a string\n        if (!inString) {\n            // singleline comment start\n            if (!inComment && curChar + nextChar === '//') {\n                ++i;\n                inComment = 1;\n            // singleline comment end\n            } else if (inComment === 1 && curChar === '\\n') {\n                inComment = false;\n            // multiline comment start\n            } else if (!inComment && curChar + nextChar === '/*') {\n                ++i;\n                inComment = 2;\n                curChar = '';\n            // multiline comment end\n            } else if (inComment === 2 && curChar + nextChar === '*/') {\n                ++i;\n                inComment = false;\n                curChar = '';\n            }\n\n            if (inComment) {\n                curChar = '';\n            }\n        }\n\n        newStr += curChar;\n    }\n\n\n    return newStr;\n};\n\n/**\n * Decomment the string and parse json.\n *\n * @param {String} json.\n * @param {Function} [reviver] will be called for every key and value at every\n *     level of the final result.\n * @return {Object} parsed json object.\n */\nexports.parse = function(str, reviver) {\n    return exports.options.parse(exports.decomment(str), reviver);\n};\n\n/**\n * Replace templates with data. {{toReplace}}\n *\n * @param {String} json.\n * @param {Object} data data hash.\n * @return {String} json string with replaced data.\n */\nexports.replace = function(str, data) {\n    return str.replace(/\\{\\{([^}]+)\\}\\}/g, function(match, search) {\n        return data[search] ? data[search] : match;\n    });\n};\n\n/**\n * Merge objects to the first one\n *\n * @param {Boolean|Object} deep if set true, deep merge will be done.\n * @param {Object} obj1 any object.\n * @param {Object} obj2 any object.\n * @return {Object} target merged object.\n */\nexports.extend = (function() {\n    var toString = Object.prototype.toString,\n        obj = '[object Object]';\n\n    return function extend(deep, obj1, obj2 /*, obj1, obj2, obj3 */) {\n        // take first argument, if its not a boolean\n        var args = arguments,\n            i = deep === true ? 1 : 0,\n            key,\n            target = args[i];\n\n        for (++i; i < args.length; ++i) {\n            for (key in args[i]) {\n                if (deep === true &&\n                    target[key] &&\n                    // if not doing this check you may end in\n                    // endless loop if using deep option\n                    toString.call(args[i][key]) === obj &&\n                    toString.call(target[key]) === obj) {\n\n                    // create a copy of target object to avoid subobjects changes\n                    target[key] = extend(deep, {}, target[key]);\n\n                    extend(deep, target[key], args[i][key]);\n                } else {\n                    target[key] = args[i][key];\n                }\n            }\n        }\n\n        return target;\n    };\n}());\n\n/**\n * Freeze the object recursively.\n *\n * @param {Object} obj.\n * @return {Object}\n */\nexports.freeze = function freeze(obj) {\n    var key;\n\n    if (obj instanceof Object) {\n        for (key in obj) {\n            freeze(obj[key]);\n        }\n\n        Object.freeze(obj);\n    }\n};\n\n/**\n * Load and parse a config file/files.\n *\n * @param {String|Array} path absolute path/paths to the file/files or dir.\n * @param {Object|Boolean} [options] if true, extend all jsons to the first one,\n *     it can be also object {merge: true, replace: {key: 'value'}}\n * @return {Object} conf parsed json object.\n */\nexports.load = function load(path, options) {\n    var data, paths, conf;\n\n    if (options === true) {\n        options = {merge: true};\n    }\n\n    options = exports.extend({}, exports.options, options);\n\n    if (Array.isArray(path)) {\n        conf = {};\n        path.forEach(function(path) {\n            var data = load(path, options),\n                filename;\n\n            if (options.merge) {\n                exports.extend(true, conf, data);\n            } else {\n                filename = Path.basename(path, options.ext);\n                conf[filename] = data;\n            }\n        });\n\n        return conf;\n    }\n\n    if (fs.statSync(path).isDirectory()) {\n        paths = [];\n        fs.readdirSync(path).forEach(function(filename) {\n            var file = Path.join(path, filename);\n\n            if (Path.extname(file) == options.ext && fs.statSync(file).isFile()) {\n                paths.push(file);\n            }\n        });\n\n        return load(paths, options);\n    }\n\n    data = fs.readFileSync(path, 'utf-8');\n\n    // replace BOM Character\n    data = data.replace(/\\ufeff/g, '');\n\n    if (options.replace) {\n        data = exports.replace(data, options.replace);\n    }\n\n    try {\n        data = exports.parse(data);\n    } catch(err) {\n        err.message += '\\nFile: \"' + path + '\"';\n        throw err;\n    }\n\n    if (options.freeze) {\n        exports.freeze(data);\n    }\n\n    return data;\n};\n"]},"metadata":{},"sourceType":"script"}