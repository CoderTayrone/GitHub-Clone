{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.HubExport = void 0;\n\nconst path = require(\"path\");\n\nconst fs = require(\"fs\");\n\nconst fse = require(\"fs-extra\");\n\nconst http = require(\"http\");\n\nconst api = require(\"../api\");\n\nconst logger_1 = require(\"../logger\");\n\nconst types_1 = require(\"./types\");\n\nconst registry_1 = require(\"./registry\");\n\nconst error_1 = require(\"../error\");\n\nconst hub_1 = require(\"./hub\");\n\nconst downloadableEmulators_1 = require(\"./downloadableEmulators\");\n\nconst rimraf = require(\"rimraf\");\n\nclass HubExport {\n  constructor(projectId, exportPath) {\n    this.projectId = projectId;\n    this.exportPath = exportPath;\n    this.tmpDir = fs.mkdtempSync(`firebase-export-${new Date().getTime()}`);\n  }\n\n  static readMetadata(exportPath) {\n    const metadataPath = path.join(exportPath, this.METADATA_FILE_NAME);\n\n    if (!fs.existsSync(metadataPath)) {\n      return undefined;\n    }\n\n    return JSON.parse(fs.readFileSync(metadataPath, \"utf8\").toString());\n  }\n\n  async exportAll() {\n    const toExport = types_1.ALL_EMULATORS.filter(shouldExport);\n\n    if (toExport.length === 0) {\n      throw new error_1.FirebaseError(\"No running emulators support import/export.\");\n    }\n\n    const metadata = {\n      version: hub_1.EmulatorHub.CLI_VERSION\n    };\n\n    if (shouldExport(types_1.Emulators.FIRESTORE)) {\n      metadata.firestore = {\n        version: downloadableEmulators_1.getDownloadDetails(types_1.Emulators.FIRESTORE).version,\n        path: \"firestore_export\",\n        metadata_file: \"firestore_export/firestore_export.overall_export_metadata\"\n      };\n      await this.exportFirestore(metadata);\n    }\n\n    if (shouldExport(types_1.Emulators.DATABASE)) {\n      metadata.database = {\n        version: downloadableEmulators_1.getDownloadDetails(types_1.Emulators.DATABASE).version,\n        path: \"database_export\"\n      };\n      await this.exportDatabase(metadata);\n    }\n\n    if (shouldExport(types_1.Emulators.AUTH)) {\n      metadata.auth = {\n        version: hub_1.EmulatorHub.CLI_VERSION,\n        path: \"auth_export\"\n      };\n      await this.exportAuth(metadata);\n    }\n\n    if (shouldExport(types_1.Emulators.STORAGE)) {\n      metadata.storage = {\n        version: hub_1.EmulatorHub.CLI_VERSION,\n        path: \"storage_export\"\n      };\n      await this.exportStorage(metadata);\n    }\n\n    if (!fs.existsSync(this.exportPath)) {\n      fs.mkdirSync(this.exportPath);\n    }\n\n    const metadataPath = path.join(this.tmpDir, HubExport.METADATA_FILE_NAME);\n    fs.writeFileSync(metadataPath, JSON.stringify(metadata, undefined, 2));\n    logger_1.logger.debug(`hubExport: swapping ${this.tmpDir} with ${this.exportPath}`);\n    rimraf.sync(this.exportPath);\n    fse.moveSync(this.tmpDir, this.exportPath);\n  }\n\n  async exportFirestore(metadata) {\n    const firestoreInfo = registry_1.EmulatorRegistry.get(types_1.Emulators.FIRESTORE).getInfo();\n    const firestoreHost = `http://${registry_1.EmulatorRegistry.getInfoHostString(firestoreInfo)}`;\n    const firestoreExportBody = {\n      database: `projects/${this.projectId}/databases/(default)`,\n      export_directory: this.tmpDir,\n      export_name: metadata.firestore.path\n    };\n    return api.request(\"POST\", `/emulator/v1/projects/${this.projectId}:export`, {\n      origin: firestoreHost,\n      json: true,\n      data: firestoreExportBody\n    });\n  }\n\n  async exportDatabase(metadata) {\n    const databaseEmulator = registry_1.EmulatorRegistry.get(types_1.Emulators.DATABASE);\n    const databaseAddr = `http://${registry_1.EmulatorRegistry.getInfoHostString(databaseEmulator.getInfo())}`;\n    const inspectURL = `/.inspect/databases.json?ns=${this.projectId}`;\n    const inspectRes = await api.request(\"GET\", inspectURL, {\n      origin: databaseAddr,\n      auth: true\n    });\n    const namespaces = inspectRes.body.map(instance => instance.name);\n    const namespacesToExport = [];\n\n    for (const ns of namespaces) {\n      const checkDataPath = `/.json?ns=${ns}&shallow=true&limitToFirst=1`;\n      const checkDataRes = await api.request(\"GET\", checkDataPath, {\n        origin: databaseAddr,\n        auth: true\n      });\n\n      if (checkDataRes.body !== null) {\n        namespacesToExport.push(ns);\n      } else {\n        logger_1.logger.debug(`Namespace ${ns} contained null data, not exporting`);\n      }\n    }\n\n    for (const ns of databaseEmulator.getImportedNamespaces()) {\n      if (!namespacesToExport.includes(ns)) {\n        logger_1.logger.debug(`Namespace ${ns} was imported, exporting.`);\n        namespacesToExport.push(ns);\n      }\n    }\n\n    const dbExportPath = path.join(this.tmpDir, metadata.database.path);\n\n    if (!fs.existsSync(dbExportPath)) {\n      fs.mkdirSync(dbExportPath);\n    }\n\n    const {\n      host,\n      port\n    } = databaseEmulator.getInfo();\n\n    for (const ns of namespacesToExport) {\n      const exportFile = path.join(dbExportPath, `${ns}.json`);\n      logger_1.logger.debug(`Exporting database instance: ${ns} to ${exportFile}`);\n      await fetchToFile({\n        host,\n        port,\n        path: `/.json?ns=${ns}&format=export`,\n        headers: {\n          Authorization: \"Bearer owner\"\n        }\n      }, exportFile);\n    }\n  }\n\n  async exportAuth(metadata) {\n    const {\n      host,\n      port\n    } = registry_1.EmulatorRegistry.get(types_1.Emulators.AUTH).getInfo();\n    const authExportPath = path.join(this.tmpDir, metadata.auth.path);\n\n    if (!fs.existsSync(authExportPath)) {\n      fs.mkdirSync(authExportPath);\n    }\n\n    const accountsFile = path.join(authExportPath, \"accounts.json\");\n    logger_1.logger.debug(`Exporting auth users in Project ${this.projectId} to ${accountsFile}`);\n    await fetchToFile({\n      host,\n      port,\n      path: `/identitytoolkit.googleapis.com/v1/projects/${this.projectId}/accounts:batchGet?maxResults=-1`,\n      headers: {\n        Authorization: \"Bearer owner\"\n      }\n    }, accountsFile);\n    const configFile = path.join(authExportPath, \"config.json\");\n    logger_1.logger.debug(`Exporting project config in Project ${this.projectId} to ${accountsFile}`);\n    await fetchToFile({\n      host,\n      port,\n      path: `/emulator/v1/projects/${this.projectId}/config`,\n      headers: {\n        Authorization: \"Bearer owner\"\n      }\n    }, configFile);\n  }\n\n  async exportStorage(metadata) {\n    const storageEmulator = registry_1.EmulatorRegistry.get(types_1.Emulators.STORAGE);\n    const storageExportPath = path.join(this.tmpDir, metadata.storage.path);\n\n    if (fs.existsSync(storageExportPath)) {\n      fse.removeSync(storageExportPath);\n    }\n\n    fs.mkdirSync(storageExportPath, {\n      recursive: true\n    });\n    const storageHost = `http://${registry_1.EmulatorRegistry.getInfoHostString(storageEmulator.getInfo())}`;\n    const storageExportBody = {\n      path: storageExportPath\n    };\n    return api.request(\"POST\", \"/internal/export\", {\n      origin: storageHost,\n      json: true,\n      data: storageExportBody\n    });\n  }\n\n}\n\nexports.HubExport = HubExport;\nHubExport.METADATA_FILE_NAME = \"firebase-export-metadata.json\";\n\nfunction fetchToFile(options, path) {\n  const writeStream = fs.createWriteStream(path);\n  return new Promise((resolve, reject) => {\n    http.get(options, response => {\n      response.pipe(writeStream, {\n        end: true\n      }).once(\"close\", resolve);\n    }).on(\"error\", reject);\n  });\n}\n\nfunction shouldExport(e) {\n  return types_1.IMPORT_EXPORT_EMULATORS.includes(e) && registry_1.EmulatorRegistry.isRunning(e);\n}","map":{"version":3,"sources":["/home/dev/Documentos/Projects/github-clone/node_modules/firebase-tools/lib/emulator/hubExport.js"],"names":["Object","defineProperty","exports","value","HubExport","path","require","fs","fse","http","api","logger_1","types_1","registry_1","error_1","hub_1","downloadableEmulators_1","rimraf","constructor","projectId","exportPath","tmpDir","mkdtempSync","Date","getTime","readMetadata","metadataPath","join","METADATA_FILE_NAME","existsSync","undefined","JSON","parse","readFileSync","toString","exportAll","toExport","ALL_EMULATORS","filter","shouldExport","length","FirebaseError","metadata","version","EmulatorHub","CLI_VERSION","Emulators","FIRESTORE","firestore","getDownloadDetails","metadata_file","exportFirestore","DATABASE","database","exportDatabase","AUTH","auth","exportAuth","STORAGE","storage","exportStorage","mkdirSync","writeFileSync","stringify","logger","debug","sync","moveSync","firestoreInfo","EmulatorRegistry","get","getInfo","firestoreHost","getInfoHostString","firestoreExportBody","export_directory","export_name","request","origin","json","data","databaseEmulator","databaseAddr","inspectURL","inspectRes","namespaces","body","map","instance","name","namespacesToExport","ns","checkDataPath","checkDataRes","push","getImportedNamespaces","includes","dbExportPath","host","port","exportFile","fetchToFile","headers","Authorization","authExportPath","accountsFile","configFile","storageEmulator","storageExportPath","removeSync","recursive","storageHost","storageExportBody","options","writeStream","createWriteStream","Promise","resolve","reject","response","pipe","end","once","on","e","IMPORT_EXPORT_EMULATORS","isRunning"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,SAAR,GAAoB,KAAK,CAAzB;;AACA,MAAMC,IAAI,GAAGC,OAAO,CAAC,MAAD,CAApB;;AACA,MAAMC,EAAE,GAAGD,OAAO,CAAC,IAAD,CAAlB;;AACA,MAAME,GAAG,GAAGF,OAAO,CAAC,UAAD,CAAnB;;AACA,MAAMG,IAAI,GAAGH,OAAO,CAAC,MAAD,CAApB;;AACA,MAAMI,GAAG,GAAGJ,OAAO,CAAC,QAAD,CAAnB;;AACA,MAAMK,QAAQ,GAAGL,OAAO,CAAC,WAAD,CAAxB;;AACA,MAAMM,OAAO,GAAGN,OAAO,CAAC,SAAD,CAAvB;;AACA,MAAMO,UAAU,GAAGP,OAAO,CAAC,YAAD,CAA1B;;AACA,MAAMQ,OAAO,GAAGR,OAAO,CAAC,UAAD,CAAvB;;AACA,MAAMS,KAAK,GAAGT,OAAO,CAAC,OAAD,CAArB;;AACA,MAAMU,uBAAuB,GAAGV,OAAO,CAAC,yBAAD,CAAvC;;AACA,MAAMW,MAAM,GAAGX,OAAO,CAAC,QAAD,CAAtB;;AACA,MAAMF,SAAN,CAAgB;AACZc,EAAAA,WAAW,CAACC,SAAD,EAAYC,UAAZ,EAAwB;AAC/B,SAAKD,SAAL,GAAiBA,SAAjB;AACA,SAAKC,UAAL,GAAkBA,UAAlB;AACA,SAAKC,MAAL,GAAcd,EAAE,CAACe,WAAH,CAAgB,mBAAkB,IAAIC,IAAJ,GAAWC,OAAX,EAAqB,EAAvD,CAAd;AACH;;AACkB,SAAZC,YAAY,CAACL,UAAD,EAAa;AAC5B,UAAMM,YAAY,GAAGrB,IAAI,CAACsB,IAAL,CAAUP,UAAV,EAAsB,KAAKQ,kBAA3B,CAArB;;AACA,QAAI,CAACrB,EAAE,CAACsB,UAAH,CAAcH,YAAd,CAAL,EAAkC;AAC9B,aAAOI,SAAP;AACH;;AACD,WAAOC,IAAI,CAACC,KAAL,CAAWzB,EAAE,CAAC0B,YAAH,CAAgBP,YAAhB,EAA8B,MAA9B,EAAsCQ,QAAtC,EAAX,CAAP;AACH;;AACc,QAATC,SAAS,GAAG;AACd,UAAMC,QAAQ,GAAGxB,OAAO,CAACyB,aAAR,CAAsBC,MAAtB,CAA6BC,YAA7B,CAAjB;;AACA,QAAIH,QAAQ,CAACI,MAAT,KAAoB,CAAxB,EAA2B;AACvB,YAAM,IAAI1B,OAAO,CAAC2B,aAAZ,CAA0B,6CAA1B,CAAN;AACH;;AACD,UAAMC,QAAQ,GAAG;AACbC,MAAAA,OAAO,EAAE5B,KAAK,CAAC6B,WAAN,CAAkBC;AADd,KAAjB;;AAGA,QAAIN,YAAY,CAAC3B,OAAO,CAACkC,SAAR,CAAkBC,SAAnB,CAAhB,EAA+C;AAC3CL,MAAAA,QAAQ,CAACM,SAAT,GAAqB;AACjBL,QAAAA,OAAO,EAAE3B,uBAAuB,CAACiC,kBAAxB,CAA2CrC,OAAO,CAACkC,SAAR,CAAkBC,SAA7D,EAAwEJ,OADhE;AAEjBtC,QAAAA,IAAI,EAAE,kBAFW;AAGjB6C,QAAAA,aAAa,EAAE;AAHE,OAArB;AAKA,YAAM,KAAKC,eAAL,CAAqBT,QAArB,CAAN;AACH;;AACD,QAAIH,YAAY,CAAC3B,OAAO,CAACkC,SAAR,CAAkBM,QAAnB,CAAhB,EAA8C;AAC1CV,MAAAA,QAAQ,CAACW,QAAT,GAAoB;AAChBV,QAAAA,OAAO,EAAE3B,uBAAuB,CAACiC,kBAAxB,CAA2CrC,OAAO,CAACkC,SAAR,CAAkBM,QAA7D,EAAuET,OADhE;AAEhBtC,QAAAA,IAAI,EAAE;AAFU,OAApB;AAIA,YAAM,KAAKiD,cAAL,CAAoBZ,QAApB,CAAN;AACH;;AACD,QAAIH,YAAY,CAAC3B,OAAO,CAACkC,SAAR,CAAkBS,IAAnB,CAAhB,EAA0C;AACtCb,MAAAA,QAAQ,CAACc,IAAT,GAAgB;AACZb,QAAAA,OAAO,EAAE5B,KAAK,CAAC6B,WAAN,CAAkBC,WADf;AAEZxC,QAAAA,IAAI,EAAE;AAFM,OAAhB;AAIA,YAAM,KAAKoD,UAAL,CAAgBf,QAAhB,CAAN;AACH;;AACD,QAAIH,YAAY,CAAC3B,OAAO,CAACkC,SAAR,CAAkBY,OAAnB,CAAhB,EAA6C;AACzChB,MAAAA,QAAQ,CAACiB,OAAT,GAAmB;AACfhB,QAAAA,OAAO,EAAE5B,KAAK,CAAC6B,WAAN,CAAkBC,WADZ;AAEfxC,QAAAA,IAAI,EAAE;AAFS,OAAnB;AAIA,YAAM,KAAKuD,aAAL,CAAmBlB,QAAnB,CAAN;AACH;;AACD,QAAI,CAACnC,EAAE,CAACsB,UAAH,CAAc,KAAKT,UAAnB,CAAL,EAAqC;AACjCb,MAAAA,EAAE,CAACsD,SAAH,CAAa,KAAKzC,UAAlB;AACH;;AACD,UAAMM,YAAY,GAAGrB,IAAI,CAACsB,IAAL,CAAU,KAAKN,MAAf,EAAuBjB,SAAS,CAACwB,kBAAjC,CAArB;AACArB,IAAAA,EAAE,CAACuD,aAAH,CAAiBpC,YAAjB,EAA+BK,IAAI,CAACgC,SAAL,CAAerB,QAAf,EAAyBZ,SAAzB,EAAoC,CAApC,CAA/B;AACAnB,IAAAA,QAAQ,CAACqD,MAAT,CAAgBC,KAAhB,CAAuB,uBAAsB,KAAK5C,MAAO,SAAQ,KAAKD,UAAW,EAAjF;AACAH,IAAAA,MAAM,CAACiD,IAAP,CAAY,KAAK9C,UAAjB;AACAZ,IAAAA,GAAG,CAAC2D,QAAJ,CAAa,KAAK9C,MAAlB,EAA0B,KAAKD,UAA/B;AACH;;AACoB,QAAf+B,eAAe,CAACT,QAAD,EAAW;AAC5B,UAAM0B,aAAa,GAAGvD,UAAU,CAACwD,gBAAX,CAA4BC,GAA5B,CAAgC1D,OAAO,CAACkC,SAAR,CAAkBC,SAAlD,EAA6DwB,OAA7D,EAAtB;AACA,UAAMC,aAAa,GAAI,UAAS3D,UAAU,CAACwD,gBAAX,CAA4BI,iBAA5B,CAA8CL,aAA9C,CAA6D,EAA7F;AACA,UAAMM,mBAAmB,GAAG;AACxBrB,MAAAA,QAAQ,EAAG,YAAW,KAAKlC,SAAU,sBADb;AAExBwD,MAAAA,gBAAgB,EAAE,KAAKtD,MAFC;AAGxBuD,MAAAA,WAAW,EAAElC,QAAQ,CAACM,SAAT,CAAmB3C;AAHR,KAA5B;AAKA,WAAOK,GAAG,CAACmE,OAAJ,CAAY,MAAZ,EAAqB,yBAAwB,KAAK1D,SAAU,SAA5D,EAAsE;AACzE2D,MAAAA,MAAM,EAAEN,aADiE;AAEzEO,MAAAA,IAAI,EAAE,IAFmE;AAGzEC,MAAAA,IAAI,EAAEN;AAHmE,KAAtE,CAAP;AAKH;;AACmB,QAAdpB,cAAc,CAACZ,QAAD,EAAW;AAC3B,UAAMuC,gBAAgB,GAAGpE,UAAU,CAACwD,gBAAX,CAA4BC,GAA5B,CAAgC1D,OAAO,CAACkC,SAAR,CAAkBM,QAAlD,CAAzB;AACA,UAAM8B,YAAY,GAAI,UAASrE,UAAU,CAACwD,gBAAX,CAA4BI,iBAA5B,CAA8CQ,gBAAgB,CAACV,OAAjB,EAA9C,CAA0E,EAAzG;AACA,UAAMY,UAAU,GAAI,+BAA8B,KAAKhE,SAAU,EAAjE;AACA,UAAMiE,UAAU,GAAG,MAAM1E,GAAG,CAACmE,OAAJ,CAAY,KAAZ,EAAmBM,UAAnB,EAA+B;AAAEL,MAAAA,MAAM,EAAEI,YAAV;AAAwB1B,MAAAA,IAAI,EAAE;AAA9B,KAA/B,CAAzB;AACA,UAAM6B,UAAU,GAAGD,UAAU,CAACE,IAAX,CAAgBC,GAAhB,CAAqBC,QAAD,IAAcA,QAAQ,CAACC,IAA3C,CAAnB;AACA,UAAMC,kBAAkB,GAAG,EAA3B;;AACA,SAAK,MAAMC,EAAX,IAAiBN,UAAjB,EAA6B;AACzB,YAAMO,aAAa,GAAI,aAAYD,EAAG,8BAAtC;AACA,YAAME,YAAY,GAAG,MAAMnF,GAAG,CAACmE,OAAJ,CAAY,KAAZ,EAAmBe,aAAnB,EAAkC;AACzDd,QAAAA,MAAM,EAAEI,YADiD;AAEzD1B,QAAAA,IAAI,EAAE;AAFmD,OAAlC,CAA3B;;AAIA,UAAIqC,YAAY,CAACP,IAAb,KAAsB,IAA1B,EAAgC;AAC5BI,QAAAA,kBAAkB,CAACI,IAAnB,CAAwBH,EAAxB;AACH,OAFD,MAGK;AACDhF,QAAAA,QAAQ,CAACqD,MAAT,CAAgBC,KAAhB,CAAuB,aAAY0B,EAAG,qCAAtC;AACH;AACJ;;AACD,SAAK,MAAMA,EAAX,IAAiBV,gBAAgB,CAACc,qBAAjB,EAAjB,EAA2D;AACvD,UAAI,CAACL,kBAAkB,CAACM,QAAnB,CAA4BL,EAA5B,CAAL,EAAsC;AAClChF,QAAAA,QAAQ,CAACqD,MAAT,CAAgBC,KAAhB,CAAuB,aAAY0B,EAAG,2BAAtC;AACAD,QAAAA,kBAAkB,CAACI,IAAnB,CAAwBH,EAAxB;AACH;AACJ;;AACD,UAAMM,YAAY,GAAG5F,IAAI,CAACsB,IAAL,CAAU,KAAKN,MAAf,EAAuBqB,QAAQ,CAACW,QAAT,CAAkBhD,IAAzC,CAArB;;AACA,QAAI,CAACE,EAAE,CAACsB,UAAH,CAAcoE,YAAd,CAAL,EAAkC;AAC9B1F,MAAAA,EAAE,CAACsD,SAAH,CAAaoC,YAAb;AACH;;AACD,UAAM;AAAEC,MAAAA,IAAF;AAAQC,MAAAA;AAAR,QAAiBlB,gBAAgB,CAACV,OAAjB,EAAvB;;AACA,SAAK,MAAMoB,EAAX,IAAiBD,kBAAjB,EAAqC;AACjC,YAAMU,UAAU,GAAG/F,IAAI,CAACsB,IAAL,CAAUsE,YAAV,EAAyB,GAAEN,EAAG,OAA9B,CAAnB;AACAhF,MAAAA,QAAQ,CAACqD,MAAT,CAAgBC,KAAhB,CAAuB,gCAA+B0B,EAAG,OAAMS,UAAW,EAA1E;AACA,YAAMC,WAAW,CAAC;AACdH,QAAAA,IADc;AAEdC,QAAAA,IAFc;AAGd9F,QAAAA,IAAI,EAAG,aAAYsF,EAAG,gBAHR;AAIdW,QAAAA,OAAO,EAAE;AAAEC,UAAAA,aAAa,EAAE;AAAjB;AAJK,OAAD,EAKdH,UALc,CAAjB;AAMH;AACJ;;AACe,QAAV3C,UAAU,CAACf,QAAD,EAAW;AACvB,UAAM;AAAEwD,MAAAA,IAAF;AAAQC,MAAAA;AAAR,QAAiBtF,UAAU,CAACwD,gBAAX,CAA4BC,GAA5B,CAAgC1D,OAAO,CAACkC,SAAR,CAAkBS,IAAlD,EAAwDgB,OAAxD,EAAvB;AACA,UAAMiC,cAAc,GAAGnG,IAAI,CAACsB,IAAL,CAAU,KAAKN,MAAf,EAAuBqB,QAAQ,CAACc,IAAT,CAAcnD,IAArC,CAAvB;;AACA,QAAI,CAACE,EAAE,CAACsB,UAAH,CAAc2E,cAAd,CAAL,EAAoC;AAChCjG,MAAAA,EAAE,CAACsD,SAAH,CAAa2C,cAAb;AACH;;AACD,UAAMC,YAAY,GAAGpG,IAAI,CAACsB,IAAL,CAAU6E,cAAV,EAA0B,eAA1B,CAArB;AACA7F,IAAAA,QAAQ,CAACqD,MAAT,CAAgBC,KAAhB,CAAuB,mCAAkC,KAAK9C,SAAU,OAAMsF,YAAa,EAA3F;AACA,UAAMJ,WAAW,CAAC;AACdH,MAAAA,IADc;AAEdC,MAAAA,IAFc;AAGd9F,MAAAA,IAAI,EAAG,+CAA8C,KAAKc,SAAU,kCAHtD;AAIdmF,MAAAA,OAAO,EAAE;AAAEC,QAAAA,aAAa,EAAE;AAAjB;AAJK,KAAD,EAKdE,YALc,CAAjB;AAMA,UAAMC,UAAU,GAAGrG,IAAI,CAACsB,IAAL,CAAU6E,cAAV,EAA0B,aAA1B,CAAnB;AACA7F,IAAAA,QAAQ,CAACqD,MAAT,CAAgBC,KAAhB,CAAuB,uCAAsC,KAAK9C,SAAU,OAAMsF,YAAa,EAA/F;AACA,UAAMJ,WAAW,CAAC;AACdH,MAAAA,IADc;AAEdC,MAAAA,IAFc;AAGd9F,MAAAA,IAAI,EAAG,yBAAwB,KAAKc,SAAU,SAHhC;AAIdmF,MAAAA,OAAO,EAAE;AAAEC,QAAAA,aAAa,EAAE;AAAjB;AAJK,KAAD,EAKdG,UALc,CAAjB;AAMH;;AACkB,QAAb9C,aAAa,CAAClB,QAAD,EAAW;AAC1B,UAAMiE,eAAe,GAAG9F,UAAU,CAACwD,gBAAX,CAA4BC,GAA5B,CAAgC1D,OAAO,CAACkC,SAAR,CAAkBY,OAAlD,CAAxB;AACA,UAAMkD,iBAAiB,GAAGvG,IAAI,CAACsB,IAAL,CAAU,KAAKN,MAAf,EAAuBqB,QAAQ,CAACiB,OAAT,CAAiBtD,IAAxC,CAA1B;;AACA,QAAIE,EAAE,CAACsB,UAAH,CAAc+E,iBAAd,CAAJ,EAAsC;AAClCpG,MAAAA,GAAG,CAACqG,UAAJ,CAAeD,iBAAf;AACH;;AACDrG,IAAAA,EAAE,CAACsD,SAAH,CAAa+C,iBAAb,EAAgC;AAAEE,MAAAA,SAAS,EAAE;AAAb,KAAhC;AACA,UAAMC,WAAW,GAAI,UAASlG,UAAU,CAACwD,gBAAX,CAA4BI,iBAA5B,CAA8CkC,eAAe,CAACpC,OAAhB,EAA9C,CAAyE,EAAvG;AACA,UAAMyC,iBAAiB,GAAG;AACtB3G,MAAAA,IAAI,EAAEuG;AADgB,KAA1B;AAGA,WAAOlG,GAAG,CAACmE,OAAJ,CAAY,MAAZ,EAAoB,kBAApB,EAAwC;AAC3CC,MAAAA,MAAM,EAAEiC,WADmC;AAE3ChC,MAAAA,IAAI,EAAE,IAFqC;AAG3CC,MAAAA,IAAI,EAAEgC;AAHqC,KAAxC,CAAP;AAKH;;AA1JW;;AA4JhB9G,OAAO,CAACE,SAAR,GAAoBA,SAApB;AACAA,SAAS,CAACwB,kBAAV,GAA+B,+BAA/B;;AACA,SAASyE,WAAT,CAAqBY,OAArB,EAA8B5G,IAA9B,EAAoC;AAChC,QAAM6G,WAAW,GAAG3G,EAAE,CAAC4G,iBAAH,CAAqB9G,IAArB,CAApB;AACA,SAAO,IAAI+G,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACpC7G,IAAAA,IAAI,CACC6D,GADL,CACS2C,OADT,EACmBM,QAAD,IAAc;AAC5BA,MAAAA,QAAQ,CAACC,IAAT,CAAcN,WAAd,EAA2B;AAAEO,QAAAA,GAAG,EAAE;AAAP,OAA3B,EAA0CC,IAA1C,CAA+C,OAA/C,EAAwDL,OAAxD;AACH,KAHD,EAIKM,EAJL,CAIQ,OAJR,EAIiBL,MAJjB;AAKH,GANM,CAAP;AAOH;;AACD,SAAS/E,YAAT,CAAsBqF,CAAtB,EAAyB;AACrB,SAAOhH,OAAO,CAACiH,uBAAR,CAAgC7B,QAAhC,CAAyC4B,CAAzC,KAA+C/G,UAAU,CAACwD,gBAAX,CAA4ByD,SAA5B,CAAsCF,CAAtC,CAAtD;AACH","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HubExport = void 0;\nconst path = require(\"path\");\nconst fs = require(\"fs\");\nconst fse = require(\"fs-extra\");\nconst http = require(\"http\");\nconst api = require(\"../api\");\nconst logger_1 = require(\"../logger\");\nconst types_1 = require(\"./types\");\nconst registry_1 = require(\"./registry\");\nconst error_1 = require(\"../error\");\nconst hub_1 = require(\"./hub\");\nconst downloadableEmulators_1 = require(\"./downloadableEmulators\");\nconst rimraf = require(\"rimraf\");\nclass HubExport {\n    constructor(projectId, exportPath) {\n        this.projectId = projectId;\n        this.exportPath = exportPath;\n        this.tmpDir = fs.mkdtempSync(`firebase-export-${new Date().getTime()}`);\n    }\n    static readMetadata(exportPath) {\n        const metadataPath = path.join(exportPath, this.METADATA_FILE_NAME);\n        if (!fs.existsSync(metadataPath)) {\n            return undefined;\n        }\n        return JSON.parse(fs.readFileSync(metadataPath, \"utf8\").toString());\n    }\n    async exportAll() {\n        const toExport = types_1.ALL_EMULATORS.filter(shouldExport);\n        if (toExport.length === 0) {\n            throw new error_1.FirebaseError(\"No running emulators support import/export.\");\n        }\n        const metadata = {\n            version: hub_1.EmulatorHub.CLI_VERSION,\n        };\n        if (shouldExport(types_1.Emulators.FIRESTORE)) {\n            metadata.firestore = {\n                version: downloadableEmulators_1.getDownloadDetails(types_1.Emulators.FIRESTORE).version,\n                path: \"firestore_export\",\n                metadata_file: \"firestore_export/firestore_export.overall_export_metadata\",\n            };\n            await this.exportFirestore(metadata);\n        }\n        if (shouldExport(types_1.Emulators.DATABASE)) {\n            metadata.database = {\n                version: downloadableEmulators_1.getDownloadDetails(types_1.Emulators.DATABASE).version,\n                path: \"database_export\",\n            };\n            await this.exportDatabase(metadata);\n        }\n        if (shouldExport(types_1.Emulators.AUTH)) {\n            metadata.auth = {\n                version: hub_1.EmulatorHub.CLI_VERSION,\n                path: \"auth_export\",\n            };\n            await this.exportAuth(metadata);\n        }\n        if (shouldExport(types_1.Emulators.STORAGE)) {\n            metadata.storage = {\n                version: hub_1.EmulatorHub.CLI_VERSION,\n                path: \"storage_export\",\n            };\n            await this.exportStorage(metadata);\n        }\n        if (!fs.existsSync(this.exportPath)) {\n            fs.mkdirSync(this.exportPath);\n        }\n        const metadataPath = path.join(this.tmpDir, HubExport.METADATA_FILE_NAME);\n        fs.writeFileSync(metadataPath, JSON.stringify(metadata, undefined, 2));\n        logger_1.logger.debug(`hubExport: swapping ${this.tmpDir} with ${this.exportPath}`);\n        rimraf.sync(this.exportPath);\n        fse.moveSync(this.tmpDir, this.exportPath);\n    }\n    async exportFirestore(metadata) {\n        const firestoreInfo = registry_1.EmulatorRegistry.get(types_1.Emulators.FIRESTORE).getInfo();\n        const firestoreHost = `http://${registry_1.EmulatorRegistry.getInfoHostString(firestoreInfo)}`;\n        const firestoreExportBody = {\n            database: `projects/${this.projectId}/databases/(default)`,\n            export_directory: this.tmpDir,\n            export_name: metadata.firestore.path,\n        };\n        return api.request(\"POST\", `/emulator/v1/projects/${this.projectId}:export`, {\n            origin: firestoreHost,\n            json: true,\n            data: firestoreExportBody,\n        });\n    }\n    async exportDatabase(metadata) {\n        const databaseEmulator = registry_1.EmulatorRegistry.get(types_1.Emulators.DATABASE);\n        const databaseAddr = `http://${registry_1.EmulatorRegistry.getInfoHostString(databaseEmulator.getInfo())}`;\n        const inspectURL = `/.inspect/databases.json?ns=${this.projectId}`;\n        const inspectRes = await api.request(\"GET\", inspectURL, { origin: databaseAddr, auth: true });\n        const namespaces = inspectRes.body.map((instance) => instance.name);\n        const namespacesToExport = [];\n        for (const ns of namespaces) {\n            const checkDataPath = `/.json?ns=${ns}&shallow=true&limitToFirst=1`;\n            const checkDataRes = await api.request(\"GET\", checkDataPath, {\n                origin: databaseAddr,\n                auth: true,\n            });\n            if (checkDataRes.body !== null) {\n                namespacesToExport.push(ns);\n            }\n            else {\n                logger_1.logger.debug(`Namespace ${ns} contained null data, not exporting`);\n            }\n        }\n        for (const ns of databaseEmulator.getImportedNamespaces()) {\n            if (!namespacesToExport.includes(ns)) {\n                logger_1.logger.debug(`Namespace ${ns} was imported, exporting.`);\n                namespacesToExport.push(ns);\n            }\n        }\n        const dbExportPath = path.join(this.tmpDir, metadata.database.path);\n        if (!fs.existsSync(dbExportPath)) {\n            fs.mkdirSync(dbExportPath);\n        }\n        const { host, port } = databaseEmulator.getInfo();\n        for (const ns of namespacesToExport) {\n            const exportFile = path.join(dbExportPath, `${ns}.json`);\n            logger_1.logger.debug(`Exporting database instance: ${ns} to ${exportFile}`);\n            await fetchToFile({\n                host,\n                port,\n                path: `/.json?ns=${ns}&format=export`,\n                headers: { Authorization: \"Bearer owner\" },\n            }, exportFile);\n        }\n    }\n    async exportAuth(metadata) {\n        const { host, port } = registry_1.EmulatorRegistry.get(types_1.Emulators.AUTH).getInfo();\n        const authExportPath = path.join(this.tmpDir, metadata.auth.path);\n        if (!fs.existsSync(authExportPath)) {\n            fs.mkdirSync(authExportPath);\n        }\n        const accountsFile = path.join(authExportPath, \"accounts.json\");\n        logger_1.logger.debug(`Exporting auth users in Project ${this.projectId} to ${accountsFile}`);\n        await fetchToFile({\n            host,\n            port,\n            path: `/identitytoolkit.googleapis.com/v1/projects/${this.projectId}/accounts:batchGet?maxResults=-1`,\n            headers: { Authorization: \"Bearer owner\" },\n        }, accountsFile);\n        const configFile = path.join(authExportPath, \"config.json\");\n        logger_1.logger.debug(`Exporting project config in Project ${this.projectId} to ${accountsFile}`);\n        await fetchToFile({\n            host,\n            port,\n            path: `/emulator/v1/projects/${this.projectId}/config`,\n            headers: { Authorization: \"Bearer owner\" },\n        }, configFile);\n    }\n    async exportStorage(metadata) {\n        const storageEmulator = registry_1.EmulatorRegistry.get(types_1.Emulators.STORAGE);\n        const storageExportPath = path.join(this.tmpDir, metadata.storage.path);\n        if (fs.existsSync(storageExportPath)) {\n            fse.removeSync(storageExportPath);\n        }\n        fs.mkdirSync(storageExportPath, { recursive: true });\n        const storageHost = `http://${registry_1.EmulatorRegistry.getInfoHostString(storageEmulator.getInfo())}`;\n        const storageExportBody = {\n            path: storageExportPath,\n        };\n        return api.request(\"POST\", \"/internal/export\", {\n            origin: storageHost,\n            json: true,\n            data: storageExportBody,\n        });\n    }\n}\nexports.HubExport = HubExport;\nHubExport.METADATA_FILE_NAME = \"firebase-export-metadata.json\";\nfunction fetchToFile(options, path) {\n    const writeStream = fs.createWriteStream(path);\n    return new Promise((resolve, reject) => {\n        http\n            .get(options, (response) => {\n            response.pipe(writeStream, { end: true }).once(\"close\", resolve);\n        })\n            .on(\"error\", reject);\n    });\n}\nfunction shouldExport(e) {\n    return types_1.IMPORT_EXPORT_EMULATORS.includes(e) && registry_1.EmulatorRegistry.isRunning(e);\n}\n"]},"metadata":{},"sourceType":"script"}