{"ast":null,"code":"var Match = require('../match');\n/**\n * Charset recognizer for UTF-8\n */\n\n\nmodule.exports = function () {\n  this.name = function () {\n    return 'UTF-8';\n  };\n\n  this.match = function (det) {\n    var hasBOM = false,\n        numValid = 0,\n        numInvalid = 0,\n        input = det.fRawInput,\n        trailBytes = 0,\n        confidence;\n\n    if (det.fRawLength >= 3 && (input[0] & 0xff) == 0xef && (input[1] & 0xff) == 0xbb && (input[2] & 0xff) == 0xbf) {\n      hasBOM = true;\n    } // Scan for multi-byte sequences\n\n\n    for (var i = 0; i < det.fRawLength; i++) {\n      var b = input[i];\n      if ((b & 0x80) == 0) continue; // ASCII\n      // Hi bit on char found.  Figure out how long the sequence should be\n\n      if ((b & 0x0e0) == 0x0c0) {\n        trailBytes = 1;\n      } else if ((b & 0x0f0) == 0x0e0) {\n        trailBytes = 2;\n      } else if ((b & 0x0f8) == 0xf0) {\n        trailBytes = 3;\n      } else {\n        numInvalid++;\n        if (numInvalid > 5) break;\n        trailBytes = 0;\n      } // Verify that we've got the right number of trail bytes in the sequence\n\n\n      for (;;) {\n        i++;\n        if (i >= det.fRawLength) break;\n\n        if ((input[i] & 0xc0) != 0x080) {\n          numInvalid++;\n          break;\n        }\n\n        if (--trailBytes == 0) {\n          numValid++;\n          break;\n        }\n      }\n    } // Cook up some sort of confidence score, based on presense of a BOM\n    //    and the existence of valid and/or invalid multi-byte sequences.\n\n\n    confidence = 0;\n    if (hasBOM && numInvalid == 0) confidence = 100;else if (hasBOM && numValid > numInvalid * 10) confidence = 80;else if (numValid > 3 && numInvalid == 0) confidence = 100;else if (numValid > 0 && numInvalid == 0) confidence = 80;else if (numValid == 0 && numInvalid == 0) // Plain ASCII.\n      confidence = 10;else if (numValid > numInvalid * 10) // Probably corruput utf-8 data.  Valid sequences aren't likely by chance.\n      confidence = 25;else return null;\n    return new Match(det, this, confidence);\n  };\n};","map":{"version":3,"sources":["/home/dev/Documentos/Projects/github-clone/node_modules/chardet/encoding/utf8.js"],"names":["Match","require","module","exports","name","match","det","hasBOM","numValid","numInvalid","input","fRawInput","trailBytes","confidence","fRawLength","i","b"],"mappings":"AACA,IAAIA,KAAK,GAAGC,OAAO,CAAE,UAAF,CAAnB;AAEA;AACA;AACA;;;AACAC,MAAM,CAACC,OAAP,GAAiB,YAAW;AAC1B,OAAKC,IAAL,GAAY,YAAW;AACrB,WAAO,OAAP;AACD,GAFD;;AAGA,OAAKC,KAAL,GAAa,UAASC,GAAT,EAAc;AAEzB,QAAIC,MAAM,GAAG,KAAb;AAAA,QACEC,QAAQ,GAAG,CADb;AAAA,QAEEC,UAAU,GAAG,CAFf;AAAA,QAGEC,KAAK,GAAGJ,GAAG,CAACK,SAHd;AAAA,QAIEC,UAAU,GAAG,CAJf;AAAA,QAKEC,UALF;;AAOA,QAAIP,GAAG,CAACQ,UAAJ,IAAkB,CAAlB,IACF,CAACJ,KAAK,CAAC,CAAD,CAAL,GAAW,IAAZ,KAAqB,IADnB,IAC2B,CAACA,KAAK,CAAC,CAAD,CAAL,GAAW,IAAZ,KAAqB,IADhD,IACwD,CAACA,KAAK,CAAC,CAAD,CAAL,GAAW,IAAZ,KAAqB,IADjF,EACuF;AACrFH,MAAAA,MAAM,GAAG,IAAT;AACD,KAZwB,CAczB;;;AACA,SAAK,IAAIQ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGT,GAAG,CAACQ,UAAxB,EAAoCC,CAAC,EAArC,EAAyC;AACvC,UAAIC,CAAC,GAAGN,KAAK,CAACK,CAAD,CAAb;AACA,UAAI,CAACC,CAAC,GAAG,IAAL,KAAc,CAAlB,EACE,SAHqC,CAG3B;AAEZ;;AACA,UAAI,CAACA,CAAC,GAAG,KAAL,KAAe,KAAnB,EAA0B;AACxBJ,QAAAA,UAAU,GAAG,CAAb;AACD,OAFD,MAEO,IAAI,CAACI,CAAC,GAAG,KAAL,KAAe,KAAnB,EAA0B;AAC/BJ,QAAAA,UAAU,GAAG,CAAb;AACD,OAFM,MAEA,IAAI,CAACI,CAAC,GAAG,KAAL,KAAe,IAAnB,EAAyB;AAC9BJ,QAAAA,UAAU,GAAG,CAAb;AACD,OAFM,MAEA;AACLH,QAAAA,UAAU;AACV,YAAIA,UAAU,GAAG,CAAjB,EACE;AACFG,QAAAA,UAAU,GAAG,CAAb;AACD,OAjBsC,CAmBvC;;;AACA,eAAS;AACPG,QAAAA,CAAC;AACD,YAAIA,CAAC,IAAIT,GAAG,CAACQ,UAAb,EACE;;AAEF,YAAI,CAACJ,KAAK,CAACK,CAAD,CAAL,GAAW,IAAZ,KAAqB,KAAzB,EAAgC;AAC9BN,UAAAA,UAAU;AACV;AACD;;AACD,YAAI,EAAEG,UAAF,IAAgB,CAApB,EAAuB;AACrBJ,UAAAA,QAAQ;AACR;AACD;AACF;AACF,KAjDwB,CAmDzB;AACA;;;AACAK,IAAAA,UAAU,GAAG,CAAb;AACA,QAAIN,MAAM,IAAIE,UAAU,IAAI,CAA5B,EACEI,UAAU,GAAG,GAAb,CADF,KAEK,IAAIN,MAAM,IAAIC,QAAQ,GAAGC,UAAU,GAAG,EAAtC,EACHI,UAAU,GAAG,EAAb,CADG,KAEA,IAAIL,QAAQ,GAAG,CAAX,IAAgBC,UAAU,IAAI,CAAlC,EACHI,UAAU,GAAG,GAAb,CADG,KAEA,IAAIL,QAAQ,GAAG,CAAX,IAAgBC,UAAU,IAAI,CAAlC,EACHI,UAAU,GAAG,EAAb,CADG,KAEA,IAAIL,QAAQ,IAAI,CAAZ,IAAiBC,UAAU,IAAI,CAAnC,EACH;AACAI,MAAAA,UAAU,GAAG,EAAb,CAFG,KAGA,IAAIL,QAAQ,GAAGC,UAAU,GAAG,EAA5B,EACH;AACAI,MAAAA,UAAU,GAAG,EAAb,CAFG,KAIH,OAAO,IAAP;AAEF,WAAO,IAAIb,KAAJ,CAAUM,GAAV,EAAe,IAAf,EAAqBO,UAArB,CAAP;AACD,GAxED;AAyED,CA7ED","sourcesContent":["\nvar Match = require ('../match');\n\n/**\n * Charset recognizer for UTF-8\n */\nmodule.exports = function() {\n  this.name = function() {\n    return 'UTF-8';\n  };\n  this.match = function(det) {\n\n    var hasBOM = false,\n      numValid = 0,\n      numInvalid = 0,\n      input = det.fRawInput,\n      trailBytes = 0,\n      confidence;\n\n    if (det.fRawLength >= 3 &&\n      (input[0] & 0xff) == 0xef && (input[1] & 0xff) == 0xbb && (input[2] & 0xff) == 0xbf) {\n      hasBOM = true;\n    }\n\n    // Scan for multi-byte sequences\n    for (var i = 0; i < det.fRawLength; i++) {\n      var b = input[i];\n      if ((b & 0x80) == 0)\n        continue; // ASCII\n\n      // Hi bit on char found.  Figure out how long the sequence should be\n      if ((b & 0x0e0) == 0x0c0) {\n        trailBytes = 1;\n      } else if ((b & 0x0f0) == 0x0e0) {\n        trailBytes = 2;\n      } else if ((b & 0x0f8) == 0xf0) {\n        trailBytes = 3;\n      } else {\n        numInvalid++;\n        if (numInvalid > 5)\n          break;\n        trailBytes = 0;\n      }\n\n      // Verify that we've got the right number of trail bytes in the sequence\n      for (;;) {\n        i++;\n        if (i >= det.fRawLength)\n          break;\n\n        if ((input[i] & 0xc0) != 0x080) {\n          numInvalid++;\n          break;\n        }\n        if (--trailBytes == 0) {\n          numValid++;\n          break;\n        }\n      }\n    }\n\n    // Cook up some sort of confidence score, based on presense of a BOM\n    //    and the existence of valid and/or invalid multi-byte sequences.\n    confidence = 0;\n    if (hasBOM && numInvalid == 0)\n      confidence = 100;\n    else if (hasBOM && numValid > numInvalid * 10)\n      confidence = 80;\n    else if (numValid > 3 && numInvalid == 0)\n      confidence = 100;\n    else if (numValid > 0 && numInvalid == 0)\n      confidence = 80;\n    else if (numValid == 0 && numInvalid == 0)\n      // Plain ASCII.\n      confidence = 10;\n    else if (numValid > numInvalid * 10)\n      // Probably corruput utf-8 data.  Valid sequences aren't likely by chance.\n      confidence = 25;\n    else\n      return null\n\n    return new Match(det, this, confidence);\n  };\n};\n"]},"metadata":{},"sourceType":"script"}