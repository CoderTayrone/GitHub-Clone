{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst fs_1 = require(\"fs\");\n\nconst fs_extra_1 = require(\"fs-extra\");\n\nconst file_uri_to_path_1 = __importDefault(require(\"file-uri-to-path\"));\n\nconst notfound_1 = __importDefault(require(\"./notfound\"));\n\nconst notmodified_1 = __importDefault(require(\"./notmodified\"));\n\nconst debug = debug_1.default('get-uri:file');\n/**\n * Returns a `fs.ReadStream` instance from a \"file:\" URI.\n */\n\nfunction get({\n  href: uri\n}, opts) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const {\n      cache,\n      flags = 'r',\n      mode = 438 // =0666\n\n    } = opts;\n\n    try {\n      // Convert URI → Path\n      const filepath = file_uri_to_path_1.default(uri);\n      debug('Normalized pathname: %o', filepath); // `open()` first to get a file descriptor and ensure that the file\n      // exists.\n\n      const fd = yield fs_extra_1.open(filepath, flags, mode); // Now `fstat()` to check the `mtime` and store the stat object for\n      // the cache.\n\n      const stat = yield fs_extra_1.fstat(fd); // if a `cache` was provided, check if the file has not been modified\n\n      if (cache && cache.stat && stat && isNotModified(cache.stat, stat)) {\n        throw new notmodified_1.default();\n      } // `fs.ReadStream` takes care of calling `fs.close()` on the\n      // fd after it's done reading\n      // @ts-ignore - `@types/node` doesn't allow `null` as file path :/\n\n\n      const rs = fs_1.createReadStream(null, Object.assign(Object.assign({\n        autoClose: true\n      }, opts), {\n        fd\n      }));\n      rs.stat = stat;\n      return rs;\n    } catch (err) {\n      if (err.code === 'ENOENT') {\n        throw new notfound_1.default();\n      }\n\n      throw err;\n    }\n  });\n}\n\nexports.default = get; // returns `true` if the `mtime` of the 2 stat objects are equal\n\nfunction isNotModified(prev, curr) {\n  return +prev.mtime === +curr.mtime;\n}","map":{"version":3,"sources":["../src/file.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA,MAAA,OAAA,GAAA,eAAA,CAAA,OAAA,CAAA,OAAA,CAAA,CAAA;;AACA,MAAA,IAAA,GAAA,OAAA,CAAA,IAAA,CAAA;;AACA,MAAA,UAAA,GAAA,OAAA,CAAA,UAAA,CAAA;;AACA,MAAA,kBAAA,GAAA,eAAA,CAAA,OAAA,CAAA,kBAAA,CAAA,CAAA;;AAEA,MAAA,UAAA,GAAA,eAAA,CAAA,OAAA,CAAA,YAAA,CAAA,CAAA;;AACA,MAAA,aAAA,GAAA,eAAA,CAAA,OAAA,CAAA,eAAA,CAAA,CAAA;;AAEA,MAAM,KAAK,GAAG,OAAA,CAAA,OAAA,CAAY,cAAZ,CAAd;AAgBA;;AAEG;;AAEH,SAA8B,GAA9B,CACC;AAAE,EAAA,IAAI,EAAE;AAAR,CADD,EAEC,IAFD,EAEkB;;AAEjB,UAAM;AACL,MAAA,KADK;AAEL,MAAA,KAAK,GAAG,GAFH;AAGL,MAAA,IAAI,GAAG,GAHF,CAGM;;AAHN,QAIF,IAJJ;;AAMA,QAAI;AACH;AACA,YAAM,QAAQ,GAAG,kBAAA,CAAA,OAAA,CAAS,GAAT,CAAjB;AACA,MAAA,KAAK,CAAC,yBAAD,EAA4B,QAA5B,CAAL,CAHG,CAKH;AACA;;AACA,YAAM,EAAE,GAAG,MAAM,UAAA,CAAA,IAAA,CAAK,QAAL,EAAe,KAAf,EAAsB,IAAtB,CAAjB,CAPG,CASH;AACA;;AACA,YAAM,IAAI,GAAG,MAAM,UAAA,CAAA,KAAA,CAAM,EAAN,CAAnB,CAXG,CAaH;;AACA,UAAI,KAAK,IAAI,KAAK,CAAC,IAAf,IAAuB,IAAvB,IAA+B,aAAa,CAAC,KAAK,CAAC,IAAP,EAAa,IAAb,CAAhD,EAAoE;AACnE,cAAM,IAAI,aAAA,CAAA,OAAJ,EAAN;AACA,OAhBE,CAkBH;AACA;AACA;;;AACA,YAAM,EAAE,GAAG,IAAA,CAAA,gBAAA,CAAiB,IAAjB,EAAqB,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA;AAC/B,QAAA,SAAS,EAAE;AADoB,OAAA,EAE5B,IAF4B,CAAA,EAExB;AACP,QAAA;AADO,OAFwB,CAArB,CAAX;AAKA,MAAA,EAAE,CAAC,IAAH,GAAU,IAAV;AACA,aAAO,EAAP;AACA,KA5BD,CA4BE,OAAO,GAAP,EAAY;AACb,UAAI,GAAG,CAAC,IAAJ,KAAa,QAAjB,EAA2B;AAC1B,cAAM,IAAI,UAAA,CAAA,OAAJ,EAAN;AACA;;AACD,YAAM,GAAN;AACA;AACD,G;AAAA;;AA5CD,OAAA,CAAA,OAAA,GAAA,GAAA,C,CA8CA;;AACA,SAAS,aAAT,CAAuB,IAAvB,EAAoC,IAApC,EAA+C;AAC9C,SAAO,CAAC,IAAI,CAAC,KAAN,KAAgB,CAAC,IAAI,CAAC,KAA7B;AACA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst debug_1 = __importDefault(require(\"debug\"));\nconst fs_1 = require(\"fs\");\nconst fs_extra_1 = require(\"fs-extra\");\nconst file_uri_to_path_1 = __importDefault(require(\"file-uri-to-path\"));\nconst notfound_1 = __importDefault(require(\"./notfound\"));\nconst notmodified_1 = __importDefault(require(\"./notmodified\"));\nconst debug = debug_1.default('get-uri:file');\n/**\n * Returns a `fs.ReadStream` instance from a \"file:\" URI.\n */\nfunction get({ href: uri }, opts) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const { cache, flags = 'r', mode = 438 // =0666\n         } = opts;\n        try {\n            // Convert URI → Path\n            const filepath = file_uri_to_path_1.default(uri);\n            debug('Normalized pathname: %o', filepath);\n            // `open()` first to get a file descriptor and ensure that the file\n            // exists.\n            const fd = yield fs_extra_1.open(filepath, flags, mode);\n            // Now `fstat()` to check the `mtime` and store the stat object for\n            // the cache.\n            const stat = yield fs_extra_1.fstat(fd);\n            // if a `cache` was provided, check if the file has not been modified\n            if (cache && cache.stat && stat && isNotModified(cache.stat, stat)) {\n                throw new notmodified_1.default();\n            }\n            // `fs.ReadStream` takes care of calling `fs.close()` on the\n            // fd after it's done reading\n            // @ts-ignore - `@types/node` doesn't allow `null` as file path :/\n            const rs = fs_1.createReadStream(null, Object.assign(Object.assign({ autoClose: true }, opts), { fd }));\n            rs.stat = stat;\n            return rs;\n        }\n        catch (err) {\n            if (err.code === 'ENOENT') {\n                throw new notfound_1.default();\n            }\n            throw err;\n        }\n    });\n}\nexports.default = get;\n// returns `true` if the `mtime` of the 2 stat objects are equal\nfunction isNotModified(prev, curr) {\n    return +prev.mtime === +curr.mtime;\n}\n//# sourceMappingURL=file.js.map"]},"metadata":{},"sourceType":"script"}