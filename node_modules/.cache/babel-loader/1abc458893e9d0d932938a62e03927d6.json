{"ast":null,"code":"var assert = require('assert');\n\nvar tokenize = require('./parse').tokenize;\n\nvar stringify = require('./stringify').stringify;\n\nvar analyze = require('./analyze').analyze;\n\nfunction isObject(x) {\n  return typeof x === 'object' && x !== null;\n}\n\nfunction value_to_tokenlist(value, stack, options, is_key, indent) {\n  options = Object.create(options);\n  options._stringify_key = !!is_key;\n\n  if (indent) {\n    options._prefix = indent.prefix.map(function (x) {\n      return x.raw;\n    }).join('');\n  }\n\n  if (options._splitMin == null) options._splitMin = 0;\n  if (options._splitMax == null) options._splitMax = 0;\n  var stringified = stringify(value, options);\n\n  if (is_key) {\n    return [{\n      raw: stringified,\n      type: 'key',\n      stack: stack,\n      value: value\n    }];\n  }\n\n  options._addstack = stack;\n  var result = tokenize(stringified, {\n    _addstack: stack\n  });\n  result.data = null;\n  return result;\n} // '1.2.3' -> ['1','2','3']\n\n\nfunction arg_to_path(path) {\n  // array indexes\n  if (typeof path === 'number') path = String(path);\n  if (path === '') path = [];\n  if (typeof path === 'string') path = path.split('.');\n  if (!Array.isArray(path)) throw Error('Invalid path type, string or array expected');\n  return path;\n} // returns new [begin, end] or false if not found\n//\n//          {x:3, xxx: 111, y: [111,  {q: 1, e: 2}  ,333]  }\n// f('y',0) returns this       B^^^^^^^^^^^^^^^^^^^^^^^^E\n// then f('1',1) would reduce it to   B^^^^^^^^^^E\n\n\nfunction find_element_in_tokenlist(element, lvl, tokens, begin, end) {\n  while (tokens[begin].stack[lvl] != element) {\n    if (begin++ >= end) return false;\n  }\n\n  while (tokens[end].stack[lvl] != element) {\n    if (end-- < begin) return false;\n  }\n\n  return [begin, end];\n}\n\nfunction is_whitespace(token_type) {\n  return token_type === 'whitespace' || token_type === 'newline' || token_type === 'comment';\n}\n\nfunction find_first_non_ws_token(tokens, begin, end) {\n  while (is_whitespace(tokens[begin].type)) {\n    if (begin++ >= end) return false;\n  }\n\n  return begin;\n}\n\nfunction find_last_non_ws_token(tokens, begin, end) {\n  while (is_whitespace(tokens[end].type)) {\n    if (end-- < begin) return false;\n  }\n\n  return end;\n}\n/*\n * when appending a new element of an object/array, we are trying to\n * figure out the style used on the previous element\n *\n * return {prefix, sep1, sep2, suffix}\n *\n *      '    \"key\" :  \"element\"    \\r\\n'\n * prefix^^^^ sep1^ ^^sep2     ^^^^^^^^suffix\n *\n * begin - the beginning of the object/array\n * end - last token of the last element (value or comma usually)\n */\n\n\nfunction detect_indent_style(tokens, is_array, begin, end, level) {\n  var result = {\n    sep1: [],\n    sep2: [],\n    suffix: [],\n    prefix: [],\n    newline: []\n  };\n\n  if (tokens[end].type === 'separator' && tokens[end].stack.length !== level + 1 && tokens[end].raw !== ',') {\n    // either a beginning of the array (no last element) or other weird situation\n    //\n    // just return defaults\n    return result;\n  } //                              ' \"key\"  : \"value\"  ,'\n  // skipping last separator, we're now here        ^^\n\n\n  if (tokens[end].type === 'separator') end = find_last_non_ws_token(tokens, begin, end - 1);\n  if (end === false) return result; //                              ' \"key\"  : \"value\"  ,'\n  // skipping value                          ^^^^^^^\n\n  while (tokens[end].stack.length > level) end--;\n\n  if (!is_array) {\n    while (is_whitespace(tokens[end].type)) {\n      if (end < begin) return result;\n\n      if (tokens[end].type === 'whitespace') {\n        result.sep2.unshift(tokens[end]);\n      } else {\n        // newline, comment or other unrecognized codestyle\n        return result;\n      }\n\n      end--;\n    } //                              ' \"key\"  : \"value\"  ,'\n    // skipping separator                    ^\n\n\n    assert.equal(tokens[end].type, 'separator');\n    assert.equal(tokens[end].raw, ':');\n\n    while (is_whitespace(tokens[--end].type)) {\n      if (end < begin) return result;\n\n      if (tokens[end].type === 'whitespace') {\n        result.sep1.unshift(tokens[end]);\n      } else {\n        // newline, comment or other unrecognized codestyle\n        return result;\n      }\n    }\n\n    assert.equal(tokens[end].type, 'key');\n    end--;\n  } //                              ' \"key\"  : \"value\"  ,'\n  // skipping key                   ^^^^^\n\n\n  while (is_whitespace(tokens[end].type)) {\n    if (end < begin) return result;\n\n    if (tokens[end].type === 'whitespace') {\n      result.prefix.unshift(tokens[end]);\n    } else if (tokens[end].type === 'newline') {\n      result.newline.unshift(tokens[end]);\n      return result;\n    } else {\n      // comment or other unrecognized codestyle\n      return result;\n    }\n\n    end--;\n  }\n\n  return result;\n}\n\nfunction Document(text, options) {\n  var self = Object.create(Document.prototype);\n  if (options == null) options = {}; //options._structure = true\n\n  var tokens = self._tokens = tokenize(text, options);\n  self._data = tokens.data;\n  tokens.data = null;\n  self._options = options;\n  var stats = analyze(text, options);\n\n  if (options.indent == null) {\n    options.indent = stats.indent;\n  }\n\n  if (options.quote == null) {\n    options.quote = stats.quote;\n  }\n\n  if (options.quote_keys == null) {\n    options.quote_keys = stats.quote_keys;\n  }\n\n  if (options.no_trailing_comma == null) {\n    options.no_trailing_comma = !stats.has_trailing_comma;\n  }\n\n  return self;\n} // return true if it's a proper object\n//        throw otherwise\n\n\nfunction check_if_can_be_placed(key, object, is_unset) {\n  //if (object == null) return false\n  function error(add) {\n    return Error(\"You can't \" + (is_unset ? 'unset' : 'set') + \" key '\" + key + \"'\" + add);\n  }\n\n  if (!isObject(object)) {\n    throw error(' of an non-object');\n  }\n\n  if (Array.isArray(object)) {\n    // array, check boundary\n    if (String(key).match(/^\\d+$/)) {\n      key = Number(String(key));\n\n      if (object.length < key || is_unset && object.length === key) {\n        throw error(', out of bounds');\n      } else if (is_unset && object.length !== key + 1) {\n        throw error(' in the middle of an array');\n      } else {\n        return true;\n      }\n    } else {\n      throw error(' of an array');\n    }\n  } else {\n    // object\n    return true;\n  }\n} // usage: document.set('path.to.something', 'value')\n//    or: document.set(['path','to','something'], 'value')\n\n\nDocument.prototype.set = function (path, value) {\n  path = arg_to_path(path); // updating this._data and check for errors\n\n  if (path.length === 0) {\n    if (value === undefined) throw Error(\"can't remove root document\");\n    this._data = value;\n    var new_key = false;\n  } else {\n    var data = this._data;\n\n    for (var i = 0; i < path.length - 1; i++) {\n      check_if_can_be_placed(path[i], data, false);\n      data = data[path[i]];\n    }\n\n    if (i === path.length - 1) {\n      check_if_can_be_placed(path[i], data, value === undefined);\n    }\n\n    var new_key = !(path[i] in data);\n\n    if (value === undefined) {\n      if (Array.isArray(data)) {\n        data.pop();\n      } else {\n        delete data[path[i]];\n      }\n    } else {\n      data[path[i]] = value;\n    }\n  } // for inserting document\n\n\n  if (!this._tokens.length) this._tokens = [{\n    raw: '',\n    type: 'literal',\n    stack: [],\n    value: undefined\n  }];\n  var position = [find_first_non_ws_token(this._tokens, 0, this._tokens.length - 1), find_last_non_ws_token(this._tokens, 0, this._tokens.length - 1)];\n\n  for (var i = 0; i < path.length - 1; i++) {\n    position = find_element_in_tokenlist(path[i], i, this._tokens, position[0], position[1]);\n    if (position == false) throw Error('internal error, please report this');\n  } // assume that i == path.length-1 here\n\n\n  if (path.length === 0) {\n    var newtokens = value_to_tokenlist(value, path, this._options); // all good\n  } else if (!new_key) {\n    // replace old value with a new one (or deleting something)\n    var pos_old = position;\n    position = find_element_in_tokenlist(path[i], i, this._tokens, position[0], position[1]);\n\n    if (value === undefined && position !== false) {\n      // deleting element (position !== false ensures there's something)\n      var newtokens = [];\n\n      if (!Array.isArray(data)) {\n        // removing element from an object, `{x:1, key:CURRENT} -> {x:1}`\n        // removing sep, literal and optional sep\n        // ':'\n        var pos2 = find_last_non_ws_token(this._tokens, pos_old[0], position[0] - 1);\n        assert.equal(this._tokens[pos2].type, 'separator');\n        assert.equal(this._tokens[pos2].raw, ':');\n        position[0] = pos2; // key\n\n        var pos2 = find_last_non_ws_token(this._tokens, pos_old[0], position[0] - 1);\n        assert.equal(this._tokens[pos2].type, 'key');\n        assert.equal(this._tokens[pos2].value, path[path.length - 1]);\n        position[0] = pos2;\n      } // removing comma in arrays and objects\n\n\n      var pos2 = find_last_non_ws_token(this._tokens, pos_old[0], position[0] - 1);\n      assert.equal(this._tokens[pos2].type, 'separator');\n\n      if (this._tokens[pos2].raw === ',') {\n        position[0] = pos2;\n      } else {\n        // beginning of the array/object, so we should remove trailing comma instead\n        pos2 = find_first_non_ws_token(this._tokens, position[1] + 1, pos_old[1]);\n        assert.equal(this._tokens[pos2].type, 'separator');\n\n        if (this._tokens[pos2].raw === ',') {\n          position[1] = pos2;\n        }\n      }\n    } else {\n      var indent = pos2 !== false ? detect_indent_style(this._tokens, Array.isArray(data), pos_old[0], position[1] - 1, i) : {};\n      var newtokens = value_to_tokenlist(value, path, this._options, false, indent);\n    }\n  } else {\n    // insert new key, that's tricky\n    var path_1 = path.slice(0, i); //  find a last separator after which we're inserting it\n\n    var pos2 = find_last_non_ws_token(this._tokens, position[0] + 1, position[1] - 1);\n    assert(pos2 !== false);\n    var indent = pos2 !== false ? detect_indent_style(this._tokens, Array.isArray(data), position[0] + 1, pos2, i) : {};\n    var newtokens = value_to_tokenlist(value, path, this._options, false, indent); // adding leading whitespaces according to detected codestyle\n\n    var prefix = [];\n    if (indent.newline && indent.newline.length) prefix = prefix.concat(indent.newline);\n    if (indent.prefix && indent.prefix.length) prefix = prefix.concat(indent.prefix); // adding '\"key\":' (as in \"key\":\"value\") to object values\n\n    if (!Array.isArray(data)) {\n      prefix = prefix.concat(value_to_tokenlist(path[path.length - 1], path_1, this._options, true));\n      if (indent.sep1 && indent.sep1.length) prefix = prefix.concat(indent.sep1);\n      prefix.push({\n        raw: ':',\n        type: 'separator',\n        stack: path_1\n      });\n      if (indent.sep2 && indent.sep2.length) prefix = prefix.concat(indent.sep2);\n    }\n\n    newtokens.unshift.apply(newtokens, prefix); // check if prev token is a separator AND they're at the same level\n\n    if (this._tokens[pos2].type === 'separator' && this._tokens[pos2].stack.length === path.length - 1) {\n      // previous token is either , or [ or {\n      if (this._tokens[pos2].raw === ',') {\n        // restore ending comma\n        newtokens.push({\n          raw: ',',\n          type: 'separator',\n          stack: path_1\n        });\n      }\n    } else {\n      // previous token isn't a separator, so need to insert one\n      newtokens.unshift({\n        raw: ',',\n        type: 'separator',\n        stack: path_1\n      });\n    }\n\n    if (indent.suffix && indent.suffix.length) newtokens.push.apply(newtokens, indent.suffix);\n    assert.equal(this._tokens[position[1]].type, 'separator');\n    position[0] = pos2 + 1;\n    position[1] = pos2;\n  }\n\n  newtokens.unshift(position[1] - position[0] + 1);\n  newtokens.unshift(position[0]);\n\n  this._tokens.splice.apply(this._tokens, newtokens);\n\n  return this;\n}; // convenience method\n\n\nDocument.prototype.unset = function (path) {\n  return this.set(path, undefined);\n};\n\nDocument.prototype.get = function (path) {\n  path = arg_to_path(path);\n  var data = this._data;\n\n  for (var i = 0; i < path.length; i++) {\n    if (!isObject(data)) return undefined;\n    data = data[path[i]];\n  }\n\n  return data;\n};\n\nDocument.prototype.has = function (path) {\n  path = arg_to_path(path);\n  var data = this._data;\n\n  for (var i = 0; i < path.length; i++) {\n    if (!isObject(data)) return false;\n    data = data[path[i]];\n  }\n\n  return data !== undefined;\n}; // compare old object and new one, and change differences only\n\n\nDocument.prototype.update = function (value) {\n  var self = this;\n  change([], self._data, value);\n  return self;\n\n  function change(path, old_data, new_data) {\n    if (!isObject(new_data) || !isObject(old_data)) {\n      // if source or dest is primitive, just replace\n      if (new_data !== old_data) self.set(path, new_data);\n    } else if (Array.isArray(new_data) != Array.isArray(old_data)) {\n      // old data is an array XOR new data is an array, replace as well\n      self.set(path, new_data);\n    } else if (Array.isArray(new_data)) {\n      // both values are arrays here\n      if (new_data.length > old_data.length) {\n        // adding new elements, so going forward\n        for (var i = 0; i < new_data.length; i++) {\n          path.push(String(i));\n          change(path, old_data[i], new_data[i]);\n          path.pop();\n        }\n      } else {\n        // removing something, so going backward\n        for (var i = old_data.length - 1; i >= 0; i--) {\n          path.push(String(i));\n          change(path, old_data[i], new_data[i]);\n          path.pop();\n        }\n      }\n    } else {\n      // both values are objects here\n      for (var i in new_data) {\n        path.push(String(i));\n        change(path, old_data[i], new_data[i]);\n        path.pop();\n      }\n\n      for (var i in old_data) {\n        if (i in new_data) continue;\n        path.push(String(i));\n        change(path, old_data[i], new_data[i]);\n        path.pop();\n      }\n    }\n  }\n};\n\nDocument.prototype.toString = function () {\n  return this._tokens.map(function (x) {\n    return x.raw;\n  }).join('');\n};\n\nmodule.exports.Document = Document;\n\nmodule.exports.update = function updateJSON(source, new_value, options) {\n  return Document(source, options).update(new_value).toString();\n};","map":{"version":3,"sources":["/home/dev/Documentos/Projects/github-clone/node_modules/jju/lib/document.js"],"names":["assert","require","tokenize","stringify","analyze","isObject","x","value_to_tokenlist","value","stack","options","is_key","indent","Object","create","_stringify_key","_prefix","prefix","map","raw","join","_splitMin","_splitMax","stringified","type","_addstack","result","data","arg_to_path","path","String","split","Array","isArray","Error","find_element_in_tokenlist","element","lvl","tokens","begin","end","is_whitespace","token_type","find_first_non_ws_token","find_last_non_ws_token","detect_indent_style","is_array","level","sep1","sep2","suffix","newline","length","unshift","equal","Document","text","self","prototype","_tokens","_data","_options","stats","quote","quote_keys","no_trailing_comma","has_trailing_comma","check_if_can_be_placed","key","object","is_unset","error","add","match","Number","set","undefined","new_key","i","pop","position","newtokens","pos_old","pos2","path_1","slice","concat","push","apply","splice","unset","get","has","update","change","old_data","new_data","toString","module","exports","updateJSON","source","new_value"],"mappings":"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","sourcesContent":["\nvar assert = require('assert')\nvar tokenize = require('./parse').tokenize\nvar stringify = require('./stringify').stringify\nvar analyze = require('./analyze').analyze\n\nfunction isObject(x) {\n  return typeof(x) === 'object' && x !== null\n}\n\nfunction value_to_tokenlist(value, stack, options, is_key, indent) {\n  options = Object.create(options)\n  options._stringify_key = !!is_key\n\n  if (indent) {\n    options._prefix = indent.prefix.map(function(x) {\n      return x.raw\n    }).join('')\n  }\n\n  if (options._splitMin == null) options._splitMin = 0\n  if (options._splitMax == null) options._splitMax = 0\n\n  var stringified = stringify(value, options)\n\n  if (is_key) {\n    return [ { raw: stringified, type: 'key', stack: stack, value: value } ]\n  }\n\n  options._addstack = stack\n  var result = tokenize(stringified, {\n    _addstack: stack,\n  })\n  result.data = null\n  return result\n}\n\n// '1.2.3' -> ['1','2','3']\nfunction arg_to_path(path) {\n  // array indexes\n  if (typeof(path) === 'number') path = String(path)\n\n  if (path === '') path = []\n  if (typeof(path) === 'string') path = path.split('.')\n\n  if (!Array.isArray(path)) throw Error('Invalid path type, string or array expected')\n  return path\n}\n\n// returns new [begin, end] or false if not found\n//\n//          {x:3, xxx: 111, y: [111,  {q: 1, e: 2}  ,333]  }\n// f('y',0) returns this       B^^^^^^^^^^^^^^^^^^^^^^^^E\n// then f('1',1) would reduce it to   B^^^^^^^^^^E\nfunction find_element_in_tokenlist(element, lvl, tokens, begin, end) {\n  while(tokens[begin].stack[lvl] != element) {\n    if (begin++ >= end) return false\n  }\n  while(tokens[end].stack[lvl] != element) {\n    if (end-- < begin) return false\n  }\n  return [begin, end]\n}\n\nfunction is_whitespace(token_type) {\n  return token_type === 'whitespace'\n      || token_type === 'newline'\n      || token_type === 'comment'\n}\n\nfunction find_first_non_ws_token(tokens, begin, end) {\n  while(is_whitespace(tokens[begin].type)) {\n    if (begin++ >= end) return false\n  }\n  return begin\n}\n\nfunction find_last_non_ws_token(tokens, begin, end) {\n  while(is_whitespace(tokens[end].type)) {\n    if (end-- < begin) return false\n  }\n  return end\n}\n\n/*\n * when appending a new element of an object/array, we are trying to\n * figure out the style used on the previous element\n *\n * return {prefix, sep1, sep2, suffix}\n *\n *      '    \"key\" :  \"element\"    \\r\\n'\n * prefix^^^^ sep1^ ^^sep2     ^^^^^^^^suffix\n *\n * begin - the beginning of the object/array\n * end - last token of the last element (value or comma usually)\n */\nfunction detect_indent_style(tokens, is_array, begin, end, level) {\n  var result = {\n    sep1: [],\n    sep2: [],\n    suffix: [],\n    prefix: [],\n    newline: [],\n  }\n\n  if (tokens[end].type === 'separator' && tokens[end].stack.length !== level+1 && tokens[end].raw !== ',') {\n    // either a beginning of the array (no last element) or other weird situation\n    //\n    // just return defaults\n    return result\n  }\n\n  //                              ' \"key\"  : \"value\"  ,'\n  // skipping last separator, we're now here        ^^\n  if (tokens[end].type === 'separator')\n    end = find_last_non_ws_token(tokens, begin, end - 1)\n  if (end === false) return result\n\n  //                              ' \"key\"  : \"value\"  ,'\n  // skipping value                          ^^^^^^^\n  while(tokens[end].stack.length > level) end--\n\n  if (!is_array) {\n    while(is_whitespace(tokens[end].type)) {\n      if (end < begin) return result\n      if (tokens[end].type === 'whitespace') {\n        result.sep2.unshift(tokens[end])\n      } else {\n        // newline, comment or other unrecognized codestyle\n        return result\n      }\n      end--\n    }\n\n    //                              ' \"key\"  : \"value\"  ,'\n    // skipping separator                    ^\n    assert.equal(tokens[end].type, 'separator')\n    assert.equal(tokens[end].raw, ':')\n    while(is_whitespace(tokens[--end].type)) {\n      if (end < begin) return result\n      if (tokens[end].type === 'whitespace') {\n        result.sep1.unshift(tokens[end])\n      } else {\n        // newline, comment or other unrecognized codestyle\n        return result\n      }\n    }\n\n    assert.equal(tokens[end].type, 'key')\n    end--\n  }\n\n  //                              ' \"key\"  : \"value\"  ,'\n  // skipping key                   ^^^^^\n  while(is_whitespace(tokens[end].type)) {\n    if (end < begin) return result\n    if (tokens[end].type === 'whitespace') {\n      result.prefix.unshift(tokens[end])\n    } else if (tokens[end].type === 'newline') {\n      result.newline.unshift(tokens[end])\n      return result\n    } else {\n      // comment or other unrecognized codestyle\n      return result\n    }\n    end--\n  }\n\n  return result\n}\n\nfunction Document(text, options) {\n  var self = Object.create(Document.prototype)\n\n  if (options == null) options = {}\n  //options._structure = true\n  var tokens = self._tokens = tokenize(text, options)\n  self._data = tokens.data\n  tokens.data = null\n  self._options = options\n\n  var stats = analyze(text, options)\n  if (options.indent == null) {\n    options.indent = stats.indent\n  }\n  if (options.quote == null) {\n    options.quote = stats.quote\n  }\n  if (options.quote_keys == null) {\n    options.quote_keys = stats.quote_keys\n  }\n  if (options.no_trailing_comma == null) {\n    options.no_trailing_comma = !stats.has_trailing_comma\n  }\n  return self\n}\n\n// return true if it's a proper object\n//        throw otherwise\nfunction check_if_can_be_placed(key, object, is_unset) {\n  //if (object == null) return false\n  function error(add) {\n    return Error(\"You can't \" + (is_unset ? 'unset' : 'set') + \" key '\" + key + \"'\" + add)\n  }\n\n  if (!isObject(object)) {\n    throw error(' of an non-object')\n  }\n  if (Array.isArray(object)) {\n    // array, check boundary\n    if (String(key).match(/^\\d+$/)) {\n      key = Number(String(key))\n      if (object.length < key || (is_unset && object.length === key)) {\n        throw error(', out of bounds')\n      } else if (is_unset && object.length !== key+1) {\n        throw error(' in the middle of an array')\n      } else {\n        return true\n      }\n    } else {\n      throw error(' of an array')\n    }\n  } else {\n    // object\n    return true\n  }\n}\n\n// usage: document.set('path.to.something', 'value')\n//    or: document.set(['path','to','something'], 'value')\nDocument.prototype.set = function(path, value) {\n  path = arg_to_path(path)\n\n  // updating this._data and check for errors\n  if (path.length === 0) {\n    if (value === undefined) throw Error(\"can't remove root document\")\n    this._data = value\n    var new_key = false\n\n  } else {\n    var data = this._data\n\n    for (var i=0; i<path.length-1; i++) {\n      check_if_can_be_placed(path[i], data, false)\n      data = data[path[i]]\n    }\n    if (i === path.length-1) {\n      check_if_can_be_placed(path[i], data, value === undefined)\n    }\n\n    var new_key = !(path[i] in data)\n\n    if (value === undefined) {\n      if (Array.isArray(data)) {\n        data.pop()\n      } else {\n        delete data[path[i]]\n      }\n    } else {\n      data[path[i]] = value\n    }\n  }\n\n  // for inserting document\n  if (!this._tokens.length)\n    this._tokens = [ { raw: '', type: 'literal', stack: [], value: undefined } ]\n\n  var position = [\n    find_first_non_ws_token(this._tokens, 0, this._tokens.length - 1),\n    find_last_non_ws_token(this._tokens, 0, this._tokens.length - 1),\n  ]\n  for (var i=0; i<path.length-1; i++) {\n    position = find_element_in_tokenlist(path[i], i, this._tokens, position[0], position[1])\n    if (position == false) throw Error('internal error, please report this')\n  }\n  // assume that i == path.length-1 here\n\n  if (path.length === 0) {\n    var newtokens = value_to_tokenlist(value, path, this._options)\n    // all good\n\n  } else if (!new_key) {\n    // replace old value with a new one (or deleting something)\n    var pos_old = position\n    position = find_element_in_tokenlist(path[i], i, this._tokens, position[0], position[1])\n\n    if (value === undefined && position !== false) {\n      // deleting element (position !== false ensures there's something)\n      var newtokens = []\n\n      if (!Array.isArray(data)) {\n        // removing element from an object, `{x:1, key:CURRENT} -> {x:1}`\n        // removing sep, literal and optional sep\n        // ':'\n        var pos2 = find_last_non_ws_token(this._tokens, pos_old[0], position[0] - 1)\n        assert.equal(this._tokens[pos2].type, 'separator')\n        assert.equal(this._tokens[pos2].raw, ':')\n        position[0] = pos2\n\n        // key\n        var pos2 = find_last_non_ws_token(this._tokens, pos_old[0], position[0] - 1)\n        assert.equal(this._tokens[pos2].type, 'key')\n        assert.equal(this._tokens[pos2].value, path[path.length-1])\n        position[0] = pos2\n      }\n\n      // removing comma in arrays and objects\n      var pos2 = find_last_non_ws_token(this._tokens, pos_old[0], position[0] - 1)\n      assert.equal(this._tokens[pos2].type, 'separator')\n      if (this._tokens[pos2].raw === ',') {\n        position[0] = pos2\n      } else {\n        // beginning of the array/object, so we should remove trailing comma instead\n        pos2 = find_first_non_ws_token(this._tokens, position[1] + 1, pos_old[1])\n        assert.equal(this._tokens[pos2].type, 'separator')\n        if (this._tokens[pos2].raw === ',') {\n          position[1] = pos2\n        }\n      }\n\n    } else {\n      var indent = pos2 !== false\n                 ? detect_indent_style(this._tokens, Array.isArray(data), pos_old[0], position[1] - 1, i)\n                 : {}\n      var newtokens = value_to_tokenlist(value, path, this._options, false, indent)\n    }\n\n  } else {\n    // insert new key, that's tricky\n    var path_1 = path.slice(0, i)\n\n    //  find a last separator after which we're inserting it\n    var pos2 = find_last_non_ws_token(this._tokens, position[0] + 1, position[1] - 1)\n    assert(pos2 !== false)\n\n    var indent = pos2 !== false\n               ? detect_indent_style(this._tokens, Array.isArray(data), position[0] + 1, pos2, i)\n               : {}\n\n    var newtokens = value_to_tokenlist(value, path, this._options, false, indent)\n\n    // adding leading whitespaces according to detected codestyle\n    var prefix = []\n    if (indent.newline && indent.newline.length)\n      prefix = prefix.concat(indent.newline)\n    if (indent.prefix && indent.prefix.length)\n      prefix = prefix.concat(indent.prefix)\n\n    // adding '\"key\":' (as in \"key\":\"value\") to object values\n    if (!Array.isArray(data)) {\n      prefix = prefix.concat(value_to_tokenlist(path[path.length-1], path_1, this._options, true))\n      if (indent.sep1 && indent.sep1.length)\n        prefix = prefix.concat(indent.sep1)\n      prefix.push({raw: ':', type: 'separator', stack: path_1})\n      if (indent.sep2 && indent.sep2.length)\n        prefix = prefix.concat(indent.sep2)\n    }\n\n    newtokens.unshift.apply(newtokens, prefix)\n\n    // check if prev token is a separator AND they're at the same level\n    if (this._tokens[pos2].type === 'separator' && this._tokens[pos2].stack.length === path.length-1) {\n      // previous token is either , or [ or {\n      if (this._tokens[pos2].raw === ',') {\n        // restore ending comma\n        newtokens.push({raw: ',', type: 'separator', stack: path_1})\n      }\n    } else {\n      // previous token isn't a separator, so need to insert one\n      newtokens.unshift({raw: ',', type: 'separator', stack: path_1})\n    }\n\n    if (indent.suffix && indent.suffix.length)\n      newtokens.push.apply(newtokens, indent.suffix)\n\n    assert.equal(this._tokens[position[1]].type, 'separator')\n    position[0] = pos2+1\n    position[1] = pos2\n  }\n\n  newtokens.unshift(position[1] - position[0] + 1)\n  newtokens.unshift(position[0])\n  this._tokens.splice.apply(this._tokens, newtokens)\n\n  return this\n}\n\n// convenience method\nDocument.prototype.unset = function(path) {\n  return this.set(path, undefined)\n}\n\nDocument.prototype.get = function(path) {\n  path = arg_to_path(path)\n\n  var data = this._data\n  for (var i=0; i<path.length; i++) {\n    if (!isObject(data)) return undefined\n    data = data[path[i]]\n  }\n  return data\n}\n\nDocument.prototype.has = function(path) {\n  path = arg_to_path(path)\n\n  var data = this._data\n  for (var i=0; i<path.length; i++) {\n    if (!isObject(data)) return false\n    data = data[path[i]]\n  }\n  return data !== undefined\n}\n\n// compare old object and new one, and change differences only\nDocument.prototype.update = function(value) {\n  var self = this\n  change([], self._data, value)\n  return self\n\n  function change(path, old_data, new_data) {\n    if (!isObject(new_data) || !isObject(old_data)) {\n      // if source or dest is primitive, just replace\n      if (new_data !== old_data)\n        self.set(path, new_data)\n\n    } else if (Array.isArray(new_data) != Array.isArray(old_data)) {\n      // old data is an array XOR new data is an array, replace as well\n      self.set(path, new_data)\n\n    } else if (Array.isArray(new_data)) {\n      // both values are arrays here\n\n      if (new_data.length > old_data.length) {\n        // adding new elements, so going forward\n        for (var i=0; i<new_data.length; i++) {\n          path.push(String(i))\n          change(path, old_data[i], new_data[i])\n          path.pop()\n        }\n\n      } else {\n        // removing something, so going backward\n        for (var i=old_data.length-1; i>=0; i--) {\n          path.push(String(i))\n          change(path, old_data[i], new_data[i])\n          path.pop()\n        }\n      }\n\n    } else {\n      // both values are objects here\n      for (var i in new_data) {\n        path.push(String(i))\n        change(path, old_data[i], new_data[i])\n        path.pop()\n      }\n\n      for (var i in old_data) {\n        if (i in new_data) continue\n        path.push(String(i))\n        change(path, old_data[i], new_data[i])\n        path.pop()\n      }\n    }\n  }\n}\n\nDocument.prototype.toString = function() {\n  return this._tokens.map(function(x) {\n    return x.raw\n  }).join('')\n}\n\nmodule.exports.Document = Document\n\nmodule.exports.update = function updateJSON(source, new_value, options) {\n  return Document(source, options).update(new_value).toString()\n}\n\n"]},"metadata":{},"sourceType":"script"}