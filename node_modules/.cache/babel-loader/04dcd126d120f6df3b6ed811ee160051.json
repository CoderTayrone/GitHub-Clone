{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst deep_freeze_1 = __importDefault(require(\"deep-freeze\"));\n\nconst lodash_1 = __importDefault(require(\"lodash\"));\n\nconst promise_breaker_1 = __importDefault(require(\"promise-breaker\"));\n\nconst mime_1 = require(\"../utils/mime\");\n\nconst oasUtils_1 = require(\"./oasUtils\");\n\nconst Parameter_1 = __importDefault(require(\"./Parameter\"));\n\nconst parameterParsers_1 = require(\"./parameterParsers\");\n\nconst extensions_1 = require(\"./extensions\");\n\nconst Responses_1 = __importDefault(require(\"./Responses\"));\n\nconst SecuritySchemes_1 = __importDefault(require(\"./SecuritySchemes\"));\n\nconst METHODS_WITH_BODY = ['post', 'put', 'patch'];\n\nfunction isAuthenticationFailure(result) {\n  return !!(result.type === 'invalid' || result.type === 'missing');\n}\n\nfunction getMissing(required, have) {\n  if (!have || have.length === 0) {\n    return required;\n  } else {\n    return required.filter(r => !have.includes(r));\n  }\n}\n\nfunction validateController(context, controller, operationId) {\n  if (!controller && !context.options.allowMissingControllers) {\n    throw new Error(`Missing ${extensions_1.EXEGESIS_CONTROLLER} for ${context.jsonPointer}`);\n  }\n\n  if (!operationId && !context.options.allowMissingControllers) {\n    throw new Error(`Missing operationId or ${extensions_1.EXEGESIS_OPERATION_ID} for ${context.jsonPointer}`);\n  }\n\n  if (controller && operationId) {\n    if (!context.options.controllers[controller]) {\n      throw new Error(`Could not find controller ${controller} defined in ${context.jsonPointer}`);\n    } else if (!context.options.controllers[controller][operationId]) {\n      throw new Error(`Could not find operation ${controller}#${operationId} defined in ${context.jsonPointer}`);\n    }\n  }\n}\n/*\n * Validate that all operations/request bodies have a controller and\n * operationId defined.\n */\n\n\nfunction validateControllers(context, requestBody, opController, operationId) {\n  if (requestBody) {\n    for (const mediaType of Object.keys(requestBody.content)) {\n      const mediaContext = context.childContext(['requestBody', 'content', mediaType]);\n      const mediaTypeObject = requestBody.content[mediaType];\n      const mediaController = mediaTypeObject[extensions_1.EXEGESIS_CONTROLLER] || opController;\n      const mediaOperationId = mediaTypeObject[extensions_1.EXEGESIS_OPERATION_ID] || operationId;\n      validateController(mediaContext, mediaController, mediaOperationId);\n    }\n  } else {\n    validateController(context, opController, operationId);\n  }\n}\n\nclass Operation {\n  constructor(context, oaOperation, oaPath, method, exegesisController, parentParameters) {\n    this.context = context;\n    this.oaOperation = oaOperation;\n    this.oaPath = oaPath;\n    this.exegesisController = oaOperation[extensions_1.EXEGESIS_CONTROLLER] || exegesisController;\n    this.operationId = oaOperation[extensions_1.EXEGESIS_OPERATION_ID] || oaOperation.operationId;\n    this.securityRequirements = oaOperation.security || context.openApiDoc.security || [];\n    this._securitySchemes = new SecuritySchemes_1.default(context.openApiDoc);\n    this._responses = new Responses_1.default(context.childContext('responses'), oaOperation.responses);\n\n    for (const securityRequirement of this.securityRequirements) {\n      for (const schemeName of Object.keys(securityRequirement)) {\n        if (!context.options.authenticators[schemeName]) {\n          throw new Error(`Operation ${context.jsonPointer} references security scheme \"${schemeName}\" ` + `but no authenticator was provided.`);\n        }\n      }\n    }\n\n    const requestBody = oaOperation.requestBody && METHODS_WITH_BODY.includes(method) ? context.resolveRef(oaOperation.requestBody) : undefined;\n    validateControllers(context, requestBody, this.exegesisController, this.operationId);\n\n    if (requestBody) {\n      this.validRequestContentTypes = Object.keys(requestBody.content);\n      this.bodyRequired = requestBody.required || false;\n      const contentContext = context.childContext(['requestBody', 'content']);\n      this._requestBodyContentTypes = oasUtils_1.contentToRequestMediaTypeRegistry(contentContext, {\n        in: 'request',\n        name: 'body',\n        docPath: contentContext.jsonPointer\n      }, requestBody.required || false, requestBody.content);\n    } else {\n      this._requestBodyContentTypes = new mime_1.MimeTypeRegistry();\n      this.bodyRequired = false;\n    }\n\n    const localParameters = (this.oaOperation.parameters || []).map((parameter, index) => new Parameter_1.default(context.childContext(['parameters', '' + index]), parameter));\n    const allParameters = parentParameters.concat(localParameters);\n    this._parameters = allParameters.reduce((result, parameter) => {\n      result[parameter.oaParameter.in].push(parameter);\n      return result;\n    }, {\n      query: [],\n      header: [],\n      path: [],\n      server: [],\n      cookie: []\n    });\n    this.parameterLocations = deep_freeze_1.default(allParameters.reduce((result, parameter) => {\n      result[parameter.oaParameter.in] = parameter.location;\n      return result;\n    }, {\n      query: {},\n      header: {},\n      path: {},\n      cookie: {}\n    }));\n  }\n  /**\n   * Given a 'content-type' from a request, return a `MediaType` object that\n   * matches, or `undefined` if no objects match.\n   *\n   * @param contentType - The content type from the 'content-type' header on\n   *   a request.\n   * @returns - The MediaType object to handle this request, or undefined if\n   *   no MediaType is set for the given contentType.\n   */\n\n\n  getRequestMediaType(contentType) {\n    return this._requestBodyContentTypes.get(contentType);\n  }\n  /**\n   * Parse parameters for this operation.\n   * @param params - Raw headers, raw path params and server params from\n   *   `PathResolver`, and the raw queryString.\n   * @returns parsed parameters.\n   */\n\n\n  parseParameters(params) {\n    const {\n      headers,\n      rawPathParams,\n      queryString\n    } = params;\n    return {\n      query: parameterParsers_1.parseQueryParameters(this._parameters.query, queryString),\n      header: parameterParsers_1.parseParameterGroup(this._parameters.header, headers || {}),\n      server: params.serverParams || {},\n      path: rawPathParams ? parameterParsers_1.parseParameterGroup(this._parameters.path, rawPathParams) : {},\n      cookie: {}\n    };\n  }\n\n  validateParameters(parameterValues) {\n    // TODO: We could probably make this a lot more efficient by building the schema\n    // for the parameter tree.\n    let errors = null;\n\n    for (const parameterLocation of Object.keys(parameterValues)) {\n      const parameters = this._parameters[parameterLocation];\n      const values = parameterValues[parameterLocation];\n\n      for (const parameter of parameters) {\n        const innerResult = parameter.validate(values[parameter.oaParameter.name]);\n\n        if (innerResult && innerResult.errors && innerResult.errors.length > 0) {\n          errors = errors || [];\n          errors = errors.concat(innerResult.errors);\n        } else {\n          values[parameter.oaParameter.name] = innerResult.value;\n        }\n      }\n    }\n\n    return errors;\n  }\n  /**\n   * Validate a response.\n   *\n   * @param response - The response generated by a controller.\n   * @param validateDefaultResponses - true to validate all responses, false\n   *   to only validate non-default responses.\n   */\n\n\n  validateResponse(response, validateDefaultResponses) {\n    return this._responses.validateResponse(response.statusCode, response.headers, response.body, validateDefaultResponses);\n  }\n\n  _runAuthenticator(schemeName, triedSchemes, exegesisContext, requiredScopes) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!(schemeName in triedSchemes)) {\n        const authenticator = this.context.options.authenticators[schemeName];\n\n        const info = this._securitySchemes.getInfo(schemeName);\n\n        const result = (yield promise_breaker_1.default.call(authenticator, null, exegesisContext, info)) || {\n          type: 'missing',\n          status: 401\n        };\n\n        if (result.type !== 'success' && result.type !== 'invalid' && result.type !== 'missing') {\n          throw new Error(`Invalid result ${result.type} from authenticator for ${schemeName}`);\n        }\n\n        if (isAuthenticationFailure(result)) {\n          result.status = result.status || 401;\n\n          if (result.status === 401 && !result.challenge) {\n            result.challenge = this._securitySchemes.getChallenge(schemeName);\n          }\n        }\n\n        triedSchemes[schemeName] = result;\n      }\n\n      let result = triedSchemes[schemeName];\n\n      if (!isAuthenticationFailure(result)) {\n        // For OAuth3, need to verify we have the oauth scopes defined in the API doc.\n        const missingScopes = getMissing(requiredScopes, result.scopes);\n\n        if (missingScopes.length > 0) {\n          result = {\n            type: 'invalid',\n            status: 403,\n            message: `Authenticated using '${schemeName}' but missing ` + `required scopes: ${missingScopes.join(', ')}.`\n          };\n        }\n      }\n\n      return result;\n    });\n  }\n  /**\n   * Checks a single security requirement from an OAS3 `security` field.\n   *\n   * @param triedSchemes - A cache where keys are names of security schemes\n   *   we've already tried, and values are the results returned by the\n   *   authenticator.\n   * @param errors - An array of strings - we can push any errors we encounter\n   *   to this list.\n   * @param securityRequirement - The security requirement to check.\n   * @param exegesisContext - The context for the request to check.\n   * @returns - If the security requirement matches, this returns a\n   *   `{type: 'authenticated', result}` object, where result is an object\n   *   where keys are security schemes and the values are the results from\n   *   the authenticator.  If the requirements are not met, returns a\n   *   `{type: 'missing', failure}` object or a `{type: 'invalid', failure}`,\n   *   object where `failure` is the the failure that caused this security\n   *   requirement to not pass.\n   */\n\n\n  _checkSecurityRequirement(triedSchemes, securityRequirement, exegesisContext) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const requiredSchemes = Object.keys(securityRequirement);\n      const result = Object.create(null);\n      let failure;\n      let failedSchemeName;\n\n      for (const scheme of requiredSchemes) {\n        if (exegesisContext.isResponseFinished()) {\n          // Some authenticator has written a response.  We're done.  :(\n          break;\n        }\n\n        const requiredScopes = securityRequirement[scheme];\n        const authResult = yield this._runAuthenticator(scheme, triedSchemes, exegesisContext, requiredScopes);\n\n        if (isAuthenticationFailure(authResult)) {\n          // Couldn't authenticate.  Try the next one.\n          failure = authResult;\n          failedSchemeName = scheme;\n          break;\n        }\n\n        result[scheme] = authResult;\n      }\n\n      if (failure) {\n        return {\n          type: failure.type,\n          failure,\n          failedSchemeName\n        };\n      } else if (result) {\n        return {\n          type: 'authenticated',\n          result\n        };\n      } else {\n        return undefined;\n      }\n    });\n  }\n\n  authenticate(exegesisContext) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.securityRequirements.length === 0) {\n        // No auth required\n        return {};\n      }\n\n      let firstFailureResult;\n      const challenges = {};\n      let firstAuthenticatedResult;\n      const triedSchemes = Object.create(null);\n\n      for (const securityRequirement of this.securityRequirements) {\n        const securityRequirementResult = yield this._checkSecurityRequirement(triedSchemes, securityRequirement, exegesisContext);\n\n        if (!securityRequirementResult) {\n          break;\n        } else if (securityRequirementResult.type === 'authenticated') {\n          firstAuthenticatedResult = firstAuthenticatedResult || securityRequirementResult.result;\n        } else if (securityRequirementResult.type === 'missing' || securityRequirementResult.type === 'invalid') {\n          const failure = securityRequirementResult.failure;\n\n          if (!failure) {\n            throw new Error('Missing failure.');\n          }\n\n          if (!securityRequirementResult.failedSchemeName) {\n            throw new Error('Missing failed scheme name.');\n          } // No luck with this security requirement.\n\n\n          if (failure.status === 401 && failure.challenge) {\n            challenges[securityRequirementResult.failedSchemeName] = failure.challenge;\n          }\n\n          if (securityRequirementResult.type === 'invalid') {\n            firstFailureResult = firstFailureResult || failure;\n            break;\n          }\n        } else {\n          /* istanbul ignore this */\n          throw new Error('Invalid result from `_checkSecurityRequirement()`');\n        }\n\n        if (exegesisContext.isResponseFinished()) {\n          // We're done!\n          break;\n        }\n      }\n\n      if (firstAuthenticatedResult && !firstFailureResult) {\n        // Successs!\n        return firstAuthenticatedResult;\n      } else if (exegesisContext.isResponseFinished()) {\n        // Someone already wrote a response.\n        return undefined;\n      } else {\n        const authSchemes = this.securityRequirements.map(requirement => {\n          const schemes = Object.keys(requirement);\n          return schemes.length === 1 ? schemes[0] : `(${schemes.join(' + ')})`;\n        });\n        const authChallenges = lodash_1.default(this.securityRequirements).map(requirement => Object.keys(requirement)).flatten().map(schemeName => challenges[schemeName] || this._securitySchemes.getChallenge(schemeName)).filter(challenge => challenge !== undefined).value();\n        const message = firstFailureResult && firstFailureResult.message || `Must authenticate using one of the following schemes: ${authSchemes.join(', ')}.`;\n        exegesisContext.res.setStatus(firstFailureResult && firstFailureResult.status || 401).set('WWW-Authenticate', authChallenges).setBody({\n          message\n        });\n        return undefined;\n      }\n    });\n  }\n\n}\n\nexports.default = Operation;","map":{"version":3,"sources":["../../src/oas3/Operation.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst deep_freeze_1 = __importDefault(require(\"deep-freeze\"));\nconst lodash_1 = __importDefault(require(\"lodash\"));\nconst promise_breaker_1 = __importDefault(require(\"promise-breaker\"));\nconst mime_1 = require(\"../utils/mime\");\nconst oasUtils_1 = require(\"./oasUtils\");\nconst Parameter_1 = __importDefault(require(\"./Parameter\"));\nconst parameterParsers_1 = require(\"./parameterParsers\");\nconst extensions_1 = require(\"./extensions\");\nconst Responses_1 = __importDefault(require(\"./Responses\"));\nconst SecuritySchemes_1 = __importDefault(require(\"./SecuritySchemes\"));\nconst METHODS_WITH_BODY = ['post', 'put', 'patch'];\nfunction isAuthenticationFailure(result) {\n    return !!(result.type === 'invalid' || result.type === 'missing');\n}\nfunction getMissing(required, have) {\n    if (!have || have.length === 0) {\n        return required;\n    }\n    else {\n        return required.filter((r) => !have.includes(r));\n    }\n}\nfunction validateController(context, controller, operationId) {\n    if (!controller && !context.options.allowMissingControllers) {\n        throw new Error(`Missing ${extensions_1.EXEGESIS_CONTROLLER} for ${context.jsonPointer}`);\n    }\n    if (!operationId && !context.options.allowMissingControllers) {\n        throw new Error(`Missing operationId or ${extensions_1.EXEGESIS_OPERATION_ID} for ${context.jsonPointer}`);\n    }\n    if (controller && operationId) {\n        if (!context.options.controllers[controller]) {\n            throw new Error(`Could not find controller ${controller} defined in ${context.jsonPointer}`);\n        }\n        else if (!context.options.controllers[controller][operationId]) {\n            throw new Error(`Could not find operation ${controller}#${operationId} defined in ${context.jsonPointer}`);\n        }\n    }\n}\n/*\n * Validate that all operations/request bodies have a controller and\n * operationId defined.\n */\nfunction validateControllers(context, requestBody, opController, operationId) {\n    if (requestBody) {\n        for (const mediaType of Object.keys(requestBody.content)) {\n            const mediaContext = context.childContext(['requestBody', 'content', mediaType]);\n            const mediaTypeObject = requestBody.content[mediaType];\n            const mediaController = mediaTypeObject[extensions_1.EXEGESIS_CONTROLLER] || opController;\n            const mediaOperationId = mediaTypeObject[extensions_1.EXEGESIS_OPERATION_ID] || operationId;\n            validateController(mediaContext, mediaController, mediaOperationId);\n        }\n    }\n    else {\n        validateController(context, opController, operationId);\n    }\n}\nclass Operation {\n    constructor(context, oaOperation, oaPath, method, exegesisController, parentParameters) {\n        this.context = context;\n        this.oaOperation = oaOperation;\n        this.oaPath = oaPath;\n        this.exegesisController = oaOperation[extensions_1.EXEGESIS_CONTROLLER] || exegesisController;\n        this.operationId = oaOperation[extensions_1.EXEGESIS_OPERATION_ID] || oaOperation.operationId;\n        this.securityRequirements = oaOperation.security || context.openApiDoc.security || [];\n        this._securitySchemes = new SecuritySchemes_1.default(context.openApiDoc);\n        this._responses = new Responses_1.default(context.childContext('responses'), oaOperation.responses);\n        for (const securityRequirement of this.securityRequirements) {\n            for (const schemeName of Object.keys(securityRequirement)) {\n                if (!context.options.authenticators[schemeName]) {\n                    throw new Error(`Operation ${context.jsonPointer} references security scheme \"${schemeName}\" ` +\n                        `but no authenticator was provided.`);\n                }\n            }\n        }\n        const requestBody = oaOperation.requestBody && METHODS_WITH_BODY.includes(method)\n            ? context.resolveRef(oaOperation.requestBody)\n            : undefined;\n        validateControllers(context, requestBody, this.exegesisController, this.operationId);\n        if (requestBody) {\n            this.validRequestContentTypes = Object.keys(requestBody.content);\n            this.bodyRequired = requestBody.required || false;\n            const contentContext = context.childContext(['requestBody', 'content']);\n            this._requestBodyContentTypes = oasUtils_1.contentToRequestMediaTypeRegistry(contentContext, { in: 'request', name: 'body', docPath: contentContext.jsonPointer }, requestBody.required || false, requestBody.content);\n        }\n        else {\n            this._requestBodyContentTypes = new mime_1.MimeTypeRegistry();\n            this.bodyRequired = false;\n        }\n        const localParameters = (this.oaOperation.parameters || []).map((parameter, index) => new Parameter_1.default(context.childContext(['parameters', '' + index]), parameter));\n        const allParameters = parentParameters.concat(localParameters);\n        this._parameters = allParameters.reduce((result, parameter) => {\n            result[parameter.oaParameter.in].push(parameter);\n            return result;\n        }, { query: [], header: [], path: [], server: [], cookie: [] });\n        this.parameterLocations = deep_freeze_1.default(allParameters.reduce((result, parameter) => {\n            result[parameter.oaParameter.in] = parameter.location;\n            return result;\n        }, { query: {}, header: {}, path: {}, cookie: {} }));\n    }\n    /**\n     * Given a 'content-type' from a request, return a `MediaType` object that\n     * matches, or `undefined` if no objects match.\n     *\n     * @param contentType - The content type from the 'content-type' header on\n     *   a request.\n     * @returns - The MediaType object to handle this request, or undefined if\n     *   no MediaType is set for the given contentType.\n     */\n    getRequestMediaType(contentType) {\n        return this._requestBodyContentTypes.get(contentType);\n    }\n    /**\n     * Parse parameters for this operation.\n     * @param params - Raw headers, raw path params and server params from\n     *   `PathResolver`, and the raw queryString.\n     * @returns parsed parameters.\n     */\n    parseParameters(params) {\n        const { headers, rawPathParams, queryString } = params;\n        return {\n            query: parameterParsers_1.parseQueryParameters(this._parameters.query, queryString),\n            header: parameterParsers_1.parseParameterGroup(this._parameters.header, headers || {}),\n            server: params.serverParams || {},\n            path: rawPathParams ? parameterParsers_1.parseParameterGroup(this._parameters.path, rawPathParams) : {},\n            cookie: {},\n        };\n    }\n    validateParameters(parameterValues) {\n        // TODO: We could probably make this a lot more efficient by building the schema\n        // for the parameter tree.\n        let errors = null;\n        for (const parameterLocation of Object.keys(parameterValues)) {\n            const parameters = this._parameters[parameterLocation];\n            const values = parameterValues[parameterLocation];\n            for (const parameter of parameters) {\n                const innerResult = parameter.validate(values[parameter.oaParameter.name]);\n                if (innerResult && innerResult.errors && innerResult.errors.length > 0) {\n                    errors = errors || [];\n                    errors = errors.concat(innerResult.errors);\n                }\n                else {\n                    values[parameter.oaParameter.name] = innerResult.value;\n                }\n            }\n        }\n        return errors;\n    }\n    /**\n     * Validate a response.\n     *\n     * @param response - The response generated by a controller.\n     * @param validateDefaultResponses - true to validate all responses, false\n     *   to only validate non-default responses.\n     */\n    validateResponse(response, validateDefaultResponses) {\n        return this._responses.validateResponse(response.statusCode, response.headers, response.body, validateDefaultResponses);\n    }\n    _runAuthenticator(schemeName, triedSchemes, exegesisContext, requiredScopes) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!(schemeName in triedSchemes)) {\n                const authenticator = this.context.options.authenticators[schemeName];\n                const info = this._securitySchemes.getInfo(schemeName);\n                const result = (yield promise_breaker_1.default.call(authenticator, null, exegesisContext, info)) || { type: 'missing', status: 401 };\n                if (result.type !== 'success' &&\n                    result.type !== 'invalid' &&\n                    result.type !== 'missing') {\n                    throw new Error(`Invalid result ${result.type} from authenticator for ${schemeName}`);\n                }\n                if (isAuthenticationFailure(result)) {\n                    result.status = result.status || 401;\n                    if (result.status === 401 && !result.challenge) {\n                        result.challenge = this._securitySchemes.getChallenge(schemeName);\n                    }\n                }\n                triedSchemes[schemeName] = result;\n            }\n            let result = triedSchemes[schemeName];\n            if (!isAuthenticationFailure(result)) {\n                // For OAuth3, need to verify we have the oauth scopes defined in the API doc.\n                const missingScopes = getMissing(requiredScopes, result.scopes);\n                if (missingScopes.length > 0) {\n                    result = {\n                        type: 'invalid',\n                        status: 403,\n                        message: `Authenticated using '${schemeName}' but missing ` +\n                            `required scopes: ${missingScopes.join(', ')}.`,\n                    };\n                }\n            }\n            return result;\n        });\n    }\n    /**\n     * Checks a single security requirement from an OAS3 `security` field.\n     *\n     * @param triedSchemes - A cache where keys are names of security schemes\n     *   we've already tried, and values are the results returned by the\n     *   authenticator.\n     * @param errors - An array of strings - we can push any errors we encounter\n     *   to this list.\n     * @param securityRequirement - The security requirement to check.\n     * @param exegesisContext - The context for the request to check.\n     * @returns - If the security requirement matches, this returns a\n     *   `{type: 'authenticated', result}` object, where result is an object\n     *   where keys are security schemes and the values are the results from\n     *   the authenticator.  If the requirements are not met, returns a\n     *   `{type: 'missing', failure}` object or a `{type: 'invalid', failure}`,\n     *   object where `failure` is the the failure that caused this security\n     *   requirement to not pass.\n     */\n    _checkSecurityRequirement(triedSchemes, securityRequirement, exegesisContext) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const requiredSchemes = Object.keys(securityRequirement);\n            const result = Object.create(null);\n            let failure;\n            let failedSchemeName;\n            for (const scheme of requiredSchemes) {\n                if (exegesisContext.isResponseFinished()) {\n                    // Some authenticator has written a response.  We're done.  :(\n                    break;\n                }\n                const requiredScopes = securityRequirement[scheme];\n                const authResult = yield this._runAuthenticator(scheme, triedSchemes, exegesisContext, requiredScopes);\n                if (isAuthenticationFailure(authResult)) {\n                    // Couldn't authenticate.  Try the next one.\n                    failure = authResult;\n                    failedSchemeName = scheme;\n                    break;\n                }\n                result[scheme] = authResult;\n            }\n            if (failure) {\n                return { type: failure.type, failure, failedSchemeName };\n            }\n            else if (result) {\n                return { type: 'authenticated', result };\n            }\n            else {\n                return undefined;\n            }\n        });\n    }\n    authenticate(exegesisContext) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.securityRequirements.length === 0) {\n                // No auth required\n                return {};\n            }\n            let firstFailureResult;\n            const challenges = {};\n            let firstAuthenticatedResult;\n            const triedSchemes = Object.create(null);\n            for (const securityRequirement of this.securityRequirements) {\n                const securityRequirementResult = yield this._checkSecurityRequirement(triedSchemes, securityRequirement, exegesisContext);\n                if (!securityRequirementResult) {\n                    break;\n                }\n                else if (securityRequirementResult.type === 'authenticated') {\n                    firstAuthenticatedResult =\n                        firstAuthenticatedResult || securityRequirementResult.result;\n                }\n                else if (securityRequirementResult.type === 'missing' ||\n                    securityRequirementResult.type === 'invalid') {\n                    const failure = securityRequirementResult.failure;\n                    if (!failure) {\n                        throw new Error('Missing failure.');\n                    }\n                    if (!securityRequirementResult.failedSchemeName) {\n                        throw new Error('Missing failed scheme name.');\n                    }\n                    // No luck with this security requirement.\n                    if (failure.status === 401 && failure.challenge) {\n                        challenges[securityRequirementResult.failedSchemeName] = failure.challenge;\n                    }\n                    if (securityRequirementResult.type === 'invalid') {\n                        firstFailureResult = firstFailureResult || failure;\n                        break;\n                    }\n                }\n                else {\n                    /* istanbul ignore this */\n                    throw new Error('Invalid result from `_checkSecurityRequirement()`');\n                }\n                if (exegesisContext.isResponseFinished()) {\n                    // We're done!\n                    break;\n                }\n            }\n            if (firstAuthenticatedResult && !firstFailureResult) {\n                // Successs!\n                return firstAuthenticatedResult;\n            }\n            else if (exegesisContext.isResponseFinished()) {\n                // Someone already wrote a response.\n                return undefined;\n            }\n            else {\n                const authSchemes = this.securityRequirements.map((requirement) => {\n                    const schemes = Object.keys(requirement);\n                    return schemes.length === 1 ? schemes[0] : `(${schemes.join(' + ')})`;\n                });\n                const authChallenges = lodash_1.default(this.securityRequirements)\n                    .map((requirement) => Object.keys(requirement))\n                    .flatten()\n                    .map((schemeName) => challenges[schemeName] || this._securitySchemes.getChallenge(schemeName))\n                    .filter((challenge) => challenge !== undefined)\n                    .value();\n                const message = (firstFailureResult && firstFailureResult.message) ||\n                    `Must authenticate using one of the following schemes: ${authSchemes.join(', ')}.`;\n                exegesisContext.res\n                    .setStatus((firstFailureResult && firstFailureResult.status) || 401)\n                    .set('WWW-Authenticate', authChallenges)\n                    .setBody({ message });\n                return undefined;\n            }\n        });\n    }\n}\nexports.default = Operation;\n//# sourceMappingURL=Operation.js.map"]},"metadata":{},"sourceType":"script"}