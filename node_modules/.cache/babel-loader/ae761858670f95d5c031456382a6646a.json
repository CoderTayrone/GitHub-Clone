{"ast":null,"code":"\"use strict\";\n\nvar reAnsi = require(\"ansi-regex\"),\n    stringifiable = require(\"es5-ext/object/validate-stringifiable-value\"),\n    length = require(\"./get-stripped-length\"),\n    sgr = require(\"./lib/sgr\"),\n    max = Math.max;\n\nvar Token = function (token) {\n  this.token = token;\n};\n\nvar tokenize = function (str) {\n  var match = reAnsi().exec(str);\n\n  if (!match) {\n    return [str];\n  }\n\n  var index = match.index,\n      head,\n      prehead,\n      tail;\n\n  if (index === 0) {\n    head = match[0];\n    tail = str.slice(head.length);\n    return [new Token(head)].concat(tokenize(tail));\n  }\n\n  prehead = str.slice(0, index);\n  head = match[0];\n  tail = str.slice(index + head.length);\n  return [prehead, new Token(head)].concat(tokenize(tail));\n};\n\nvar isChunkInSlice = function (chunk, index, begin, end) {\n  var endIndex = chunk.length + index;\n  if (begin > endIndex) return false;\n  if (end < index) return false;\n  return true;\n}; // eslint-disable-next-line max-lines-per-function\n\n\nvar sliceSeq = function (seq, begin, end) {\n  var sliced = seq.reduce(function (state, chunk) {\n    var index = state.index;\n\n    if (chunk instanceof Token) {\n      var code = sgr.extractCode(chunk.token);\n\n      if (index <= begin) {\n        if (code in sgr.openers) {\n          sgr.openStyle(state.preOpeners, code);\n        }\n\n        if (code in sgr.closers) {\n          sgr.closeStyle(state.preOpeners, code);\n        }\n      } else if (index < end) {\n        if (code in sgr.openers) {\n          sgr.openStyle(state.inOpeners, code);\n          state.seq.push(chunk);\n        } else if (code in sgr.closers) {\n          state.inClosers.push(code);\n          state.seq.push(chunk);\n        }\n      }\n    } else {\n      var nextChunk = \"\";\n\n      if (isChunkInSlice(chunk, index, begin, end)) {\n        var relBegin = Math.max(begin - index, 0),\n            relEnd = Math.min(end - index, chunk.length);\n        nextChunk = chunk.slice(relBegin, relEnd);\n      }\n\n      state.seq.push(nextChunk);\n      state.index = index + chunk.length;\n    }\n\n    return state;\n  }, {\n    index: 0,\n    seq: [],\n    // preOpeners -> [ mod ]\n    // preOpeners must be prepended to the slice if they wasn't closed til the end of it\n    // preOpeners must be closed if they wasn't closed til the end of the slice\n    preOpeners: [],\n    // inOpeners  -> [ mod ]\n    // inOpeners already in the slice and must not be prepended to the slice\n    // inOpeners must be closed if they wasn't closed til the end of the slice\n    inOpeners: [],\n    // opener CSI inside slice\n    // inClosers -> [ code ]\n    // closer CSIs for determining which pre/in-Openers must be closed\n    inClosers: []\n  });\n  sliced.seq = [].concat(sgr.prepend(sliced.preOpeners), sliced.seq, sgr.complete([].concat(sliced.preOpeners, sliced.inOpeners), sliced.inClosers));\n  return sliced.seq;\n};\n\nmodule.exports = function (str\n/*, begin, end*/\n) {\n  var seq,\n      begin = Number(arguments[1]),\n      end = Number(arguments[2]),\n      len;\n  str = stringifiable(str);\n  len = length(str);\n\n  if (isNaN(begin)) {\n    begin = 0;\n  }\n\n  if (isNaN(end)) {\n    end = len;\n  }\n\n  if (begin < 0) {\n    begin = max(len + begin, 0);\n  }\n\n  if (end < 0) {\n    end = max(len + end, 0);\n  }\n\n  seq = tokenize(str);\n  seq = sliceSeq(seq, begin, end);\n  return seq.map(function (chunk) {\n    if (chunk instanceof Token) {\n      return chunk.token;\n    }\n\n    return chunk;\n  }).join(\"\");\n};","map":{"version":3,"sources":["/home/dev/Documentos/Projects/github-clone/node_modules/cli-color/slice.js"],"names":["reAnsi","require","stringifiable","length","sgr","max","Math","Token","token","tokenize","str","match","exec","index","head","prehead","tail","slice","concat","isChunkInSlice","chunk","begin","end","endIndex","sliceSeq","seq","sliced","reduce","state","code","extractCode","openers","openStyle","preOpeners","closers","closeStyle","inOpeners","push","inClosers","nextChunk","relBegin","relEnd","min","prepend","complete","module","exports","Number","arguments","len","isNaN","map","join"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar reAnsi        = require(\"ansi-regex\")\n  , stringifiable = require(\"es5-ext/object/validate-stringifiable-value\")\n  , length        = require(\"./get-stripped-length\")\n  , sgr           = require(\"./lib/sgr\")\n  , max           = Math.max;\n\nvar Token = function (token) { this.token = token; };\n\nvar tokenize = function (str) {\n\tvar match = reAnsi().exec(str);\n\n\tif (!match) {\n\t\treturn [str];\n\t}\n\n\tvar index = match.index, head, prehead, tail;\n\n\tif (index === 0) {\n\t\thead = match[0];\n\t\ttail = str.slice(head.length);\n\n\t\treturn [new Token(head)].concat(tokenize(tail));\n\t}\n\n\tprehead = str.slice(0, index);\n\thead = match[0];\n\ttail = str.slice(index + head.length);\n\n\treturn [prehead, new Token(head)].concat(tokenize(tail));\n};\n\nvar isChunkInSlice = function (chunk, index, begin, end) {\n\tvar endIndex = chunk.length + index;\n\n\tif (begin > endIndex) return false;\n\tif (end < index) return false;\n\treturn true;\n};\n\n// eslint-disable-next-line max-lines-per-function\nvar sliceSeq = function (seq, begin, end) {\n\tvar sliced = seq.reduce(\n\t\tfunction (state, chunk) {\n\t\t\tvar index = state.index;\n\n\t\t\tif (chunk instanceof Token) {\n\t\t\t\tvar code = sgr.extractCode(chunk.token);\n\n\t\t\t\tif (index <= begin) {\n\t\t\t\t\tif (code in sgr.openers) {\n\t\t\t\t\t\tsgr.openStyle(state.preOpeners, code);\n\t\t\t\t\t}\n\t\t\t\t\tif (code in sgr.closers) {\n\t\t\t\t\t\tsgr.closeStyle(state.preOpeners, code);\n\t\t\t\t\t}\n\t\t\t\t} else if (index < end) {\n\t\t\t\t\tif (code in sgr.openers) {\n\t\t\t\t\t\tsgr.openStyle(state.inOpeners, code);\n\t\t\t\t\t\tstate.seq.push(chunk);\n\t\t\t\t\t} else if (code in sgr.closers) {\n\t\t\t\t\t\tstate.inClosers.push(code);\n\t\t\t\t\t\tstate.seq.push(chunk);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar nextChunk = \"\";\n\n\t\t\t\tif (isChunkInSlice(chunk, index, begin, end)) {\n\t\t\t\t\tvar relBegin = Math.max(begin - index, 0)\n\t\t\t\t\t  , relEnd = Math.min(end - index, chunk.length);\n\n\t\t\t\t\tnextChunk = chunk.slice(relBegin, relEnd);\n\t\t\t\t}\n\n\t\t\t\tstate.seq.push(nextChunk);\n\t\t\t\tstate.index = index + chunk.length;\n\t\t\t}\n\n\t\t\treturn state;\n\t\t},\n\t\t{\n\t\t\tindex: 0,\n\t\t\tseq: [],\n\n\t\t\t// preOpeners -> [ mod ]\n\t\t\t// preOpeners must be prepended to the slice if they wasn't closed til the end of it\n\t\t\t// preOpeners must be closed if they wasn't closed til the end of the slice\n\t\t\tpreOpeners: [],\n\n\t\t\t// inOpeners  -> [ mod ]\n\t\t\t// inOpeners already in the slice and must not be prepended to the slice\n\t\t\t// inOpeners must be closed if they wasn't closed til the end of the slice\n\t\t\tinOpeners: [], // opener CSI inside slice\n\n\t\t\t// inClosers -> [ code ]\n\t\t\t// closer CSIs for determining which pre/in-Openers must be closed\n\t\t\tinClosers: []\n\t\t}\n\t);\n\n\tsliced.seq = [].concat(\n\t\tsgr.prepend(sliced.preOpeners), sliced.seq,\n\t\tsgr.complete([].concat(sliced.preOpeners, sliced.inOpeners), sliced.inClosers)\n\t);\n\n\treturn sliced.seq;\n};\n\nmodule.exports = function (str/*, begin, end*/) {\n\tvar seq, begin = Number(arguments[1]), end = Number(arguments[2]), len;\n\n\tstr = stringifiable(str);\n\tlen = length(str);\n\n\tif (isNaN(begin)) {\n\t\tbegin = 0;\n\t}\n\tif (isNaN(end)) {\n\t\tend = len;\n\t}\n\tif (begin < 0) {\n\t\tbegin = max(len + begin, 0);\n\t}\n\tif (end < 0) {\n\t\tend = max(len + end, 0);\n\t}\n\n\tseq = tokenize(str);\n\tseq = sliceSeq(seq, begin, end);\n\treturn seq\n\t\t.map(function (chunk) {\n\t\t\tif (chunk instanceof Token) {\n\t\t\t\treturn chunk.token;\n\t\t\t}\n\n\t\t\treturn chunk;\n\t\t})\n\t\t.join(\"\");\n};\n"]},"metadata":{},"sourceType":"script"}