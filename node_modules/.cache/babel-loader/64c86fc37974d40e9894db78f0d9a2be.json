{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst url_1 = require(\"url\");\n\nconst semver = __importStar(require(\"semver\"));\n\nconst Paths_1 = __importDefault(require(\"./Paths\"));\n\nconst Servers_1 = __importDefault(require(\"./Servers\"));\n\nconst Oas3CompileContext_1 = __importDefault(require(\"./Oas3CompileContext\"));\n\nconst extensions_1 = require(\"./extensions\");\n\nconst errors_1 = require(\"../errors\");\n\nconst httpUtils_1 = require(\"../utils/httpUtils\");\n\nclass OpenApi {\n  /**\n   * Creates a new OpenApi object.\n   *\n   * @param openApiDoc - The complete JSON definition of the API.\n   *   The passed in definition should be a complete JSON object with no $refs.\n   */\n  constructor(openApiDoc, options) {\n    if (!openApiDoc.openapi) {\n      throw new Error(\"OpenAPI definition is missing 'openapi' field\");\n    }\n\n    if (!semver.satisfies(openApiDoc.openapi, '>=3.0.0 <4.0.0')) {\n      throw new Error(`OpenAPI version ${openApiDoc.openapi} not supported`);\n    }\n\n    this.openApiDoc = openApiDoc;\n    this._options = options; // TODO: Optimize this case when no `servers` were present in openApi doc,\n    // or where we don't need to match servers (only server is {url: '/'})?\n\n    if (!options.ignoreServers && openApiDoc.servers) {\n      this._servers = new Servers_1.default(openApiDoc.servers);\n    }\n\n    const exegesisController = openApiDoc[extensions_1.EXEGESIS_CONTROLLER];\n    this._paths = new Paths_1.default(new Oas3CompileContext_1.default(openApiDoc, ['paths'], options), exegesisController);\n  }\n\n  resolve(method, url, headers) {\n    const parsedUrl = url_1.parse(url);\n    const pathname = parsedUrl.pathname || '';\n    const host = parsedUrl.hostname || headers['host'] || '';\n    const contentType = headers['content-type'];\n    let pathToResolve;\n    let oaServer;\n    let serverParams;\n    let baseUrl = '';\n\n    if (!this._servers) {\n      pathToResolve = pathname;\n    } else {\n      const serverData = this._servers.resolveServer(host, pathname);\n\n      if (serverData) {\n        oaServer = serverData.oaServer;\n        pathToResolve = serverData.pathnameRest;\n        serverParams = serverData.serverParams;\n        baseUrl = serverData.baseUrl;\n      }\n    }\n\n    if (pathToResolve) {\n      const resolvedPath = this._paths.resolvePath(pathToResolve);\n\n      if (resolvedPath) {\n        const {\n          path,\n          rawPathParams\n        } = resolvedPath;\n        const operation = path.getOperation(method);\n        let mediaType;\n\n        if (operation && contentType) {\n          mediaType = operation.getRequestMediaType(contentType);\n\n          if (!mediaType && (httpUtils_1.httpHasBody(headers) || httpUtils_1.requestMayHaveBody(method))) {\n            throw new errors_1.HttpBadRequestError(`Invalid content-type: ${contentType}`);\n          }\n        } else if (operation && operation.bodyRequired && operation.validRequestContentTypes) {\n          throw new errors_1.HttpBadRequestError(`Missing content-type. ` + `Expected one of: ${operation.validRequestContentTypes}`);\n        }\n\n        let resolvedOperation;\n\n        if (operation) {\n          const parseParameters = function () {\n            return operation.parseParameters({\n              headers,\n              rawPathParams,\n              serverParams,\n              queryString: parsedUrl.query || undefined\n            });\n          };\n\n          const validateParameters = parameterValues => operation.validateParameters(parameterValues);\n\n          const bodyParser = mediaType && mediaType.parser;\n          const validateBody = mediaType && mediaType.validator;\n\n          const validateResponse = (response, validateDefaultResponses) => operation.validateResponse(response, validateDefaultResponses);\n\n          const exegesisControllerName = mediaType && mediaType.oaMediaType[extensions_1.EXEGESIS_CONTROLLER] || operation.exegesisController;\n          const operationId = mediaType && mediaType.oaMediaType[extensions_1.EXEGESIS_OPERATION_ID] || operation.operationId;\n          const controllerModule = exegesisControllerName && this._options.controllers[exegesisControllerName];\n          const controller = operationId && controllerModule && controllerModule[operationId];\n\n          const authenticate = context => {\n            return operation.authenticate(context);\n          };\n\n          resolvedOperation = {\n            parseParameters,\n            validateParameters,\n            parameterLocations: operation.parameterLocations,\n            bodyParser,\n            validateBody,\n            validateResponse,\n            exegesisControllerName,\n            operationId,\n            controllerModule,\n            controller,\n            authenticate\n          };\n        }\n\n        return {\n          operation: resolvedOperation,\n          api: {\n            openApiDoc: this.openApiDoc,\n            serverPtr: undefined,\n            serverObject: oaServer,\n            pathItemPtr: path.context.jsonPointer,\n            pathItemObject: path.oaPath,\n            operationPtr: operation && operation.context.jsonPointer,\n            operationObject: operation && operation.oaOperation,\n            requestBodyMediaTypePtr: mediaType && mediaType.context.jsonPointer,\n            requestBodyMediaTypeObject: mediaType && mediaType.oaMediaType\n          },\n          path: resolvedPath.pathKey,\n          baseUrl\n        };\n      }\n    }\n\n    return undefined;\n  }\n\n}\n\nexports.default = OpenApi;","map":{"version":3,"sources":["../../src/oas3/OpenApi.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst url_1 = require(\"url\");\nconst semver = __importStar(require(\"semver\"));\nconst Paths_1 = __importDefault(require(\"./Paths\"));\nconst Servers_1 = __importDefault(require(\"./Servers\"));\nconst Oas3CompileContext_1 = __importDefault(require(\"./Oas3CompileContext\"));\nconst extensions_1 = require(\"./extensions\");\nconst errors_1 = require(\"../errors\");\nconst httpUtils_1 = require(\"../utils/httpUtils\");\nclass OpenApi {\n    /**\n     * Creates a new OpenApi object.\n     *\n     * @param openApiDoc - The complete JSON definition of the API.\n     *   The passed in definition should be a complete JSON object with no $refs.\n     */\n    constructor(openApiDoc, options) {\n        if (!openApiDoc.openapi) {\n            throw new Error(\"OpenAPI definition is missing 'openapi' field\");\n        }\n        if (!semver.satisfies(openApiDoc.openapi, '>=3.0.0 <4.0.0')) {\n            throw new Error(`OpenAPI version ${openApiDoc.openapi} not supported`);\n        }\n        this.openApiDoc = openApiDoc;\n        this._options = options;\n        // TODO: Optimize this case when no `servers` were present in openApi doc,\n        // or where we don't need to match servers (only server is {url: '/'})?\n        if (!options.ignoreServers && openApiDoc.servers) {\n            this._servers = new Servers_1.default(openApiDoc.servers);\n        }\n        const exegesisController = openApiDoc[extensions_1.EXEGESIS_CONTROLLER];\n        this._paths = new Paths_1.default(new Oas3CompileContext_1.default(openApiDoc, ['paths'], options), exegesisController);\n    }\n    resolve(method, url, headers) {\n        const parsedUrl = url_1.parse(url);\n        const pathname = parsedUrl.pathname || '';\n        const host = parsedUrl.hostname || headers['host'] || '';\n        const contentType = headers['content-type'];\n        let pathToResolve;\n        let oaServer;\n        let serverParams;\n        let baseUrl = '';\n        if (!this._servers) {\n            pathToResolve = pathname;\n        }\n        else {\n            const serverData = this._servers.resolveServer(host, pathname);\n            if (serverData) {\n                oaServer = serverData.oaServer;\n                pathToResolve = serverData.pathnameRest;\n                serverParams = serverData.serverParams;\n                baseUrl = serverData.baseUrl;\n            }\n        }\n        if (pathToResolve) {\n            const resolvedPath = this._paths.resolvePath(pathToResolve);\n            if (resolvedPath) {\n                const { path, rawPathParams } = resolvedPath;\n                const operation = path.getOperation(method);\n                let mediaType;\n                if (operation && contentType) {\n                    mediaType = operation.getRequestMediaType(contentType);\n                    if (!mediaType && (httpUtils_1.httpHasBody(headers) || httpUtils_1.requestMayHaveBody(method))) {\n                        throw new errors_1.HttpBadRequestError(`Invalid content-type: ${contentType}`);\n                    }\n                }\n                else if (operation &&\n                    operation.bodyRequired &&\n                    operation.validRequestContentTypes) {\n                    throw new errors_1.HttpBadRequestError(`Missing content-type. ` +\n                        `Expected one of: ${operation.validRequestContentTypes}`);\n                }\n                let resolvedOperation;\n                if (operation) {\n                    const parseParameters = function () {\n                        return operation.parseParameters({\n                            headers,\n                            rawPathParams,\n                            serverParams,\n                            queryString: parsedUrl.query || undefined,\n                        });\n                    };\n                    const validateParameters = (parameterValues) => operation.validateParameters(parameterValues);\n                    const bodyParser = mediaType && mediaType.parser;\n                    const validateBody = mediaType && mediaType.validator;\n                    const validateResponse = (response, validateDefaultResponses) => operation.validateResponse(response, validateDefaultResponses);\n                    const exegesisControllerName = (mediaType && mediaType.oaMediaType[extensions_1.EXEGESIS_CONTROLLER]) ||\n                        operation.exegesisController;\n                    const operationId = (mediaType && mediaType.oaMediaType[extensions_1.EXEGESIS_OPERATION_ID]) ||\n                        operation.operationId;\n                    const controllerModule = exegesisControllerName && this._options.controllers[exegesisControllerName];\n                    const controller = operationId && controllerModule && controllerModule[operationId];\n                    const authenticate = (context) => {\n                        return operation.authenticate(context);\n                    };\n                    resolvedOperation = {\n                        parseParameters,\n                        validateParameters,\n                        parameterLocations: operation.parameterLocations,\n                        bodyParser,\n                        validateBody,\n                        validateResponse,\n                        exegesisControllerName,\n                        operationId,\n                        controllerModule,\n                        controller,\n                        authenticate,\n                    };\n                }\n                return {\n                    operation: resolvedOperation,\n                    api: {\n                        openApiDoc: this.openApiDoc,\n                        serverPtr: undefined,\n                        serverObject: oaServer,\n                        pathItemPtr: path.context.jsonPointer,\n                        pathItemObject: path.oaPath,\n                        operationPtr: operation && operation.context.jsonPointer,\n                        operationObject: operation && operation.oaOperation,\n                        requestBodyMediaTypePtr: mediaType && mediaType.context.jsonPointer,\n                        requestBodyMediaTypeObject: mediaType && mediaType.oaMediaType,\n                    },\n                    path: resolvedPath.pathKey,\n                    baseUrl,\n                };\n            }\n        }\n        return undefined;\n    }\n}\nexports.default = OpenApi;\n//# sourceMappingURL=OpenApi.js.map"]},"metadata":{},"sourceType":"script"}