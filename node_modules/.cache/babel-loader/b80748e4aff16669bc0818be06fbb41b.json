{"ast":null,"code":"'use strict';\n\nconst fs = require('graceful-fs');\n\nconst path = require('path');\n\nconst mkdirp = require('../mkdirs').mkdirs;\n\nconst pathExists = require('../path-exists').pathExists;\n\nconst utimes = require('../util/utimes').utimesMillis;\n\nconst notExist = Symbol('notExist');\nconst existsReg = Symbol('existsReg');\n\nfunction copy(src, dest, opts, cb) {\n  if (typeof opts === 'function' && !cb) {\n    cb = opts;\n    opts = {};\n  } else if (typeof opts === 'function') {\n    opts = {\n      filter: opts\n    };\n  }\n\n  cb = cb || function () {};\n\n  opts = opts || {};\n  opts.clobber = 'clobber' in opts ? !!opts.clobber : true; // default to true for now\n\n  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber; // overwrite falls back to clobber\n  // Warn about using preserveTimestamps on 32-bit node\n\n  if (opts.preserveTimestamps && process.arch === 'ia32') {\n    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\\n\n    see https://github.com/jprichardson/node-fs-extra/issues/269`);\n  }\n\n  src = path.resolve(src);\n  dest = path.resolve(dest); // don't allow src and dest to be the same\n\n  if (src === dest) return cb(new Error('Source and destination must not be the same.'));\n  if (opts.filter) return handleFilter(checkParentDir, src, dest, opts, cb);\n  return checkParentDir(src, dest, opts, cb);\n}\n\nfunction checkParentDir(src, dest, opts, cb) {\n  const destParent = path.dirname(dest);\n  pathExists(destParent, (err, dirExists) => {\n    if (err) return cb(err);\n    if (dirExists) return startCopy(src, dest, opts, cb);\n    mkdirp(destParent, err => {\n      if (err) return cb(err);\n      return startCopy(src, dest, opts, cb);\n    });\n  });\n}\n\nfunction startCopy(src, dest, opts, cb) {\n  if (opts.filter) return handleFilter(getStats, src, dest, opts, cb);\n  return getStats(src, dest, opts, cb);\n}\n\nfunction handleFilter(onInclude, src, dest, opts, cb) {\n  Promise.resolve(opts.filter(src, dest)).then(include => {\n    if (include) return onInclude(src, dest, opts, cb);\n    return cb();\n  }, error => cb(error));\n}\n\nfunction getStats(src, dest, opts, cb) {\n  const stat = opts.dereference ? fs.stat : fs.lstat;\n  stat(src, (err, st) => {\n    if (err) return cb(err);\n    if (st.isDirectory()) return onDir(st, src, dest, opts, cb);else if (st.isFile() || st.isCharacterDevice() || st.isBlockDevice()) return onFile(st, src, dest, opts, cb);else if (st.isSymbolicLink()) return onLink(src, dest, opts, cb);\n  });\n}\n\nfunction onFile(srcStat, src, dest, opts, cb) {\n  checkDest(dest, (err, resolvedPath) => {\n    if (err) return cb(err);\n\n    if (resolvedPath === notExist) {\n      return copyFile(srcStat, src, dest, opts, cb);\n    } else if (resolvedPath === existsReg) {\n      return mayCopyFile(srcStat, src, dest, opts, cb);\n    } else {\n      if (src === resolvedPath) return cb();\n      return mayCopyFile(srcStat, src, dest, opts, cb);\n    }\n  });\n}\n\nfunction mayCopyFile(srcStat, src, dest, opts, cb) {\n  if (opts.overwrite) {\n    fs.unlink(dest, err => {\n      if (err) return cb(err);\n      return copyFile(srcStat, src, dest, opts, cb);\n    });\n  } else if (opts.errorOnExist) {\n    return cb(new Error(`'${dest}' already exists`));\n  } else return cb();\n}\n\nfunction copyFile(srcStat, src, dest, opts, cb) {\n  if (typeof fs.copyFile === 'function') {\n    return fs.copyFile(src, dest, err => {\n      if (err) return cb(err);\n      return setDestModeAndTimestamps(srcStat, dest, opts, cb);\n    });\n  }\n\n  return copyFileFallback(srcStat, src, dest, opts, cb);\n}\n\nfunction copyFileFallback(srcStat, src, dest, opts, cb) {\n  const rs = fs.createReadStream(src);\n  rs.on('error', err => cb(err)).once('open', () => {\n    const ws = fs.createWriteStream(dest, {\n      mode: srcStat.mode\n    });\n    ws.on('error', err => cb(err)).on('open', () => rs.pipe(ws)).once('close', () => setDestModeAndTimestamps(srcStat, dest, opts, cb));\n  });\n}\n\nfunction setDestModeAndTimestamps(srcStat, dest, opts, cb) {\n  fs.chmod(dest, srcStat.mode, err => {\n    if (err) return cb(err);\n\n    if (opts.preserveTimestamps) {\n      return utimes(dest, srcStat.atime, srcStat.mtime, cb);\n    }\n\n    return cb();\n  });\n}\n\nfunction onDir(srcStat, src, dest, opts, cb) {\n  checkDest(dest, (err, resolvedPath) => {\n    if (err) return cb(err);\n\n    if (resolvedPath === notExist) {\n      if (isSrcSubdir(src, dest)) {\n        return cb(new Error(`Cannot copy '${src}' to a subdirectory of itself, '${dest}'.`));\n      }\n\n      return mkDirAndCopy(srcStat, src, dest, opts, cb);\n    } else if (resolvedPath === existsReg) {\n      if (isSrcSubdir(src, dest)) {\n        return cb(new Error(`Cannot copy '${src}' to a subdirectory of itself, '${dest}'.`));\n      }\n\n      return mayCopyDir(src, dest, opts, cb);\n    } else {\n      if (src === resolvedPath) return cb();\n      return copyDir(src, dest, opts, cb);\n    }\n  });\n}\n\nfunction mayCopyDir(src, dest, opts, cb) {\n  fs.stat(dest, (err, st) => {\n    if (err) return cb(err);\n\n    if (!st.isDirectory()) {\n      return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`));\n    }\n\n    return copyDir(src, dest, opts, cb);\n  });\n}\n\nfunction mkDirAndCopy(srcStat, src, dest, opts, cb) {\n  fs.mkdir(dest, srcStat.mode, err => {\n    if (err) return cb(err);\n    fs.chmod(dest, srcStat.mode, err => {\n      if (err) return cb(err);\n      return copyDir(src, dest, opts, cb);\n    });\n  });\n}\n\nfunction copyDir(src, dest, opts, cb) {\n  fs.readdir(src, (err, items) => {\n    if (err) return cb(err);\n    return copyDirItems(items, src, dest, opts, cb);\n  });\n}\n\nfunction copyDirItems(items, src, dest, opts, cb) {\n  const item = items.pop();\n  if (!item) return cb();\n  startCopy(path.join(src, item), path.join(dest, item), opts, err => {\n    if (err) return cb(err);\n    return copyDirItems(items, src, dest, opts, cb);\n  });\n}\n\nfunction onLink(src, dest, opts, cb) {\n  fs.readlink(src, (err, resolvedSrcPath) => {\n    if (err) return cb(err);\n\n    if (opts.dereference) {\n      resolvedSrcPath = path.resolve(process.cwd(), resolvedSrcPath);\n    }\n\n    checkDest(dest, (err, resolvedDestPath) => {\n      if (err) return cb(err);\n\n      if (resolvedDestPath === notExist || resolvedDestPath === existsReg) {\n        // if dest already exists, fs throws error anyway,\n        // so no need to guard against it here.\n        return fs.symlink(resolvedSrcPath, dest, cb);\n      } else {\n        if (opts.dereference) {\n          resolvedDestPath = path.resolve(process.cwd(), resolvedDestPath);\n        }\n\n        if (resolvedDestPath === resolvedSrcPath) return cb(); // prevent copy if src is a subdir of dest since unlinking\n        // dest in this case would result in removing src contents\n        // and therefore a broken symlink would be created.\n\n        fs.stat(dest, (err, st) => {\n          if (err) return cb(err);\n\n          if (st.isDirectory() && isSrcSubdir(resolvedDestPath, resolvedSrcPath)) {\n            return cb(new Error(`Cannot overwrite '${resolvedDestPath}' with '${resolvedSrcPath}'.`));\n          }\n\n          return copyLink(resolvedSrcPath, dest, cb);\n        });\n      }\n    });\n  });\n}\n\nfunction copyLink(resolvedSrcPath, dest, cb) {\n  fs.unlink(dest, err => {\n    if (err) return cb(err);\n    return fs.symlink(resolvedSrcPath, dest, cb);\n  });\n} // check if dest exists and/or is a symlink\n\n\nfunction checkDest(dest, cb) {\n  fs.readlink(dest, (err, resolvedPath) => {\n    if (err) {\n      if (err.code === 'ENOENT') return cb(null, notExist); // dest exists and is a regular file or directory, Windows may throw UNKNOWN error.\n\n      if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return cb(null, existsReg);\n      return cb(err);\n    }\n\n    return cb(null, resolvedPath); // dest exists and is a symlink\n  });\n} // return true if dest is a subdir of src, otherwise false.\n// extract dest base dir and check if that is the same as src basename\n\n\nfunction isSrcSubdir(src, dest) {\n  const baseDir = dest.split(path.dirname(src) + path.sep)[1];\n\n  if (baseDir) {\n    const destBasename = baseDir.split(path.sep)[0];\n\n    if (destBasename) {\n      return src !== dest && dest.indexOf(src) > -1 && destBasename === path.basename(src);\n    }\n\n    return false;\n  }\n\n  return false;\n}\n\nmodule.exports = copy;","map":{"version":3,"sources":["/home/dev/Documentos/Projects/github-clone/node_modules/firebase-tools/node_modules/fs-extra/lib/copy/copy.js"],"names":["fs","require","path","mkdirp","mkdirs","pathExists","utimes","utimesMillis","notExist","Symbol","existsReg","copy","src","dest","opts","cb","filter","clobber","overwrite","preserveTimestamps","process","arch","console","warn","resolve","Error","handleFilter","checkParentDir","destParent","dirname","err","dirExists","startCopy","getStats","onInclude","Promise","then","include","error","stat","dereference","lstat","st","isDirectory","onDir","isFile","isCharacterDevice","isBlockDevice","onFile","isSymbolicLink","onLink","srcStat","checkDest","resolvedPath","copyFile","mayCopyFile","unlink","errorOnExist","setDestModeAndTimestamps","copyFileFallback","rs","createReadStream","on","once","ws","createWriteStream","mode","pipe","chmod","atime","mtime","isSrcSubdir","mkDirAndCopy","mayCopyDir","copyDir","mkdir","readdir","items","copyDirItems","item","pop","join","readlink","resolvedSrcPath","cwd","resolvedDestPath","symlink","copyLink","code","baseDir","split","sep","destBasename","indexOf","basename","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,EAAE,GAAGC,OAAO,CAAC,aAAD,CAAlB;;AACA,MAAMC,IAAI,GAAGD,OAAO,CAAC,MAAD,CAApB;;AACA,MAAME,MAAM,GAAGF,OAAO,CAAC,WAAD,CAAP,CAAqBG,MAApC;;AACA,MAAMC,UAAU,GAAGJ,OAAO,CAAC,gBAAD,CAAP,CAA0BI,UAA7C;;AACA,MAAMC,MAAM,GAAGL,OAAO,CAAC,gBAAD,CAAP,CAA0BM,YAAzC;;AAEA,MAAMC,QAAQ,GAAGC,MAAM,CAAC,UAAD,CAAvB;AACA,MAAMC,SAAS,GAAGD,MAAM,CAAC,WAAD,CAAxB;;AAEA,SAASE,IAAT,CAAeC,GAAf,EAAoBC,IAApB,EAA0BC,IAA1B,EAAgCC,EAAhC,EAAoC;AAClC,MAAI,OAAOD,IAAP,KAAgB,UAAhB,IAA8B,CAACC,EAAnC,EAAuC;AACrCA,IAAAA,EAAE,GAAGD,IAAL;AACAA,IAAAA,IAAI,GAAG,EAAP;AACD,GAHD,MAGO,IAAI,OAAOA,IAAP,KAAgB,UAApB,EAAgC;AACrCA,IAAAA,IAAI,GAAG;AAACE,MAAAA,MAAM,EAAEF;AAAT,KAAP;AACD;;AAEDC,EAAAA,EAAE,GAAGA,EAAE,IAAI,YAAY,CAAE,CAAzB;;AACAD,EAAAA,IAAI,GAAGA,IAAI,IAAI,EAAf;AAEAA,EAAAA,IAAI,CAACG,OAAL,GAAe,aAAaH,IAAb,GAAoB,CAAC,CAACA,IAAI,CAACG,OAA3B,GAAqC,IAApD,CAXkC,CAWuB;;AACzDH,EAAAA,IAAI,CAACI,SAAL,GAAiB,eAAeJ,IAAf,GAAsB,CAAC,CAACA,IAAI,CAACI,SAA7B,GAAyCJ,IAAI,CAACG,OAA/D,CAZkC,CAYqC;AAEvE;;AACA,MAAIH,IAAI,CAACK,kBAAL,IAA2BC,OAAO,CAACC,IAAR,KAAiB,MAAhD,EAAwD;AACtDC,IAAAA,OAAO,CAACC,IAAR,CAAc;AAClB,iEADI;AAED;;AAEDX,EAAAA,GAAG,GAAGV,IAAI,CAACsB,OAAL,CAAaZ,GAAb,CAAN;AACAC,EAAAA,IAAI,GAAGX,IAAI,CAACsB,OAAL,CAAaX,IAAb,CAAP,CArBkC,CAuBlC;;AACA,MAAID,GAAG,KAAKC,IAAZ,EAAkB,OAAOE,EAAE,CAAC,IAAIU,KAAJ,CAAU,8CAAV,CAAD,CAAT;AAElB,MAAIX,IAAI,CAACE,MAAT,EAAiB,OAAOU,YAAY,CAACC,cAAD,EAAiBf,GAAjB,EAAsBC,IAAtB,EAA4BC,IAA5B,EAAkCC,EAAlC,CAAnB;AACjB,SAAOY,cAAc,CAACf,GAAD,EAAMC,IAAN,EAAYC,IAAZ,EAAkBC,EAAlB,CAArB;AACD;;AAED,SAASY,cAAT,CAAyBf,GAAzB,EAA8BC,IAA9B,EAAoCC,IAApC,EAA0CC,EAA1C,EAA8C;AAC5C,QAAMa,UAAU,GAAG1B,IAAI,CAAC2B,OAAL,CAAahB,IAAb,CAAnB;AACAR,EAAAA,UAAU,CAACuB,UAAD,EAAa,CAACE,GAAD,EAAMC,SAAN,KAAoB;AACzC,QAAID,GAAJ,EAAS,OAAOf,EAAE,CAACe,GAAD,CAAT;AACT,QAAIC,SAAJ,EAAe,OAAOC,SAAS,CAACpB,GAAD,EAAMC,IAAN,EAAYC,IAAZ,EAAkBC,EAAlB,CAAhB;AACfZ,IAAAA,MAAM,CAACyB,UAAD,EAAaE,GAAG,IAAI;AACxB,UAAIA,GAAJ,EAAS,OAAOf,EAAE,CAACe,GAAD,CAAT;AACT,aAAOE,SAAS,CAACpB,GAAD,EAAMC,IAAN,EAAYC,IAAZ,EAAkBC,EAAlB,CAAhB;AACD,KAHK,CAAN;AAID,GAPS,CAAV;AAQD;;AAED,SAASiB,SAAT,CAAoBpB,GAApB,EAAyBC,IAAzB,EAA+BC,IAA/B,EAAqCC,EAArC,EAAyC;AACvC,MAAID,IAAI,CAACE,MAAT,EAAiB,OAAOU,YAAY,CAACO,QAAD,EAAWrB,GAAX,EAAgBC,IAAhB,EAAsBC,IAAtB,EAA4BC,EAA5B,CAAnB;AACjB,SAAOkB,QAAQ,CAACrB,GAAD,EAAMC,IAAN,EAAYC,IAAZ,EAAkBC,EAAlB,CAAf;AACD;;AAED,SAASW,YAAT,CAAuBQ,SAAvB,EAAkCtB,GAAlC,EAAuCC,IAAvC,EAA6CC,IAA7C,EAAmDC,EAAnD,EAAuD;AACrDoB,EAAAA,OAAO,CAACX,OAAR,CAAgBV,IAAI,CAACE,MAAL,CAAYJ,GAAZ,EAAiBC,IAAjB,CAAhB,EACGuB,IADH,CACQC,OAAO,IAAI;AACf,QAAIA,OAAJ,EAAa,OAAOH,SAAS,CAACtB,GAAD,EAAMC,IAAN,EAAYC,IAAZ,EAAkBC,EAAlB,CAAhB;AACb,WAAOA,EAAE,EAAT;AACD,GAJH,EAIKuB,KAAK,IAAIvB,EAAE,CAACuB,KAAD,CAJhB;AAKD;;AAED,SAASL,QAAT,CAAmBrB,GAAnB,EAAwBC,IAAxB,EAA8BC,IAA9B,EAAoCC,EAApC,EAAwC;AACtC,QAAMwB,IAAI,GAAGzB,IAAI,CAAC0B,WAAL,GAAmBxC,EAAE,CAACuC,IAAtB,GAA6BvC,EAAE,CAACyC,KAA7C;AACAF,EAAAA,IAAI,CAAC3B,GAAD,EAAM,CAACkB,GAAD,EAAMY,EAAN,KAAa;AACrB,QAAIZ,GAAJ,EAAS,OAAOf,EAAE,CAACe,GAAD,CAAT;AAET,QAAIY,EAAE,CAACC,WAAH,EAAJ,EAAsB,OAAOC,KAAK,CAACF,EAAD,EAAK9B,GAAL,EAAUC,IAAV,EAAgBC,IAAhB,EAAsBC,EAAtB,CAAZ,CAAtB,KACK,IAAI2B,EAAE,CAACG,MAAH,MACAH,EAAE,CAACI,iBAAH,EADA,IAEAJ,EAAE,CAACK,aAAH,EAFJ,EAEwB,OAAOC,MAAM,CAACN,EAAD,EAAK9B,GAAL,EAAUC,IAAV,EAAgBC,IAAhB,EAAsBC,EAAtB,CAAb,CAFxB,KAGA,IAAI2B,EAAE,CAACO,cAAH,EAAJ,EAAyB,OAAOC,MAAM,CAACtC,GAAD,EAAMC,IAAN,EAAYC,IAAZ,EAAkBC,EAAlB,CAAb;AAC/B,GARG,CAAJ;AASD;;AAED,SAASiC,MAAT,CAAiBG,OAAjB,EAA0BvC,GAA1B,EAA+BC,IAA/B,EAAqCC,IAArC,EAA2CC,EAA3C,EAA+C;AAC7CqC,EAAAA,SAAS,CAACvC,IAAD,EAAO,CAACiB,GAAD,EAAMuB,YAAN,KAAuB;AACrC,QAAIvB,GAAJ,EAAS,OAAOf,EAAE,CAACe,GAAD,CAAT;;AACT,QAAIuB,YAAY,KAAK7C,QAArB,EAA+B;AAC7B,aAAO8C,QAAQ,CAACH,OAAD,EAAUvC,GAAV,EAAeC,IAAf,EAAqBC,IAArB,EAA2BC,EAA3B,CAAf;AACD,KAFD,MAEO,IAAIsC,YAAY,KAAK3C,SAArB,EAAgC;AACrC,aAAO6C,WAAW,CAACJ,OAAD,EAAUvC,GAAV,EAAeC,IAAf,EAAqBC,IAArB,EAA2BC,EAA3B,CAAlB;AACD,KAFM,MAEA;AACL,UAAIH,GAAG,KAAKyC,YAAZ,EAA0B,OAAOtC,EAAE,EAAT;AAC1B,aAAOwC,WAAW,CAACJ,OAAD,EAAUvC,GAAV,EAAeC,IAAf,EAAqBC,IAArB,EAA2BC,EAA3B,CAAlB;AACD;AACF,GAVQ,CAAT;AAWD;;AAED,SAASwC,WAAT,CAAsBJ,OAAtB,EAA+BvC,GAA/B,EAAoCC,IAApC,EAA0CC,IAA1C,EAAgDC,EAAhD,EAAoD;AAClD,MAAID,IAAI,CAACI,SAAT,EAAoB;AAClBlB,IAAAA,EAAE,CAACwD,MAAH,CAAU3C,IAAV,EAAgBiB,GAAG,IAAI;AACrB,UAAIA,GAAJ,EAAS,OAAOf,EAAE,CAACe,GAAD,CAAT;AACT,aAAOwB,QAAQ,CAACH,OAAD,EAAUvC,GAAV,EAAeC,IAAf,EAAqBC,IAArB,EAA2BC,EAA3B,CAAf;AACD,KAHD;AAID,GALD,MAKO,IAAID,IAAI,CAAC2C,YAAT,EAAuB;AAC5B,WAAO1C,EAAE,CAAC,IAAIU,KAAJ,CAAW,IAAGZ,IAAK,kBAAnB,CAAD,CAAT;AACD,GAFM,MAEA,OAAOE,EAAE,EAAT;AACR;;AAED,SAASuC,QAAT,CAAmBH,OAAnB,EAA4BvC,GAA5B,EAAiCC,IAAjC,EAAuCC,IAAvC,EAA6CC,EAA7C,EAAiD;AAC/C,MAAI,OAAOf,EAAE,CAACsD,QAAV,KAAuB,UAA3B,EAAuC;AACrC,WAAOtD,EAAE,CAACsD,QAAH,CAAY1C,GAAZ,EAAiBC,IAAjB,EAAuBiB,GAAG,IAAI;AACnC,UAAIA,GAAJ,EAAS,OAAOf,EAAE,CAACe,GAAD,CAAT;AACT,aAAO4B,wBAAwB,CAACP,OAAD,EAAUtC,IAAV,EAAgBC,IAAhB,EAAsBC,EAAtB,CAA/B;AACD,KAHM,CAAP;AAID;;AACD,SAAO4C,gBAAgB,CAACR,OAAD,EAAUvC,GAAV,EAAeC,IAAf,EAAqBC,IAArB,EAA2BC,EAA3B,CAAvB;AACD;;AAED,SAAS4C,gBAAT,CAA2BR,OAA3B,EAAoCvC,GAApC,EAAyCC,IAAzC,EAA+CC,IAA/C,EAAqDC,EAArD,EAAyD;AACvD,QAAM6C,EAAE,GAAG5D,EAAE,CAAC6D,gBAAH,CAAoBjD,GAApB,CAAX;AACAgD,EAAAA,EAAE,CAACE,EAAH,CAAM,OAAN,EAAehC,GAAG,IAAIf,EAAE,CAACe,GAAD,CAAxB,EACGiC,IADH,CACQ,MADR,EACgB,MAAM;AAClB,UAAMC,EAAE,GAAGhE,EAAE,CAACiE,iBAAH,CAAqBpD,IAArB,EAA2B;AAAEqD,MAAAA,IAAI,EAAEf,OAAO,CAACe;AAAhB,KAA3B,CAAX;AACAF,IAAAA,EAAE,CAACF,EAAH,CAAM,OAAN,EAAehC,GAAG,IAAIf,EAAE,CAACe,GAAD,CAAxB,EACGgC,EADH,CACM,MADN,EACc,MAAMF,EAAE,CAACO,IAAH,CAAQH,EAAR,CADpB,EAEGD,IAFH,CAEQ,OAFR,EAEiB,MAAML,wBAAwB,CAACP,OAAD,EAAUtC,IAAV,EAAgBC,IAAhB,EAAsBC,EAAtB,CAF/C;AAGD,GANH;AAOD;;AAED,SAAS2C,wBAAT,CAAmCP,OAAnC,EAA4CtC,IAA5C,EAAkDC,IAAlD,EAAwDC,EAAxD,EAA4D;AAC1Df,EAAAA,EAAE,CAACoE,KAAH,CAASvD,IAAT,EAAesC,OAAO,CAACe,IAAvB,EAA6BpC,GAAG,IAAI;AAClC,QAAIA,GAAJ,EAAS,OAAOf,EAAE,CAACe,GAAD,CAAT;;AACT,QAAIhB,IAAI,CAACK,kBAAT,EAA6B;AAC3B,aAAOb,MAAM,CAACO,IAAD,EAAOsC,OAAO,CAACkB,KAAf,EAAsBlB,OAAO,CAACmB,KAA9B,EAAqCvD,EAArC,CAAb;AACD;;AACD,WAAOA,EAAE,EAAT;AACD,GAND;AAOD;;AAED,SAAS6B,KAAT,CAAgBO,OAAhB,EAAyBvC,GAAzB,EAA8BC,IAA9B,EAAoCC,IAApC,EAA0CC,EAA1C,EAA8C;AAC5CqC,EAAAA,SAAS,CAACvC,IAAD,EAAO,CAACiB,GAAD,EAAMuB,YAAN,KAAuB;AACrC,QAAIvB,GAAJ,EAAS,OAAOf,EAAE,CAACe,GAAD,CAAT;;AACT,QAAIuB,YAAY,KAAK7C,QAArB,EAA+B;AAC7B,UAAI+D,WAAW,CAAC3D,GAAD,EAAMC,IAAN,CAAf,EAA4B;AAC1B,eAAOE,EAAE,CAAC,IAAIU,KAAJ,CAAW,gBAAeb,GAAI,mCAAkCC,IAAK,IAArE,CAAD,CAAT;AACD;;AACD,aAAO2D,YAAY,CAACrB,OAAD,EAAUvC,GAAV,EAAeC,IAAf,EAAqBC,IAArB,EAA2BC,EAA3B,CAAnB;AACD,KALD,MAKO,IAAIsC,YAAY,KAAK3C,SAArB,EAAgC;AACrC,UAAI6D,WAAW,CAAC3D,GAAD,EAAMC,IAAN,CAAf,EAA4B;AAC1B,eAAOE,EAAE,CAAC,IAAIU,KAAJ,CAAW,gBAAeb,GAAI,mCAAkCC,IAAK,IAArE,CAAD,CAAT;AACD;;AACD,aAAO4D,UAAU,CAAC7D,GAAD,EAAMC,IAAN,EAAYC,IAAZ,EAAkBC,EAAlB,CAAjB;AACD,KALM,MAKA;AACL,UAAIH,GAAG,KAAKyC,YAAZ,EAA0B,OAAOtC,EAAE,EAAT;AAC1B,aAAO2D,OAAO,CAAC9D,GAAD,EAAMC,IAAN,EAAYC,IAAZ,EAAkBC,EAAlB,CAAd;AACD;AACF,GAhBQ,CAAT;AAiBD;;AAED,SAAS0D,UAAT,CAAqB7D,GAArB,EAA0BC,IAA1B,EAAgCC,IAAhC,EAAsCC,EAAtC,EAA0C;AACxCf,EAAAA,EAAE,CAACuC,IAAH,CAAQ1B,IAAR,EAAc,CAACiB,GAAD,EAAMY,EAAN,KAAa;AACzB,QAAIZ,GAAJ,EAAS,OAAOf,EAAE,CAACe,GAAD,CAAT;;AACT,QAAI,CAACY,EAAE,CAACC,WAAH,EAAL,EAAuB;AACrB,aAAO5B,EAAE,CAAC,IAAIU,KAAJ,CAAW,mCAAkCZ,IAAK,qBAAoBD,GAAI,IAA1E,CAAD,CAAT;AACD;;AACD,WAAO8D,OAAO,CAAC9D,GAAD,EAAMC,IAAN,EAAYC,IAAZ,EAAkBC,EAAlB,CAAd;AACD,GAND;AAOD;;AAED,SAASyD,YAAT,CAAuBrB,OAAvB,EAAgCvC,GAAhC,EAAqCC,IAArC,EAA2CC,IAA3C,EAAiDC,EAAjD,EAAqD;AACnDf,EAAAA,EAAE,CAAC2E,KAAH,CAAS9D,IAAT,EAAesC,OAAO,CAACe,IAAvB,EAA6BpC,GAAG,IAAI;AAClC,QAAIA,GAAJ,EAAS,OAAOf,EAAE,CAACe,GAAD,CAAT;AACT9B,IAAAA,EAAE,CAACoE,KAAH,CAASvD,IAAT,EAAesC,OAAO,CAACe,IAAvB,EAA6BpC,GAAG,IAAI;AAClC,UAAIA,GAAJ,EAAS,OAAOf,EAAE,CAACe,GAAD,CAAT;AACT,aAAO4C,OAAO,CAAC9D,GAAD,EAAMC,IAAN,EAAYC,IAAZ,EAAkBC,EAAlB,CAAd;AACD,KAHD;AAID,GAND;AAOD;;AAED,SAAS2D,OAAT,CAAkB9D,GAAlB,EAAuBC,IAAvB,EAA6BC,IAA7B,EAAmCC,EAAnC,EAAuC;AACrCf,EAAAA,EAAE,CAAC4E,OAAH,CAAWhE,GAAX,EAAgB,CAACkB,GAAD,EAAM+C,KAAN,KAAgB;AAC9B,QAAI/C,GAAJ,EAAS,OAAOf,EAAE,CAACe,GAAD,CAAT;AACT,WAAOgD,YAAY,CAACD,KAAD,EAAQjE,GAAR,EAAaC,IAAb,EAAmBC,IAAnB,EAAyBC,EAAzB,CAAnB;AACD,GAHD;AAID;;AAED,SAAS+D,YAAT,CAAuBD,KAAvB,EAA8BjE,GAA9B,EAAmCC,IAAnC,EAAyCC,IAAzC,EAA+CC,EAA/C,EAAmD;AACjD,QAAMgE,IAAI,GAAGF,KAAK,CAACG,GAAN,EAAb;AACA,MAAI,CAACD,IAAL,EAAW,OAAOhE,EAAE,EAAT;AACXiB,EAAAA,SAAS,CAAC9B,IAAI,CAAC+E,IAAL,CAAUrE,GAAV,EAAemE,IAAf,CAAD,EAAuB7E,IAAI,CAAC+E,IAAL,CAAUpE,IAAV,EAAgBkE,IAAhB,CAAvB,EAA8CjE,IAA9C,EAAoDgB,GAAG,IAAI;AAClE,QAAIA,GAAJ,EAAS,OAAOf,EAAE,CAACe,GAAD,CAAT;AACT,WAAOgD,YAAY,CAACD,KAAD,EAAQjE,GAAR,EAAaC,IAAb,EAAmBC,IAAnB,EAAyBC,EAAzB,CAAnB;AACD,GAHQ,CAAT;AAID;;AAED,SAASmC,MAAT,CAAiBtC,GAAjB,EAAsBC,IAAtB,EAA4BC,IAA5B,EAAkCC,EAAlC,EAAsC;AACpCf,EAAAA,EAAE,CAACkF,QAAH,CAAYtE,GAAZ,EAAiB,CAACkB,GAAD,EAAMqD,eAAN,KAA0B;AACzC,QAAIrD,GAAJ,EAAS,OAAOf,EAAE,CAACe,GAAD,CAAT;;AAET,QAAIhB,IAAI,CAAC0B,WAAT,EAAsB;AACpB2C,MAAAA,eAAe,GAAGjF,IAAI,CAACsB,OAAL,CAAaJ,OAAO,CAACgE,GAAR,EAAb,EAA4BD,eAA5B,CAAlB;AACD;;AAED/B,IAAAA,SAAS,CAACvC,IAAD,EAAO,CAACiB,GAAD,EAAMuD,gBAAN,KAA2B;AACzC,UAAIvD,GAAJ,EAAS,OAAOf,EAAE,CAACe,GAAD,CAAT;;AAET,UAAIuD,gBAAgB,KAAK7E,QAArB,IAAiC6E,gBAAgB,KAAK3E,SAA1D,EAAqE;AACnE;AACA;AACA,eAAOV,EAAE,CAACsF,OAAH,CAAWH,eAAX,EAA4BtE,IAA5B,EAAkCE,EAAlC,CAAP;AACD,OAJD,MAIO;AACL,YAAID,IAAI,CAAC0B,WAAT,EAAsB;AACpB6C,UAAAA,gBAAgB,GAAGnF,IAAI,CAACsB,OAAL,CAAaJ,OAAO,CAACgE,GAAR,EAAb,EAA4BC,gBAA5B,CAAnB;AACD;;AACD,YAAIA,gBAAgB,KAAKF,eAAzB,EAA0C,OAAOpE,EAAE,EAAT,CAJrC,CAML;AACA;AACA;;AACAf,QAAAA,EAAE,CAACuC,IAAH,CAAQ1B,IAAR,EAAc,CAACiB,GAAD,EAAMY,EAAN,KAAa;AACzB,cAAIZ,GAAJ,EAAS,OAAOf,EAAE,CAACe,GAAD,CAAT;;AACT,cAAIY,EAAE,CAACC,WAAH,MAAoB4B,WAAW,CAACc,gBAAD,EAAmBF,eAAnB,CAAnC,EAAwE;AACtE,mBAAOpE,EAAE,CAAC,IAAIU,KAAJ,CAAW,qBAAoB4D,gBAAiB,WAAUF,eAAgB,IAA1E,CAAD,CAAT;AACD;;AACD,iBAAOI,QAAQ,CAACJ,eAAD,EAAkBtE,IAAlB,EAAwBE,EAAxB,CAAf;AACD,SAND;AAOD;AACF,KAxBQ,CAAT;AAyBD,GAhCD;AAiCD;;AAED,SAASwE,QAAT,CAAmBJ,eAAnB,EAAoCtE,IAApC,EAA0CE,EAA1C,EAA8C;AAC5Cf,EAAAA,EAAE,CAACwD,MAAH,CAAU3C,IAAV,EAAgBiB,GAAG,IAAI;AACrB,QAAIA,GAAJ,EAAS,OAAOf,EAAE,CAACe,GAAD,CAAT;AACT,WAAO9B,EAAE,CAACsF,OAAH,CAAWH,eAAX,EAA4BtE,IAA5B,EAAkCE,EAAlC,CAAP;AACD,GAHD;AAID,C,CAED;;;AACA,SAASqC,SAAT,CAAoBvC,IAApB,EAA0BE,EAA1B,EAA8B;AAC5Bf,EAAAA,EAAE,CAACkF,QAAH,CAAYrE,IAAZ,EAAkB,CAACiB,GAAD,EAAMuB,YAAN,KAAuB;AACvC,QAAIvB,GAAJ,EAAS;AACP,UAAIA,GAAG,CAAC0D,IAAJ,KAAa,QAAjB,EAA2B,OAAOzE,EAAE,CAAC,IAAD,EAAOP,QAAP,CAAT,CADpB,CAGP;;AACA,UAAIsB,GAAG,CAAC0D,IAAJ,KAAa,QAAb,IAAyB1D,GAAG,CAAC0D,IAAJ,KAAa,SAA1C,EAAqD,OAAOzE,EAAE,CAAC,IAAD,EAAOL,SAAP,CAAT;AAErD,aAAOK,EAAE,CAACe,GAAD,CAAT;AACD;;AACD,WAAOf,EAAE,CAAC,IAAD,EAAOsC,YAAP,CAAT,CATuC,CAST;AAC/B,GAVD;AAWD,C,CAED;AACA;;;AACA,SAASkB,WAAT,CAAsB3D,GAAtB,EAA2BC,IAA3B,EAAiC;AAC/B,QAAM4E,OAAO,GAAG5E,IAAI,CAAC6E,KAAL,CAAWxF,IAAI,CAAC2B,OAAL,CAAajB,GAAb,IAAoBV,IAAI,CAACyF,GAApC,EAAyC,CAAzC,CAAhB;;AACA,MAAIF,OAAJ,EAAa;AACX,UAAMG,YAAY,GAAGH,OAAO,CAACC,KAAR,CAAcxF,IAAI,CAACyF,GAAnB,EAAwB,CAAxB,CAArB;;AACA,QAAIC,YAAJ,EAAkB;AAChB,aAAOhF,GAAG,KAAKC,IAAR,IAAgBA,IAAI,CAACgF,OAAL,CAAajF,GAAb,IAAoB,CAAC,CAArC,IAA0CgF,YAAY,KAAK1F,IAAI,CAAC4F,QAAL,CAAclF,GAAd,CAAlE;AACD;;AACD,WAAO,KAAP;AACD;;AACD,SAAO,KAAP;AACD;;AAEDmF,MAAM,CAACC,OAAP,GAAiBrF,IAAjB","sourcesContent":["'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst mkdirp = require('../mkdirs').mkdirs\nconst pathExists = require('../path-exists').pathExists\nconst utimes = require('../util/utimes').utimesMillis\n\nconst notExist = Symbol('notExist')\nconst existsReg = Symbol('existsReg')\n\nfunction copy (src, dest, opts, cb) {\n  if (typeof opts === 'function' && !cb) {\n    cb = opts\n    opts = {}\n  } else if (typeof opts === 'function') {\n    opts = {filter: opts}\n  }\n\n  cb = cb || function () {}\n  opts = opts || {}\n\n  opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now\n  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber\n\n  // Warn about using preserveTimestamps on 32-bit node\n  if (opts.preserveTimestamps && process.arch === 'ia32') {\n    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\\n\n    see https://github.com/jprichardson/node-fs-extra/issues/269`)\n  }\n\n  src = path.resolve(src)\n  dest = path.resolve(dest)\n\n  // don't allow src and dest to be the same\n  if (src === dest) return cb(new Error('Source and destination must not be the same.'))\n\n  if (opts.filter) return handleFilter(checkParentDir, src, dest, opts, cb)\n  return checkParentDir(src, dest, opts, cb)\n}\n\nfunction checkParentDir (src, dest, opts, cb) {\n  const destParent = path.dirname(dest)\n  pathExists(destParent, (err, dirExists) => {\n    if (err) return cb(err)\n    if (dirExists) return startCopy(src, dest, opts, cb)\n    mkdirp(destParent, err => {\n      if (err) return cb(err)\n      return startCopy(src, dest, opts, cb)\n    })\n  })\n}\n\nfunction startCopy (src, dest, opts, cb) {\n  if (opts.filter) return handleFilter(getStats, src, dest, opts, cb)\n  return getStats(src, dest, opts, cb)\n}\n\nfunction handleFilter (onInclude, src, dest, opts, cb) {\n  Promise.resolve(opts.filter(src, dest))\n    .then(include => {\n      if (include) return onInclude(src, dest, opts, cb)\n      return cb()\n    }, error => cb(error))\n}\n\nfunction getStats (src, dest, opts, cb) {\n  const stat = opts.dereference ? fs.stat : fs.lstat\n  stat(src, (err, st) => {\n    if (err) return cb(err)\n\n    if (st.isDirectory()) return onDir(st, src, dest, opts, cb)\n    else if (st.isFile() ||\n             st.isCharacterDevice() ||\n             st.isBlockDevice()) return onFile(st, src, dest, opts, cb)\n    else if (st.isSymbolicLink()) return onLink(src, dest, opts, cb)\n  })\n}\n\nfunction onFile (srcStat, src, dest, opts, cb) {\n  checkDest(dest, (err, resolvedPath) => {\n    if (err) return cb(err)\n    if (resolvedPath === notExist) {\n      return copyFile(srcStat, src, dest, opts, cb)\n    } else if (resolvedPath === existsReg) {\n      return mayCopyFile(srcStat, src, dest, opts, cb)\n    } else {\n      if (src === resolvedPath) return cb()\n      return mayCopyFile(srcStat, src, dest, opts, cb)\n    }\n  })\n}\n\nfunction mayCopyFile (srcStat, src, dest, opts, cb) {\n  if (opts.overwrite) {\n    fs.unlink(dest, err => {\n      if (err) return cb(err)\n      return copyFile(srcStat, src, dest, opts, cb)\n    })\n  } else if (opts.errorOnExist) {\n    return cb(new Error(`'${dest}' already exists`))\n  } else return cb()\n}\n\nfunction copyFile (srcStat, src, dest, opts, cb) {\n  if (typeof fs.copyFile === 'function') {\n    return fs.copyFile(src, dest, err => {\n      if (err) return cb(err)\n      return setDestModeAndTimestamps(srcStat, dest, opts, cb)\n    })\n  }\n  return copyFileFallback(srcStat, src, dest, opts, cb)\n}\n\nfunction copyFileFallback (srcStat, src, dest, opts, cb) {\n  const rs = fs.createReadStream(src)\n  rs.on('error', err => cb(err))\n    .once('open', () => {\n      const ws = fs.createWriteStream(dest, { mode: srcStat.mode })\n      ws.on('error', err => cb(err))\n        .on('open', () => rs.pipe(ws))\n        .once('close', () => setDestModeAndTimestamps(srcStat, dest, opts, cb))\n    })\n}\n\nfunction setDestModeAndTimestamps (srcStat, dest, opts, cb) {\n  fs.chmod(dest, srcStat.mode, err => {\n    if (err) return cb(err)\n    if (opts.preserveTimestamps) {\n      return utimes(dest, srcStat.atime, srcStat.mtime, cb)\n    }\n    return cb()\n  })\n}\n\nfunction onDir (srcStat, src, dest, opts, cb) {\n  checkDest(dest, (err, resolvedPath) => {\n    if (err) return cb(err)\n    if (resolvedPath === notExist) {\n      if (isSrcSubdir(src, dest)) {\n        return cb(new Error(`Cannot copy '${src}' to a subdirectory of itself, '${dest}'.`))\n      }\n      return mkDirAndCopy(srcStat, src, dest, opts, cb)\n    } else if (resolvedPath === existsReg) {\n      if (isSrcSubdir(src, dest)) {\n        return cb(new Error(`Cannot copy '${src}' to a subdirectory of itself, '${dest}'.`))\n      }\n      return mayCopyDir(src, dest, opts, cb)\n    } else {\n      if (src === resolvedPath) return cb()\n      return copyDir(src, dest, opts, cb)\n    }\n  })\n}\n\nfunction mayCopyDir (src, dest, opts, cb) {\n  fs.stat(dest, (err, st) => {\n    if (err) return cb(err)\n    if (!st.isDirectory()) {\n      return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`))\n    }\n    return copyDir(src, dest, opts, cb)\n  })\n}\n\nfunction mkDirAndCopy (srcStat, src, dest, opts, cb) {\n  fs.mkdir(dest, srcStat.mode, err => {\n    if (err) return cb(err)\n    fs.chmod(dest, srcStat.mode, err => {\n      if (err) return cb(err)\n      return copyDir(src, dest, opts, cb)\n    })\n  })\n}\n\nfunction copyDir (src, dest, opts, cb) {\n  fs.readdir(src, (err, items) => {\n    if (err) return cb(err)\n    return copyDirItems(items, src, dest, opts, cb)\n  })\n}\n\nfunction copyDirItems (items, src, dest, opts, cb) {\n  const item = items.pop()\n  if (!item) return cb()\n  startCopy(path.join(src, item), path.join(dest, item), opts, err => {\n    if (err) return cb(err)\n    return copyDirItems(items, src, dest, opts, cb)\n  })\n}\n\nfunction onLink (src, dest, opts, cb) {\n  fs.readlink(src, (err, resolvedSrcPath) => {\n    if (err) return cb(err)\n\n    if (opts.dereference) {\n      resolvedSrcPath = path.resolve(process.cwd(), resolvedSrcPath)\n    }\n\n    checkDest(dest, (err, resolvedDestPath) => {\n      if (err) return cb(err)\n\n      if (resolvedDestPath === notExist || resolvedDestPath === existsReg) {\n        // if dest already exists, fs throws error anyway,\n        // so no need to guard against it here.\n        return fs.symlink(resolvedSrcPath, dest, cb)\n      } else {\n        if (opts.dereference) {\n          resolvedDestPath = path.resolve(process.cwd(), resolvedDestPath)\n        }\n        if (resolvedDestPath === resolvedSrcPath) return cb()\n\n        // prevent copy if src is a subdir of dest since unlinking\n        // dest in this case would result in removing src contents\n        // and therefore a broken symlink would be created.\n        fs.stat(dest, (err, st) => {\n          if (err) return cb(err)\n          if (st.isDirectory() && isSrcSubdir(resolvedDestPath, resolvedSrcPath)) {\n            return cb(new Error(`Cannot overwrite '${resolvedDestPath}' with '${resolvedSrcPath}'.`))\n          }\n          return copyLink(resolvedSrcPath, dest, cb)\n        })\n      }\n    })\n  })\n}\n\nfunction copyLink (resolvedSrcPath, dest, cb) {\n  fs.unlink(dest, err => {\n    if (err) return cb(err)\n    return fs.symlink(resolvedSrcPath, dest, cb)\n  })\n}\n\n// check if dest exists and/or is a symlink\nfunction checkDest (dest, cb) {\n  fs.readlink(dest, (err, resolvedPath) => {\n    if (err) {\n      if (err.code === 'ENOENT') return cb(null, notExist)\n\n      // dest exists and is a regular file or directory, Windows may throw UNKNOWN error.\n      if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return cb(null, existsReg)\n\n      return cb(err)\n    }\n    return cb(null, resolvedPath) // dest exists and is a symlink\n  })\n}\n\n// return true if dest is a subdir of src, otherwise false.\n// extract dest base dir and check if that is the same as src basename\nfunction isSrcSubdir (src, dest) {\n  const baseDir = dest.split(path.dirname(src) + path.sep)[1]\n  if (baseDir) {\n    const destBasename = baseDir.split(path.sep)[0]\n    if (destBasename) {\n      return src !== dest && dest.indexOf(src) > -1 && destBasename === path.basename(src)\n    }\n    return false\n  }\n  return false\n}\n\nmodule.exports = copy\n"]},"metadata":{},"sourceType":"script"}