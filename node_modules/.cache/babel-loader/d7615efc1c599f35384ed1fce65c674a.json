{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _construct(Parent, args, Class) {\n  if (_isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) _setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}\n\nfunction _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\n\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !_isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return _setPrototypeOf(Wrapper, Class);\n  };\n\n  return _wrapNativeSuper(Class);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nfunction _get(target, property, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get(target, property, receiver || target);\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _toArray(arr) {\n  return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function () {};\n\n      return {\n        s: F,\n        n: function () {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function (e) {\n          throw e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function () {\n      it = o[Symbol.iterator]();\n    },\n    n: function () {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function (e) {\n      didErr = true;\n      err = e;\n    },\n    f: function () {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nvar Char = {\n  ANCHOR: '&',\n  COMMENT: '#',\n  TAG: '!',\n  DIRECTIVES_END: '-',\n  DOCUMENT_END: '.'\n};\nvar Type = {\n  ALIAS: 'ALIAS',\n  BLANK_LINE: 'BLANK_LINE',\n  BLOCK_FOLDED: 'BLOCK_FOLDED',\n  BLOCK_LITERAL: 'BLOCK_LITERAL',\n  COMMENT: 'COMMENT',\n  DIRECTIVE: 'DIRECTIVE',\n  DOCUMENT: 'DOCUMENT',\n  FLOW_MAP: 'FLOW_MAP',\n  FLOW_SEQ: 'FLOW_SEQ',\n  MAP: 'MAP',\n  MAP_KEY: 'MAP_KEY',\n  MAP_VALUE: 'MAP_VALUE',\n  PLAIN: 'PLAIN',\n  QUOTE_DOUBLE: 'QUOTE_DOUBLE',\n  QUOTE_SINGLE: 'QUOTE_SINGLE',\n  SEQ: 'SEQ',\n  SEQ_ITEM: 'SEQ_ITEM'\n};\nvar defaultTagPrefix = 'tag:yaml.org,2002:';\nvar defaultTags = {\n  MAP: 'tag:yaml.org,2002:map',\n  SEQ: 'tag:yaml.org,2002:seq',\n  STR: 'tag:yaml.org,2002:str'\n};\n\nfunction findLineStarts(src) {\n  var ls = [0];\n  var offset = src.indexOf('\\n');\n\n  while (offset !== -1) {\n    offset += 1;\n    ls.push(offset);\n    offset = src.indexOf('\\n', offset);\n  }\n\n  return ls;\n}\n\nfunction getSrcInfo(cst) {\n  var lineStarts, src;\n\n  if (typeof cst === 'string') {\n    lineStarts = findLineStarts(cst);\n    src = cst;\n  } else {\n    if (Array.isArray(cst)) cst = cst[0];\n\n    if (cst && cst.context) {\n      if (!cst.lineStarts) cst.lineStarts = findLineStarts(cst.context.src);\n      lineStarts = cst.lineStarts;\n      src = cst.context.src;\n    }\n  }\n\n  return {\n    lineStarts: lineStarts,\n    src: src\n  };\n}\n/**\n * @typedef {Object} LinePos - One-indexed position in the source\n * @property {number} line\n * @property {number} col\n */\n\n/**\n * Determine the line/col position matching a character offset.\n *\n * Accepts a source string or a CST document as the second parameter. With\n * the latter, starting indices for lines are cached in the document as\n * `lineStarts: number[]`.\n *\n * Returns a one-indexed `{ line, col }` location if found, or\n * `undefined` otherwise.\n *\n * @param {number} offset\n * @param {string|Document|Document[]} cst\n * @returns {?LinePos}\n */\n\n\nfunction getLinePos(offset, cst) {\n  if (typeof offset !== 'number' || offset < 0) return null;\n\n  var _getSrcInfo = getSrcInfo(cst),\n      lineStarts = _getSrcInfo.lineStarts,\n      src = _getSrcInfo.src;\n\n  if (!lineStarts || !src || offset > src.length) return null;\n\n  for (var i = 0; i < lineStarts.length; ++i) {\n    var start = lineStarts[i];\n\n    if (offset < start) {\n      return {\n        line: i,\n        col: offset - lineStarts[i - 1] + 1\n      };\n    }\n\n    if (offset === start) return {\n      line: i + 1,\n      col: 1\n    };\n  }\n\n  var line = lineStarts.length;\n  return {\n    line: line,\n    col: offset - lineStarts[line - 1] + 1\n  };\n}\n/**\n * Get a specified line from the source.\n *\n * Accepts a source string or a CST document as the second parameter. With\n * the latter, starting indices for lines are cached in the document as\n * `lineStarts: number[]`.\n *\n * Returns the line as a string if found, or `null` otherwise.\n *\n * @param {number} line One-indexed line number\n * @param {string|Document|Document[]} cst\n * @returns {?string}\n */\n\n\nfunction getLine(line, cst) {\n  var _getSrcInfo2 = getSrcInfo(cst),\n      lineStarts = _getSrcInfo2.lineStarts,\n      src = _getSrcInfo2.src;\n\n  if (!lineStarts || !(line >= 1) || line > lineStarts.length) return null;\n  var start = lineStarts[line - 1];\n  var end = lineStarts[line]; // undefined for last line; that's ok for slice()\n\n  while (end && end > start && src[end - 1] === '\\n') {\n    --end;\n  }\n\n  return src.slice(start, end);\n}\n/**\n * Pretty-print the starting line from the source indicated by the range `pos`\n *\n * Trims output to `maxWidth` chars while keeping the starting column visible,\n * using `…` at either end to indicate dropped characters.\n *\n * Returns a two-line string (or `null`) with `\\n` as separator; the second line\n * will hold appropriately indented `^` marks indicating the column range.\n *\n * @param {Object} pos\n * @param {LinePos} pos.start\n * @param {LinePos} [pos.end]\n * @param {string|Document|Document[]*} cst\n * @param {number} [maxWidth=80]\n * @returns {?string}\n */\n\n\nfunction getPrettyContext(_ref, cst) {\n  var start = _ref.start,\n      end = _ref.end;\n  var maxWidth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 80;\n  var src = getLine(start.line, cst);\n  if (!src) return null;\n  var col = start.col;\n\n  if (src.length > maxWidth) {\n    if (col <= maxWidth - 10) {\n      src = src.substr(0, maxWidth - 1) + '…';\n    } else {\n      var halfWidth = Math.round(maxWidth / 2);\n      if (src.length > col + halfWidth) src = src.substr(0, col + halfWidth - 1) + '…';\n      col -= src.length - maxWidth;\n      src = '…' + src.substr(1 - maxWidth);\n    }\n  }\n\n  var errLen = 1;\n  var errEnd = '';\n\n  if (end) {\n    if (end.line === start.line && col + (end.col - start.col) <= maxWidth + 1) {\n      errLen = end.col - start.col;\n    } else {\n      errLen = Math.min(src.length + 1, maxWidth) - col;\n      errEnd = '…';\n    }\n  }\n\n  var offset = col > 1 ? ' '.repeat(col - 1) : '';\n  var err = '^'.repeat(errLen);\n  return \"\".concat(src, \"\\n\").concat(offset).concat(err).concat(errEnd);\n}\n\nvar Range = /*#__PURE__*/function () {\n  function Range(start, end) {\n    _classCallCheck(this, Range);\n\n    this.start = start;\n    this.end = end || start;\n  }\n\n  _createClass(Range, [{\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return typeof this.start !== 'number' || !this.end || this.end <= this.start;\n    }\n    /**\n     * Set `origStart` and `origEnd` to point to the original source range for\n     * this node, which may differ due to dropped CR characters.\n     *\n     * @param {number[]} cr - Positions of dropped CR characters\n     * @param {number} offset - Starting index of `cr` from the last call\n     * @returns {number} - The next offset, matching the one found for `origStart`\n     */\n\n  }, {\n    key: \"setOrigRange\",\n    value: function setOrigRange(cr, offset) {\n      var start = this.start,\n          end = this.end;\n\n      if (cr.length === 0 || end <= cr[0]) {\n        this.origStart = start;\n        this.origEnd = end;\n        return offset;\n      }\n\n      var i = offset;\n\n      while (i < cr.length) {\n        if (cr[i] > start) break;else ++i;\n      }\n\n      this.origStart = start + i;\n      var nextOffset = i;\n\n      while (i < cr.length) {\n        // if end was at \\n, it should now be at \\r\n        if (cr[i] >= end) break;else ++i;\n      }\n\n      this.origEnd = end + i;\n      return nextOffset;\n    }\n  }], [{\n    key: \"copy\",\n    value: function copy(orig) {\n      return new Range(orig.start, orig.end);\n    }\n  }]);\n\n  return Range;\n}();\n/** Root class of all nodes */\n\n\nvar Node = /*#__PURE__*/function () {\n  function Node(type, props, context) {\n    _classCallCheck(this, Node);\n\n    Object.defineProperty(this, 'context', {\n      value: context || null,\n      writable: true\n    });\n    this.error = null;\n    this.range = null;\n    this.valueRange = null;\n    this.props = props || [];\n    this.type = type;\n    this.value = null;\n  }\n\n  _createClass(Node, [{\n    key: \"getPropValue\",\n    value: function getPropValue(idx, key, skipKey) {\n      if (!this.context) return null;\n      var src = this.context.src;\n      var prop = this.props[idx];\n      return prop && src[prop.start] === key ? src.slice(prop.start + (skipKey ? 1 : 0), prop.end) : null;\n    }\n  }, {\n    key: \"anchor\",\n    get: function get() {\n      for (var i = 0; i < this.props.length; ++i) {\n        var anchor = this.getPropValue(i, Char.ANCHOR, true);\n        if (anchor != null) return anchor;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"comment\",\n    get: function get() {\n      var comments = [];\n\n      for (var i = 0; i < this.props.length; ++i) {\n        var comment = this.getPropValue(i, Char.COMMENT, true);\n        if (comment != null) comments.push(comment);\n      }\n\n      return comments.length > 0 ? comments.join('\\n') : null;\n    }\n  }, {\n    key: \"commentHasRequiredWhitespace\",\n    value: function commentHasRequiredWhitespace(start) {\n      var src = this.context.src;\n      if (this.header && start === this.header.end) return false;\n      if (!this.valueRange) return false;\n      var end = this.valueRange.end;\n      return start !== end || Node.atBlank(src, end - 1);\n    }\n  }, {\n    key: \"hasComment\",\n    get: function get() {\n      if (this.context) {\n        var src = this.context.src;\n\n        for (var i = 0; i < this.props.length; ++i) {\n          if (src[this.props[i].start] === Char.COMMENT) return true;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"hasProps\",\n    get: function get() {\n      if (this.context) {\n        var src = this.context.src;\n\n        for (var i = 0; i < this.props.length; ++i) {\n          if (src[this.props[i].start] !== Char.COMMENT) return true;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"includesTrailingLines\",\n    get: function get() {\n      return false;\n    }\n  }, {\n    key: \"jsonLike\",\n    get: function get() {\n      var jsonLikeTypes = [Type.FLOW_MAP, Type.FLOW_SEQ, Type.QUOTE_DOUBLE, Type.QUOTE_SINGLE];\n      return jsonLikeTypes.indexOf(this.type) !== -1;\n    }\n  }, {\n    key: \"rangeAsLinePos\",\n    get: function get() {\n      if (!this.range || !this.context) return undefined;\n      var start = getLinePos(this.range.start, this.context.root);\n      if (!start) return undefined;\n      var end = getLinePos(this.range.end, this.context.root);\n      return {\n        start: start,\n        end: end\n      };\n    }\n  }, {\n    key: \"rawValue\",\n    get: function get() {\n      if (!this.valueRange || !this.context) return null;\n      var _this$valueRange = this.valueRange,\n          start = _this$valueRange.start,\n          end = _this$valueRange.end;\n      return this.context.src.slice(start, end);\n    }\n  }, {\n    key: \"tag\",\n    get: function get() {\n      for (var i = 0; i < this.props.length; ++i) {\n        var tag = this.getPropValue(i, Char.TAG, false);\n\n        if (tag != null) {\n          if (tag[1] === '<') {\n            return {\n              verbatim: tag.slice(2, -1)\n            };\n          } else {\n            // eslint-disable-next-line no-unused-vars\n            var _tag$match = tag.match(/^(.*!)([^!]*)$/),\n                _tag$match2 = _slicedToArray(_tag$match, 3);\n\n            _tag$match2[0];\n            var handle = _tag$match2[1],\n                suffix = _tag$match2[2];\n            return {\n              handle: handle,\n              suffix: suffix\n            };\n          }\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"valueRangeContainsNewline\",\n    get: function get() {\n      if (!this.valueRange || !this.context) return false;\n      var _this$valueRange2 = this.valueRange,\n          start = _this$valueRange2.start,\n          end = _this$valueRange2.end;\n      var src = this.context.src;\n\n      for (var i = start; i < end; ++i) {\n        if (src[i] === '\\n') return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"parseComment\",\n    value: function parseComment(start) {\n      var src = this.context.src;\n\n      if (src[start] === Char.COMMENT) {\n        var end = Node.endOfLine(src, start + 1);\n        var commentRange = new Range(start, end);\n        this.props.push(commentRange);\n        return end;\n      }\n\n      return start;\n    }\n    /**\n     * Populates the `origStart` and `origEnd` values of all ranges for this\n     * node. Extended by child classes to handle descendant nodes.\n     *\n     * @param {number[]} cr - Positions of dropped CR characters\n     * @param {number} offset - Starting index of `cr` from the last call\n     * @returns {number} - The next offset, matching the one found for `origStart`\n     */\n\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      if (this.range) offset = this.range.setOrigRange(cr, offset);\n      if (this.valueRange) this.valueRange.setOrigRange(cr, offset);\n      this.props.forEach(function (prop) {\n        return prop.setOrigRange(cr, offset);\n      });\n      return offset;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var src = this.context.src,\n          range = this.range,\n          value = this.value;\n      if (value != null) return value;\n      var str = src.slice(range.start, range.end);\n      return Node.addStringTerminator(src, range.end, str);\n    }\n  }], [{\n    key: \"addStringTerminator\",\n    value: function addStringTerminator(src, offset, str) {\n      if (str[str.length - 1] === '\\n') return str;\n      var next = Node.endOfWhiteSpace(src, offset);\n      return next >= src.length || src[next] === '\\n' ? str + '\\n' : str;\n    } // ^(---|...)\n\n  }, {\n    key: \"atDocumentBoundary\",\n    value: function atDocumentBoundary(src, offset, sep) {\n      var ch0 = src[offset];\n      if (!ch0) return true;\n      var prev = src[offset - 1];\n      if (prev && prev !== '\\n') return false;\n\n      if (sep) {\n        if (ch0 !== sep) return false;\n      } else {\n        if (ch0 !== Char.DIRECTIVES_END && ch0 !== Char.DOCUMENT_END) return false;\n      }\n\n      var ch1 = src[offset + 1];\n      var ch2 = src[offset + 2];\n      if (ch1 !== ch0 || ch2 !== ch0) return false;\n      var ch3 = src[offset + 3];\n      return !ch3 || ch3 === '\\n' || ch3 === '\\t' || ch3 === ' ';\n    }\n  }, {\n    key: \"endOfIdentifier\",\n    value: function endOfIdentifier(src, offset) {\n      var ch = src[offset];\n      var isVerbatim = ch === '<';\n      var notOk = isVerbatim ? ['\\n', '\\t', ' ', '>'] : ['\\n', '\\t', ' ', '[', ']', '{', '}', ','];\n\n      while (ch && notOk.indexOf(ch) === -1) {\n        ch = src[offset += 1];\n      }\n\n      if (isVerbatim && ch === '>') offset += 1;\n      return offset;\n    }\n  }, {\n    key: \"endOfIndent\",\n    value: function endOfIndent(src, offset) {\n      var ch = src[offset];\n\n      while (ch === ' ') {\n        ch = src[offset += 1];\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"endOfLine\",\n    value: function endOfLine(src, offset) {\n      var ch = src[offset];\n\n      while (ch && ch !== '\\n') {\n        ch = src[offset += 1];\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"endOfWhiteSpace\",\n    value: function endOfWhiteSpace(src, offset) {\n      var ch = src[offset];\n\n      while (ch === '\\t' || ch === ' ') {\n        ch = src[offset += 1];\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"startOfLine\",\n    value: function startOfLine(src, offset) {\n      var ch = src[offset - 1];\n      if (ch === '\\n') return offset;\n\n      while (ch && ch !== '\\n') {\n        ch = src[offset -= 1];\n      }\n\n      return offset + 1;\n    }\n    /**\n     * End of indentation, or null if the line's indent level is not more\n     * than `indent`\n     *\n     * @param {string} src\n     * @param {number} indent\n     * @param {number} lineStart\n     * @returns {?number}\n     */\n\n  }, {\n    key: \"endOfBlockIndent\",\n    value: function endOfBlockIndent(src, indent, lineStart) {\n      var inEnd = Node.endOfIndent(src, lineStart);\n\n      if (inEnd > lineStart + indent) {\n        return inEnd;\n      } else {\n        var wsEnd = Node.endOfWhiteSpace(src, inEnd);\n        var ch = src[wsEnd];\n        if (!ch || ch === '\\n') return wsEnd;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"atBlank\",\n    value: function atBlank(src, offset, endAsBlank) {\n      var ch = src[offset];\n      return ch === '\\n' || ch === '\\t' || ch === ' ' || endAsBlank && !ch;\n    }\n  }, {\n    key: \"nextNodeIsIndented\",\n    value: function nextNodeIsIndented(ch, indentDiff, indicatorAsIndent) {\n      if (!ch || indentDiff < 0) return false;\n      if (indentDiff > 0) return true;\n      return indicatorAsIndent && ch === '-';\n    } // should be at line or string end, or at next non-whitespace char\n\n  }, {\n    key: \"normalizeOffset\",\n    value: function normalizeOffset(src, offset) {\n      var ch = src[offset];\n      return !ch ? offset : ch !== '\\n' && src[offset - 1] === '\\n' ? offset - 1 : Node.endOfWhiteSpace(src, offset);\n    } // fold single newline into space, multiple newlines to N - 1 newlines\n    // presumes src[offset] === '\\n'\n\n  }, {\n    key: \"foldNewline\",\n    value: function foldNewline(src, offset, indent) {\n      var inCount = 0;\n      var error = false;\n      var fold = '';\n      var ch = src[offset + 1];\n\n      while (ch === ' ' || ch === '\\t' || ch === '\\n') {\n        switch (ch) {\n          case '\\n':\n            inCount = 0;\n            offset += 1;\n            fold += '\\n';\n            break;\n\n          case '\\t':\n            if (inCount <= indent) error = true;\n            offset = Node.endOfWhiteSpace(src, offset + 2) - 1;\n            break;\n\n          case ' ':\n            inCount += 1;\n            offset += 1;\n            break;\n        }\n\n        ch = src[offset + 1];\n      }\n\n      if (!fold) fold = ' ';\n      if (ch && inCount <= indent) error = true;\n      return {\n        fold: fold,\n        offset: offset,\n        error: error\n      };\n    }\n  }]);\n\n  return Node;\n}();\n\nvar YAMLError = /*#__PURE__*/function (_Error) {\n  _inherits(YAMLError, _Error);\n\n  var _super = _createSuper(YAMLError);\n\n  function YAMLError(name, source, message) {\n    var _this;\n\n    _classCallCheck(this, YAMLError);\n\n    if (!message || !(source instanceof Node)) throw new Error(\"Invalid arguments for new \".concat(name));\n    _this = _super.call(this);\n    _this.name = name;\n    _this.message = message;\n    _this.source = source;\n    return _this;\n  }\n\n  _createClass(YAMLError, [{\n    key: \"makePretty\",\n    value: function makePretty() {\n      if (!this.source) return;\n      this.nodeType = this.source.type;\n      var cst = this.source.context && this.source.context.root;\n\n      if (typeof this.offset === 'number') {\n        this.range = new Range(this.offset, this.offset + 1);\n        var start = cst && getLinePos(this.offset, cst);\n\n        if (start) {\n          var end = {\n            line: start.line,\n            col: start.col + 1\n          };\n          this.linePos = {\n            start: start,\n            end: end\n          };\n        }\n\n        delete this.offset;\n      } else {\n        this.range = this.source.range;\n        this.linePos = this.source.rangeAsLinePos;\n      }\n\n      if (this.linePos) {\n        var _this$linePos$start = this.linePos.start,\n            line = _this$linePos$start.line,\n            col = _this$linePos$start.col;\n        this.message += \" at line \".concat(line, \", column \").concat(col);\n        var ctx = cst && getPrettyContext(this.linePos, cst);\n        if (ctx) this.message += \":\\n\\n\".concat(ctx, \"\\n\");\n      }\n\n      delete this.source;\n    }\n  }]);\n\n  return YAMLError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nvar YAMLReferenceError = /*#__PURE__*/function (_YAMLError) {\n  _inherits(YAMLReferenceError, _YAMLError);\n\n  var _super2 = _createSuper(YAMLReferenceError);\n\n  function YAMLReferenceError(source, message) {\n    _classCallCheck(this, YAMLReferenceError);\n\n    return _super2.call(this, 'YAMLReferenceError', source, message);\n  }\n\n  return YAMLReferenceError;\n}(YAMLError);\n\nvar YAMLSemanticError = /*#__PURE__*/function (_YAMLError2) {\n  _inherits(YAMLSemanticError, _YAMLError2);\n\n  var _super3 = _createSuper(YAMLSemanticError);\n\n  function YAMLSemanticError(source, message) {\n    _classCallCheck(this, YAMLSemanticError);\n\n    return _super3.call(this, 'YAMLSemanticError', source, message);\n  }\n\n  return YAMLSemanticError;\n}(YAMLError);\n\nvar YAMLSyntaxError = /*#__PURE__*/function (_YAMLError3) {\n  _inherits(YAMLSyntaxError, _YAMLError3);\n\n  var _super4 = _createSuper(YAMLSyntaxError);\n\n  function YAMLSyntaxError(source, message) {\n    _classCallCheck(this, YAMLSyntaxError);\n\n    return _super4.call(this, 'YAMLSyntaxError', source, message);\n  }\n\n  return YAMLSyntaxError;\n}(YAMLError);\n\nvar YAMLWarning = /*#__PURE__*/function (_YAMLError4) {\n  _inherits(YAMLWarning, _YAMLError4);\n\n  var _super5 = _createSuper(YAMLWarning);\n\n  function YAMLWarning(source, message) {\n    _classCallCheck(this, YAMLWarning);\n\n    return _super5.call(this, 'YAMLWarning', source, message);\n  }\n\n  return YAMLWarning;\n}(YAMLError);\n\nvar PlainValue = /*#__PURE__*/function (_Node) {\n  _inherits(PlainValue, _Node);\n\n  var _super = _createSuper(PlainValue);\n\n  function PlainValue() {\n    _classCallCheck(this, PlainValue);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(PlainValue, [{\n    key: \"strValue\",\n    get: function get() {\n      if (!this.valueRange || !this.context) return null;\n      var _this$valueRange = this.valueRange,\n          start = _this$valueRange.start,\n          end = _this$valueRange.end;\n      var src = this.context.src;\n      var ch = src[end - 1];\n\n      while (start < end && (ch === '\\n' || ch === '\\t' || ch === ' ')) {\n        ch = src[--end - 1];\n      }\n\n      var str = '';\n\n      for (var i = start; i < end; ++i) {\n        var _ch = src[i];\n\n        if (_ch === '\\n') {\n          var _Node$foldNewline = Node.foldNewline(src, i, -1),\n              fold = _Node$foldNewline.fold,\n              offset = _Node$foldNewline.offset;\n\n          str += fold;\n          i = offset;\n        } else if (_ch === ' ' || _ch === '\\t') {\n          // trim trailing whitespace\n          var wsStart = i;\n          var next = src[i + 1];\n\n          while (i < end && (next === ' ' || next === '\\t')) {\n            i += 1;\n            next = src[i + 1];\n          }\n\n          if (next !== '\\n') str += i > wsStart ? src.slice(wsStart, i + 1) : _ch;\n        } else {\n          str += _ch;\n        }\n      }\n\n      var ch0 = src[start];\n\n      switch (ch0) {\n        case '\\t':\n          {\n            var msg = 'Plain value cannot start with a tab character';\n            var errors = [new YAMLSemanticError(this, msg)];\n            return {\n              errors: errors,\n              str: str\n            };\n          }\n\n        case '@':\n        case '`':\n          {\n            var _msg = \"Plain value cannot start with reserved character \".concat(ch0);\n\n            var _errors = [new YAMLSemanticError(this, _msg)];\n            return {\n              errors: _errors,\n              str: str\n            };\n          }\n\n        default:\n          return str;\n      }\n    }\n  }, {\n    key: \"parseBlockValue\",\n    value: function parseBlockValue(start) {\n      var _this$context = this.context,\n          indent = _this$context.indent,\n          inFlow = _this$context.inFlow,\n          src = _this$context.src;\n      var offset = start;\n      var valueEnd = start;\n\n      for (var ch = src[offset]; ch === '\\n'; ch = src[offset]) {\n        if (Node.atDocumentBoundary(src, offset + 1)) break;\n        var end = Node.endOfBlockIndent(src, indent, offset + 1);\n        if (end === null || src[end] === '#') break;\n\n        if (src[end] === '\\n') {\n          offset = end;\n        } else {\n          valueEnd = PlainValue.endOfLine(src, end, inFlow);\n          offset = valueEnd;\n        }\n      }\n\n      if (this.valueRange.isEmpty()) this.valueRange.start = start;\n      this.valueRange.end = valueEnd;\n      return valueEnd;\n    }\n    /**\n     * Parses a plain value from the source\n     *\n     * Accepted forms are:\n     * ```\n     * #comment\n     *\n     * first line\n     *\n     * first line #comment\n     *\n     * first line\n     * block\n     * lines\n     *\n     * #comment\n     * block\n     * lines\n     * ```\n     * where block lines are empty or have an indent level greater than `indent`.\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this scalar, may be `\\n`\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var inFlow = context.inFlow,\n          src = context.src;\n      var offset = start;\n      var ch = src[offset];\n\n      if (ch && ch !== '#' && ch !== '\\n') {\n        offset = PlainValue.endOfLine(src, start, inFlow);\n      }\n\n      this.valueRange = new Range(start, offset);\n      offset = Node.endOfWhiteSpace(src, offset);\n      offset = this.parseComment(offset);\n\n      if (!this.hasComment || this.valueRange.isEmpty()) {\n        offset = this.parseBlockValue(offset);\n      }\n\n      return offset;\n    }\n  }], [{\n    key: \"endOfLine\",\n    value: function endOfLine(src, start, inFlow) {\n      var ch = src[start];\n      var offset = start;\n\n      while (ch && ch !== '\\n') {\n        if (inFlow && (ch === '[' || ch === ']' || ch === '{' || ch === '}' || ch === ',')) break;\n        var next = src[offset + 1];\n        if (ch === ':' && (!next || next === '\\n' || next === '\\t' || next === ' ' || inFlow && next === ',')) break;\n        if ((ch === ' ' || ch === '\\t') && next === '#') break;\n        offset += 1;\n        ch = next;\n      }\n\n      return offset;\n    }\n  }]);\n\n  return PlainValue;\n}(Node);\n\nexport { Char as C, Node as N, PlainValue as P, Range as R, Type as T, YAMLSyntaxError as Y, _createForOfIteratorHelper as _, _typeof as a, _createClass as b, _classCallCheck as c, defaultTagPrefix as d, _defineProperty as e, YAMLWarning as f, YAMLSemanticError as g, _slicedToArray as h, YAMLError as i, _inherits as j, _createSuper as k, _get as l, _getPrototypeOf as m, defaultTags as n, YAMLReferenceError as o, _assertThisInitialized as p, _toArray as q, _possibleConstructorReturn as r };","map":{"version":3,"sources":["/home/dev/Documentos/Projects/github-clone/node_modules/yaml/browser/dist/PlainValue-b8036b75.js"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","_defineProperty","value","_inherits","subClass","superClass","create","_setPrototypeOf","_getPrototypeOf","o","setPrototypeOf","getPrototypeOf","__proto__","p","_isNativeReflectConstruct","Reflect","construct","sham","Proxy","Boolean","valueOf","call","e","_construct","Parent","args","Class","a","push","apply","Function","bind","arguments","_isNativeFunction","fn","toString","indexOf","_wrapNativeSuper","_cache","Map","undefined","has","get","set","Wrapper","_assertThisInitialized","self","ReferenceError","_possibleConstructorReturn","_createSuper","Derived","hasNativeReflectConstruct","_createSuperInternal","Super","result","NewTarget","_superPropBase","object","property","hasOwnProperty","_get","receiver","base","desc","getOwnPropertyDescriptor","_slicedToArray","arr","_arrayWithHoles","_iterableToArrayLimit","_unsupportedIterableToArray","_nonIterableRest","_toArray","_iterableToArray","Array","isArray","iter","from","_arr","_n","_d","_e","_i","_s","next","done","err","minLen","_arrayLikeToArray","n","slice","name","test","len","arr2","_createForOfIteratorHelper","allowArrayLike","it","F","s","f","normalCompletion","didErr","step","return","Char","ANCHOR","COMMENT","TAG","DIRECTIVES_END","DOCUMENT_END","Type","ALIAS","BLANK_LINE","BLOCK_FOLDED","BLOCK_LITERAL","DIRECTIVE","DOCUMENT","FLOW_MAP","FLOW_SEQ","MAP","MAP_KEY","MAP_VALUE","PLAIN","QUOTE_DOUBLE","QUOTE_SINGLE","SEQ","SEQ_ITEM","defaultTagPrefix","defaultTags","STR","findLineStarts","src","ls","offset","getSrcInfo","cst","lineStarts","context","getLinePos","_getSrcInfo","start","line","col","getLine","_getSrcInfo2","end","getPrettyContext","_ref","maxWidth","substr","halfWidth","Math","round","errLen","errEnd","min","repeat","concat","Range","isEmpty","setOrigRange","cr","origStart","origEnd","nextOffset","copy","orig","Node","type","error","range","valueRange","getPropValue","idx","skipKey","prop","anchor","comments","comment","join","commentHasRequiredWhitespace","header","atBlank","jsonLikeTypes","root","_this$valueRange","tag","verbatim","_tag$match","match","_tag$match2","handle","suffix","_this$valueRange2","parseComment","endOfLine","commentRange","setOrigRanges","forEach","str","addStringTerminator","endOfWhiteSpace","atDocumentBoundary","sep","ch0","prev","ch1","ch2","ch3","endOfIdentifier","ch","isVerbatim","notOk","endOfIndent","startOfLine","endOfBlockIndent","indent","lineStart","inEnd","wsEnd","endAsBlank","nextNodeIsIndented","indentDiff","indicatorAsIndent","normalizeOffset","foldNewline","inCount","fold","YAMLError","_Error","_super","source","message","_this","Error","makePretty","nodeType","linePos","rangeAsLinePos","_this$linePos$start","ctx","YAMLReferenceError","_YAMLError","_super2","YAMLSemanticError","_YAMLError2","_super3","YAMLSyntaxError","_YAMLError3","_super4","YAMLWarning","_YAMLError4","_super5","PlainValue","_Node","_ch","_Node$foldNewline","wsStart","msg","errors","_msg","_errors","parseBlockValue","_this$context","inFlow","valueEnd","parse","hasComment","C","N","P","R","T","Y","_","b","c","d","g","h","j","k","l","m","q","r"],"mappings":"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","sourcesContent":["function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _construct(Parent, args, Class) {\n  if (_isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) _setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}\n\nfunction _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\n\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !_isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return _setPrototypeOf(Wrapper, Class);\n  };\n\n  return _wrapNativeSuper(Class);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nfunction _get(target, property, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get(target, property, receiver || target);\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _toArray(arr) {\n  return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function () {};\n\n      return {\n        s: F,\n        n: function () {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function (e) {\n          throw e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function () {\n      it = o[Symbol.iterator]();\n    },\n    n: function () {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function (e) {\n      didErr = true;\n      err = e;\n    },\n    f: function () {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nvar Char = {\n  ANCHOR: '&',\n  COMMENT: '#',\n  TAG: '!',\n  DIRECTIVES_END: '-',\n  DOCUMENT_END: '.'\n};\nvar Type = {\n  ALIAS: 'ALIAS',\n  BLANK_LINE: 'BLANK_LINE',\n  BLOCK_FOLDED: 'BLOCK_FOLDED',\n  BLOCK_LITERAL: 'BLOCK_LITERAL',\n  COMMENT: 'COMMENT',\n  DIRECTIVE: 'DIRECTIVE',\n  DOCUMENT: 'DOCUMENT',\n  FLOW_MAP: 'FLOW_MAP',\n  FLOW_SEQ: 'FLOW_SEQ',\n  MAP: 'MAP',\n  MAP_KEY: 'MAP_KEY',\n  MAP_VALUE: 'MAP_VALUE',\n  PLAIN: 'PLAIN',\n  QUOTE_DOUBLE: 'QUOTE_DOUBLE',\n  QUOTE_SINGLE: 'QUOTE_SINGLE',\n  SEQ: 'SEQ',\n  SEQ_ITEM: 'SEQ_ITEM'\n};\nvar defaultTagPrefix = 'tag:yaml.org,2002:';\nvar defaultTags = {\n  MAP: 'tag:yaml.org,2002:map',\n  SEQ: 'tag:yaml.org,2002:seq',\n  STR: 'tag:yaml.org,2002:str'\n};\n\nfunction findLineStarts(src) {\n  var ls = [0];\n  var offset = src.indexOf('\\n');\n\n  while (offset !== -1) {\n    offset += 1;\n    ls.push(offset);\n    offset = src.indexOf('\\n', offset);\n  }\n\n  return ls;\n}\n\nfunction getSrcInfo(cst) {\n  var lineStarts, src;\n\n  if (typeof cst === 'string') {\n    lineStarts = findLineStarts(cst);\n    src = cst;\n  } else {\n    if (Array.isArray(cst)) cst = cst[0];\n\n    if (cst && cst.context) {\n      if (!cst.lineStarts) cst.lineStarts = findLineStarts(cst.context.src);\n      lineStarts = cst.lineStarts;\n      src = cst.context.src;\n    }\n  }\n\n  return {\n    lineStarts: lineStarts,\n    src: src\n  };\n}\n/**\n * @typedef {Object} LinePos - One-indexed position in the source\n * @property {number} line\n * @property {number} col\n */\n\n/**\n * Determine the line/col position matching a character offset.\n *\n * Accepts a source string or a CST document as the second parameter. With\n * the latter, starting indices for lines are cached in the document as\n * `lineStarts: number[]`.\n *\n * Returns a one-indexed `{ line, col }` location if found, or\n * `undefined` otherwise.\n *\n * @param {number} offset\n * @param {string|Document|Document[]} cst\n * @returns {?LinePos}\n */\n\n\nfunction getLinePos(offset, cst) {\n  if (typeof offset !== 'number' || offset < 0) return null;\n\n  var _getSrcInfo = getSrcInfo(cst),\n      lineStarts = _getSrcInfo.lineStarts,\n      src = _getSrcInfo.src;\n\n  if (!lineStarts || !src || offset > src.length) return null;\n\n  for (var i = 0; i < lineStarts.length; ++i) {\n    var start = lineStarts[i];\n\n    if (offset < start) {\n      return {\n        line: i,\n        col: offset - lineStarts[i - 1] + 1\n      };\n    }\n\n    if (offset === start) return {\n      line: i + 1,\n      col: 1\n    };\n  }\n\n  var line = lineStarts.length;\n  return {\n    line: line,\n    col: offset - lineStarts[line - 1] + 1\n  };\n}\n/**\n * Get a specified line from the source.\n *\n * Accepts a source string or a CST document as the second parameter. With\n * the latter, starting indices for lines are cached in the document as\n * `lineStarts: number[]`.\n *\n * Returns the line as a string if found, or `null` otherwise.\n *\n * @param {number} line One-indexed line number\n * @param {string|Document|Document[]} cst\n * @returns {?string}\n */\n\nfunction getLine(line, cst) {\n  var _getSrcInfo2 = getSrcInfo(cst),\n      lineStarts = _getSrcInfo2.lineStarts,\n      src = _getSrcInfo2.src;\n\n  if (!lineStarts || !(line >= 1) || line > lineStarts.length) return null;\n  var start = lineStarts[line - 1];\n  var end = lineStarts[line]; // undefined for last line; that's ok for slice()\n\n  while (end && end > start && src[end - 1] === '\\n') {\n    --end;\n  }\n\n  return src.slice(start, end);\n}\n/**\n * Pretty-print the starting line from the source indicated by the range `pos`\n *\n * Trims output to `maxWidth` chars while keeping the starting column visible,\n * using `…` at either end to indicate dropped characters.\n *\n * Returns a two-line string (or `null`) with `\\n` as separator; the second line\n * will hold appropriately indented `^` marks indicating the column range.\n *\n * @param {Object} pos\n * @param {LinePos} pos.start\n * @param {LinePos} [pos.end]\n * @param {string|Document|Document[]*} cst\n * @param {number} [maxWidth=80]\n * @returns {?string}\n */\n\nfunction getPrettyContext(_ref, cst) {\n  var start = _ref.start,\n      end = _ref.end;\n  var maxWidth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 80;\n  var src = getLine(start.line, cst);\n  if (!src) return null;\n  var col = start.col;\n\n  if (src.length > maxWidth) {\n    if (col <= maxWidth - 10) {\n      src = src.substr(0, maxWidth - 1) + '…';\n    } else {\n      var halfWidth = Math.round(maxWidth / 2);\n      if (src.length > col + halfWidth) src = src.substr(0, col + halfWidth - 1) + '…';\n      col -= src.length - maxWidth;\n      src = '…' + src.substr(1 - maxWidth);\n    }\n  }\n\n  var errLen = 1;\n  var errEnd = '';\n\n  if (end) {\n    if (end.line === start.line && col + (end.col - start.col) <= maxWidth + 1) {\n      errLen = end.col - start.col;\n    } else {\n      errLen = Math.min(src.length + 1, maxWidth) - col;\n      errEnd = '…';\n    }\n  }\n\n  var offset = col > 1 ? ' '.repeat(col - 1) : '';\n  var err = '^'.repeat(errLen);\n  return \"\".concat(src, \"\\n\").concat(offset).concat(err).concat(errEnd);\n}\n\nvar Range = /*#__PURE__*/function () {\n  function Range(start, end) {\n    _classCallCheck(this, Range);\n\n    this.start = start;\n    this.end = end || start;\n  }\n\n  _createClass(Range, [{\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return typeof this.start !== 'number' || !this.end || this.end <= this.start;\n    }\n    /**\n     * Set `origStart` and `origEnd` to point to the original source range for\n     * this node, which may differ due to dropped CR characters.\n     *\n     * @param {number[]} cr - Positions of dropped CR characters\n     * @param {number} offset - Starting index of `cr` from the last call\n     * @returns {number} - The next offset, matching the one found for `origStart`\n     */\n\n  }, {\n    key: \"setOrigRange\",\n    value: function setOrigRange(cr, offset) {\n      var start = this.start,\n          end = this.end;\n\n      if (cr.length === 0 || end <= cr[0]) {\n        this.origStart = start;\n        this.origEnd = end;\n        return offset;\n      }\n\n      var i = offset;\n\n      while (i < cr.length) {\n        if (cr[i] > start) break;else ++i;\n      }\n\n      this.origStart = start + i;\n      var nextOffset = i;\n\n      while (i < cr.length) {\n        // if end was at \\n, it should now be at \\r\n        if (cr[i] >= end) break;else ++i;\n      }\n\n      this.origEnd = end + i;\n      return nextOffset;\n    }\n  }], [{\n    key: \"copy\",\n    value: function copy(orig) {\n      return new Range(orig.start, orig.end);\n    }\n  }]);\n\n  return Range;\n}();\n\n/** Root class of all nodes */\n\nvar Node = /*#__PURE__*/function () {\n  function Node(type, props, context) {\n    _classCallCheck(this, Node);\n\n    Object.defineProperty(this, 'context', {\n      value: context || null,\n      writable: true\n    });\n    this.error = null;\n    this.range = null;\n    this.valueRange = null;\n    this.props = props || [];\n    this.type = type;\n    this.value = null;\n  }\n\n  _createClass(Node, [{\n    key: \"getPropValue\",\n    value: function getPropValue(idx, key, skipKey) {\n      if (!this.context) return null;\n      var src = this.context.src;\n      var prop = this.props[idx];\n      return prop && src[prop.start] === key ? src.slice(prop.start + (skipKey ? 1 : 0), prop.end) : null;\n    }\n  }, {\n    key: \"anchor\",\n    get: function get() {\n      for (var i = 0; i < this.props.length; ++i) {\n        var anchor = this.getPropValue(i, Char.ANCHOR, true);\n        if (anchor != null) return anchor;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"comment\",\n    get: function get() {\n      var comments = [];\n\n      for (var i = 0; i < this.props.length; ++i) {\n        var comment = this.getPropValue(i, Char.COMMENT, true);\n        if (comment != null) comments.push(comment);\n      }\n\n      return comments.length > 0 ? comments.join('\\n') : null;\n    }\n  }, {\n    key: \"commentHasRequiredWhitespace\",\n    value: function commentHasRequiredWhitespace(start) {\n      var src = this.context.src;\n      if (this.header && start === this.header.end) return false;\n      if (!this.valueRange) return false;\n      var end = this.valueRange.end;\n      return start !== end || Node.atBlank(src, end - 1);\n    }\n  }, {\n    key: \"hasComment\",\n    get: function get() {\n      if (this.context) {\n        var src = this.context.src;\n\n        for (var i = 0; i < this.props.length; ++i) {\n          if (src[this.props[i].start] === Char.COMMENT) return true;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"hasProps\",\n    get: function get() {\n      if (this.context) {\n        var src = this.context.src;\n\n        for (var i = 0; i < this.props.length; ++i) {\n          if (src[this.props[i].start] !== Char.COMMENT) return true;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"includesTrailingLines\",\n    get: function get() {\n      return false;\n    }\n  }, {\n    key: \"jsonLike\",\n    get: function get() {\n      var jsonLikeTypes = [Type.FLOW_MAP, Type.FLOW_SEQ, Type.QUOTE_DOUBLE, Type.QUOTE_SINGLE];\n      return jsonLikeTypes.indexOf(this.type) !== -1;\n    }\n  }, {\n    key: \"rangeAsLinePos\",\n    get: function get() {\n      if (!this.range || !this.context) return undefined;\n      var start = getLinePos(this.range.start, this.context.root);\n      if (!start) return undefined;\n      var end = getLinePos(this.range.end, this.context.root);\n      return {\n        start: start,\n        end: end\n      };\n    }\n  }, {\n    key: \"rawValue\",\n    get: function get() {\n      if (!this.valueRange || !this.context) return null;\n      var _this$valueRange = this.valueRange,\n          start = _this$valueRange.start,\n          end = _this$valueRange.end;\n      return this.context.src.slice(start, end);\n    }\n  }, {\n    key: \"tag\",\n    get: function get() {\n      for (var i = 0; i < this.props.length; ++i) {\n        var tag = this.getPropValue(i, Char.TAG, false);\n\n        if (tag != null) {\n          if (tag[1] === '<') {\n            return {\n              verbatim: tag.slice(2, -1)\n            };\n          } else {\n            // eslint-disable-next-line no-unused-vars\n            var _tag$match = tag.match(/^(.*!)([^!]*)$/),\n                _tag$match2 = _slicedToArray(_tag$match, 3);\n                _tag$match2[0];\n                var handle = _tag$match2[1],\n                suffix = _tag$match2[2];\n\n            return {\n              handle: handle,\n              suffix: suffix\n            };\n          }\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"valueRangeContainsNewline\",\n    get: function get() {\n      if (!this.valueRange || !this.context) return false;\n      var _this$valueRange2 = this.valueRange,\n          start = _this$valueRange2.start,\n          end = _this$valueRange2.end;\n      var src = this.context.src;\n\n      for (var i = start; i < end; ++i) {\n        if (src[i] === '\\n') return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"parseComment\",\n    value: function parseComment(start) {\n      var src = this.context.src;\n\n      if (src[start] === Char.COMMENT) {\n        var end = Node.endOfLine(src, start + 1);\n        var commentRange = new Range(start, end);\n        this.props.push(commentRange);\n        return end;\n      }\n\n      return start;\n    }\n    /**\n     * Populates the `origStart` and `origEnd` values of all ranges for this\n     * node. Extended by child classes to handle descendant nodes.\n     *\n     * @param {number[]} cr - Positions of dropped CR characters\n     * @param {number} offset - Starting index of `cr` from the last call\n     * @returns {number} - The next offset, matching the one found for `origStart`\n     */\n\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      if (this.range) offset = this.range.setOrigRange(cr, offset);\n      if (this.valueRange) this.valueRange.setOrigRange(cr, offset);\n      this.props.forEach(function (prop) {\n        return prop.setOrigRange(cr, offset);\n      });\n      return offset;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var src = this.context.src,\n          range = this.range,\n          value = this.value;\n      if (value != null) return value;\n      var str = src.slice(range.start, range.end);\n      return Node.addStringTerminator(src, range.end, str);\n    }\n  }], [{\n    key: \"addStringTerminator\",\n    value: function addStringTerminator(src, offset, str) {\n      if (str[str.length - 1] === '\\n') return str;\n      var next = Node.endOfWhiteSpace(src, offset);\n      return next >= src.length || src[next] === '\\n' ? str + '\\n' : str;\n    } // ^(---|...)\n\n  }, {\n    key: \"atDocumentBoundary\",\n    value: function atDocumentBoundary(src, offset, sep) {\n      var ch0 = src[offset];\n      if (!ch0) return true;\n      var prev = src[offset - 1];\n      if (prev && prev !== '\\n') return false;\n\n      if (sep) {\n        if (ch0 !== sep) return false;\n      } else {\n        if (ch0 !== Char.DIRECTIVES_END && ch0 !== Char.DOCUMENT_END) return false;\n      }\n\n      var ch1 = src[offset + 1];\n      var ch2 = src[offset + 2];\n      if (ch1 !== ch0 || ch2 !== ch0) return false;\n      var ch3 = src[offset + 3];\n      return !ch3 || ch3 === '\\n' || ch3 === '\\t' || ch3 === ' ';\n    }\n  }, {\n    key: \"endOfIdentifier\",\n    value: function endOfIdentifier(src, offset) {\n      var ch = src[offset];\n      var isVerbatim = ch === '<';\n      var notOk = isVerbatim ? ['\\n', '\\t', ' ', '>'] : ['\\n', '\\t', ' ', '[', ']', '{', '}', ','];\n\n      while (ch && notOk.indexOf(ch) === -1) {\n        ch = src[offset += 1];\n      }\n\n      if (isVerbatim && ch === '>') offset += 1;\n      return offset;\n    }\n  }, {\n    key: \"endOfIndent\",\n    value: function endOfIndent(src, offset) {\n      var ch = src[offset];\n\n      while (ch === ' ') {\n        ch = src[offset += 1];\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"endOfLine\",\n    value: function endOfLine(src, offset) {\n      var ch = src[offset];\n\n      while (ch && ch !== '\\n') {\n        ch = src[offset += 1];\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"endOfWhiteSpace\",\n    value: function endOfWhiteSpace(src, offset) {\n      var ch = src[offset];\n\n      while (ch === '\\t' || ch === ' ') {\n        ch = src[offset += 1];\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"startOfLine\",\n    value: function startOfLine(src, offset) {\n      var ch = src[offset - 1];\n      if (ch === '\\n') return offset;\n\n      while (ch && ch !== '\\n') {\n        ch = src[offset -= 1];\n      }\n\n      return offset + 1;\n    }\n    /**\n     * End of indentation, or null if the line's indent level is not more\n     * than `indent`\n     *\n     * @param {string} src\n     * @param {number} indent\n     * @param {number} lineStart\n     * @returns {?number}\n     */\n\n  }, {\n    key: \"endOfBlockIndent\",\n    value: function endOfBlockIndent(src, indent, lineStart) {\n      var inEnd = Node.endOfIndent(src, lineStart);\n\n      if (inEnd > lineStart + indent) {\n        return inEnd;\n      } else {\n        var wsEnd = Node.endOfWhiteSpace(src, inEnd);\n        var ch = src[wsEnd];\n        if (!ch || ch === '\\n') return wsEnd;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"atBlank\",\n    value: function atBlank(src, offset, endAsBlank) {\n      var ch = src[offset];\n      return ch === '\\n' || ch === '\\t' || ch === ' ' || endAsBlank && !ch;\n    }\n  }, {\n    key: \"nextNodeIsIndented\",\n    value: function nextNodeIsIndented(ch, indentDiff, indicatorAsIndent) {\n      if (!ch || indentDiff < 0) return false;\n      if (indentDiff > 0) return true;\n      return indicatorAsIndent && ch === '-';\n    } // should be at line or string end, or at next non-whitespace char\n\n  }, {\n    key: \"normalizeOffset\",\n    value: function normalizeOffset(src, offset) {\n      var ch = src[offset];\n      return !ch ? offset : ch !== '\\n' && src[offset - 1] === '\\n' ? offset - 1 : Node.endOfWhiteSpace(src, offset);\n    } // fold single newline into space, multiple newlines to N - 1 newlines\n    // presumes src[offset] === '\\n'\n\n  }, {\n    key: \"foldNewline\",\n    value: function foldNewline(src, offset, indent) {\n      var inCount = 0;\n      var error = false;\n      var fold = '';\n      var ch = src[offset + 1];\n\n      while (ch === ' ' || ch === '\\t' || ch === '\\n') {\n        switch (ch) {\n          case '\\n':\n            inCount = 0;\n            offset += 1;\n            fold += '\\n';\n            break;\n\n          case '\\t':\n            if (inCount <= indent) error = true;\n            offset = Node.endOfWhiteSpace(src, offset + 2) - 1;\n            break;\n\n          case ' ':\n            inCount += 1;\n            offset += 1;\n            break;\n        }\n\n        ch = src[offset + 1];\n      }\n\n      if (!fold) fold = ' ';\n      if (ch && inCount <= indent) error = true;\n      return {\n        fold: fold,\n        offset: offset,\n        error: error\n      };\n    }\n  }]);\n\n  return Node;\n}();\n\nvar YAMLError = /*#__PURE__*/function (_Error) {\n  _inherits(YAMLError, _Error);\n\n  var _super = _createSuper(YAMLError);\n\n  function YAMLError(name, source, message) {\n    var _this;\n\n    _classCallCheck(this, YAMLError);\n\n    if (!message || !(source instanceof Node)) throw new Error(\"Invalid arguments for new \".concat(name));\n    _this = _super.call(this);\n    _this.name = name;\n    _this.message = message;\n    _this.source = source;\n    return _this;\n  }\n\n  _createClass(YAMLError, [{\n    key: \"makePretty\",\n    value: function makePretty() {\n      if (!this.source) return;\n      this.nodeType = this.source.type;\n      var cst = this.source.context && this.source.context.root;\n\n      if (typeof this.offset === 'number') {\n        this.range = new Range(this.offset, this.offset + 1);\n        var start = cst && getLinePos(this.offset, cst);\n\n        if (start) {\n          var end = {\n            line: start.line,\n            col: start.col + 1\n          };\n          this.linePos = {\n            start: start,\n            end: end\n          };\n        }\n\n        delete this.offset;\n      } else {\n        this.range = this.source.range;\n        this.linePos = this.source.rangeAsLinePos;\n      }\n\n      if (this.linePos) {\n        var _this$linePos$start = this.linePos.start,\n            line = _this$linePos$start.line,\n            col = _this$linePos$start.col;\n        this.message += \" at line \".concat(line, \", column \").concat(col);\n        var ctx = cst && getPrettyContext(this.linePos, cst);\n        if (ctx) this.message += \":\\n\\n\".concat(ctx, \"\\n\");\n      }\n\n      delete this.source;\n    }\n  }]);\n\n  return YAMLError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\nvar YAMLReferenceError = /*#__PURE__*/function (_YAMLError) {\n  _inherits(YAMLReferenceError, _YAMLError);\n\n  var _super2 = _createSuper(YAMLReferenceError);\n\n  function YAMLReferenceError(source, message) {\n    _classCallCheck(this, YAMLReferenceError);\n\n    return _super2.call(this, 'YAMLReferenceError', source, message);\n  }\n\n  return YAMLReferenceError;\n}(YAMLError);\nvar YAMLSemanticError = /*#__PURE__*/function (_YAMLError2) {\n  _inherits(YAMLSemanticError, _YAMLError2);\n\n  var _super3 = _createSuper(YAMLSemanticError);\n\n  function YAMLSemanticError(source, message) {\n    _classCallCheck(this, YAMLSemanticError);\n\n    return _super3.call(this, 'YAMLSemanticError', source, message);\n  }\n\n  return YAMLSemanticError;\n}(YAMLError);\nvar YAMLSyntaxError = /*#__PURE__*/function (_YAMLError3) {\n  _inherits(YAMLSyntaxError, _YAMLError3);\n\n  var _super4 = _createSuper(YAMLSyntaxError);\n\n  function YAMLSyntaxError(source, message) {\n    _classCallCheck(this, YAMLSyntaxError);\n\n    return _super4.call(this, 'YAMLSyntaxError', source, message);\n  }\n\n  return YAMLSyntaxError;\n}(YAMLError);\nvar YAMLWarning = /*#__PURE__*/function (_YAMLError4) {\n  _inherits(YAMLWarning, _YAMLError4);\n\n  var _super5 = _createSuper(YAMLWarning);\n\n  function YAMLWarning(source, message) {\n    _classCallCheck(this, YAMLWarning);\n\n    return _super5.call(this, 'YAMLWarning', source, message);\n  }\n\n  return YAMLWarning;\n}(YAMLError);\n\nvar PlainValue = /*#__PURE__*/function (_Node) {\n  _inherits(PlainValue, _Node);\n\n  var _super = _createSuper(PlainValue);\n\n  function PlainValue() {\n    _classCallCheck(this, PlainValue);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(PlainValue, [{\n    key: \"strValue\",\n    get: function get() {\n      if (!this.valueRange || !this.context) return null;\n      var _this$valueRange = this.valueRange,\n          start = _this$valueRange.start,\n          end = _this$valueRange.end;\n      var src = this.context.src;\n      var ch = src[end - 1];\n\n      while (start < end && (ch === '\\n' || ch === '\\t' || ch === ' ')) {\n        ch = src[--end - 1];\n      }\n\n      var str = '';\n\n      for (var i = start; i < end; ++i) {\n        var _ch = src[i];\n\n        if (_ch === '\\n') {\n          var _Node$foldNewline = Node.foldNewline(src, i, -1),\n              fold = _Node$foldNewline.fold,\n              offset = _Node$foldNewline.offset;\n\n          str += fold;\n          i = offset;\n        } else if (_ch === ' ' || _ch === '\\t') {\n          // trim trailing whitespace\n          var wsStart = i;\n          var next = src[i + 1];\n\n          while (i < end && (next === ' ' || next === '\\t')) {\n            i += 1;\n            next = src[i + 1];\n          }\n\n          if (next !== '\\n') str += i > wsStart ? src.slice(wsStart, i + 1) : _ch;\n        } else {\n          str += _ch;\n        }\n      }\n\n      var ch0 = src[start];\n\n      switch (ch0) {\n        case '\\t':\n          {\n            var msg = 'Plain value cannot start with a tab character';\n            var errors = [new YAMLSemanticError(this, msg)];\n            return {\n              errors: errors,\n              str: str\n            };\n          }\n\n        case '@':\n        case '`':\n          {\n            var _msg = \"Plain value cannot start with reserved character \".concat(ch0);\n\n            var _errors = [new YAMLSemanticError(this, _msg)];\n            return {\n              errors: _errors,\n              str: str\n            };\n          }\n\n        default:\n          return str;\n      }\n    }\n  }, {\n    key: \"parseBlockValue\",\n    value: function parseBlockValue(start) {\n      var _this$context = this.context,\n          indent = _this$context.indent,\n          inFlow = _this$context.inFlow,\n          src = _this$context.src;\n      var offset = start;\n      var valueEnd = start;\n\n      for (var ch = src[offset]; ch === '\\n'; ch = src[offset]) {\n        if (Node.atDocumentBoundary(src, offset + 1)) break;\n        var end = Node.endOfBlockIndent(src, indent, offset + 1);\n        if (end === null || src[end] === '#') break;\n\n        if (src[end] === '\\n') {\n          offset = end;\n        } else {\n          valueEnd = PlainValue.endOfLine(src, end, inFlow);\n          offset = valueEnd;\n        }\n      }\n\n      if (this.valueRange.isEmpty()) this.valueRange.start = start;\n      this.valueRange.end = valueEnd;\n      return valueEnd;\n    }\n    /**\n     * Parses a plain value from the source\n     *\n     * Accepted forms are:\n     * ```\n     * #comment\n     *\n     * first line\n     *\n     * first line #comment\n     *\n     * first line\n     * block\n     * lines\n     *\n     * #comment\n     * block\n     * lines\n     * ```\n     * where block lines are empty or have an indent level greater than `indent`.\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this scalar, may be `\\n`\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var inFlow = context.inFlow,\n          src = context.src;\n      var offset = start;\n      var ch = src[offset];\n\n      if (ch && ch !== '#' && ch !== '\\n') {\n        offset = PlainValue.endOfLine(src, start, inFlow);\n      }\n\n      this.valueRange = new Range(start, offset);\n      offset = Node.endOfWhiteSpace(src, offset);\n      offset = this.parseComment(offset);\n\n      if (!this.hasComment || this.valueRange.isEmpty()) {\n        offset = this.parseBlockValue(offset);\n      }\n\n      return offset;\n    }\n  }], [{\n    key: \"endOfLine\",\n    value: function endOfLine(src, start, inFlow) {\n      var ch = src[start];\n      var offset = start;\n\n      while (ch && ch !== '\\n') {\n        if (inFlow && (ch === '[' || ch === ']' || ch === '{' || ch === '}' || ch === ',')) break;\n        var next = src[offset + 1];\n        if (ch === ':' && (!next || next === '\\n' || next === '\\t' || next === ' ' || inFlow && next === ',')) break;\n        if ((ch === ' ' || ch === '\\t') && next === '#') break;\n        offset += 1;\n        ch = next;\n      }\n\n      return offset;\n    }\n  }]);\n\n  return PlainValue;\n}(Node);\n\nexport { Char as C, Node as N, PlainValue as P, Range as R, Type as T, YAMLSyntaxError as Y, _createForOfIteratorHelper as _, _typeof as a, _createClass as b, _classCallCheck as c, defaultTagPrefix as d, _defineProperty as e, YAMLWarning as f, YAMLSemanticError as g, _slicedToArray as h, YAMLError as i, _inherits as j, _createSuper as k, _get as l, _getPrototypeOf as m, defaultTags as n, YAMLReferenceError as o, _assertThisInitialized as p, _toArray as q, _possibleConstructorReturn as r };\n"]},"metadata":{},"sourceType":"module"}