{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Uploader = void 0;\n\nconst lodash_1 = require(\"lodash\");\n\nconst abort_controller_1 = require(\"abort-controller\");\n\nconst clc = require(\"cli-color\");\n\nconst crypto = require(\"crypto\");\n\nconst fs = require(\"fs\");\n\nconst path = require(\"path\");\n\nconst zlib = require(\"zlib\");\n\nconst apiv2_1 = require(\"../../apiv2\");\n\nconst queue_1 = require(\"../../throttler/queue\");\n\nconst api_1 = require(\"../../api\");\n\nconst hashcache = require(\"./hashcache\");\n\nconst logger_1 = require(\"../../logger\");\n\nconst error_1 = require(\"../../error\");\n\nconst MIN_UPLOAD_TIMEOUT = 30000;\nconst MAX_UPLOAD_TIMEOUT = 7200000;\n\nfunction progressMessage(message, current, total) {\n  current = Math.min(current, total);\n  const percent = Math.floor(current * 1.0 / total * 100).toString();\n  return `${message} [${current}/${total}] (${clc.bold.green(`${percent}%`)})`;\n}\n\nclass Uploader {\n  constructor(options) {\n    this.hashClient = new apiv2_1.Client({\n      urlPrefix: api_1.hostingApiOrigin,\n      auth: true,\n      apiVersion: \"v1beta1\"\n    });\n    this.version = options.version;\n    this.cwd = options.cwd || process.cwd();\n    this.projectRoot = options.projectRoot;\n    this.gzipLevel = options.gzipLevel || 9;\n    this.hashQueue = new queue_1.Queue({\n      name: \"hashQueue\",\n      concurrency: options.hashConcurrency || 50,\n      handler: this.hashHandler.bind(this)\n    });\n    this.populateBatchSize = options.populateBatchSize || 1000;\n    this.populateBatch = {};\n    this.populateQueue = new queue_1.Queue({\n      name: \"populateQueue\",\n      concurrency: options.populateConcurrency || 10,\n      handler: this.populateHandler.bind(this),\n      retries: 3\n    });\n    this.uploadQueue = new queue_1.Queue({\n      name: \"uploadQueue\",\n      concurrency: options.uploadConcurrency || 200,\n      handler: this.uploadHandler.bind(this),\n      retries: 5\n    });\n    this.public = options.public || this.cwd;\n    this.files = options.files;\n    this.fileCount = this.files.length;\n    this.cache = hashcache.load(this.projectRoot, this.hashcacheName());\n    this.cacheNew = new Map();\n    this.sizeMap = {};\n    this.hashMap = {};\n    this.pathMap = {};\n  }\n\n  hashcacheName() {\n    return Buffer.from(path.relative(this.projectRoot, this.public)).toString(\"base64\").replace(/=+$/, \"\");\n  }\n\n  async start() {\n    if (this.files.length === 0) {\n      return;\n    }\n\n    for (const f of this.files) {\n      this.hashQueue.add(f);\n    }\n\n    this.hashQueue.close();\n    this.hashQueue.process();\n    this.hashQueue.wait().then(this.queuePopulate.bind(this)).then(() => {\n      hashcache.dump(this.projectRoot, this.hashcacheName(), this.cacheNew);\n      logger_1.logger.debug(\"[hosting][hash queue][FINAL]\", this.hashQueue.stats());\n      this.populateQueue.close();\n      return this.populateQueue.wait();\n    }).then(() => {\n      logger_1.logger.debug(\"[hosting][populate queue][FINAL]\", this.populateQueue.stats());\n      logger_1.logger.debug(\"[hosting] uploads queued:\", this.uploadQueue.stats().total);\n      this.uploadQueue.close();\n    });\n    this.uploadQueue.wait().catch(err => {\n      if (err.message.includes(\"content hash\")) {\n        logger_1.logger.debug(\"[hosting][upload queue] upload failed with content hash error. Deleting hash cache\");\n        hashcache.dump(this.projectRoot, this.hashcacheName(), new Map());\n      }\n    });\n\n    const fin = err => {\n      logger_1.logger.debug(\"[hosting][upload queue][FINAL]\", this.uploadQueue.stats());\n\n      if (err) {\n        throw err;\n      }\n    };\n\n    return this.wait().then(fin).catch(fin);\n  }\n\n  async wait() {\n    await Promise.all([this.hashQueue.wait(), this.populateQueue.wait(), this.uploadQueue.wait()]);\n  }\n\n  statusMessage() {\n    if (!this.hashQueue.finished) {\n      return progressMessage(\"hashing files\", this.hashQueue.complete, this.fileCount);\n    } else if (!this.populateQueue.finished) {\n      return progressMessage(\"adding files to version\", this.populateQueue.complete * 1000, this.fileCount);\n    } else if (!this.uploadQueue.finished) {\n      return progressMessage(\"uploading new files\", this.uploadQueue.complete, this.uploadQueue.stats().total);\n    } else {\n      return \"upload complete\";\n    }\n  }\n\n  async hashHandler(filePath) {\n    const stats = fs.statSync(path.resolve(this.public, filePath));\n    const mtime = stats.mtime.getTime();\n    this.sizeMap[filePath] = stats.size;\n    const cached = this.cache[filePath];\n\n    if (cached && cached.mtime === mtime) {\n      this.cacheNew.set(filePath, cached);\n      this.addHash(filePath, cached.hash);\n      return;\n    }\n\n    const fstream = this.zipStream(filePath);\n    const hash = crypto.createHash(\"sha256\");\n    fstream.pipe(hash);\n    return new Promise((resolve, reject) => {\n      fstream.on(\"end\", resolve);\n      fstream.on(\"error\", reject);\n    }).then(() => {\n      const hashVal = hash.read().toString(\"hex\");\n      this.cacheNew.set(filePath, {\n        mtime: mtime,\n        hash: hashVal\n      });\n      this.addHash(filePath, hashVal);\n    });\n  }\n\n  addHash(filePath, hash) {\n    this.hashMap[hash] = filePath;\n    this.pathMap[filePath] = hash;\n    this.populateBatch[\"/\" + filePath] = hash;\n    const curBatchSize = lodash_1.size(this.populateBatch);\n\n    if (curBatchSize > 0 && curBatchSize % this.populateBatchSize === 0) {\n      this.queuePopulate();\n    }\n  }\n\n  queuePopulate() {\n    const pop = this.populateBatch;\n    this.populateQueue.add(pop);\n    this.populateBatch = {};\n    this.populateQueue.process();\n  }\n\n  async populateHandler(batch) {\n    const res = await this.hashClient.post(`/${this.version}:populateFiles`, {\n      files: batch\n    });\n    this.uploadUrl = res.body.uploadUrl;\n    this.uploadClient = new apiv2_1.Client({\n      urlPrefix: this.uploadUrl,\n      auth: true\n    });\n    this.addUploads(res.body.uploadRequiredHashes || []);\n  }\n\n  addUploads(hashes) {\n    for (const hash of hashes) {\n      this.uploadQueue.add(hash);\n    }\n\n    this.uploadQueue.process();\n  }\n\n  async uploadHandler(toUpload) {\n    if (!this.uploadClient) {\n      throw new error_1.FirebaseError(\"No upload client available.\", {\n        exit: 2\n      });\n    }\n\n    const controller = new abort_controller_1.default();\n    const timeout = setTimeout(() => {\n      controller.abort();\n    }, this.uploadTimeout(this.hashMap[toUpload]));\n    const res = await this.uploadClient.request({\n      method: \"POST\",\n      path: `/${toUpload}`,\n      body: this.zipStream(this.hashMap[toUpload]),\n      resolveOnHTTPError: true,\n      responseType: \"stream\",\n      signal: controller.signal\n    });\n    clearTimeout(timeout);\n\n    if (this.uploadQueue.cursor % 100 === 0) {\n      logger_1.logger.debug(\"[hosting][upload]\", this.uploadQueue.stats());\n    }\n\n    if (res.status !== 200) {\n      const errorMessage = await res.response.text();\n      logger_1.logger.debug(`[hosting][upload] ${this.hashMap[toUpload]} (${toUpload}) HTTP ERROR ${res.status}: headers=${JSON.stringify(res.response.headers)} ${errorMessage}`);\n      throw new Error(`Unexpected error while uploading file: ${errorMessage}`);\n    }\n  }\n\n  zipStream(filePath) {\n    const file = fs.createReadStream(path.resolve(this.public, filePath));\n    const gzip = zlib.createGzip({\n      level: this.gzipLevel\n    });\n    return file.pipe(gzip);\n  }\n\n  uploadTimeout(filePath) {\n    const size = this.sizeMap[filePath] || 0;\n    return Math.min(Math.max(Math.round(size / 1000) * 20, MIN_UPLOAD_TIMEOUT), MAX_UPLOAD_TIMEOUT);\n  }\n\n}\n\nexports.Uploader = Uploader;","map":{"version":3,"sources":["/home/dev/Documentos/Projects/github-clone/node_modules/firebase-tools/lib/deploy/hosting/uploader.js"],"names":["Object","defineProperty","exports","value","Uploader","lodash_1","require","abort_controller_1","clc","crypto","fs","path","zlib","apiv2_1","queue_1","api_1","hashcache","logger_1","error_1","MIN_UPLOAD_TIMEOUT","MAX_UPLOAD_TIMEOUT","progressMessage","message","current","total","Math","min","percent","floor","toString","bold","green","constructor","options","hashClient","Client","urlPrefix","hostingApiOrigin","auth","apiVersion","version","cwd","process","projectRoot","gzipLevel","hashQueue","Queue","name","concurrency","hashConcurrency","handler","hashHandler","bind","populateBatchSize","populateBatch","populateQueue","populateConcurrency","populateHandler","retries","uploadQueue","uploadConcurrency","uploadHandler","public","files","fileCount","length","cache","load","hashcacheName","cacheNew","Map","sizeMap","hashMap","pathMap","Buffer","from","relative","replace","start","f","add","close","wait","then","queuePopulate","dump","logger","debug","stats","catch","err","includes","fin","Promise","all","statusMessage","finished","complete","filePath","statSync","resolve","mtime","getTime","size","cached","set","addHash","hash","fstream","zipStream","createHash","pipe","reject","on","hashVal","read","curBatchSize","pop","batch","res","post","uploadUrl","body","uploadClient","addUploads","uploadRequiredHashes","hashes","toUpload","FirebaseError","exit","controller","default","timeout","setTimeout","abort","uploadTimeout","request","method","resolveOnHTTPError","responseType","signal","clearTimeout","cursor","status","errorMessage","response","text","JSON","stringify","headers","Error","file","createReadStream","gzip","createGzip","level","max","round"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Uploader = void 0;\nconst lodash_1 = require(\"lodash\");\nconst abort_controller_1 = require(\"abort-controller\");\nconst clc = require(\"cli-color\");\nconst crypto = require(\"crypto\");\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst zlib = require(\"zlib\");\nconst apiv2_1 = require(\"../../apiv2\");\nconst queue_1 = require(\"../../throttler/queue\");\nconst api_1 = require(\"../../api\");\nconst hashcache = require(\"./hashcache\");\nconst logger_1 = require(\"../../logger\");\nconst error_1 = require(\"../../error\");\nconst MIN_UPLOAD_TIMEOUT = 30000;\nconst MAX_UPLOAD_TIMEOUT = 7200000;\nfunction progressMessage(message, current, total) {\n    current = Math.min(current, total);\n    const percent = Math.floor(((current * 1.0) / total) * 100).toString();\n    return `${message} [${current}/${total}] (${clc.bold.green(`${percent}%`)})`;\n}\nclass Uploader {\n    constructor(options) {\n        this.hashClient = new apiv2_1.Client({\n            urlPrefix: api_1.hostingApiOrigin,\n            auth: true,\n            apiVersion: \"v1beta1\",\n        });\n        this.version = options.version;\n        this.cwd = options.cwd || process.cwd();\n        this.projectRoot = options.projectRoot;\n        this.gzipLevel = options.gzipLevel || 9;\n        this.hashQueue = new queue_1.Queue({\n            name: \"hashQueue\",\n            concurrency: options.hashConcurrency || 50,\n            handler: this.hashHandler.bind(this),\n        });\n        this.populateBatchSize = options.populateBatchSize || 1000;\n        this.populateBatch = {};\n        this.populateQueue = new queue_1.Queue({\n            name: \"populateQueue\",\n            concurrency: options.populateConcurrency || 10,\n            handler: this.populateHandler.bind(this),\n            retries: 3,\n        });\n        this.uploadQueue = new queue_1.Queue({\n            name: \"uploadQueue\",\n            concurrency: options.uploadConcurrency || 200,\n            handler: this.uploadHandler.bind(this),\n            retries: 5,\n        });\n        this.public = options.public || this.cwd;\n        this.files = options.files;\n        this.fileCount = this.files.length;\n        this.cache = hashcache.load(this.projectRoot, this.hashcacheName());\n        this.cacheNew = new Map();\n        this.sizeMap = {};\n        this.hashMap = {};\n        this.pathMap = {};\n    }\n    hashcacheName() {\n        return Buffer.from(path.relative(this.projectRoot, this.public))\n            .toString(\"base64\")\n            .replace(/=+$/, \"\");\n    }\n    async start() {\n        if (this.files.length === 0) {\n            return;\n        }\n        for (const f of this.files) {\n            this.hashQueue.add(f);\n        }\n        this.hashQueue.close();\n        this.hashQueue.process();\n        this.hashQueue\n            .wait()\n            .then(this.queuePopulate.bind(this))\n            .then(() => {\n            hashcache.dump(this.projectRoot, this.hashcacheName(), this.cacheNew);\n            logger_1.logger.debug(\"[hosting][hash queue][FINAL]\", this.hashQueue.stats());\n            this.populateQueue.close();\n            return this.populateQueue.wait();\n        })\n            .then(() => {\n            logger_1.logger.debug(\"[hosting][populate queue][FINAL]\", this.populateQueue.stats());\n            logger_1.logger.debug(\"[hosting] uploads queued:\", this.uploadQueue.stats().total);\n            this.uploadQueue.close();\n        });\n        this.uploadQueue.wait().catch((err) => {\n            if (err.message.includes(\"content hash\")) {\n                logger_1.logger.debug(\"[hosting][upload queue] upload failed with content hash error. Deleting hash cache\");\n                hashcache.dump(this.projectRoot, this.hashcacheName(), new Map());\n            }\n        });\n        const fin = (err) => {\n            logger_1.logger.debug(\"[hosting][upload queue][FINAL]\", this.uploadQueue.stats());\n            if (err) {\n                throw err;\n            }\n        };\n        return this.wait().then(fin).catch(fin);\n    }\n    async wait() {\n        await Promise.all([this.hashQueue.wait(), this.populateQueue.wait(), this.uploadQueue.wait()]);\n    }\n    statusMessage() {\n        if (!this.hashQueue.finished) {\n            return progressMessage(\"hashing files\", this.hashQueue.complete, this.fileCount);\n        }\n        else if (!this.populateQueue.finished) {\n            return progressMessage(\"adding files to version\", this.populateQueue.complete * 1000, this.fileCount);\n        }\n        else if (!this.uploadQueue.finished) {\n            return progressMessage(\"uploading new files\", this.uploadQueue.complete, this.uploadQueue.stats().total);\n        }\n        else {\n            return \"upload complete\";\n        }\n    }\n    async hashHandler(filePath) {\n        const stats = fs.statSync(path.resolve(this.public, filePath));\n        const mtime = stats.mtime.getTime();\n        this.sizeMap[filePath] = stats.size;\n        const cached = this.cache[filePath];\n        if (cached && cached.mtime === mtime) {\n            this.cacheNew.set(filePath, cached);\n            this.addHash(filePath, cached.hash);\n            return;\n        }\n        const fstream = this.zipStream(filePath);\n        const hash = crypto.createHash(\"sha256\");\n        fstream.pipe(hash);\n        return new Promise((resolve, reject) => {\n            fstream.on(\"end\", resolve);\n            fstream.on(\"error\", reject);\n        }).then(() => {\n            const hashVal = hash.read().toString(\"hex\");\n            this.cacheNew.set(filePath, { mtime: mtime, hash: hashVal });\n            this.addHash(filePath, hashVal);\n        });\n    }\n    addHash(filePath, hash) {\n        this.hashMap[hash] = filePath;\n        this.pathMap[filePath] = hash;\n        this.populateBatch[\"/\" + filePath] = hash;\n        const curBatchSize = lodash_1.size(this.populateBatch);\n        if (curBatchSize > 0 && curBatchSize % this.populateBatchSize === 0) {\n            this.queuePopulate();\n        }\n    }\n    queuePopulate() {\n        const pop = this.populateBatch;\n        this.populateQueue.add(pop);\n        this.populateBatch = {};\n        this.populateQueue.process();\n    }\n    async populateHandler(batch) {\n        const res = await this.hashClient.post(`/${this.version}:populateFiles`, { files: batch });\n        this.uploadUrl = res.body.uploadUrl;\n        this.uploadClient = new apiv2_1.Client({ urlPrefix: this.uploadUrl, auth: true });\n        this.addUploads(res.body.uploadRequiredHashes || []);\n    }\n    addUploads(hashes) {\n        for (const hash of hashes) {\n            this.uploadQueue.add(hash);\n        }\n        this.uploadQueue.process();\n    }\n    async uploadHandler(toUpload) {\n        if (!this.uploadClient) {\n            throw new error_1.FirebaseError(\"No upload client available.\", { exit: 2 });\n        }\n        const controller = new abort_controller_1.default();\n        const timeout = setTimeout(() => {\n            controller.abort();\n        }, this.uploadTimeout(this.hashMap[toUpload]));\n        const res = await this.uploadClient.request({\n            method: \"POST\",\n            path: `/${toUpload}`,\n            body: this.zipStream(this.hashMap[toUpload]),\n            resolveOnHTTPError: true,\n            responseType: \"stream\",\n            signal: controller.signal,\n        });\n        clearTimeout(timeout);\n        if (this.uploadQueue.cursor % 100 === 0) {\n            logger_1.logger.debug(\"[hosting][upload]\", this.uploadQueue.stats());\n        }\n        if (res.status !== 200) {\n            const errorMessage = await res.response.text();\n            logger_1.logger.debug(`[hosting][upload] ${this.hashMap[toUpload]} (${toUpload}) HTTP ERROR ${res.status}: headers=${JSON.stringify(res.response.headers)} ${errorMessage}`);\n            throw new Error(`Unexpected error while uploading file: ${errorMessage}`);\n        }\n    }\n    zipStream(filePath) {\n        const file = fs.createReadStream(path.resolve(this.public, filePath));\n        const gzip = zlib.createGzip({ level: this.gzipLevel });\n        return file.pipe(gzip);\n    }\n    uploadTimeout(filePath) {\n        const size = this.sizeMap[filePath] || 0;\n        return Math.min(Math.max(Math.round(size / 1000) * 20, MIN_UPLOAD_TIMEOUT), MAX_UPLOAD_TIMEOUT);\n    }\n}\nexports.Uploader = Uploader;\n"]},"metadata":{},"sourceType":"script"}