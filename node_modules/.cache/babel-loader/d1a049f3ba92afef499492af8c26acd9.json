{"ast":null,"code":"'use strict';\n\nfunction isPromise(obj) {\n  return !!obj && (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function';\n}\n/**\n * Return a function that will run a function asynchronously or synchronously\n *\n * example:\n * runAsync(wrappedFunction, callback)(...args);\n *\n * @param   {Function} func  Function to run\n * @param   {Function} cb    Callback function passed the `func` returned value\n * @return  {Function(arguments)} Arguments to pass to `func`. This function will in turn\n *                                return a Promise (Node >= 0.12) or call the callbacks.\n */\n\n\nvar runAsync = module.exports = function (func, cb) {\n  cb = cb || function () {};\n\n  return function () {\n    var args = arguments;\n    var promise = new Promise(function (resolve, reject) {\n      var resolved = false;\n\n      const wrappedResolve = function (value) {\n        if (resolved) {\n          console.warn('Run-async promise already resolved.');\n        }\n\n        resolved = true;\n        resolve(value);\n      };\n\n      var rejected = false;\n\n      const wrappedReject = function (value) {\n        if (rejected) {\n          console.warn('Run-async promise already rejected.');\n        }\n\n        rejected = true;\n        reject(value);\n      };\n\n      var usingCallback = false;\n      var callbackConflict = false;\n      var contextEnded = false;\n      var answer = func.apply({\n        async: function () {\n          if (contextEnded) {\n            console.warn('Run-async async() called outside a valid run-async context, callback will be ignored.');\n            return function () {};\n          }\n\n          if (callbackConflict) {\n            console.warn('Run-async wrapped function (async) returned a promise.\\nCalls to async() callback can have unexpected results.');\n          }\n\n          usingCallback = true;\n          return function (err, value) {\n            if (err) {\n              wrappedReject(err);\n            } else {\n              wrappedResolve(value);\n            }\n          };\n        }\n      }, Array.prototype.slice.call(args));\n\n      if (usingCallback) {\n        if (isPromise(answer)) {\n          console.warn('Run-async wrapped function (sync) returned a promise but async() callback must be executed to resolve.');\n        }\n      } else {\n        if (isPromise(answer)) {\n          callbackConflict = true;\n          answer.then(wrappedResolve, wrappedReject);\n        } else {\n          wrappedResolve(answer);\n        }\n      }\n\n      contextEnded = true;\n    });\n    promise.then(cb.bind(null, null), cb);\n    return promise;\n  };\n};\n\nrunAsync.cb = function (func, cb) {\n  return runAsync(function () {\n    var args = Array.prototype.slice.call(arguments);\n\n    if (args.length === func.length - 1) {\n      args.push(this.async());\n    }\n\n    return func.apply(this, args);\n  }, cb);\n};","map":{"version":3,"sources":["/home/dev/Documentos/Projects/github-clone/node_modules/run-async/index.js"],"names":["isPromise","obj","then","runAsync","module","exports","func","cb","args","arguments","promise","Promise","resolve","reject","resolved","wrappedResolve","value","console","warn","rejected","wrappedReject","usingCallback","callbackConflict","contextEnded","answer","apply","async","err","Array","prototype","slice","call","bind","length","push"],"mappings":"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","sourcesContent":["'use strict';\n\nfunction isPromise(obj) {\n  return !!obj && (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function';\n}\n\n/**\n * Return a function that will run a function asynchronously or synchronously\n *\n * example:\n * runAsync(wrappedFunction, callback)(...args);\n *\n * @param   {Function} func  Function to run\n * @param   {Function} cb    Callback function passed the `func` returned value\n * @return  {Function(arguments)} Arguments to pass to `func`. This function will in turn\n *                                return a Promise (Node >= 0.12) or call the callbacks.\n */\n\nvar runAsync = module.exports = function (func, cb) {\n  cb = cb || function () {};\n\n  return function () {\n\n    var args = arguments;\n\n    var promise = new Promise(function (resolve, reject) {\n      var resolved = false;\n      const wrappedResolve = function (value) {\n        if (resolved) {\n          console.warn('Run-async promise already resolved.')\n        }\n        resolved = true;\n        resolve(value);\n      }\n\n      var rejected = false;\n      const wrappedReject = function (value) {\n        if (rejected) {\n          console.warn('Run-async promise already rejected.')\n        }\n        rejected = true;\n        reject(value);\n      }\n\n      var usingCallback = false;\n      var callbackConflict = false;\n      var contextEnded = false;\n\n      var answer = func.apply({\n        async: function () {\n          if (contextEnded) {\n            console.warn('Run-async async() called outside a valid run-async context, callback will be ignored.');\n            return function() {};\n          }\n          if (callbackConflict) {\n            console.warn('Run-async wrapped function (async) returned a promise.\\nCalls to async() callback can have unexpected results.');\n          }\n          usingCallback = true;\n          return function (err, value) {\n            if (err) {\n              wrappedReject(err);\n            } else {\n              wrappedResolve(value);\n            }\n          };\n        }\n      }, Array.prototype.slice.call(args));\n\n      if (usingCallback) {\n        if (isPromise(answer)) {\n          console.warn('Run-async wrapped function (sync) returned a promise but async() callback must be executed to resolve.');\n        }\n      } else {\n        if (isPromise(answer)) {\n          callbackConflict = true;\n          answer.then(wrappedResolve, wrappedReject);\n        } else {\n          wrappedResolve(answer);\n        }\n      }\n      contextEnded = true;\n    });\n\n    promise.then(cb.bind(null, null), cb);\n\n    return promise;\n  }\n};\n\nrunAsync.cb = function (func, cb) {\n  return runAsync(function () {\n    var args = Array.prototype.slice.call(arguments);\n    if (args.length === func.length - 1) {\n      args.push(this.async());\n    }\n    return func.apply(this, args);\n  }, cb);\n};\n"]},"metadata":{},"sourceType":"script"}