{"ast":null,"code":"var Chainsaw = require('chainsaw');\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar Buffers = require('buffers');\n\nvar Vars = require('./lib/vars.js');\n\nvar Stream = require('stream').Stream;\n\nexports = module.exports = function (bufOrEm, eventName) {\n  if (Buffer.isBuffer(bufOrEm)) {\n    return exports.parse(bufOrEm);\n  }\n\n  var s = exports.stream();\n\n  if (bufOrEm && bufOrEm.pipe) {\n    bufOrEm.pipe(s);\n  } else if (bufOrEm) {\n    bufOrEm.on(eventName || 'data', function (buf) {\n      s.write(buf);\n    });\n    bufOrEm.on('end', function () {\n      s.end();\n    });\n  }\n\n  return s;\n};\n\nexports.stream = function (input) {\n  if (input) return exports.apply(null, arguments);\n  var pending = null;\n\n  function getBytes(bytes, cb, skip) {\n    pending = {\n      bytes: bytes,\n      skip: skip,\n      cb: function (buf) {\n        pending = null;\n        cb(buf);\n      }\n    };\n    dispatch();\n  }\n\n  var offset = null;\n\n  function dispatch() {\n    if (!pending) {\n      if (caughtEnd) done = true;\n      return;\n    }\n\n    if (typeof pending === 'function') {\n      pending();\n    } else {\n      var bytes = offset + pending.bytes;\n\n      if (buffers.length >= bytes) {\n        var buf;\n\n        if (offset == null) {\n          buf = buffers.splice(0, bytes);\n\n          if (!pending.skip) {\n            buf = buf.slice();\n          }\n        } else {\n          if (!pending.skip) {\n            buf = buffers.slice(offset, bytes);\n          }\n\n          offset = bytes;\n        }\n\n        if (pending.skip) {\n          pending.cb();\n        } else {\n          pending.cb(buf);\n        }\n      }\n    }\n  }\n\n  function builder(saw) {\n    function next() {\n      if (!done) saw.next();\n    }\n\n    var self = words(function (bytes, cb) {\n      return function (name) {\n        getBytes(bytes, function (buf) {\n          vars.set(name, cb(buf));\n          next();\n        });\n      };\n    });\n\n    self.tap = function (cb) {\n      saw.nest(cb, vars.store);\n    };\n\n    self.into = function (key, cb) {\n      if (!vars.get(key)) vars.set(key, {});\n      var parent = vars;\n      vars = Vars(parent.get(key));\n      saw.nest(function () {\n        cb.apply(this, arguments);\n        this.tap(function () {\n          vars = parent;\n        });\n      }, vars.store);\n    };\n\n    self.flush = function () {\n      vars.store = {};\n      next();\n    };\n\n    self.loop = function (cb) {\n      var end = false;\n      saw.nest(false, function loop() {\n        this.vars = vars.store;\n        cb.call(this, function () {\n          end = true;\n          next();\n        }, vars.store);\n        this.tap(function () {\n          if (end) saw.next();else loop.call(this);\n        }.bind(this));\n      }, vars.store);\n    };\n\n    self.buffer = function (name, bytes) {\n      if (typeof bytes === 'string') {\n        bytes = vars.get(bytes);\n      }\n\n      getBytes(bytes, function (buf) {\n        vars.set(name, buf);\n        next();\n      });\n    };\n\n    self.skip = function (bytes) {\n      if (typeof bytes === 'string') {\n        bytes = vars.get(bytes);\n      }\n\n      getBytes(bytes, function () {\n        next();\n      });\n    };\n\n    self.scan = function find(name, search) {\n      if (typeof search === 'string') {\n        search = new Buffer(search);\n      } else if (!Buffer.isBuffer(search)) {\n        throw new Error('search must be a Buffer or a string');\n      }\n\n      var taken = 0;\n\n      pending = function () {\n        var pos = buffers.indexOf(search, offset + taken);\n        var i = pos - offset - taken;\n\n        if (pos !== -1) {\n          pending = null;\n\n          if (offset != null) {\n            vars.set(name, buffers.slice(offset, offset + taken + i));\n            offset += taken + i + search.length;\n          } else {\n            vars.set(name, buffers.slice(0, taken + i));\n            buffers.splice(0, taken + i + search.length);\n          }\n\n          next();\n          dispatch();\n        } else {\n          i = Math.max(buffers.length - search.length - offset - taken, 0);\n        }\n\n        taken += i;\n      };\n\n      dispatch();\n    };\n\n    self.peek = function (cb) {\n      offset = 0;\n      saw.nest(function () {\n        cb.call(this, vars.store);\n        this.tap(function () {\n          offset = null;\n        });\n      });\n    };\n\n    return self;\n  }\n\n  ;\n  var stream = Chainsaw.light(builder);\n  stream.writable = true;\n  var buffers = Buffers();\n\n  stream.write = function (buf) {\n    buffers.push(buf);\n    dispatch();\n  };\n\n  var vars = Vars();\n  var done = false,\n      caughtEnd = false;\n\n  stream.end = function () {\n    caughtEnd = true;\n  };\n\n  stream.pipe = Stream.prototype.pipe;\n  Object.getOwnPropertyNames(EventEmitter.prototype).forEach(function (name) {\n    stream[name] = EventEmitter.prototype[name];\n  });\n  return stream;\n};\n\nexports.parse = function parse(buffer) {\n  var self = words(function (bytes, cb) {\n    return function (name) {\n      if (offset + bytes <= buffer.length) {\n        var buf = buffer.slice(offset, offset + bytes);\n        offset += bytes;\n        vars.set(name, cb(buf));\n      } else {\n        vars.set(name, null);\n      }\n\n      return self;\n    };\n  });\n  var offset = 0;\n  var vars = Vars();\n  self.vars = vars.store;\n\n  self.tap = function (cb) {\n    cb.call(self, vars.store);\n    return self;\n  };\n\n  self.into = function (key, cb) {\n    if (!vars.get(key)) {\n      vars.set(key, {});\n    }\n\n    var parent = vars;\n    vars = Vars(parent.get(key));\n    cb.call(self, vars.store);\n    vars = parent;\n    return self;\n  };\n\n  self.loop = function (cb) {\n    var end = false;\n\n    var ender = function () {\n      end = true;\n    };\n\n    while (end === false) {\n      cb.call(self, ender, vars.store);\n    }\n\n    return self;\n  };\n\n  self.buffer = function (name, size) {\n    if (typeof size === 'string') {\n      size = vars.get(size);\n    }\n\n    var buf = buffer.slice(offset, Math.min(buffer.length, offset + size));\n    offset += size;\n    vars.set(name, buf);\n    return self;\n  };\n\n  self.skip = function (bytes) {\n    if (typeof bytes === 'string') {\n      bytes = vars.get(bytes);\n    }\n\n    offset += bytes;\n    return self;\n  };\n\n  self.scan = function (name, search) {\n    if (typeof search === 'string') {\n      search = new Buffer(search);\n    } else if (!Buffer.isBuffer(search)) {\n      throw new Error('search must be a Buffer or a string');\n    }\n\n    vars.set(name, null); // simple but slow string search\n\n    for (var i = 0; i + offset <= buffer.length - search.length + 1; i++) {\n      for (var j = 0; j < search.length && buffer[offset + i + j] === search[j]; j++);\n\n      if (j === search.length) break;\n    }\n\n    vars.set(name, buffer.slice(offset, offset + i));\n    offset += i + search.length;\n    return self;\n  };\n\n  self.peek = function (cb) {\n    var was = offset;\n    cb.call(self, vars.store);\n    offset = was;\n    return self;\n  };\n\n  self.flush = function () {\n    vars.store = {};\n    return self;\n  };\n\n  self.eof = function () {\n    return offset >= buffer.length;\n  };\n\n  return self;\n}; // convert byte strings to unsigned little endian numbers\n\n\nfunction decodeLEu(bytes) {\n  var acc = 0;\n\n  for (var i = 0; i < bytes.length; i++) {\n    acc += Math.pow(256, i) * bytes[i];\n  }\n\n  return acc;\n} // convert byte strings to unsigned big endian numbers\n\n\nfunction decodeBEu(bytes) {\n  var acc = 0;\n\n  for (var i = 0; i < bytes.length; i++) {\n    acc += Math.pow(256, bytes.length - i - 1) * bytes[i];\n  }\n\n  return acc;\n} // convert byte strings to signed big endian numbers\n\n\nfunction decodeBEs(bytes) {\n  var val = decodeBEu(bytes);\n\n  if ((bytes[0] & 0x80) == 0x80) {\n    val -= Math.pow(256, bytes.length);\n  }\n\n  return val;\n} // convert byte strings to signed little endian numbers\n\n\nfunction decodeLEs(bytes) {\n  var val = decodeLEu(bytes);\n\n  if ((bytes[bytes.length - 1] & 0x80) == 0x80) {\n    val -= Math.pow(256, bytes.length);\n  }\n\n  return val;\n}\n\nfunction words(decode) {\n  var self = {};\n  [1, 2, 4, 8].forEach(function (bytes) {\n    var bits = bytes * 8;\n    self['word' + bits + 'le'] = self['word' + bits + 'lu'] = decode(bytes, decodeLEu);\n    self['word' + bits + 'ls'] = decode(bytes, decodeLEs);\n    self['word' + bits + 'be'] = self['word' + bits + 'bu'] = decode(bytes, decodeBEu);\n    self['word' + bits + 'bs'] = decode(bytes, decodeBEs);\n  }); // word8be(n) == word8le(n) for all n\n\n  self.word8 = self.word8u = self.word8be;\n  self.word8s = self.word8bs;\n  return self;\n}","map":{"version":3,"sources":["/home/dev/Documentos/Projects/github-clone/node_modules/binary/index.js"],"names":["Chainsaw","require","EventEmitter","Buffers","Vars","Stream","exports","module","bufOrEm","eventName","Buffer","isBuffer","parse","s","stream","pipe","on","buf","write","end","input","apply","arguments","pending","getBytes","bytes","cb","skip","dispatch","offset","caughtEnd","done","buffers","length","splice","slice","builder","saw","next","self","words","name","vars","set","tap","nest","store","into","key","get","parent","flush","loop","call","bind","buffer","scan","find","search","Error","taken","pos","indexOf","i","Math","max","peek","light","writable","push","prototype","Object","getOwnPropertyNames","forEach","ender","size","min","j","was","eof","decodeLEu","acc","pow","decodeBEu","decodeBEs","val","decodeLEs","decode","bits","word8","word8u","word8be","word8s","word8bs"],"mappings":"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","sourcesContent":["var Chainsaw = require('chainsaw');\nvar EventEmitter = require('events').EventEmitter;\nvar Buffers = require('buffers');\nvar Vars = require('./lib/vars.js');\nvar Stream = require('stream').Stream;\n\nexports = module.exports = function (bufOrEm, eventName) {\n    if (Buffer.isBuffer(bufOrEm)) {\n        return exports.parse(bufOrEm);\n    }\n    \n    var s = exports.stream();\n    if (bufOrEm && bufOrEm.pipe) {\n        bufOrEm.pipe(s);\n    }\n    else if (bufOrEm) {\n        bufOrEm.on(eventName || 'data', function (buf) {\n            s.write(buf);\n        });\n        \n        bufOrEm.on('end', function () {\n            s.end();\n        });\n    }\n    return s;\n};\n\nexports.stream = function (input) {\n    if (input) return exports.apply(null, arguments);\n    \n    var pending = null;\n    function getBytes (bytes, cb, skip) {\n        pending = {\n            bytes : bytes,\n            skip : skip,\n            cb : function (buf) {\n                pending = null;\n                cb(buf);\n            },\n        };\n        dispatch();\n    }\n    \n    var offset = null;\n    function dispatch () {\n        if (!pending) {\n            if (caughtEnd) done = true;\n            return;\n        }\n        if (typeof pending === 'function') {\n            pending();\n        }\n        else {\n            var bytes = offset + pending.bytes;\n            \n            if (buffers.length >= bytes) {\n                var buf;\n                if (offset == null) {\n                    buf = buffers.splice(0, bytes);\n                    if (!pending.skip) {\n                        buf = buf.slice();\n                    }\n                }\n                else {\n                    if (!pending.skip) {\n                        buf = buffers.slice(offset, bytes);\n                    }\n                    offset = bytes;\n                }\n                \n                if (pending.skip) {\n                    pending.cb();\n                }\n                else {\n                    pending.cb(buf);\n                }\n            }\n        }\n    }\n    \n    function builder (saw) {\n        function next () { if (!done) saw.next() }\n        \n        var self = words(function (bytes, cb) {\n            return function (name) {\n                getBytes(bytes, function (buf) {\n                    vars.set(name, cb(buf));\n                    next();\n                });\n            };\n        });\n        \n        self.tap = function (cb) {\n            saw.nest(cb, vars.store);\n        };\n        \n        self.into = function (key, cb) {\n            if (!vars.get(key)) vars.set(key, {});\n            var parent = vars;\n            vars = Vars(parent.get(key));\n            \n            saw.nest(function () {\n                cb.apply(this, arguments);\n                this.tap(function () {\n                    vars = parent;\n                });\n            }, vars.store);\n        };\n        \n        self.flush = function () {\n            vars.store = {};\n            next();\n        };\n        \n        self.loop = function (cb) {\n            var end = false;\n            \n            saw.nest(false, function loop () {\n                this.vars = vars.store;\n                cb.call(this, function () {\n                    end = true;\n                    next();\n                }, vars.store);\n                this.tap(function () {\n                    if (end) saw.next()\n                    else loop.call(this)\n                }.bind(this));\n            }, vars.store);\n        };\n        \n        self.buffer = function (name, bytes) {\n            if (typeof bytes === 'string') {\n                bytes = vars.get(bytes);\n            }\n            \n            getBytes(bytes, function (buf) {\n                vars.set(name, buf);\n                next();\n            });\n        };\n        \n        self.skip = function (bytes) {\n            if (typeof bytes === 'string') {\n                bytes = vars.get(bytes);\n            }\n            \n            getBytes(bytes, function () {\n                next();\n            });\n        };\n        \n        self.scan = function find (name, search) {\n            if (typeof search === 'string') {\n                search = new Buffer(search);\n            }\n            else if (!Buffer.isBuffer(search)) {\n                throw new Error('search must be a Buffer or a string');\n            }\n            \n            var taken = 0;\n            pending = function () {\n                var pos = buffers.indexOf(search, offset + taken);\n                var i = pos-offset-taken;\n                if (pos !== -1) {\n                    pending = null;\n                    if (offset != null) {\n                        vars.set(\n                            name,\n                            buffers.slice(offset, offset + taken + i)\n                        );\n                        offset += taken + i + search.length;\n                    }\n                    else {\n                        vars.set(\n                            name,\n                            buffers.slice(0, taken + i)\n                        );\n                        buffers.splice(0, taken + i + search.length);\n                    }\n                    next();\n                    dispatch();\n                } else {\n                    i = Math.max(buffers.length - search.length - offset - taken, 0);\n\t\t\t\t}\n                taken += i;\n            };\n            dispatch();\n        };\n        \n        self.peek = function (cb) {\n            offset = 0;\n            saw.nest(function () {\n                cb.call(this, vars.store);\n                this.tap(function () {\n                    offset = null;\n                });\n            });\n        };\n        \n        return self;\n    };\n    \n    var stream = Chainsaw.light(builder);\n    stream.writable = true;\n    \n    var buffers = Buffers();\n    \n    stream.write = function (buf) {\n        buffers.push(buf);\n        dispatch();\n    };\n    \n    var vars = Vars();\n    \n    var done = false, caughtEnd = false;\n    stream.end = function () {\n        caughtEnd = true;\n    };\n    \n    stream.pipe = Stream.prototype.pipe;\n    Object.getOwnPropertyNames(EventEmitter.prototype).forEach(function (name) {\n        stream[name] = EventEmitter.prototype[name];\n    });\n    \n    return stream;\n};\n\nexports.parse = function parse (buffer) {\n    var self = words(function (bytes, cb) {\n        return function (name) {\n            if (offset + bytes <= buffer.length) {\n                var buf = buffer.slice(offset, offset + bytes);\n                offset += bytes;\n                vars.set(name, cb(buf));\n            }\n            else {\n                vars.set(name, null);\n            }\n            return self;\n        };\n    });\n    \n    var offset = 0;\n    var vars = Vars();\n    self.vars = vars.store;\n    \n    self.tap = function (cb) {\n        cb.call(self, vars.store);\n        return self;\n    };\n    \n    self.into = function (key, cb) {\n        if (!vars.get(key)) {\n            vars.set(key, {});\n        }\n        var parent = vars;\n        vars = Vars(parent.get(key));\n        cb.call(self, vars.store);\n        vars = parent;\n        return self;\n    };\n    \n    self.loop = function (cb) {\n        var end = false;\n        var ender = function () { end = true };\n        while (end === false) {\n            cb.call(self, ender, vars.store);\n        }\n        return self;\n    };\n    \n    self.buffer = function (name, size) {\n        if (typeof size === 'string') {\n            size = vars.get(size);\n        }\n        var buf = buffer.slice(offset, Math.min(buffer.length, offset + size));\n        offset += size;\n        vars.set(name, buf);\n        \n        return self;\n    };\n    \n    self.skip = function (bytes) {\n        if (typeof bytes === 'string') {\n            bytes = vars.get(bytes);\n        }\n        offset += bytes;\n        \n        return self;\n    };\n    \n    self.scan = function (name, search) {\n        if (typeof search === 'string') {\n            search = new Buffer(search);\n        }\n        else if (!Buffer.isBuffer(search)) {\n            throw new Error('search must be a Buffer or a string');\n        }\n        vars.set(name, null);\n        \n        // simple but slow string search\n        for (var i = 0; i + offset <= buffer.length - search.length + 1; i++) {\n            for (\n                var j = 0;\n                j < search.length && buffer[offset+i+j] === search[j];\n                j++\n            );\n            if (j === search.length) break;\n        }\n        \n        vars.set(name, buffer.slice(offset, offset + i));\n        offset += i + search.length;\n        return self;\n    };\n    \n    self.peek = function (cb) {\n        var was = offset;\n        cb.call(self, vars.store);\n        offset = was;\n        return self;\n    };\n    \n    self.flush = function () {\n        vars.store = {};\n        return self;\n    };\n    \n    self.eof = function () {\n        return offset >= buffer.length;\n    };\n    \n    return self;\n};\n\n// convert byte strings to unsigned little endian numbers\nfunction decodeLEu (bytes) {\n    var acc = 0;\n    for (var i = 0; i < bytes.length; i++) {\n        acc += Math.pow(256,i) * bytes[i];\n    }\n    return acc;\n}\n\n// convert byte strings to unsigned big endian numbers\nfunction decodeBEu (bytes) {\n    var acc = 0;\n    for (var i = 0; i < bytes.length; i++) {\n        acc += Math.pow(256, bytes.length - i - 1) * bytes[i];\n    }\n    return acc;\n}\n\n// convert byte strings to signed big endian numbers\nfunction decodeBEs (bytes) {\n    var val = decodeBEu(bytes);\n    if ((bytes[0] & 0x80) == 0x80) {\n        val -= Math.pow(256, bytes.length);\n    }\n    return val;\n}\n\n// convert byte strings to signed little endian numbers\nfunction decodeLEs (bytes) {\n    var val = decodeLEu(bytes);\n    if ((bytes[bytes.length - 1] & 0x80) == 0x80) {\n        val -= Math.pow(256, bytes.length);\n    }\n    return val;\n}\n\nfunction words (decode) {\n    var self = {};\n    \n    [ 1, 2, 4, 8 ].forEach(function (bytes) {\n        var bits = bytes * 8;\n        \n        self['word' + bits + 'le']\n        = self['word' + bits + 'lu']\n        = decode(bytes, decodeLEu);\n        \n        self['word' + bits + 'ls']\n        = decode(bytes, decodeLEs);\n        \n        self['word' + bits + 'be']\n        = self['word' + bits + 'bu']\n        = decode(bytes, decodeBEu);\n        \n        self['word' + bits + 'bs']\n        = decode(bytes, decodeBEs);\n    });\n    \n    // word8be(n) == word8le(n) for all n\n    self.word8 = self.word8u = self.word8be;\n    self.word8s = self.word8bs;\n    \n    return self;\n}\n"]},"metadata":{},"sourceType":"script"}