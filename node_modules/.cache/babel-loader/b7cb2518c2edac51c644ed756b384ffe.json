{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MimeTypeRegistry = exports.parseMimeType = void 0; // A mime-type, per RFC 7231 section 3.1.1.1\n\nconst TCHAR = \"[!#$%&'*+-.^_`|~A-Za-z0-9]\";\nconst TOKEN = `${TCHAR}+`;\nconst OWS = '[ \\t]*';\nconst MIME_TYPE_REGEX = new RegExp(`^(${TOKEN})/(${TOKEN})${OWS}(.*)$`);\n/**\n * Parses a mimeType into a `{type, subtype}` object.\n * Parameters provided with the mimeType are ignored.\n */\n\nfunction parseMimeType(mimeType) {\n  const match = MIME_TYPE_REGEX.exec(mimeType);\n\n  if (!match) {\n    throw new Error(`Invalid MIME type: \"${mimeType}\"`);\n  }\n\n  if (match[3] && match[3][0] !== ';') {\n    throw new Error(`Invalid MIME type: \"${mimeType}\"`);\n  }\n\n  return {\n    type: match[1].toLowerCase(),\n    subtype: match[2].toLowerCase()\n  };\n}\n\nexports.parseMimeType = parseMimeType;\n\nfunction isParsedMimeType(val) {\n  return !!(val.type && val.subtype);\n}\n\nclass MimeTypeRegistry {\n  constructor(map) {\n    // This is a registry of mime types with no wildcards.\n    this._staticMimeTypes = Object.create(null); // This is a registry of \"types\" for mime types where the subtype was wildcarded.\n\n    this._wildcardSubtypes = Object.create(null);\n\n    if (map) {\n      for (const mimeType of Object.keys(map)) {\n        const t = map[mimeType];\n\n        if (t) {\n          this.set(mimeType, t);\n        }\n      }\n    }\n  }\n\n  set(mimeType, value) {\n    const {\n      type,\n      subtype\n    } = isParsedMimeType(mimeType) ? mimeType : parseMimeType(mimeType);\n\n    if (type === '*' && subtype === '*') {\n      this._defaultMimeType = value;\n    } else if (subtype === '*') {\n      this._wildcardSubtypes[type] = value;\n    } else if (type === '*') {\n      throw new Error(`Do not allow wildcarding mime \"type\" unless also wildcarding \"subtype\": ${mimeType}`);\n    } else {\n      this._staticMimeTypes[`${type}/${subtype}`] = value;\n    }\n  }\n\n  get(mimeType) {\n    const {\n      type,\n      subtype\n    } = isParsedMimeType(mimeType) ? mimeType : parseMimeType(mimeType);\n    return this._staticMimeTypes[`${type}/${subtype}`] || this._wildcardSubtypes[type] || this._defaultMimeType;\n  }\n\n  getRegisteredTypes() {\n    const answer = Object.keys(this._staticMimeTypes).concat(Object.keys(this._wildcardSubtypes).map(type => `${type}/*`));\n\n    if (this._defaultMimeType) {\n      answer.push('*/*');\n    }\n\n    return answer;\n  }\n\n}\n\nexports.MimeTypeRegistry = MimeTypeRegistry;","map":{"version":3,"sources":["../../src/utils/mime.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MimeTypeRegistry = exports.parseMimeType = void 0;\n// A mime-type, per RFC 7231 section 3.1.1.1\nconst TCHAR = \"[!#$%&'*+-.^_`|~A-Za-z0-9]\";\nconst TOKEN = `${TCHAR}+`;\nconst OWS = '[ \\t]*';\nconst MIME_TYPE_REGEX = new RegExp(`^(${TOKEN})/(${TOKEN})${OWS}(.*)$`);\n/**\n * Parses a mimeType into a `{type, subtype}` object.\n * Parameters provided with the mimeType are ignored.\n */\nfunction parseMimeType(mimeType) {\n    const match = MIME_TYPE_REGEX.exec(mimeType);\n    if (!match) {\n        throw new Error(`Invalid MIME type: \"${mimeType}\"`);\n    }\n    if (match[3] && match[3][0] !== ';') {\n        throw new Error(`Invalid MIME type: \"${mimeType}\"`);\n    }\n    return { type: match[1].toLowerCase(), subtype: match[2].toLowerCase() };\n}\nexports.parseMimeType = parseMimeType;\nfunction isParsedMimeType(val) {\n    return !!(val.type && val.subtype);\n}\nclass MimeTypeRegistry {\n    constructor(map) {\n        // This is a registry of mime types with no wildcards.\n        this._staticMimeTypes = Object.create(null);\n        // This is a registry of \"types\" for mime types where the subtype was wildcarded.\n        this._wildcardSubtypes = Object.create(null);\n        if (map) {\n            for (const mimeType of Object.keys(map)) {\n                const t = map[mimeType];\n                if (t) {\n                    this.set(mimeType, t);\n                }\n            }\n        }\n    }\n    set(mimeType, value) {\n        const { type, subtype } = isParsedMimeType(mimeType) ? mimeType : parseMimeType(mimeType);\n        if (type === '*' && subtype === '*') {\n            this._defaultMimeType = value;\n        }\n        else if (subtype === '*') {\n            this._wildcardSubtypes[type] = value;\n        }\n        else if (type === '*') {\n            throw new Error(`Do not allow wildcarding mime \"type\" unless also wildcarding \"subtype\": ${mimeType}`);\n        }\n        else {\n            this._staticMimeTypes[`${type}/${subtype}`] = value;\n        }\n    }\n    get(mimeType) {\n        const { type, subtype } = isParsedMimeType(mimeType) ? mimeType : parseMimeType(mimeType);\n        return (this._staticMimeTypes[`${type}/${subtype}`] ||\n            this._wildcardSubtypes[type] ||\n            this._defaultMimeType);\n    }\n    getRegisteredTypes() {\n        const answer = Object.keys(this._staticMimeTypes).concat(Object.keys(this._wildcardSubtypes).map((type) => `${type}/*`));\n        if (this._defaultMimeType) {\n            answer.push('*/*');\n        }\n        return answer;\n    }\n}\nexports.MimeTypeRegistry = MimeTypeRegistry;\n//# sourceMappingURL=mime.js.map"]},"metadata":{},"sourceType":"script"}