{"ast":null,"code":"\"use strict\";\n\nconst $Ref = require(\"./ref\");\n\nconst Pointer = require(\"./pointer\");\n\nconst parse = require(\"./parse\");\n\nconst url = require(\"./util/url\");\n\nconst {\n  isHandledError\n} = require(\"./util/errors\");\n\nmodule.exports = resolveExternal;\n/**\n * Crawls the JSON schema, finds all external JSON references, and resolves their values.\n * This method does not mutate the JSON schema. The resolved values are added to {@link $RefParser#$refs}.\n *\n * NOTE: We only care about EXTERNAL references here. INTERNAL references are only relevant when dereferencing.\n *\n * @param {$RefParser} parser\n * @param {$RefParserOptions} options\n *\n * @returns {Promise}\n * The promise resolves once all JSON references in the schema have been resolved,\n * including nested references that are contained in externally-referenced files.\n */\n\nfunction resolveExternal(parser, options) {\n  if (!options.resolve.external) {\n    // Nothing to resolve, so exit early\n    return Promise.resolve();\n  }\n\n  try {\n    // console.log('Resolving $ref pointers in %s', parser.$refs._root$Ref.path);\n    let promises = crawl(parser.schema, parser.$refs._root$Ref.path + \"#\", parser.$refs, options);\n    return Promise.all(promises);\n  } catch (e) {\n    return Promise.reject(e);\n  }\n}\n/**\n * Recursively crawls the given value, and resolves any external JSON references.\n *\n * @param {*} obj - The value to crawl. If it's not an object or array, it will be ignored.\n * @param {string} path - The full path of `obj`, possibly with a JSON Pointer in the hash\n * @param {$Refs} $refs\n * @param {$RefParserOptions} options\n * @param {Set} seen - Internal.\n *\n * @returns {Promise[]}\n * Returns an array of promises. There will be one promise for each JSON reference in `obj`.\n * If `obj` does not contain any JSON references, then the array will be empty.\n * If any of the JSON references point to files that contain additional JSON references,\n * then the corresponding promise will internally reference an array of promises.\n */\n\n\nfunction crawl(obj, path, $refs, options, seen) {\n  seen = seen || new Set();\n  let promises = [];\n\n  if (obj && typeof obj === \"object\" && !ArrayBuffer.isView(obj) && !seen.has(obj)) {\n    seen.add(obj); // Track previously seen objects to avoid infinite recursion\n\n    if ($Ref.isExternal$Ref(obj)) {\n      promises.push(resolve$Ref(obj, path, $refs, options));\n    } else {\n      for (let key of Object.keys(obj)) {\n        let keyPath = Pointer.join(path, key);\n        let value = obj[key];\n\n        if ($Ref.isExternal$Ref(value)) {\n          promises.push(resolve$Ref(value, keyPath, $refs, options));\n        } else {\n          promises = promises.concat(crawl(value, keyPath, $refs, options, seen));\n        }\n      }\n    }\n  }\n\n  return promises;\n}\n/**\n * Resolves the given JSON Reference, and then crawls the resulting value.\n *\n * @param {{$ref: string}} $ref - The JSON Reference to resolve\n * @param {string} path - The full path of `$ref`, possibly with a JSON Pointer in the hash\n * @param {$Refs} $refs\n * @param {$RefParserOptions} options\n *\n * @returns {Promise}\n * The promise resolves once all JSON references in the object have been resolved,\n * including nested references that are contained in externally-referenced files.\n */\n\n\nasync function resolve$Ref($ref, path, $refs, options) {\n  // console.log('Resolving $ref pointer \"%s\" at %s', $ref.$ref, path);\n  let resolvedPath = url.resolve(path, $ref.$ref);\n  let withoutHash = url.stripHash(resolvedPath); // Do we already have this $ref?\n\n  $ref = $refs._$refs[withoutHash];\n\n  if ($ref) {\n    // We've already parsed this $ref, so use the existing value\n    return Promise.resolve($ref.value);\n  } // Parse the $referenced file/url\n\n\n  try {\n    const result = await parse(resolvedPath, $refs, options); // Crawl the parsed value\n    // console.log('Resolving $ref pointers in %s', withoutHash);\n\n    let promises = crawl(result, withoutHash + \"#\", $refs, options);\n    return Promise.all(promises);\n  } catch (err) {\n    if (!options.continueOnError || !isHandledError(err)) {\n      throw err;\n    }\n\n    if ($refs._$refs[withoutHash]) {\n      err.source = url.stripHash(path);\n      err.path = url.safePointerToPath(url.getHash(path));\n    }\n\n    return [];\n  }\n}","map":{"version":3,"sources":["/home/dev/Documentos/Projects/github-clone/node_modules/@apidevtools/json-schema-ref-parser/lib/resolve-external.js"],"names":["$Ref","require","Pointer","parse","url","isHandledError","module","exports","resolveExternal","parser","options","resolve","external","Promise","promises","crawl","schema","$refs","_root$Ref","path","all","e","reject","obj","seen","Set","ArrayBuffer","isView","has","add","isExternal$Ref","push","resolve$Ref","key","Object","keys","keyPath","join","value","concat","$ref","resolvedPath","withoutHash","stripHash","_$refs","result","err","continueOnError","source","safePointerToPath","getHash"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst $Ref = require(\"./ref\");\nconst Pointer = require(\"./pointer\");\nconst parse = require(\"./parse\");\nconst url = require(\"./util/url\");\nconst { isHandledError } = require(\"./util/errors\");\n\nmodule.exports = resolveExternal;\n\n/**\n * Crawls the JSON schema, finds all external JSON references, and resolves their values.\n * This method does not mutate the JSON schema. The resolved values are added to {@link $RefParser#$refs}.\n *\n * NOTE: We only care about EXTERNAL references here. INTERNAL references are only relevant when dereferencing.\n *\n * @param {$RefParser} parser\n * @param {$RefParserOptions} options\n *\n * @returns {Promise}\n * The promise resolves once all JSON references in the schema have been resolved,\n * including nested references that are contained in externally-referenced files.\n */\nfunction resolveExternal (parser, options) {\n  if (!options.resolve.external) {\n    // Nothing to resolve, so exit early\n    return Promise.resolve();\n  }\n\n  try {\n    // console.log('Resolving $ref pointers in %s', parser.$refs._root$Ref.path);\n    let promises = crawl(parser.schema, parser.$refs._root$Ref.path + \"#\", parser.$refs, options);\n    return Promise.all(promises);\n  }\n  catch (e) {\n    return Promise.reject(e);\n  }\n}\n\n/**\n * Recursively crawls the given value, and resolves any external JSON references.\n *\n * @param {*} obj - The value to crawl. If it's not an object or array, it will be ignored.\n * @param {string} path - The full path of `obj`, possibly with a JSON Pointer in the hash\n * @param {$Refs} $refs\n * @param {$RefParserOptions} options\n * @param {Set} seen - Internal.\n *\n * @returns {Promise[]}\n * Returns an array of promises. There will be one promise for each JSON reference in `obj`.\n * If `obj` does not contain any JSON references, then the array will be empty.\n * If any of the JSON references point to files that contain additional JSON references,\n * then the corresponding promise will internally reference an array of promises.\n */\nfunction crawl (obj, path, $refs, options, seen) {\n  seen = seen || new Set();\n  let promises = [];\n\n  if (obj && typeof obj === \"object\" && !ArrayBuffer.isView(obj) && !seen.has(obj)) {\n    seen.add(obj); // Track previously seen objects to avoid infinite recursion\n    if ($Ref.isExternal$Ref(obj)) {\n      promises.push(resolve$Ref(obj, path, $refs, options));\n    }\n    else {\n      for (let key of Object.keys(obj)) {\n        let keyPath = Pointer.join(path, key);\n        let value = obj[key];\n\n        if ($Ref.isExternal$Ref(value)) {\n          promises.push(resolve$Ref(value, keyPath, $refs, options));\n        }\n        else {\n          promises = promises.concat(crawl(value, keyPath, $refs, options, seen));\n        }\n      }\n    }\n  }\n\n  return promises;\n}\n\n/**\n * Resolves the given JSON Reference, and then crawls the resulting value.\n *\n * @param {{$ref: string}} $ref - The JSON Reference to resolve\n * @param {string} path - The full path of `$ref`, possibly with a JSON Pointer in the hash\n * @param {$Refs} $refs\n * @param {$RefParserOptions} options\n *\n * @returns {Promise}\n * The promise resolves once all JSON references in the object have been resolved,\n * including nested references that are contained in externally-referenced files.\n */\nasync function resolve$Ref ($ref, path, $refs, options) {\n  // console.log('Resolving $ref pointer \"%s\" at %s', $ref.$ref, path);\n\n  let resolvedPath = url.resolve(path, $ref.$ref);\n  let withoutHash = url.stripHash(resolvedPath);\n\n  // Do we already have this $ref?\n  $ref = $refs._$refs[withoutHash];\n  if ($ref) {\n    // We've already parsed this $ref, so use the existing value\n    return Promise.resolve($ref.value);\n  }\n\n  // Parse the $referenced file/url\n  try {\n    const result = await parse(resolvedPath, $refs, options);\n\n    // Crawl the parsed value\n    // console.log('Resolving $ref pointers in %s', withoutHash);\n    let promises = crawl(result, withoutHash + \"#\", $refs, options);\n\n    return Promise.all(promises);\n  }\n  catch (err) {\n    if (!options.continueOnError || !isHandledError(err)) {\n      throw err;\n    }\n\n    if ($refs._$refs[withoutHash]) {\n      err.source = url.stripHash(path);\n      err.path = url.safePointerToPath(url.getHash(path));\n    }\n\n    return [];\n  }\n}\n"]},"metadata":{},"sourceType":"script"}