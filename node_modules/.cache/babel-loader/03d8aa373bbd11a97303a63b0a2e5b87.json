{"ast":null,"code":"\"use strict\";\n\nconst {\n  ParserError\n} = require(\"../util/errors\");\n\nlet TEXT_REGEXP = /\\.(txt|htm|html|md|xml|js|min|map|css|scss|less|svg)$/i;\nmodule.exports = {\n  /**\n   * The order that this parser will run, in relation to other parsers.\n   *\n   * @type {number}\n   */\n  order: 300,\n\n  /**\n   * Whether to allow \"empty\" files (zero bytes).\n   *\n   * @type {boolean}\n   */\n  allowEmpty: true,\n\n  /**\n   * The encoding that the text is expected to be in.\n   *\n   * @type {string}\n   */\n  encoding: \"utf8\",\n\n  /**\n   * Determines whether this parser can parse a given file reference.\n   * Parsers that return true will be tried, in order, until one successfully parses the file.\n   * Parsers that return false will be skipped, UNLESS all parsers returned false, in which case\n   * every parser will be tried.\n   *\n   * @param {object} file           - An object containing information about the referenced file\n   * @param {string} file.url       - The full URL of the referenced file\n   * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n   * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver\n   * @returns {boolean}\n   */\n  canParse(file) {\n    // Use this parser if the file is a string or Buffer, and has a known text-based extension\n    return (typeof file.data === \"string\" || Buffer.isBuffer(file.data)) && TEXT_REGEXP.test(file.url);\n  },\n\n  /**\n   * Parses the given file as text\n   *\n   * @param {object} file           - An object containing information about the referenced file\n   * @param {string} file.url       - The full URL of the referenced file\n   * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n   * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver\n   * @returns {string}\n   */\n  parse(file) {\n    if (typeof file.data === \"string\") {\n      return file.data;\n    } else if (Buffer.isBuffer(file.data)) {\n      return file.data.toString(this.encoding);\n    } else {\n      throw new ParserError(\"data is not text\", file.url);\n    }\n  }\n\n};","map":{"version":3,"sources":["/home/dev/Documentos/Projects/github-clone/node_modules/@apidevtools/json-schema-ref-parser/lib/parsers/text.js"],"names":["ParserError","require","TEXT_REGEXP","module","exports","order","allowEmpty","encoding","canParse","file","data","Buffer","isBuffer","test","url","parse","toString"],"mappings":"AAAA;;AAEA,MAAM;AAAEA,EAAAA;AAAF,IAAkBC,OAAO,CAAC,gBAAD,CAA/B;;AAEA,IAAIC,WAAW,GAAG,wDAAlB;AAEAC,MAAM,CAACC,OAAP,GAAiB;AACf;AACF;AACA;AACA;AACA;AACEC,EAAAA,KAAK,EAAE,GANQ;;AAQf;AACF;AACA;AACA;AACA;AACEC,EAAAA,UAAU,EAAE,IAbG;;AAef;AACF;AACA;AACA;AACA;AACEC,EAAAA,QAAQ,EAAE,MApBK;;AAsBf;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACEC,EAAAA,QAAQ,CAAEC,IAAF,EAAQ;AACd;AACA,WAAO,CAAC,OAAOA,IAAI,CAACC,IAAZ,KAAqB,QAArB,IAAiCC,MAAM,CAACC,QAAP,CAAgBH,IAAI,CAACC,IAArB,CAAlC,KAAiER,WAAW,CAACW,IAAZ,CAAiBJ,IAAI,CAACK,GAAtB,CAAxE;AACD,GArCc;;AAuCf;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACEC,EAAAA,KAAK,CAAEN,IAAF,EAAQ;AACX,QAAI,OAAOA,IAAI,CAACC,IAAZ,KAAqB,QAAzB,EAAmC;AACjC,aAAOD,IAAI,CAACC,IAAZ;AACD,KAFD,MAGK,IAAIC,MAAM,CAACC,QAAP,CAAgBH,IAAI,CAACC,IAArB,CAAJ,EAAgC;AACnC,aAAOD,IAAI,CAACC,IAAL,CAAUM,QAAV,CAAmB,KAAKT,QAAxB,CAAP;AACD,KAFI,MAGA;AACH,YAAM,IAAIP,WAAJ,CAAgB,kBAAhB,EAAoCS,IAAI,CAACK,GAAzC,CAAN;AACD;AACF;;AA1Dc,CAAjB","sourcesContent":["\"use strict\";\n\nconst { ParserError } = require(\"../util/errors\");\n\nlet TEXT_REGEXP = /\\.(txt|htm|html|md|xml|js|min|map|css|scss|less|svg)$/i;\n\nmodule.exports = {\n  /**\n   * The order that this parser will run, in relation to other parsers.\n   *\n   * @type {number}\n   */\n  order: 300,\n\n  /**\n   * Whether to allow \"empty\" files (zero bytes).\n   *\n   * @type {boolean}\n   */\n  allowEmpty: true,\n\n  /**\n   * The encoding that the text is expected to be in.\n   *\n   * @type {string}\n   */\n  encoding: \"utf8\",\n\n  /**\n   * Determines whether this parser can parse a given file reference.\n   * Parsers that return true will be tried, in order, until one successfully parses the file.\n   * Parsers that return false will be skipped, UNLESS all parsers returned false, in which case\n   * every parser will be tried.\n   *\n   * @param {object} file           - An object containing information about the referenced file\n   * @param {string} file.url       - The full URL of the referenced file\n   * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n   * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver\n   * @returns {boolean}\n   */\n  canParse (file) {\n    // Use this parser if the file is a string or Buffer, and has a known text-based extension\n    return (typeof file.data === \"string\" || Buffer.isBuffer(file.data)) && TEXT_REGEXP.test(file.url);\n  },\n\n  /**\n   * Parses the given file as text\n   *\n   * @param {object} file           - An object containing information about the referenced file\n   * @param {string} file.url       - The full URL of the referenced file\n   * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n   * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver\n   * @returns {string}\n   */\n  parse (file) {\n    if (typeof file.data === \"string\") {\n      return file.data;\n    }\n    else if (Buffer.isBuffer(file.data)) {\n      return file.data.toString(this.encoding);\n    }\n    else {\n      throw new ParserError(\"data is not text\", file.url);\n    }\n  }\n};\n"]},"metadata":{},"sourceType":"script"}