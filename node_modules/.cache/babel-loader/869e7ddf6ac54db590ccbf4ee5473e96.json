{"ast":null,"code":"'use strict';\n\nvar util = require('util'),\n    Match = require('../match');\n/**\n * This class matches UTF-16 and UTF-32, both big- and little-endian. The\n * BOM will be used if it is present.\n */\n\n\nmodule.exports.UTF_16BE = function () {\n  this.name = function () {\n    return 'UTF-16BE';\n  };\n\n  this.match = function (det) {\n    var input = det.fRawInput;\n\n    if (input.length >= 2 && (input[0] & 0xff) == 0xfe && (input[1] & 0xff) == 0xff) {\n      return new Match(det, this, 100); // confidence = 100\n    } // TODO: Do some statistics to check for unsigned UTF-16BE\n\n\n    return null;\n  };\n};\n\nmodule.exports.UTF_16LE = function () {\n  this.name = function () {\n    return 'UTF-16LE';\n  };\n\n  this.match = function (det) {\n    var input = det.fRawInput;\n\n    if (input.length >= 2 && (input[0] & 0xff) == 0xff && (input[1] & 0xff) == 0xfe) {\n      // LE BOM is present.\n      if (input.length >= 4 && input[2] == 0x00 && input[3] == 0x00) {\n        // It is probably UTF-32 LE, not UTF-16\n        return null;\n      }\n\n      return new Match(det, this, 100); // confidence = 100\n    } // TODO: Do some statistics to check for unsigned UTF-16LE\n\n\n    return null;\n  };\n};\n\nfunction UTF_32() {}\n\n;\n\nUTF_32.prototype.match = function (det) {\n  var input = det.fRawInput,\n      limit = det.fRawLength / 4 * 4,\n      numValid = 0,\n      numInvalid = 0,\n      hasBOM = false,\n      confidence = 0;\n\n  if (limit == 0) {\n    return null;\n  }\n\n  if (this.getChar(input, 0) == 0x0000FEFF) {\n    hasBOM = true;\n  }\n\n  for (var i = 0; i < limit; i += 4) {\n    var ch = this.getChar(input, i);\n\n    if (ch < 0 || ch >= 0x10FFFF || ch >= 0xD800 && ch <= 0xDFFF) {\n      numInvalid += 1;\n    } else {\n      numValid += 1;\n    }\n  } // Cook up some sort of confidence score, based on presence of a BOM\n  //    and the existence of valid and/or invalid multi-byte sequences.\n\n\n  if (hasBOM && numInvalid == 0) {\n    confidence = 100;\n  } else if (hasBOM && numValid > numInvalid * 10) {\n    confidence = 80;\n  } else if (numValid > 3 && numInvalid == 0) {\n    confidence = 100;\n  } else if (numValid > 0 && numInvalid == 0) {\n    confidence = 80;\n  } else if (numValid > numInvalid * 10) {\n    // Probably corrupt UTF-32BE data.  Valid sequences aren't likely by chance.\n    confidence = 25;\n  } // return confidence == 0 ? null : new CharsetMatch(det, this, confidence);\n\n\n  return confidence == 0 ? null : new Match(det, this, confidence);\n};\n\nmodule.exports.UTF_32BE = function () {\n  this.name = function () {\n    return 'UTF-32BE';\n  };\n\n  this.getChar = function (input, index) {\n    return (input[index + 0] & 0xff) << 24 | (input[index + 1] & 0xff) << 16 | (input[index + 2] & 0xff) << 8 | input[index + 3] & 0xff;\n  };\n};\n\nutil.inherits(module.exports.UTF_32BE, UTF_32);\n\nmodule.exports.UTF_32LE = function () {\n  this.name = function () {\n    return 'UTF-32LE';\n  };\n\n  this.getChar = function (input, index) {\n    return (input[index + 3] & 0xff) << 24 | (input[index + 2] & 0xff) << 16 | (input[index + 1] & 0xff) << 8 | input[index + 0] & 0xff;\n  };\n};\n\nutil.inherits(module.exports.UTF_32LE, UTF_32);","map":{"version":3,"sources":["/home/dev/Documentos/Projects/github-clone/node_modules/chardet/encoding/unicode.js"],"names":["util","require","Match","module","exports","UTF_16BE","name","match","det","input","fRawInput","length","UTF_16LE","UTF_32","prototype","limit","fRawLength","numValid","numInvalid","hasBOM","confidence","getChar","i","ch","UTF_32BE","index","inherits","UTF_32LE"],"mappings":"AAAA;;AACA,IAAIA,IAAI,GAAGC,OAAO,CAAC,MAAD,CAAlB;AAAA,IACEC,KAAK,GAAGD,OAAO,CAAE,UAAF,CADjB;AAGA;AACA;AACA;AACA;;;AACAE,MAAM,CAACC,OAAP,CAAeC,QAAf,GAA0B,YAAW;AACnC,OAAKC,IAAL,GAAY,YAAW;AACrB,WAAO,UAAP;AACD,GAFD;;AAGA,OAAKC,KAAL,GAAa,UAASC,GAAT,EAAc;AACzB,QAAIC,KAAK,GAAGD,GAAG,CAACE,SAAhB;;AAEA,QAAID,KAAK,CAACE,MAAN,IAAgB,CAAhB,IAAsB,CAACF,KAAK,CAAC,CAAD,CAAL,GAAW,IAAZ,KAAqB,IAArB,IAA6B,CAACA,KAAK,CAAC,CAAD,CAAL,GAAW,IAAZ,KAAqB,IAA5E,EAAmF;AACjF,aAAO,IAAIP,KAAJ,CAAUM,GAAV,EAAe,IAAf,EAAqB,GAArB,CAAP,CADiF,CAC/C;AACnC,KALwB,CAOzB;;;AACA,WAAO,IAAP;AACD,GATD;AAUD,CAdD;;AAgBAL,MAAM,CAACC,OAAP,CAAeQ,QAAf,GAA0B,YAAW;AACnC,OAAKN,IAAL,GAAY,YAAW;AACrB,WAAO,UAAP;AACD,GAFD;;AAGA,OAAKC,KAAL,GAAa,UAASC,GAAT,EAAc;AACzB,QAAIC,KAAK,GAAGD,GAAG,CAACE,SAAhB;;AAEA,QAAID,KAAK,CAACE,MAAN,IAAgB,CAAhB,IAAsB,CAACF,KAAK,CAAC,CAAD,CAAL,GAAW,IAAZ,KAAqB,IAArB,IAA6B,CAACA,KAAK,CAAC,CAAD,CAAL,GAAW,IAAZ,KAAqB,IAA5E,EAAmF;AACjF;AACA,UAAIA,KAAK,CAACE,MAAN,IAAgB,CAAhB,IAAqBF,KAAK,CAAC,CAAD,CAAL,IAAY,IAAjC,IAAyCA,KAAK,CAAC,CAAD,CAAL,IAAY,IAAzD,EAA+D;AAC7D;AACA,eAAO,IAAP;AACD;;AACD,aAAO,IAAIP,KAAJ,CAAUM,GAAV,EAAe,IAAf,EAAqB,GAArB,CAAP,CANiF,CAM/C;AACnC,KAVwB,CAYzB;;;AACA,WAAO,IAAP;AACD,GAdD;AAeD,CAnBD;;AAqBA,SAASK,MAAT,GAAkB,CAAE;;AAAA;;AACpBA,MAAM,CAACC,SAAP,CAAiBP,KAAjB,GAAyB,UAASC,GAAT,EAAc;AACrC,MAAIC,KAAK,GAAQD,GAAG,CAACE,SAArB;AAAA,MACEK,KAAK,GAASP,GAAG,CAACQ,UAAJ,GAAiB,CAAlB,GAAuB,CADtC;AAAA,MAEEC,QAAQ,GAAK,CAFf;AAAA,MAGEC,UAAU,GAAG,CAHf;AAAA,MAIEC,MAAM,GAAO,KAJf;AAAA,MAKEC,UAAU,GAAG,CALf;;AAOA,MAAIL,KAAK,IAAI,CAAb,EAAgB;AACd,WAAO,IAAP;AACD;;AAED,MAAI,KAAKM,OAAL,CAAaZ,KAAb,EAAoB,CAApB,KAA0B,UAA9B,EAA0C;AACxCU,IAAAA,MAAM,GAAG,IAAT;AACD;;AAED,OAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGP,KAApB,EAA2BO,CAAC,IAAI,CAAhC,EAAmC;AACjC,QAAIC,EAAE,GAAG,KAAKF,OAAL,CAAaZ,KAAb,EAAoBa,CAApB,CAAT;;AAEA,QAAIC,EAAE,GAAG,CAAL,IAAUA,EAAE,IAAI,QAAhB,IAA6BA,EAAE,IAAI,MAAN,IAAgBA,EAAE,IAAI,MAAvD,EAAgE;AAC9DL,MAAAA,UAAU,IAAI,CAAd;AACD,KAFD,MAEO;AACLD,MAAAA,QAAQ,IAAI,CAAZ;AACD;AACF,GAxBoC,CA0BrC;AACA;;;AACA,MAAIE,MAAM,IAAID,UAAU,IAAI,CAA5B,EAA+B;AAC7BE,IAAAA,UAAU,GAAG,GAAb;AACD,GAFD,MAEO,IAAID,MAAM,IAAIF,QAAQ,GAAGC,UAAU,GAAG,EAAtC,EAA0C;AAC/CE,IAAAA,UAAU,GAAG,EAAb;AACD,GAFM,MAEA,IAAIH,QAAQ,GAAG,CAAX,IAAgBC,UAAU,IAAI,CAAlC,EAAqC;AAC1CE,IAAAA,UAAU,GAAG,GAAb;AACD,GAFM,MAEA,IAAIH,QAAQ,GAAG,CAAX,IAAgBC,UAAU,IAAI,CAAlC,EAAqC;AAC1CE,IAAAA,UAAU,GAAG,EAAb;AACD,GAFM,MAEA,IAAIH,QAAQ,GAAGC,UAAU,GAAG,EAA5B,EAAgC;AACrC;AACAE,IAAAA,UAAU,GAAG,EAAb;AACD,GAvCoC,CAyCrC;;;AACA,SAAOA,UAAU,IAAI,CAAd,GAAkB,IAAlB,GAAyB,IAAIlB,KAAJ,CAAUM,GAAV,EAAe,IAAf,EAAqBY,UAArB,CAAhC;AACD,CA3CD;;AA6CAjB,MAAM,CAACC,OAAP,CAAeoB,QAAf,GAA0B,YAAW;AACnC,OAAKlB,IAAL,GAAY,YAAW;AACrB,WAAO,UAAP;AACD,GAFD;;AAGA,OAAKe,OAAL,GAAe,UAASZ,KAAT,EAAgBgB,KAAhB,EAAuB;AACpC,WAAO,CAAChB,KAAK,CAACgB,KAAK,GAAG,CAAT,CAAL,GAAmB,IAApB,KAA6B,EAA7B,GAAkC,CAAChB,KAAK,CAACgB,KAAK,GAAG,CAAT,CAAL,GAAmB,IAApB,KAA6B,EAA/D,GACF,CAAChB,KAAK,CAACgB,KAAK,GAAG,CAAT,CAAL,GAAmB,IAApB,KAA8B,CAD5B,GACiChB,KAAK,CAACgB,KAAK,GAAG,CAAT,CAAL,GAAmB,IAD3D;AAED,GAHD;AAID,CARD;;AASAzB,IAAI,CAAC0B,QAAL,CAAcvB,MAAM,CAACC,OAAP,CAAeoB,QAA7B,EAAuCX,MAAvC;;AAEAV,MAAM,CAACC,OAAP,CAAeuB,QAAf,GAA0B,YAAW;AACnC,OAAKrB,IAAL,GAAY,YAAW;AACrB,WAAO,UAAP;AACD,GAFD;;AAGA,OAAKe,OAAL,GAAe,UAASZ,KAAT,EAAgBgB,KAAhB,EAAuB;AACpC,WAAO,CAAChB,KAAK,CAACgB,KAAK,GAAG,CAAT,CAAL,GAAmB,IAApB,KAA6B,EAA7B,GAAkC,CAAChB,KAAK,CAACgB,KAAK,GAAG,CAAT,CAAL,GAAmB,IAApB,KAA6B,EAA/D,GACF,CAAChB,KAAK,CAACgB,KAAK,GAAG,CAAT,CAAL,GAAmB,IAApB,KAA8B,CAD5B,GACiChB,KAAK,CAACgB,KAAK,GAAG,CAAT,CAAL,GAAmB,IAD3D;AAED,GAHD;AAID,CARD;;AASAzB,IAAI,CAAC0B,QAAL,CAAcvB,MAAM,CAACC,OAAP,CAAeuB,QAA7B,EAAuCd,MAAvC","sourcesContent":["'use strict';\nvar util = require('util'),\n  Match = require ('../match');\n\n/**\n * This class matches UTF-16 and UTF-32, both big- and little-endian. The\n * BOM will be used if it is present.\n */\nmodule.exports.UTF_16BE = function() {\n  this.name = function() {\n    return 'UTF-16BE';\n  };\n  this.match = function(det) {\n    var input = det.fRawInput;\n\n    if (input.length >= 2 && ((input[0] & 0xff) == 0xfe && (input[1] & 0xff) == 0xff)) {\n      return new Match(det, this, 100); // confidence = 100\n    }\n\n    // TODO: Do some statistics to check for unsigned UTF-16BE\n    return null;\n  };\n};\n\nmodule.exports.UTF_16LE = function() {\n  this.name = function() {\n    return 'UTF-16LE';\n  };\n  this.match = function(det) {\n    var input = det.fRawInput;\n\n    if (input.length >= 2 && ((input[0] & 0xff) == 0xff && (input[1] & 0xff) == 0xfe)) {\n      // LE BOM is present.\n      if (input.length >= 4 && input[2] == 0x00 && input[3] == 0x00) {\n        // It is probably UTF-32 LE, not UTF-16\n        return null;\n      }\n      return new Match(det, this, 100); // confidence = 100\n    }\n\n    // TODO: Do some statistics to check for unsigned UTF-16LE\n    return null;\n  }\n};\n\nfunction UTF_32() {};\nUTF_32.prototype.match = function(det) {\n  var input      = det.fRawInput,\n    limit      = (det.fRawLength / 4) * 4,\n    numValid   = 0,\n    numInvalid = 0,\n    hasBOM     = false,\n    confidence = 0;\n\n  if (limit == 0) {\n    return null;\n  }\n\n  if (this.getChar(input, 0) == 0x0000FEFF) {\n    hasBOM = true;\n  }\n\n  for (var i = 0; i < limit; i += 4) {\n    var ch = this.getChar(input, i);\n\n    if (ch < 0 || ch >= 0x10FFFF || (ch >= 0xD800 && ch <= 0xDFFF)) {\n      numInvalid += 1;\n    } else {\n      numValid += 1;\n    }\n  }\n\n  // Cook up some sort of confidence score, based on presence of a BOM\n  //    and the existence of valid and/or invalid multi-byte sequences.\n  if (hasBOM && numInvalid == 0) {\n    confidence = 100;\n  } else if (hasBOM && numValid > numInvalid * 10) {\n    confidence = 80;\n  } else if (numValid > 3 && numInvalid == 0) {\n    confidence = 100;\n  } else if (numValid > 0 && numInvalid == 0) {\n    confidence = 80;\n  } else if (numValid > numInvalid * 10) {\n    // Probably corrupt UTF-32BE data.  Valid sequences aren't likely by chance.\n    confidence = 25;\n  }\n\n  // return confidence == 0 ? null : new CharsetMatch(det, this, confidence);\n  return confidence == 0 ? null : new Match(det, this, confidence);\n};\n\nmodule.exports.UTF_32BE = function() {\n  this.name = function() {\n    return 'UTF-32BE';\n  };\n  this.getChar = function(input, index) {\n    return (input[index + 0] & 0xff) << 24 | (input[index + 1] & 0xff) << 16 |\n         (input[index + 2] & 0xff) <<  8 | (input[index + 3] & 0xff);\n  };\n};\nutil.inherits(module.exports.UTF_32BE, UTF_32);\n\nmodule.exports.UTF_32LE = function() {\n  this.name = function() {\n    return 'UTF-32LE';\n  };\n  this.getChar = function(input, index) {\n    return (input[index + 3] & 0xff) << 24 | (input[index + 2] & 0xff) << 16 |\n         (input[index + 1] & 0xff) <<  8 | (input[index + 0] & 0xff);\n  };\n};\nutil.inherits(module.exports.UTF_32LE, UTF_32);\n"]},"metadata":{},"sourceType":"script"}