{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.formatServiceAccount = exports.getInvokerMembers = exports.fieldMasks = exports.renameIfPresent = exports.copyIfPresent = exports.assertOneOf = exports.durationFromSeconds = exports.secondsFromDuration = void 0;\n\nconst error_1 = require(\"../error\");\n\nfunction secondsFromDuration(d) {\n  return +d.slice(0, d.length - 1);\n}\n\nexports.secondsFromDuration = secondsFromDuration;\n\nfunction durationFromSeconds(s) {\n  return `${s}s`;\n}\n\nexports.durationFromSeconds = durationFromSeconds;\n\nfunction assertOneOf(typename, obj, oneof, ...fields) {\n  const defined = [];\n\n  for (const key of fields) {\n    const value = obj[key];\n\n    if (typeof value !== \"undefined\" && value != null) {\n      defined.push(key);\n    }\n  }\n\n  if (defined.length > 1) {\n    throw new error_1.FirebaseError(`Invalid ${typename} definition. ${oneof} can only have one field defined, but found ${defined.join(\",\")}`);\n  }\n}\n\nexports.assertOneOf = assertOneOf;\n\nfunction copyIfPresent(dest, src, ...fields) {\n  for (const field of fields) {\n    if (!Object.prototype.hasOwnProperty.call(src, field)) {\n      continue;\n    }\n\n    dest[field] = src[field];\n  }\n}\n\nexports.copyIfPresent = copyIfPresent;\n\nfunction renameIfPresent(dest, src, destField, srcField, converter = from => {\n  return from;\n}) {\n  if (!Object.prototype.hasOwnProperty.call(src, srcField)) {\n    return;\n  }\n\n  dest[destField] = converter(src[srcField]);\n}\n\nexports.renameIfPresent = renameIfPresent;\n\nfunction fieldMasks(object, ...doNotRecurseIn) {\n  const masks = [];\n  fieldMasksHelper([], object, doNotRecurseIn, masks);\n  return masks;\n}\n\nexports.fieldMasks = fieldMasks;\n\nfunction fieldMasksHelper(prefixes, cursor, doNotRecurseIn, masks) {\n  if (typeof cursor !== \"object\" || Array.isArray(cursor) || cursor === null) {\n    masks.push(prefixes.join(\".\"));\n    return;\n  }\n\n  const entries = Object.entries(cursor);\n\n  if (entries.length === 0) {\n    masks.push(prefixes.join(\".\"));\n    return;\n  }\n\n  for (const [key, value] of entries) {\n    const newPrefixes = [...prefixes, key];\n\n    if (doNotRecurseIn.includes(newPrefixes.join(\".\"))) {\n      masks.push(newPrefixes.join(\".\"));\n      continue;\n    }\n\n    fieldMasksHelper(newPrefixes, value, doNotRecurseIn, masks);\n  }\n}\n\nfunction getInvokerMembers(invoker, projectId) {\n  if (invoker[0] === \"private\") {\n    return [];\n  }\n\n  if (invoker[0] === \"public\") {\n    return [\"allUsers\"];\n  }\n\n  return invoker.map(inv => formatServiceAccount(inv, projectId));\n}\n\nexports.getInvokerMembers = getInvokerMembers;\n\nfunction formatServiceAccount(serviceAccount, projectId) {\n  if (serviceAccount.length === 0) {\n    throw new error_1.FirebaseError(\"Service account cannot be an empty string\");\n  }\n\n  if (!serviceAccount.includes(\"@\")) {\n    throw new error_1.FirebaseError(\"Service account must be of the form 'service-account@' or 'service-account@{project-id}.iam.gserviceaccount.com'\");\n  }\n\n  if (serviceAccount.endsWith(\"@\")) {\n    const suffix = `${projectId}.iam.gserviceaccount.com`;\n    return `serviceAccount:${serviceAccount}${suffix}`;\n  }\n\n  return `serviceAccount:${serviceAccount}`;\n}\n\nexports.formatServiceAccount = formatServiceAccount;","map":{"version":3,"sources":["/home/dev/Documentos/Projects/github-clone/node_modules/firebase-tools/lib/gcp/proto.js"],"names":["Object","defineProperty","exports","value","formatServiceAccount","getInvokerMembers","fieldMasks","renameIfPresent","copyIfPresent","assertOneOf","durationFromSeconds","secondsFromDuration","error_1","require","d","slice","length","s","typename","obj","oneof","fields","defined","key","push","FirebaseError","join","dest","src","field","prototype","hasOwnProperty","call","destField","srcField","converter","from","object","doNotRecurseIn","masks","fieldMasksHelper","prefixes","cursor","Array","isArray","entries","newPrefixes","includes","invoker","projectId","map","inv","serviceAccount","endsWith","suffix"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.formatServiceAccount = exports.getInvokerMembers = exports.fieldMasks = exports.renameIfPresent = exports.copyIfPresent = exports.assertOneOf = exports.durationFromSeconds = exports.secondsFromDuration = void 0;\nconst error_1 = require(\"../error\");\nfunction secondsFromDuration(d) {\n    return +d.slice(0, d.length - 1);\n}\nexports.secondsFromDuration = secondsFromDuration;\nfunction durationFromSeconds(s) {\n    return `${s}s`;\n}\nexports.durationFromSeconds = durationFromSeconds;\nfunction assertOneOf(typename, obj, oneof, ...fields) {\n    const defined = [];\n    for (const key of fields) {\n        const value = obj[key];\n        if (typeof value !== \"undefined\" && value != null) {\n            defined.push(key);\n        }\n    }\n    if (defined.length > 1) {\n        throw new error_1.FirebaseError(`Invalid ${typename} definition. ${oneof} can only have one field defined, but found ${defined.join(\",\")}`);\n    }\n}\nexports.assertOneOf = assertOneOf;\nfunction copyIfPresent(dest, src, ...fields) {\n    for (const field of fields) {\n        if (!Object.prototype.hasOwnProperty.call(src, field)) {\n            continue;\n        }\n        dest[field] = src[field];\n    }\n}\nexports.copyIfPresent = copyIfPresent;\nfunction renameIfPresent(dest, src, destField, srcField, converter = (from) => {\n    return from;\n}) {\n    if (!Object.prototype.hasOwnProperty.call(src, srcField)) {\n        return;\n    }\n    dest[destField] = converter(src[srcField]);\n}\nexports.renameIfPresent = renameIfPresent;\nfunction fieldMasks(object, ...doNotRecurseIn) {\n    const masks = [];\n    fieldMasksHelper([], object, doNotRecurseIn, masks);\n    return masks;\n}\nexports.fieldMasks = fieldMasks;\nfunction fieldMasksHelper(prefixes, cursor, doNotRecurseIn, masks) {\n    if (typeof cursor !== \"object\" || Array.isArray(cursor) || cursor === null) {\n        masks.push(prefixes.join(\".\"));\n        return;\n    }\n    const entries = Object.entries(cursor);\n    if (entries.length === 0) {\n        masks.push(prefixes.join(\".\"));\n        return;\n    }\n    for (const [key, value] of entries) {\n        const newPrefixes = [...prefixes, key];\n        if (doNotRecurseIn.includes(newPrefixes.join(\".\"))) {\n            masks.push(newPrefixes.join(\".\"));\n            continue;\n        }\n        fieldMasksHelper(newPrefixes, value, doNotRecurseIn, masks);\n    }\n}\nfunction getInvokerMembers(invoker, projectId) {\n    if (invoker[0] === \"private\") {\n        return [];\n    }\n    if (invoker[0] === \"public\") {\n        return [\"allUsers\"];\n    }\n    return invoker.map((inv) => formatServiceAccount(inv, projectId));\n}\nexports.getInvokerMembers = getInvokerMembers;\nfunction formatServiceAccount(serviceAccount, projectId) {\n    if (serviceAccount.length === 0) {\n        throw new error_1.FirebaseError(\"Service account cannot be an empty string\");\n    }\n    if (!serviceAccount.includes(\"@\")) {\n        throw new error_1.FirebaseError(\"Service account must be of the form 'service-account@' or 'service-account@{project-id}.iam.gserviceaccount.com'\");\n    }\n    if (serviceAccount.endsWith(\"@\")) {\n        const suffix = `${projectId}.iam.gserviceaccount.com`;\n        return `serviceAccount:${serviceAccount}${suffix}`;\n    }\n    return `serviceAccount:${serviceAccount}`;\n}\nexports.formatServiceAccount = formatServiceAccount;\n"]},"metadata":{},"sourceType":"script"}