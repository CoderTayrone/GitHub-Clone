{"ast":null,"code":"\"use strict\";\n\nvar csv = require(\"csv-streamify\");\n\nvar clc = require(\"cli-color\");\n\nvar fs = require(\"fs\");\n\nvar jsonStream = require(\"JSONStream\");\n\nvar _ = require(\"lodash\");\n\nvar {\n  Command\n} = require(\"../command\");\n\nvar accountImporter = require(\"../accountImporter\");\n\nvar needProjectId = require(\"../projectUtils\").needProjectId;\n\nconst {\n  logger\n} = require(\"../logger\");\n\nvar {\n  requirePermissions\n} = require(\"../requirePermissions\");\n\nvar utils = require(\"../utils\");\n\nvar MAX_BATCH_SIZE = 1000;\nvar validateOptions = accountImporter.validateOptions;\nvar validateUserJson = accountImporter.validateUserJson;\nvar transArrayToUser = accountImporter.transArrayToUser;\nvar serialImportUsers = accountImporter.serialImportUsers;\nmodule.exports = new Command(\"auth:import [dataFile]\").description(\"import users into your Firebase project from a data file(.csv or .json)\").option(\"--hash-algo <hashAlgo>\", \"specify the hash algorithm used in password for these accounts\").option(\"--hash-key <hashKey>\", \"specify the key used in hash algorithm\").option(\"--salt-separator <saltSeparator>\", \"specify the salt separator which will be appended to salt when verifying password. only used by SCRYPT now.\").option(\"--rounds <rounds>\", \"specify how many rounds for hash calculation.\").option(\"--mem-cost <memCost>\", \"specify the memory cost for firebase scrypt, or cpu/memory cost for standard scrypt\").option(\"--parallelization <parallelization>\", \"specify the parallelization for standard scrypt.\").option(\"--block-size <blockSize>\", \"specify the block size (normally is 8) for standard scrypt.\").option(\"--dk-len <dkLen>\", \"specify derived key length for standard scrypt.\").option(\"--hash-input-order <hashInputOrder>\", \"specify the order of password and salt. Possible values are SALT_FIRST and PASSWORD_FIRST. \" + \"MD5, SHA1, SHA256, SHA512, HMAC_MD5, HMAC_SHA1, HMAC_SHA256, HMAC_SHA512 support this flag.\").before(requirePermissions, [\"firebaseauth.users.create\", \"firebaseauth.users.update\"]).action(function (dataFile, options) {\n  var projectId = needProjectId(options);\n  var checkRes = validateOptions(options);\n\n  if (!checkRes.valid) {\n    return checkRes;\n  }\n\n  var hashOptions = checkRes;\n\n  if (!_.endsWith(dataFile, \".csv\") && !_.endsWith(dataFile, \".json\")) {\n    return utils.reject(\"Data file must end with .csv or .json\", {\n      exit: 1\n    });\n  }\n\n  var stats = fs.statSync(dataFile);\n  var fileSizeInBytes = stats.size;\n  logger.info(\"Processing \" + clc.bold(dataFile) + \" (\" + fileSizeInBytes + \" bytes)\");\n  var inStream = fs.createReadStream(dataFile);\n  var batches = [];\n  var currentBatch = [];\n  var counter = 0;\n  return new Promise(function (resolve, reject) {\n    var parser;\n\n    if (dataFile.endsWith(\".csv\")) {\n      parser = csv({\n        objectMode: true\n      });\n      parser.on(\"data\", function (line) {\n        counter++;\n        var user = transArrayToUser(line.map(function (str) {\n          var newStr = str.trim().replace(/^[\"|'](.*)[\"|']$/, \"$1\");\n          return newStr === \"\" ? undefined : newStr;\n        }));\n\n        if (user.error) {\n          return reject(\"Line \" + counter + \" (\" + line + \") has invalid data format: \" + user.error);\n        }\n\n        currentBatch.push(user);\n\n        if (currentBatch.length === MAX_BATCH_SIZE) {\n          batches.push(currentBatch);\n          currentBatch = [];\n        }\n      }).on(\"end\", function () {\n        if (currentBatch.length) {\n          batches.push(currentBatch);\n        }\n\n        return resolve(batches);\n      });\n      inStream.pipe(parser);\n    } else {\n      parser = jsonStream.parse([\"users\", {\n        emitKey: true\n      }]);\n      parser.on(\"data\", function (pair) {\n        counter++;\n        var res = validateUserJson(pair.value);\n\n        if (res.error) {\n          return reject(res.error);\n        }\n\n        currentBatch.push(pair.value);\n\n        if (currentBatch.length === MAX_BATCH_SIZE) {\n          batches.push(currentBatch);\n          currentBatch = [];\n        }\n      }).on(\"end\", function () {\n        if (currentBatch.length) {\n          batches.push(currentBatch);\n        }\n\n        return resolve(batches);\n      });\n      inStream.pipe(parser);\n    }\n  }).then(function (userListArr) {\n    logger.debug(\"Preparing to import\", counter, \"user records in\", userListArr.length, \"batches.\");\n\n    if (userListArr.length) {\n      return serialImportUsers(projectId, hashOptions, userListArr, 0);\n    }\n  }, function (error) {\n    return utils.reject(error, {\n      exit: 1\n    });\n  });\n});","map":{"version":3,"sources":["/home/dev/Documentos/Projects/github-clone/node_modules/firebase-tools/lib/commands/auth-import.js"],"names":["csv","require","clc","fs","jsonStream","_","Command","accountImporter","needProjectId","logger","requirePermissions","utils","MAX_BATCH_SIZE","validateOptions","validateUserJson","transArrayToUser","serialImportUsers","module","exports","description","option","before","action","dataFile","options","projectId","checkRes","valid","hashOptions","endsWith","reject","exit","stats","statSync","fileSizeInBytes","size","info","bold","inStream","createReadStream","batches","currentBatch","counter","Promise","resolve","parser","objectMode","on","line","user","map","str","newStr","trim","replace","undefined","error","push","length","pipe","parse","emitKey","pair","res","value","then","userListArr","debug"],"mappings":"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","sourcesContent":["\"use strict\";\nvar csv = require(\"csv-streamify\");\nvar clc = require(\"cli-color\");\nvar fs = require(\"fs\");\nvar jsonStream = require(\"JSONStream\");\nvar _ = require(\"lodash\");\nvar { Command } = require(\"../command\");\nvar accountImporter = require(\"../accountImporter\");\nvar needProjectId = require(\"../projectUtils\").needProjectId;\nconst { logger } = require(\"../logger\");\nvar { requirePermissions } = require(\"../requirePermissions\");\nvar utils = require(\"../utils\");\nvar MAX_BATCH_SIZE = 1000;\nvar validateOptions = accountImporter.validateOptions;\nvar validateUserJson = accountImporter.validateUserJson;\nvar transArrayToUser = accountImporter.transArrayToUser;\nvar serialImportUsers = accountImporter.serialImportUsers;\nmodule.exports = new Command(\"auth:import [dataFile]\")\n    .description(\"import users into your Firebase project from a data file(.csv or .json)\")\n    .option(\"--hash-algo <hashAlgo>\", \"specify the hash algorithm used in password for these accounts\")\n    .option(\"--hash-key <hashKey>\", \"specify the key used in hash algorithm\")\n    .option(\"--salt-separator <saltSeparator>\", \"specify the salt separator which will be appended to salt when verifying password. only used by SCRYPT now.\")\n    .option(\"--rounds <rounds>\", \"specify how many rounds for hash calculation.\")\n    .option(\"--mem-cost <memCost>\", \"specify the memory cost for firebase scrypt, or cpu/memory cost for standard scrypt\")\n    .option(\"--parallelization <parallelization>\", \"specify the parallelization for standard scrypt.\")\n    .option(\"--block-size <blockSize>\", \"specify the block size (normally is 8) for standard scrypt.\")\n    .option(\"--dk-len <dkLen>\", \"specify derived key length for standard scrypt.\")\n    .option(\"--hash-input-order <hashInputOrder>\", \"specify the order of password and salt. Possible values are SALT_FIRST and PASSWORD_FIRST. \" +\n    \"MD5, SHA1, SHA256, SHA512, HMAC_MD5, HMAC_SHA1, HMAC_SHA256, HMAC_SHA512 support this flag.\")\n    .before(requirePermissions, [\"firebaseauth.users.create\", \"firebaseauth.users.update\"])\n    .action(function (dataFile, options) {\n    var projectId = needProjectId(options);\n    var checkRes = validateOptions(options);\n    if (!checkRes.valid) {\n        return checkRes;\n    }\n    var hashOptions = checkRes;\n    if (!_.endsWith(dataFile, \".csv\") && !_.endsWith(dataFile, \".json\")) {\n        return utils.reject(\"Data file must end with .csv or .json\", { exit: 1 });\n    }\n    var stats = fs.statSync(dataFile);\n    var fileSizeInBytes = stats.size;\n    logger.info(\"Processing \" + clc.bold(dataFile) + \" (\" + fileSizeInBytes + \" bytes)\");\n    var inStream = fs.createReadStream(dataFile);\n    var batches = [];\n    var currentBatch = [];\n    var counter = 0;\n    return new Promise(function (resolve, reject) {\n        var parser;\n        if (dataFile.endsWith(\".csv\")) {\n            parser = csv({ objectMode: true });\n            parser\n                .on(\"data\", function (line) {\n                counter++;\n                var user = transArrayToUser(line.map(function (str) {\n                    var newStr = str.trim().replace(/^[\"|'](.*)[\"|']$/, \"$1\");\n                    return newStr === \"\" ? undefined : newStr;\n                }));\n                if (user.error) {\n                    return reject(\"Line \" + counter + \" (\" + line + \") has invalid data format: \" + user.error);\n                }\n                currentBatch.push(user);\n                if (currentBatch.length === MAX_BATCH_SIZE) {\n                    batches.push(currentBatch);\n                    currentBatch = [];\n                }\n            })\n                .on(\"end\", function () {\n                if (currentBatch.length) {\n                    batches.push(currentBatch);\n                }\n                return resolve(batches);\n            });\n            inStream.pipe(parser);\n        }\n        else {\n            parser = jsonStream.parse([\"users\", { emitKey: true }]);\n            parser\n                .on(\"data\", function (pair) {\n                counter++;\n                var res = validateUserJson(pair.value);\n                if (res.error) {\n                    return reject(res.error);\n                }\n                currentBatch.push(pair.value);\n                if (currentBatch.length === MAX_BATCH_SIZE) {\n                    batches.push(currentBatch);\n                    currentBatch = [];\n                }\n            })\n                .on(\"end\", function () {\n                if (currentBatch.length) {\n                    batches.push(currentBatch);\n                }\n                return resolve(batches);\n            });\n            inStream.pipe(parser);\n        }\n    }).then(function (userListArr) {\n        logger.debug(\"Preparing to import\", counter, \"user records in\", userListArr.length, \"batches.\");\n        if (userListArr.length) {\n            return serialImportUsers(projectId, hashOptions, userListArr, 0);\n        }\n    }, function (error) {\n        return utils.reject(error, { exit: 1 });\n    });\n});\n"]},"metadata":{},"sourceType":"script"}