{"ast":null,"code":"var util = require('util'),\n    Match = require('../match');\n/**\n * Binary search implementation (recursive)\n */\n\n\nfunction binarySearch(arr, searchValue) {\n  function find(arr, searchValue, left, right) {\n    if (right < left) return -1;\n    /*\n    int mid = mid = (left + right) / 2;\n    There is a bug in the above line;\n    Joshua Bloch suggests the following replacement:\n    */\n\n    var mid = Math.floor(left + right >>> 1);\n    if (searchValue > arr[mid]) return find(arr, searchValue, mid + 1, right);\n    if (searchValue < arr[mid]) return find(arr, searchValue, left, mid - 1);\n    return mid;\n  }\n\n  ;\n  return find(arr, searchValue, 0, arr.length - 1);\n}\n\n; // 'Character'  iterated character class.\n//    Recognizers for specific mbcs encodings make their 'characters' available\n//    by providing a nextChar() function that fills in an instance of iteratedChar\n//    with the next char from the input.\n//    The returned characters are not converted to Unicode, but remain as the raw\n//    bytes (concatenated into an int) from the codepage data.\n//\n//  For Asian charsets, use the raw input rather than the input that has been\n//   stripped of markup.  Detection only considers multi-byte chars, effectively\n//   stripping markup anyway, and double byte chars do occur in markup too.\n//\n\nfunction IteratedChar() {\n  this.charValue = 0; // 1-4 bytes from the raw input data\n\n  this.index = 0;\n  this.nextIndex = 0;\n  this.error = false;\n  this.done = false;\n\n  this.reset = function () {\n    this.charValue = 0;\n    this.index = -1;\n    this.nextIndex = 0;\n    this.error = false;\n    this.done = false;\n  };\n\n  this.nextByte = function (det) {\n    if (this.nextIndex >= det.fRawLength) {\n      this.done = true;\n      return -1;\n    }\n\n    var byteValue = det.fRawInput[this.nextIndex++] & 0x00ff;\n    return byteValue;\n  };\n}\n\n;\n/**\n * Asian double or multi-byte - charsets.\n * Match is determined mostly by the input data adhering to the\n * encoding scheme for the charset, and, optionally,\n * frequency-of-occurence of characters.\n */\n\nfunction mbcs() {}\n\n;\n/**\n * Test the match of this charset with the input text data\n *      which is obtained via the CharsetDetector object.\n *\n * @param det  The CharsetDetector, which contains the input text\n *             to be checked for being in this charset.\n * @return     Two values packed into one int  (Damn java, anyhow)\n *             bits 0-7:  the match confidence, ranging from 0-100\n *             bits 8-15: The match reason, an enum-like value.\n */\n\nmbcs.prototype.match = function (det) {\n  var singleByteCharCount = 0,\n      //TODO Do we really need this?\n  doubleByteCharCount = 0,\n      commonCharCount = 0,\n      badCharCount = 0,\n      totalCharCount = 0,\n      confidence = 0;\n  var iter = new IteratedChar();\n\n  detectBlock: {\n    for (iter.reset(); this.nextChar(iter, det);) {\n      totalCharCount++;\n\n      if (iter.error) {\n        badCharCount++;\n      } else {\n        var cv = iter.charValue & 0xFFFFFFFF;\n\n        if (cv <= 0xff) {\n          singleByteCharCount++;\n        } else {\n          doubleByteCharCount++;\n\n          if (this.commonChars != null) {\n            // NOTE: This assumes that there are no 4-byte common chars.\n            if (binarySearch(this.commonChars, cv) >= 0) {\n              commonCharCount++;\n            }\n          }\n        }\n      }\n\n      if (badCharCount >= 2 && badCharCount * 5 >= doubleByteCharCount) {\n        // console.log('its here!')\n        // Bail out early if the byte data is not matching the encoding scheme.\n        break detectBlock;\n      }\n    }\n\n    if (doubleByteCharCount <= 10 && badCharCount == 0) {\n      // Not many multi-byte chars.\n      if (doubleByteCharCount == 0 && totalCharCount < 10) {\n        // There weren't any multibyte sequences, and there was a low density of non-ASCII single bytes.\n        // We don't have enough data to have any confidence.\n        // Statistical analysis of single byte non-ASCII charcters would probably help here.\n        confidence = 0;\n      } else {\n        //   ASCII or ISO file?  It's probably not our encoding,\n        //   but is not incompatible with our encoding, so don't give it a zero.\n        confidence = 10;\n      }\n\n      break detectBlock;\n    } //\n    //  No match if there are too many characters that don't fit the encoding scheme.\n    //    (should we have zero tolerance for these?)\n    //\n\n\n    if (doubleByteCharCount < 20 * badCharCount) {\n      confidence = 0;\n      break detectBlock;\n    }\n\n    if (this.commonChars == null) {\n      // We have no statistics on frequently occuring characters.\n      //  Assess confidence purely on having a reasonable number of\n      //  multi-byte characters (the more the better\n      confidence = 30 + doubleByteCharCount - 20 * badCharCount;\n\n      if (confidence > 100) {\n        confidence = 100;\n      }\n    } else {\n      //\n      // Frequency of occurence statistics exist.\n      //\n      var maxVal = Math.log(parseFloat(doubleByteCharCount) / 4);\n      var scaleFactor = 90.0 / maxVal;\n      confidence = Math.floor(Math.log(commonCharCount + 1) * scaleFactor + 10);\n      confidence = Math.min(confidence, 100);\n    }\n  } // end of detectBlock:\n\n\n  return confidence == 0 ? null : new Match(det, this, confidence);\n};\n/**\n * Get the next character (however many bytes it is) from the input data\n *    Subclasses for specific charset encodings must implement this function\n *    to get characters according to the rules of their encoding scheme.\n *\n *  This function is not a method of class iteratedChar only because\n *   that would require a lot of extra derived classes, which is awkward.\n * @param it  The iteratedChar 'struct' into which the returned char is placed.\n * @param det The charset detector, which is needed to get at the input byte data\n *            being iterated over.\n * @return    True if a character was returned, false at end of input.\n */\n\n\nmbcs.prototype.nextChar = function (iter, det) {};\n/**\n * Shift-JIS charset recognizer.\n */\n\n\nmodule.exports.sjis = function () {\n  this.name = function () {\n    return 'Shift-JIS';\n  };\n\n  this.language = function () {\n    return 'ja';\n  }; // TODO:  This set of data comes from the character frequency-\n  //        of-occurence analysis tool.  The data needs to be moved\n  //        into a resource and loaded from there.\n\n\n  this.commonChars = [0x8140, 0x8141, 0x8142, 0x8145, 0x815b, 0x8169, 0x816a, 0x8175, 0x8176, 0x82a0, 0x82a2, 0x82a4, 0x82a9, 0x82aa, 0x82ab, 0x82ad, 0x82af, 0x82b1, 0x82b3, 0x82b5, 0x82b7, 0x82bd, 0x82be, 0x82c1, 0x82c4, 0x82c5, 0x82c6, 0x82c8, 0x82c9, 0x82cc, 0x82cd, 0x82dc, 0x82e0, 0x82e7, 0x82e8, 0x82e9, 0x82ea, 0x82f0, 0x82f1, 0x8341, 0x8343, 0x834e, 0x834f, 0x8358, 0x835e, 0x8362, 0x8367, 0x8375, 0x8376, 0x8389, 0x838a, 0x838b, 0x838d, 0x8393, 0x8e96, 0x93fa, 0x95aa];\n\n  this.nextChar = function (iter, det) {\n    iter.index = iter.nextIndex;\n    iter.error = false;\n    var firstByte;\n    firstByte = iter.charValue = iter.nextByte(det);\n    if (firstByte < 0) return false;\n    if (firstByte <= 0x7f || firstByte > 0xa0 && firstByte <= 0xdf) return true;\n    var secondByte = iter.nextByte(det);\n    if (secondByte < 0) return false;\n    iter.charValue = firstByte << 8 | secondByte;\n\n    if (!(secondByte >= 0x40 && secondByte <= 0x7f || secondByte >= 0x80 && secondByte <= 0xff)) {\n      // Illegal second byte value.\n      iter.error = true;\n    }\n\n    return true;\n  };\n};\n\nutil.inherits(module.exports.sjis, mbcs);\n/**\n *   Big5 charset recognizer.\n */\n\nmodule.exports.big5 = function () {\n  this.name = function () {\n    return 'Big5';\n  };\n\n  this.language = function () {\n    return 'zh';\n  }; // TODO:  This set of data comes from the character frequency-\n  //        of-occurence analysis tool.  The data needs to be moved\n  //        into a resource and loaded from there.\n\n\n  this.commonChars = [0xa140, 0xa141, 0xa142, 0xa143, 0xa147, 0xa149, 0xa175, 0xa176, 0xa440, 0xa446, 0xa447, 0xa448, 0xa451, 0xa454, 0xa457, 0xa464, 0xa46a, 0xa46c, 0xa477, 0xa4a3, 0xa4a4, 0xa4a7, 0xa4c1, 0xa4ce, 0xa4d1, 0xa4df, 0xa4e8, 0xa4fd, 0xa540, 0xa548, 0xa558, 0xa569, 0xa5cd, 0xa5e7, 0xa657, 0xa661, 0xa662, 0xa668, 0xa670, 0xa6a8, 0xa6b3, 0xa6b9, 0xa6d3, 0xa6db, 0xa6e6, 0xa6f2, 0xa740, 0xa751, 0xa759, 0xa7da, 0xa8a3, 0xa8a5, 0xa8ad, 0xa8d1, 0xa8d3, 0xa8e4, 0xa8fc, 0xa9c0, 0xa9d2, 0xa9f3, 0xaa6b, 0xaaba, 0xaabe, 0xaacc, 0xaafc, 0xac47, 0xac4f, 0xacb0, 0xacd2, 0xad59, 0xaec9, 0xafe0, 0xb0ea, 0xb16f, 0xb2b3, 0xb2c4, 0xb36f, 0xb44c, 0xb44e, 0xb54c, 0xb5a5, 0xb5bd, 0xb5d0, 0xb5d8, 0xb671, 0xb7ed, 0xb867, 0xb944, 0xbad8, 0xbb44, 0xbba1, 0xbdd1, 0xc2c4, 0xc3b9, 0xc440, 0xc45f];\n\n  this.nextChar = function (iter, det) {\n    iter.index = iter.nextIndex;\n    iter.error = false;\n    var firstByte = iter.charValue = iter.nextByte(det);\n    if (firstByte < 0) return false; // single byte character.\n\n    if (firstByte <= 0x7f || firstByte == 0xff) return true;\n    var secondByte = iter.nextByte(det);\n    if (secondByte < 0) return false;\n    iter.charValue = iter.charValue << 8 | secondByte;\n    if (secondByte < 0x40 || secondByte == 0x7f || secondByte == 0xff) iter.error = true;\n    return true;\n  };\n};\n\nutil.inherits(module.exports.big5, mbcs);\n/**\n *  EUC charset recognizers.  One abstract class that provides the common function\n *  for getting the next character according to the EUC encoding scheme,\n *  and nested derived classes for EUC_KR, EUC_JP, EUC_CN.\n *\n *  Get the next character value for EUC based encodings.\n *  Character 'value' is simply the raw bytes that make up the character\n *     packed into an int.\n */\n\nfunction eucNextChar(iter, det) {\n  iter.index = iter.nextIndex;\n  iter.error = false;\n  var firstByte = 0;\n  var secondByte = 0;\n  var thirdByte = 0; //int fourthByte = 0;\n\n  buildChar: {\n    firstByte = iter.charValue = iter.nextByte(det);\n\n    if (firstByte < 0) {\n      // Ran off the end of the input data\n      iter.done = true;\n      break buildChar;\n    }\n\n    if (firstByte <= 0x8d) {\n      // single byte char\n      break buildChar;\n    }\n\n    secondByte = iter.nextByte(det);\n    iter.charValue = iter.charValue << 8 | secondByte;\n\n    if (firstByte >= 0xA1 && firstByte <= 0xfe) {\n      // Two byte Char\n      if (secondByte < 0xa1) {\n        iter.error = true;\n      }\n\n      break buildChar;\n    }\n\n    if (firstByte == 0x8e) {\n      // Code Set 2.\n      //   In EUC-JP, total char size is 2 bytes, only one byte of actual char value.\n      //   In EUC-TW, total char size is 4 bytes, three bytes contribute to char value.\n      // We don't know which we've got.\n      // Treat it like EUC-JP.  If the data really was EUC-TW, the following two\n      //   bytes will look like a well formed 2 byte char.\n      if (secondByte < 0xa1) {\n        iter.error = true;\n      }\n\n      break buildChar;\n    }\n\n    if (firstByte == 0x8f) {\n      // Code set 3.\n      // Three byte total char size, two bytes of actual char value.\n      thirdByte = iter.nextByte(det);\n      iter.charValue = iter.charValue << 8 | thirdByte;\n\n      if (thirdByte < 0xa1) {\n        iter.error = true;\n      }\n    }\n  }\n\n  return iter.done == false;\n}\n\n;\n/**\n * The charset recognize for EUC-JP.  A singleton instance of this class\n *    is created and kept by the public CharsetDetector class\n */\n\nmodule.exports.euc_jp = function () {\n  this.name = function () {\n    return 'EUC-JP';\n  };\n\n  this.language = function () {\n    return 'ja';\n  }; // TODO:  This set of data comes from the character frequency-\n  //        of-occurence analysis tool.  The data needs to be moved\n  //        into a resource and loaded from there.\n\n\n  this.commonChars = [0xa1a1, 0xa1a2, 0xa1a3, 0xa1a6, 0xa1bc, 0xa1ca, 0xa1cb, 0xa1d6, 0xa1d7, 0xa4a2, 0xa4a4, 0xa4a6, 0xa4a8, 0xa4aa, 0xa4ab, 0xa4ac, 0xa4ad, 0xa4af, 0xa4b1, 0xa4b3, 0xa4b5, 0xa4b7, 0xa4b9, 0xa4bb, 0xa4bd, 0xa4bf, 0xa4c0, 0xa4c1, 0xa4c3, 0xa4c4, 0xa4c6, 0xa4c7, 0xa4c8, 0xa4c9, 0xa4ca, 0xa4cb, 0xa4ce, 0xa4cf, 0xa4d0, 0xa4de, 0xa4df, 0xa4e1, 0xa4e2, 0xa4e4, 0xa4e8, 0xa4e9, 0xa4ea, 0xa4eb, 0xa4ec, 0xa4ef, 0xa4f2, 0xa4f3, 0xa5a2, 0xa5a3, 0xa5a4, 0xa5a6, 0xa5a7, 0xa5aa, 0xa5ad, 0xa5af, 0xa5b0, 0xa5b3, 0xa5b5, 0xa5b7, 0xa5b8, 0xa5b9, 0xa5bf, 0xa5c3, 0xa5c6, 0xa5c7, 0xa5c8, 0xa5c9, 0xa5cb, 0xa5d0, 0xa5d5, 0xa5d6, 0xa5d7, 0xa5de, 0xa5e0, 0xa5e1, 0xa5e5, 0xa5e9, 0xa5ea, 0xa5eb, 0xa5ec, 0xa5ed, 0xa5f3, 0xb8a9, 0xb9d4, 0xbaee, 0xbbc8, 0xbef0, 0xbfb7, 0xc4ea, 0xc6fc, 0xc7bd, 0xcab8, 0xcaf3, 0xcbdc, 0xcdd1];\n  this.nextChar = eucNextChar;\n};\n\nutil.inherits(module.exports.euc_jp, mbcs);\n/**\n * The charset recognize for EUC-KR.  A singleton instance of this class\n *    is created and kept by the public CharsetDetector class\n */\n\nmodule.exports.euc_kr = function () {\n  this.name = function () {\n    return 'EUC-KR';\n  };\n\n  this.language = function () {\n    return 'ko';\n  }; // TODO:  This set of data comes from the character frequency-\n  //        of-occurence analysis tool.  The data needs to be moved\n  //        into a resource and loaded from there.\n\n\n  this.commonChars = [0xb0a1, 0xb0b3, 0xb0c5, 0xb0cd, 0xb0d4, 0xb0e6, 0xb0ed, 0xb0f8, 0xb0fa, 0xb0fc, 0xb1b8, 0xb1b9, 0xb1c7, 0xb1d7, 0xb1e2, 0xb3aa, 0xb3bb, 0xb4c2, 0xb4cf, 0xb4d9, 0xb4eb, 0xb5a5, 0xb5b5, 0xb5bf, 0xb5c7, 0xb5e9, 0xb6f3, 0xb7af, 0xb7c2, 0xb7ce, 0xb8a6, 0xb8ae, 0xb8b6, 0xb8b8, 0xb8bb, 0xb8e9, 0xb9ab, 0xb9ae, 0xb9cc, 0xb9ce, 0xb9fd, 0xbab8, 0xbace, 0xbad0, 0xbaf1, 0xbbe7, 0xbbf3, 0xbbfd, 0xbcad, 0xbcba, 0xbcd2, 0xbcf6, 0xbdba, 0xbdc0, 0xbdc3, 0xbdc5, 0xbec6, 0xbec8, 0xbedf, 0xbeee, 0xbef8, 0xbefa, 0xbfa1, 0xbfa9, 0xbfc0, 0xbfe4, 0xbfeb, 0xbfec, 0xbff8, 0xc0a7, 0xc0af, 0xc0b8, 0xc0ba, 0xc0bb, 0xc0bd, 0xc0c7, 0xc0cc, 0xc0ce, 0xc0cf, 0xc0d6, 0xc0da, 0xc0e5, 0xc0fb, 0xc0fc, 0xc1a4, 0xc1a6, 0xc1b6, 0xc1d6, 0xc1df, 0xc1f6, 0xc1f8, 0xc4a1, 0xc5cd, 0xc6ae, 0xc7cf, 0xc7d1, 0xc7d2, 0xc7d8, 0xc7e5, 0xc8ad];\n  this.nextChar = eucNextChar;\n};\n\nutil.inherits(module.exports.euc_kr, mbcs);\n/**\n *   GB-18030 recognizer. Uses simplified Chinese statistics.\n */\n\nmodule.exports.gb_18030 = function () {\n  this.name = function () {\n    return 'GB18030';\n  };\n\n  this.language = function () {\n    return 'zh';\n  };\n  /*\n   *  Get the next character value for EUC based encodings.\n   *  Character 'value' is simply the raw bytes that make up the character\n   *     packed into an int.\n   */\n\n\n  this.nextChar = function (iter, det) {\n    iter.index = iter.nextIndex;\n    iter.error = false;\n    var firstByte = 0;\n    var secondByte = 0;\n    var thirdByte = 0;\n    var fourthByte = 0;\n\n    buildChar: {\n      firstByte = iter.charValue = iter.nextByte(det);\n\n      if (firstByte < 0) {\n        // Ran off the end of the input data\n        iter.done = true;\n        break buildChar;\n      }\n\n      if (firstByte <= 0x80) {\n        // single byte char\n        break buildChar;\n      }\n\n      secondByte = iter.nextByte(det);\n      iter.charValue = iter.charValue << 8 | secondByte;\n\n      if (firstByte >= 0x81 && firstByte <= 0xFE) {\n        // Two byte Char\n        if (secondByte >= 0x40 && secondByte <= 0x7E || secondByte >= 80 && secondByte <= 0xFE) {\n          break buildChar;\n        } // Four byte char\n\n\n        if (secondByte >= 0x30 && secondByte <= 0x39) {\n          thirdByte = iter.nextByte(det);\n\n          if (thirdByte >= 0x81 && thirdByte <= 0xFE) {\n            fourthByte = iter.nextByte(det);\n\n            if (fourthByte >= 0x30 && fourthByte <= 0x39) {\n              iter.charValue = iter.charValue << 16 | thirdByte << 8 | fourthByte;\n              break buildChar;\n            }\n          }\n        }\n\n        iter.error = true;\n        break buildChar;\n      }\n    }\n\n    return iter.done == false;\n  }; // TODO:  This set of data comes from the character frequency-\n  //        of-occurence analysis tool.  The data needs to be moved\n  //        into a resource and loaded from there.\n\n\n  this.commonChars = [0xa1a1, 0xa1a2, 0xa1a3, 0xa1a4, 0xa1b0, 0xa1b1, 0xa1f1, 0xa1f3, 0xa3a1, 0xa3ac, 0xa3ba, 0xb1a8, 0xb1b8, 0xb1be, 0xb2bb, 0xb3c9, 0xb3f6, 0xb4f3, 0xb5bd, 0xb5c4, 0xb5e3, 0xb6af, 0xb6d4, 0xb6e0, 0xb7a2, 0xb7a8, 0xb7bd, 0xb7d6, 0xb7dd, 0xb8b4, 0xb8df, 0xb8f6, 0xb9ab, 0xb9c9, 0xb9d8, 0xb9fa, 0xb9fd, 0xbacd, 0xbba7, 0xbbd6, 0xbbe1, 0xbbfa, 0xbcbc, 0xbcdb, 0xbcfe, 0xbdcc, 0xbecd, 0xbedd, 0xbfb4, 0xbfc6, 0xbfc9, 0xc0b4, 0xc0ed, 0xc1cb, 0xc2db, 0xc3c7, 0xc4dc, 0xc4ea, 0xc5cc, 0xc6f7, 0xc7f8, 0xc8ab, 0xc8cb, 0xc8d5, 0xc8e7, 0xc9cf, 0xc9fa, 0xcab1, 0xcab5, 0xcac7, 0xcad0, 0xcad6, 0xcaf5, 0xcafd, 0xccec, 0xcdf8, 0xceaa, 0xcec4, 0xced2, 0xcee5, 0xcfb5, 0xcfc2, 0xcfd6, 0xd0c2, 0xd0c5, 0xd0d0, 0xd0d4, 0xd1a7, 0xd2aa, 0xd2b2, 0xd2b5, 0xd2bb, 0xd2d4, 0xd3c3, 0xd3d0, 0xd3fd, 0xd4c2, 0xd4da, 0xd5e2, 0xd6d0];\n};\n\nutil.inherits(module.exports.gb_18030, mbcs);","map":{"version":3,"sources":["/home/dev/Documentos/Projects/github-clone/node_modules/chardet/encoding/mbcs.js"],"names":["util","require","Match","binarySearch","arr","searchValue","find","left","right","mid","Math","floor","length","IteratedChar","charValue","index","nextIndex","error","done","reset","nextByte","det","fRawLength","byteValue","fRawInput","mbcs","prototype","match","singleByteCharCount","doubleByteCharCount","commonCharCount","badCharCount","totalCharCount","confidence","iter","detectBlock","nextChar","cv","commonChars","maxVal","log","parseFloat","scaleFactor","min","module","exports","sjis","name","language","firstByte","secondByte","inherits","big5","eucNextChar","thirdByte","buildChar","euc_jp","euc_kr","gb_18030","fourthByte"],"mappings":"AAAA,IAAIA,IAAI,GAAGC,OAAO,CAAC,MAAD,CAAlB;AAAA,IACEC,KAAK,GAAGD,OAAO,CAAE,UAAF,CADjB;AAGA;AACA;AACA;;;AACA,SAASE,YAAT,CAAsBC,GAAtB,EAA2BC,WAA3B,EAAwC;AACtC,WAASC,IAAT,CAAcF,GAAd,EAAmBC,WAAnB,EAAgCE,IAAhC,EAAsCC,KAAtC,EAA6C;AAC3C,QAAIA,KAAK,GAAGD,IAAZ,EACE,OAAO,CAAC,CAAR;AAEF;AACJ;AACA;AACA;AACA;;AACI,QAAIE,GAAG,GAAGC,IAAI,CAACC,KAAL,CAAYJ,IAAI,GAAGC,KAAR,KAAmB,CAA9B,CAAV;AACA,QAAIH,WAAW,GAAGD,GAAG,CAACK,GAAD,CAArB,EACE,OAAOH,IAAI,CAACF,GAAD,EAAMC,WAAN,EAAmBI,GAAG,GAAG,CAAzB,EAA4BD,KAA5B,CAAX;AAEF,QAAIH,WAAW,GAAGD,GAAG,CAACK,GAAD,CAArB,EACE,OAAOH,IAAI,CAACF,GAAD,EAAMC,WAAN,EAAmBE,IAAnB,EAAyBE,GAAG,GAAG,CAA/B,CAAX;AAEF,WAAOA,GAAP;AACD;;AAAA;AAED,SAAOH,IAAI,CAACF,GAAD,EAAMC,WAAN,EAAmB,CAAnB,EAAsBD,GAAG,CAACQ,MAAJ,GAAa,CAAnC,CAAX;AACD;;AAAA,C,CAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,YAAT,GAAwB;AAEtB,OAAKC,SAAL,GAAiB,CAAjB,CAFsB,CAEF;;AACpB,OAAKC,KAAL,GAAiB,CAAjB;AACA,OAAKC,SAAL,GAAiB,CAAjB;AACA,OAAKC,KAAL,GAAiB,KAAjB;AACA,OAAKC,IAAL,GAAiB,KAAjB;;AAEA,OAAKC,KAAL,GAAa,YAAW;AACtB,SAAKL,SAAL,GAAiB,CAAjB;AACA,SAAKC,KAAL,GAAiB,CAAC,CAAlB;AACA,SAAKC,SAAL,GAAiB,CAAjB;AACA,SAAKC,KAAL,GAAiB,KAAjB;AACA,SAAKC,IAAL,GAAiB,KAAjB;AACD,GAND;;AAQA,OAAKE,QAAL,GAAgB,UAASC,GAAT,EAAc;AAC5B,QAAI,KAAKL,SAAL,IAAkBK,GAAG,CAACC,UAA1B,EAAsC;AACpC,WAAKJ,IAAL,GAAY,IAAZ;AACA,aAAO,CAAC,CAAR;AACD;;AACD,QAAIK,SAAS,GAAGF,GAAG,CAACG,SAAJ,CAAc,KAAKR,SAAL,EAAd,IAAkC,MAAlD;AACA,WAAOO,SAAP;AACD,GAPD;AAQD;;AAAA;AAID;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASE,IAAT,GAAgB,CAAE;;AAAA;AAElB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAA,IAAI,CAACC,SAAL,CAAeC,KAAf,GAAuB,UAASN,GAAT,EAAc;AAEnC,MAAIO,mBAAmB,GAAG,CAA1B;AAAA,MAA8B;AAC5BC,EAAAA,mBAAmB,GAAG,CADxB;AAAA,MAEEC,eAAe,GAAO,CAFxB;AAAA,MAGEC,YAAY,GAAU,CAHxB;AAAA,MAIEC,cAAc,GAAQ,CAJxB;AAAA,MAKEC,UAAU,GAAY,CALxB;AAOA,MAAIC,IAAI,GAAG,IAAIrB,YAAJ,EAAX;;AAEAsB,EAAAA,WAAW,EAAE;AACX,SAAKD,IAAI,CAACf,KAAL,EAAL,EAAmB,KAAKiB,QAAL,CAAcF,IAAd,EAAoBb,GAApB,CAAnB,GAA8C;AAC5CW,MAAAA,cAAc;;AACd,UAAIE,IAAI,CAACjB,KAAT,EAAgB;AACdc,QAAAA,YAAY;AACb,OAFD,MAEO;AACL,YAAIM,EAAE,GAAGH,IAAI,CAACpB,SAAL,GAAiB,UAA1B;;AAEA,YAAIuB,EAAE,IAAI,IAAV,EAAgB;AACdT,UAAAA,mBAAmB;AACpB,SAFD,MAEO;AACLC,UAAAA,mBAAmB;;AACnB,cAAI,KAAKS,WAAL,IAAoB,IAAxB,EAA8B;AAC5B;AACA,gBAAInC,YAAY,CAAC,KAAKmC,WAAN,EAAmBD,EAAnB,CAAZ,IAAsC,CAA1C,EAA6C;AAC3CP,cAAAA,eAAe;AAChB;AACF;AACF;AACF;;AACD,UAAIC,YAAY,IAAI,CAAhB,IAAqBA,YAAY,GAAG,CAAf,IAAoBF,mBAA7C,EAAkE;AAChE;AACA;AACA,cAAMM,WAAN;AACD;AACF;;AAED,QAAIN,mBAAmB,IAAI,EAAvB,IAA6BE,YAAY,IAAG,CAAhD,EAAmD;AACjD;AACA,UAAIF,mBAAmB,IAAI,CAAvB,IAA4BG,cAAc,GAAG,EAAjD,EAAqD;AACnD;AACA;AACA;AACAC,QAAAA,UAAU,GAAG,CAAb;AACD,OALD,MAMK;AACH;AACA;AACAA,QAAAA,UAAU,GAAG,EAAb;AACD;;AACD,YAAME,WAAN;AACD,KAzCU,CA2CX;AACA;AACA;AACA;;;AACA,QAAIN,mBAAmB,GAAG,KAAKE,YAA/B,EAA6C;AAC3CE,MAAAA,UAAU,GAAG,CAAb;AACA,YAAME,WAAN;AACD;;AAED,QAAI,KAAKG,WAAL,IAAoB,IAAxB,EAA8B;AAC5B;AACA;AACA;AACAL,MAAAA,UAAU,GAAG,KAAKJ,mBAAL,GAA2B,KAAKE,YAA7C;;AACA,UAAIE,UAAU,GAAG,GAAjB,EAAsB;AACpBA,QAAAA,UAAU,GAAG,GAAb;AACD;AACF,KARD,MAQO;AACL;AACA;AACA;AACA,UAAIM,MAAM,GAAG7B,IAAI,CAAC8B,GAAL,CAASC,UAAU,CAACZ,mBAAD,CAAV,GAAkC,CAA3C,CAAb;AACA,UAAIa,WAAW,GAAG,OAAOH,MAAzB;AACAN,MAAAA,UAAU,GAAGvB,IAAI,CAACC,KAAL,CAAWD,IAAI,CAAC8B,GAAL,CAASV,eAAe,GAAG,CAA3B,IAAgCY,WAAhC,GAA8C,EAAzD,CAAb;AACAT,MAAAA,UAAU,GAAGvB,IAAI,CAACiC,GAAL,CAASV,UAAT,EAAqB,GAArB,CAAb;AACD;AACF,GAhFkC,CAgF/B;;;AAEJ,SAAOA,UAAU,IAAI,CAAd,GAAkB,IAAlB,GAAyB,IAAI/B,KAAJ,CAAUmB,GAAV,EAAe,IAAf,EAAqBY,UAArB,CAAhC;AACD,CAnFD;AAqFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEAR,IAAI,CAACC,SAAL,CAAeU,QAAf,GAA0B,UAASF,IAAT,EAAeb,GAAf,EAAoB,CAAE,CAAhD;AAIA;AACA;AACA;;;AACAuB,MAAM,CAACC,OAAP,CAAeC,IAAf,GAAsB,YAAW;AAC/B,OAAKC,IAAL,GAAY,YAAW;AACrB,WAAO,WAAP;AACD,GAFD;;AAGA,OAAKC,QAAL,GAAgB,YAAW;AACzB,WAAO,IAAP;AACD,GAFD,CAJ+B,CAQ/B;AACA;AACA;;;AACA,OAAKV,WAAL,GAAmB,CACjB,MADiB,EACT,MADS,EACD,MADC,EACO,MADP,EACe,MADf,EACuB,MADvB,EAC+B,MAD/B,EACuC,MADvC,EAC+C,MAD/C,EACuD,MADvD,EAEjB,MAFiB,EAET,MAFS,EAED,MAFC,EAEO,MAFP,EAEe,MAFf,EAEuB,MAFvB,EAE+B,MAF/B,EAEuC,MAFvC,EAE+C,MAF/C,EAEuD,MAFvD,EAGjB,MAHiB,EAGT,MAHS,EAGD,MAHC,EAGO,MAHP,EAGe,MAHf,EAGuB,MAHvB,EAG+B,MAH/B,EAGuC,MAHvC,EAG+C,MAH/C,EAGuD,MAHvD,EAIjB,MAJiB,EAIT,MAJS,EAID,MAJC,EAIO,MAJP,EAIe,MAJf,EAIuB,MAJvB,EAI+B,MAJ/B,EAIuC,MAJvC,EAI+C,MAJ/C,EAIuD,MAJvD,EAKjB,MALiB,EAKT,MALS,EAKD,MALC,EAKO,MALP,EAKe,MALf,EAKuB,MALvB,EAK+B,MAL/B,EAKuC,MALvC,EAK+C,MAL/C,EAKuD,MALvD,EAMjB,MANiB,EAMT,MANS,EAMD,MANC,EAMO,MANP,EAMe,MANf,EAMuB,MANvB,EAM+B,MAN/B,CAAnB;;AASA,OAAKF,QAAL,GAAgB,UAASF,IAAT,EAAeb,GAAf,EAAoB;AAClCa,IAAAA,IAAI,CAACnB,KAAL,GAAamB,IAAI,CAAClB,SAAlB;AACAkB,IAAAA,IAAI,CAACjB,KAAL,GAAa,KAAb;AAEA,QAAIgC,SAAJ;AACAA,IAAAA,SAAS,GAAGf,IAAI,CAACpB,SAAL,GAAiBoB,IAAI,CAACd,QAAL,CAAcC,GAAd,CAA7B;AACA,QAAI4B,SAAS,GAAG,CAAhB,EACE,OAAO,KAAP;AAEF,QAAIA,SAAS,IAAI,IAAb,IAAsBA,SAAS,GAAG,IAAZ,IAAoBA,SAAS,IAAI,IAA3D,EACE,OAAO,IAAP;AAEF,QAAIC,UAAU,GAAGhB,IAAI,CAACd,QAAL,CAAcC,GAAd,CAAjB;AACA,QAAI6B,UAAU,GAAG,CAAjB,EACE,OAAO,KAAP;AAEFhB,IAAAA,IAAI,CAACpB,SAAL,GAAkBmC,SAAS,IAAI,CAAd,GAAmBC,UAApC;;AACA,QAAI,EAAIA,UAAU,IAAI,IAAd,IAAsBA,UAAU,IAAI,IAArC,IAA+CA,UAAU,IAAI,IAAd,IAAsBA,UAAU,IAAI,IAAtF,CAAJ,EAAkG;AAChG;AACAhB,MAAAA,IAAI,CAACjB,KAAL,GAAa,IAAb;AACD;;AACD,WAAO,IAAP;AACD,GAtBD;AAuBD,CA3CD;;AA4CAjB,IAAI,CAACmD,QAAL,CAAcP,MAAM,CAACC,OAAP,CAAeC,IAA7B,EAAmCrB,IAAnC;AAIA;AACA;AACA;;AACAmB,MAAM,CAACC,OAAP,CAAeO,IAAf,GAAsB,YAAW;AAC/B,OAAKL,IAAL,GAAY,YAAW;AACrB,WAAO,MAAP;AACD,GAFD;;AAGA,OAAKC,QAAL,GAAgB,YAAW;AACzB,WAAO,IAAP;AACD,GAFD,CAJ+B,CAO/B;AACA;AACA;;;AACA,OAAKV,WAAL,GAAmB,CACjB,MADiB,EACT,MADS,EACD,MADC,EACO,MADP,EACe,MADf,EACuB,MADvB,EAC+B,MAD/B,EACuC,MADvC,EAC+C,MAD/C,EACuD,MADvD,EAEjB,MAFiB,EAET,MAFS,EAED,MAFC,EAEO,MAFP,EAEe,MAFf,EAEuB,MAFvB,EAE+B,MAF/B,EAEuC,MAFvC,EAE+C,MAF/C,EAEuD,MAFvD,EAGjB,MAHiB,EAGT,MAHS,EAGD,MAHC,EAGO,MAHP,EAGe,MAHf,EAGuB,MAHvB,EAG+B,MAH/B,EAGuC,MAHvC,EAG+C,MAH/C,EAGuD,MAHvD,EAIjB,MAJiB,EAIT,MAJS,EAID,MAJC,EAIO,MAJP,EAIe,MAJf,EAIuB,MAJvB,EAI+B,MAJ/B,EAIuC,MAJvC,EAI+C,MAJ/C,EAIuD,MAJvD,EAKjB,MALiB,EAKT,MALS,EAKD,MALC,EAKO,MALP,EAKe,MALf,EAKuB,MALvB,EAK+B,MAL/B,EAKuC,MALvC,EAK+C,MAL/C,EAKuD,MALvD,EAMjB,MANiB,EAMT,MANS,EAMD,MANC,EAMO,MANP,EAMe,MANf,EAMuB,MANvB,EAM+B,MAN/B,EAMuC,MANvC,EAM+C,MAN/C,EAMuD,MANvD,EAOjB,MAPiB,EAOT,MAPS,EAOD,MAPC,EAOO,MAPP,EAOe,MAPf,EAOuB,MAPvB,EAO+B,MAP/B,EAOuC,MAPvC,EAO+C,MAP/C,EAOuD,MAPvD,EAQjB,MARiB,EAQT,MARS,EAQD,MARC,EAQO,MARP,EAQe,MARf,EAQuB,MARvB,EAQ+B,MAR/B,EAQuC,MARvC,EAQ+C,MAR/C,EAQuD,MARvD,EASjB,MATiB,EAST,MATS,EASD,MATC,EASO,MATP,EASe,MATf,EASuB,MATvB,EAS+B,MAT/B,EASuC,MATvC,EAS+C,MAT/C,EASuD,MATvD,EAUjB,MAViB,EAUT,MAVS,EAUD,MAVC,EAUO,MAVP,EAUe,MAVf,EAUuB,MAVvB,CAAnB;;AAYA,OAAKF,QAAL,GAAgB,UAASF,IAAT,EAAeb,GAAf,EAAoB;AAClCa,IAAAA,IAAI,CAACnB,KAAL,GAAamB,IAAI,CAAClB,SAAlB;AACAkB,IAAAA,IAAI,CAACjB,KAAL,GAAa,KAAb;AAEA,QAAIgC,SAAS,GAAGf,IAAI,CAACpB,SAAL,GAAiBoB,IAAI,CAACd,QAAL,CAAcC,GAAd,CAAjC;AAEA,QAAI4B,SAAS,GAAG,CAAhB,EACE,OAAO,KAAP,CAPgC,CASlC;;AACA,QAAIA,SAAS,IAAI,IAAb,IAAqBA,SAAS,IAAI,IAAtC,EACE,OAAO,IAAP;AAEF,QAAIC,UAAU,GAAGhB,IAAI,CAACd,QAAL,CAAcC,GAAd,CAAjB;AAEA,QAAI6B,UAAU,GAAG,CAAjB,EACE,OAAO,KAAP;AAEFhB,IAAAA,IAAI,CAACpB,SAAL,GAAkBoB,IAAI,CAACpB,SAAL,IAAkB,CAAnB,GAAwBoC,UAAzC;AAEA,QAAIA,UAAU,GAAG,IAAb,IAAqBA,UAAU,IAAI,IAAnC,IAA2CA,UAAU,IAAI,IAA7D,EACEhB,IAAI,CAACjB,KAAL,GAAa,IAAb;AAEF,WAAO,IAAP;AACD,GAxBD;AAyBD,CA/CD;;AAgDAjB,IAAI,CAACmD,QAAL,CAAcP,MAAM,CAACC,OAAP,CAAeO,IAA7B,EAAmC3B,IAAnC;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAAS4B,WAAT,CAAqBnB,IAArB,EAA2Bb,GAA3B,EAAgC;AAC9Ba,EAAAA,IAAI,CAACnB,KAAL,GAAamB,IAAI,CAAClB,SAAlB;AACAkB,EAAAA,IAAI,CAACjB,KAAL,GAAa,KAAb;AACA,MAAIgC,SAAS,GAAI,CAAjB;AACA,MAAIC,UAAU,GAAG,CAAjB;AACA,MAAII,SAAS,GAAI,CAAjB,CAL8B,CAM9B;;AACAC,EAAAA,SAAS,EAAE;AACTN,IAAAA,SAAS,GAAGf,IAAI,CAACpB,SAAL,GAAiBoB,IAAI,CAACd,QAAL,CAAcC,GAAd,CAA7B;;AACA,QAAI4B,SAAS,GAAG,CAAhB,EAAmB;AACjB;AACAf,MAAAA,IAAI,CAAChB,IAAL,GAAY,IAAZ;AACA,YAAMqC,SAAN;AACD;;AACD,QAAIN,SAAS,IAAI,IAAjB,EAAuB;AACrB;AACA,YAAMM,SAAN;AACD;;AACDL,IAAAA,UAAU,GAAGhB,IAAI,CAACd,QAAL,CAAcC,GAAd,CAAb;AACAa,IAAAA,IAAI,CAACpB,SAAL,GAAkBoB,IAAI,CAACpB,SAAL,IAAkB,CAAnB,GAAwBoC,UAAzC;;AACA,QAAID,SAAS,IAAI,IAAb,IAAqBA,SAAS,IAAI,IAAtC,EAA4C;AAC1C;AACA,UAAIC,UAAU,GAAG,IAAjB,EAAuB;AACrBhB,QAAAA,IAAI,CAACjB,KAAL,GAAa,IAAb;AACD;;AACD,YAAMsC,SAAN;AACD;;AACD,QAAIN,SAAS,IAAI,IAAjB,EAAuB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,UAAIC,UAAU,GAAG,IAAjB,EAAuB;AACrBhB,QAAAA,IAAI,CAACjB,KAAL,GAAa,IAAb;AACD;;AACD,YAAMsC,SAAN;AACD;;AACD,QAAIN,SAAS,IAAI,IAAjB,EAAuB;AACrB;AACA;AACAK,MAAAA,SAAS,GAAGpB,IAAI,CAACd,QAAL,CAAcC,GAAd,CAAZ;AACAa,MAAAA,IAAI,CAACpB,SAAL,GAAkBoB,IAAI,CAACpB,SAAL,IAAkB,CAAnB,GAAwBwC,SAAzC;;AACA,UAAIA,SAAS,GAAG,IAAhB,EAAsB;AACpBpB,QAAAA,IAAI,CAACjB,KAAL,GAAa,IAAb;AACD;AACF;AACF;;AACD,SAAOiB,IAAI,CAAChB,IAAL,IAAa,KAApB;AACD;;AAAA;AAID;AACA;AACA;AACA;;AACA0B,MAAM,CAACC,OAAP,CAAeW,MAAf,GAAwB,YAAW;AACjC,OAAKT,IAAL,GAAY,YAAW;AACrB,WAAO,QAAP;AACD,GAFD;;AAGA,OAAKC,QAAL,GAAgB,YAAW;AACzB,WAAO,IAAP;AACD,GAFD,CAJiC,CAQjC;AACA;AACA;;;AACA,OAAKV,WAAL,GAAmB,CACjB,MADiB,EACT,MADS,EACD,MADC,EACO,MADP,EACe,MADf,EACuB,MADvB,EAC+B,MAD/B,EACuC,MADvC,EAC+C,MAD/C,EACuD,MADvD,EAEjB,MAFiB,EAET,MAFS,EAED,MAFC,EAEO,MAFP,EAEe,MAFf,EAEuB,MAFvB,EAE+B,MAF/B,EAEuC,MAFvC,EAE+C,MAF/C,EAEuD,MAFvD,EAGjB,MAHiB,EAGT,MAHS,EAGD,MAHC,EAGO,MAHP,EAGe,MAHf,EAGuB,MAHvB,EAG+B,MAH/B,EAGuC,MAHvC,EAG+C,MAH/C,EAGuD,MAHvD,EAIjB,MAJiB,EAIT,MAJS,EAID,MAJC,EAIO,MAJP,EAIe,MAJf,EAIuB,MAJvB,EAI+B,MAJ/B,EAIuC,MAJvC,EAI+C,MAJ/C,EAIuD,MAJvD,EAKjB,MALiB,EAKT,MALS,EAKD,MALC,EAKO,MALP,EAKe,MALf,EAKuB,MALvB,EAK+B,MAL/B,EAKuC,MALvC,EAK+C,MAL/C,EAKuD,MALvD,EAMjB,MANiB,EAMT,MANS,EAMD,MANC,EAMO,MANP,EAMe,MANf,EAMuB,MANvB,EAM+B,MAN/B,EAMuC,MANvC,EAM+C,MAN/C,EAMuD,MANvD,EAOjB,MAPiB,EAOT,MAPS,EAOD,MAPC,EAOO,MAPP,EAOe,MAPf,EAOuB,MAPvB,EAO+B,MAP/B,EAOuC,MAPvC,EAO+C,MAP/C,EAOuD,MAPvD,EAQjB,MARiB,EAQT,MARS,EAQD,MARC,EAQO,MARP,EAQe,MARf,EAQuB,MARvB,EAQ+B,MAR/B,EAQuC,MARvC,EAQ+C,MAR/C,EAQuD,MARvD,EASjB,MATiB,EAST,MATS,EASD,MATC,EASO,MATP,EASe,MATf,EASuB,MATvB,EAS+B,MAT/B,EASuC,MATvC,EAS+C,MAT/C,EASuD,MATvD,EAUjB,MAViB,EAUT,MAVS,EAUD,MAVC,EAUO,MAVP,EAUe,MAVf,EAUuB,MAVvB,EAU+B,MAV/B,EAUuC,MAVvC,EAU+C,MAV/C,EAUuD,MAVvD,CAAnB;AAaA,OAAKF,QAAL,GAAgBiB,WAAhB;AACD,CAzBD;;AA0BArD,IAAI,CAACmD,QAAL,CAAcP,MAAM,CAACC,OAAP,CAAeW,MAA7B,EAAqC/B,IAArC;AAIA;AACA;AACA;AACA;;AACAmB,MAAM,CAACC,OAAP,CAAeY,MAAf,GAAwB,YAAW;AACjC,OAAKV,IAAL,GAAY,YAAW;AACrB,WAAO,QAAP;AACD,GAFD;;AAGA,OAAKC,QAAL,GAAgB,YAAW;AACzB,WAAO,IAAP;AACD,GAFD,CAJiC,CAQjC;AACA;AACA;;;AACA,OAAKV,WAAL,GAAmB,CACjB,MADiB,EACT,MADS,EACD,MADC,EACO,MADP,EACe,MADf,EACuB,MADvB,EAC+B,MAD/B,EACuC,MADvC,EAC+C,MAD/C,EACuD,MADvD,EAEjB,MAFiB,EAET,MAFS,EAED,MAFC,EAEO,MAFP,EAEe,MAFf,EAEuB,MAFvB,EAE+B,MAF/B,EAEuC,MAFvC,EAE+C,MAF/C,EAEuD,MAFvD,EAGjB,MAHiB,EAGT,MAHS,EAGD,MAHC,EAGO,MAHP,EAGe,MAHf,EAGuB,MAHvB,EAG+B,MAH/B,EAGuC,MAHvC,EAG+C,MAH/C,EAGuD,MAHvD,EAIjB,MAJiB,EAIT,MAJS,EAID,MAJC,EAIO,MAJP,EAIe,MAJf,EAIuB,MAJvB,EAI+B,MAJ/B,EAIuC,MAJvC,EAI+C,MAJ/C,EAIuD,MAJvD,EAKjB,MALiB,EAKT,MALS,EAKD,MALC,EAKO,MALP,EAKe,MALf,EAKuB,MALvB,EAK+B,MAL/B,EAKuC,MALvC,EAK+C,MAL/C,EAKuD,MALvD,EAMjB,MANiB,EAMT,MANS,EAMD,MANC,EAMO,MANP,EAMe,MANf,EAMuB,MANvB,EAM+B,MAN/B,EAMuC,MANvC,EAM+C,MAN/C,EAMuD,MANvD,EAOjB,MAPiB,EAOT,MAPS,EAOD,MAPC,EAOO,MAPP,EAOe,MAPf,EAOuB,MAPvB,EAO+B,MAP/B,EAOuC,MAPvC,EAO+C,MAP/C,EAOuD,MAPvD,EAQjB,MARiB,EAQT,MARS,EAQD,MARC,EAQO,MARP,EAQe,MARf,EAQuB,MARvB,EAQ+B,MAR/B,EAQuC,MARvC,EAQ+C,MAR/C,EAQuD,MARvD,EASjB,MATiB,EAST,MATS,EASD,MATC,EASO,MATP,EASe,MATf,EASuB,MATvB,EAS+B,MAT/B,EASuC,MATvC,EAS+C,MAT/C,EASuD,MATvD,EAUjB,MAViB,EAUT,MAVS,EAUD,MAVC,EAUO,MAVP,EAUe,MAVf,EAUuB,MAVvB,EAU+B,MAV/B,EAUuC,MAVvC,EAU+C,MAV/C,EAUuD,MAVvD,CAAnB;AAaA,OAAKF,QAAL,GAAgBiB,WAAhB;AACD,CAzBD;;AA0BArD,IAAI,CAACmD,QAAL,CAAcP,MAAM,CAACC,OAAP,CAAeY,MAA7B,EAAqChC,IAArC;AAIA;AACA;AACA;;AACAmB,MAAM,CAACC,OAAP,CAAea,QAAf,GAA0B,YAAW;AACnC,OAAKX,IAAL,GAAY,YAAW;AACrB,WAAO,SAAP;AACD,GAFD;;AAGA,OAAKC,QAAL,GAAgB,YAAW;AACzB,WAAO,IAAP;AACD,GAFD;AAIA;AACF;AACA;AACA;AACA;;;AACE,OAAKZ,QAAL,GAAgB,UAASF,IAAT,EAAeb,GAAf,EAAoB;AAClCa,IAAAA,IAAI,CAACnB,KAAL,GAAamB,IAAI,CAAClB,SAAlB;AACAkB,IAAAA,IAAI,CAACjB,KAAL,GAAa,KAAb;AACA,QAAIgC,SAAS,GAAI,CAAjB;AACA,QAAIC,UAAU,GAAG,CAAjB;AACA,QAAII,SAAS,GAAI,CAAjB;AACA,QAAIK,UAAU,GAAG,CAAjB;;AACAJ,IAAAA,SAAS,EAAE;AACTN,MAAAA,SAAS,GAAGf,IAAI,CAACpB,SAAL,GAAiBoB,IAAI,CAACd,QAAL,CAAcC,GAAd,CAA7B;;AACA,UAAI4B,SAAS,GAAG,CAAhB,EAAmB;AACjB;AACAf,QAAAA,IAAI,CAAChB,IAAL,GAAY,IAAZ;AACA,cAAMqC,SAAN;AACD;;AACD,UAAIN,SAAS,IAAI,IAAjB,EAAuB;AACrB;AACA,cAAMM,SAAN;AACD;;AACDL,MAAAA,UAAU,GAAGhB,IAAI,CAACd,QAAL,CAAcC,GAAd,CAAb;AACAa,MAAAA,IAAI,CAACpB,SAAL,GAAkBoB,IAAI,CAACpB,SAAL,IAAkB,CAAnB,GAAwBoC,UAAzC;;AACA,UAAID,SAAS,IAAI,IAAb,IAAqBA,SAAS,IAAI,IAAtC,EAA4C;AAC1C;AACA,YAAKC,UAAU,IAAI,IAAd,IAAsBA,UAAU,IAAI,IAArC,IAA+CA,UAAU,IAAG,EAAb,IAAmBA,UAAU,IAAI,IAApF,EAA2F;AACzF,gBAAMK,SAAN;AACD,SAJyC,CAK1C;;;AACA,YAAIL,UAAU,IAAI,IAAd,IAAsBA,UAAU,IAAI,IAAxC,EAA8C;AAC5CI,UAAAA,SAAS,GAAGpB,IAAI,CAACd,QAAL,CAAcC,GAAd,CAAZ;;AACA,cAAIiC,SAAS,IAAI,IAAb,IAAqBA,SAAS,IAAI,IAAtC,EAA4C;AAC1CK,YAAAA,UAAU,GAAGzB,IAAI,CAACd,QAAL,CAAcC,GAAd,CAAb;;AACA,gBAAIsC,UAAU,IAAI,IAAd,IAAsBA,UAAU,IAAI,IAAxC,EAA8C;AAC5CzB,cAAAA,IAAI,CAACpB,SAAL,GAAkBoB,IAAI,CAACpB,SAAL,IAAkB,EAAnB,GAA0BwC,SAAS,IAAI,CAAvC,GAA4CK,UAA7D;AACA,oBAAMJ,SAAN;AACD;AACF;AACF;;AACDrB,QAAAA,IAAI,CAACjB,KAAL,GAAa,IAAb;AACA,cAAMsC,SAAN;AACD;AACF;;AACD,WAAOrB,IAAI,CAAChB,IAAL,IAAa,KAApB;AACD,GAzCD,CAbmC,CAwDnC;AACA;AACA;;;AACA,OAAKoB,WAAL,GAAmB,CACjB,MADiB,EACT,MADS,EACD,MADC,EACO,MADP,EACe,MADf,EACuB,MADvB,EAC+B,MAD/B,EACuC,MADvC,EAC+C,MAD/C,EACuD,MADvD,EAEjB,MAFiB,EAET,MAFS,EAED,MAFC,EAEO,MAFP,EAEe,MAFf,EAEuB,MAFvB,EAE+B,MAF/B,EAEuC,MAFvC,EAE+C,MAF/C,EAEuD,MAFvD,EAGjB,MAHiB,EAGT,MAHS,EAGD,MAHC,EAGO,MAHP,EAGe,MAHf,EAGuB,MAHvB,EAG+B,MAH/B,EAGuC,MAHvC,EAG+C,MAH/C,EAGuD,MAHvD,EAIjB,MAJiB,EAIT,MAJS,EAID,MAJC,EAIO,MAJP,EAIe,MAJf,EAIuB,MAJvB,EAI+B,MAJ/B,EAIuC,MAJvC,EAI+C,MAJ/C,EAIuD,MAJvD,EAKjB,MALiB,EAKT,MALS,EAKD,MALC,EAKO,MALP,EAKe,MALf,EAKuB,MALvB,EAK+B,MAL/B,EAKuC,MALvC,EAK+C,MAL/C,EAKuD,MALvD,EAMjB,MANiB,EAMT,MANS,EAMD,MANC,EAMO,MANP,EAMe,MANf,EAMuB,MANvB,EAM+B,MAN/B,EAMuC,MANvC,EAM+C,MAN/C,EAMuD,MANvD,EAOjB,MAPiB,EAOT,MAPS,EAOD,MAPC,EAOO,MAPP,EAOe,MAPf,EAOuB,MAPvB,EAO+B,MAP/B,EAOuC,MAPvC,EAO+C,MAP/C,EAOuD,MAPvD,EAQjB,MARiB,EAQT,MARS,EAQD,MARC,EAQO,MARP,EAQe,MARf,EAQuB,MARvB,EAQ+B,MAR/B,EAQuC,MARvC,EAQ+C,MAR/C,EAQuD,MARvD,EASjB,MATiB,EAST,MATS,EASD,MATC,EASO,MATP,EASe,MATf,EASuB,MATvB,EAS+B,MAT/B,EASuC,MATvC,EAS+C,MAT/C,EASuD,MATvD,EAUjB,MAViB,EAUT,MAVS,EAUD,MAVC,EAUO,MAVP,EAUe,MAVf,EAUuB,MAVvB,EAU+B,MAV/B,EAUuC,MAVvC,EAU+C,MAV/C,EAUuD,MAVvD,CAAnB;AAYD,CAvED;;AAwEAtC,IAAI,CAACmD,QAAL,CAAcP,MAAM,CAACC,OAAP,CAAea,QAA7B,EAAuCjC,IAAvC","sourcesContent":["var util = require('util'),\n  Match = require ('../match');\n\n/**\n * Binary search implementation (recursive)\n */\nfunction binarySearch(arr, searchValue) {\n  function find(arr, searchValue, left, right) {\n    if (right < left)\n      return -1;\n\n    /*\n    int mid = mid = (left + right) / 2;\n    There is a bug in the above line;\n    Joshua Bloch suggests the following replacement:\n    */\n    var mid = Math.floor((left + right) >>> 1);\n    if (searchValue > arr[mid])\n      return find(arr, searchValue, mid + 1, right);\n\n    if (searchValue < arr[mid])\n      return find(arr, searchValue, left, mid - 1);\n\n    return mid;\n  };\n\n  return find(arr, searchValue, 0, arr.length - 1);\n};\n\n// 'Character'  iterated character class.\n//    Recognizers for specific mbcs encodings make their 'characters' available\n//    by providing a nextChar() function that fills in an instance of iteratedChar\n//    with the next char from the input.\n//    The returned characters are not converted to Unicode, but remain as the raw\n//    bytes (concatenated into an int) from the codepage data.\n//\n//  For Asian charsets, use the raw input rather than the input that has been\n//   stripped of markup.  Detection only considers multi-byte chars, effectively\n//   stripping markup anyway, and double byte chars do occur in markup too.\n//\nfunction IteratedChar() {\n\n  this.charValue = 0; // 1-4 bytes from the raw input data\n  this.index     = 0;\n  this.nextIndex = 0;\n  this.error     = false;\n  this.done      = false;\n\n  this.reset = function() {\n    this.charValue = 0;\n    this.index     = -1;\n    this.nextIndex = 0;\n    this.error     = false;\n    this.done      = false;\n  };\n\n  this.nextByte = function(det) {\n    if (this.nextIndex >= det.fRawLength) {\n      this.done = true;\n      return -1;\n    }\n    var byteValue = det.fRawInput[this.nextIndex++] & 0x00ff;\n    return byteValue;\n  };\n};\n\n\n\n/**\n * Asian double or multi-byte - charsets.\n * Match is determined mostly by the input data adhering to the\n * encoding scheme for the charset, and, optionally,\n * frequency-of-occurence of characters.\n */\n\nfunction mbcs() {};\n\n/**\n * Test the match of this charset with the input text data\n *      which is obtained via the CharsetDetector object.\n *\n * @param det  The CharsetDetector, which contains the input text\n *             to be checked for being in this charset.\n * @return     Two values packed into one int  (Damn java, anyhow)\n *             bits 0-7:  the match confidence, ranging from 0-100\n *             bits 8-15: The match reason, an enum-like value.\n */\nmbcs.prototype.match = function(det) {\n\n  var singleByteCharCount = 0,  //TODO Do we really need this?\n    doubleByteCharCount = 0,\n    commonCharCount     = 0,\n    badCharCount        = 0,\n    totalCharCount      = 0,\n    confidence          = 0;\n\n  var iter = new IteratedChar();\n\n  detectBlock: {\n    for (iter.reset(); this.nextChar(iter, det);) {\n      totalCharCount++;\n      if (iter.error) {\n        badCharCount++;\n      } else {\n        var cv = iter.charValue & 0xFFFFFFFF;\n\n        if (cv <= 0xff) {\n          singleByteCharCount++;\n        } else {\n          doubleByteCharCount++;\n          if (this.commonChars != null) {\n            // NOTE: This assumes that there are no 4-byte common chars.\n            if (binarySearch(this.commonChars, cv) >= 0) {\n              commonCharCount++;\n            }\n          }\n        }\n      }\n      if (badCharCount >= 2 && badCharCount * 5 >= doubleByteCharCount) {\n        // console.log('its here!')\n        // Bail out early if the byte data is not matching the encoding scheme.\n        break detectBlock;\n      }\n    }\n\n    if (doubleByteCharCount <= 10 && badCharCount== 0) {\n      // Not many multi-byte chars.\n      if (doubleByteCharCount == 0 && totalCharCount < 10) {\n        // There weren't any multibyte sequences, and there was a low density of non-ASCII single bytes.\n        // We don't have enough data to have any confidence.\n        // Statistical analysis of single byte non-ASCII charcters would probably help here.\n        confidence = 0;\n      }\n      else {\n        //   ASCII or ISO file?  It's probably not our encoding,\n        //   but is not incompatible with our encoding, so don't give it a zero.\n        confidence = 10;\n      }\n      break detectBlock;\n    }\n\n    //\n    //  No match if there are too many characters that don't fit the encoding scheme.\n    //    (should we have zero tolerance for these?)\n    //\n    if (doubleByteCharCount < 20 * badCharCount) {\n      confidence = 0;\n      break detectBlock;\n    }\n\n    if (this.commonChars == null) {\n      // We have no statistics on frequently occuring characters.\n      //  Assess confidence purely on having a reasonable number of\n      //  multi-byte characters (the more the better\n      confidence = 30 + doubleByteCharCount - 20 * badCharCount;\n      if (confidence > 100) {\n        confidence = 100;\n      }\n    } else {\n      //\n      // Frequency of occurence statistics exist.\n      //\n      var maxVal = Math.log(parseFloat(doubleByteCharCount) / 4);\n      var scaleFactor = 90.0 / maxVal;\n      confidence = Math.floor(Math.log(commonCharCount + 1) * scaleFactor + 10);\n      confidence = Math.min(confidence, 100);\n    }\n  }   // end of detectBlock:\n\n  return confidence == 0 ? null : new Match(det, this, confidence);\n};\n\n/**\n * Get the next character (however many bytes it is) from the input data\n *    Subclasses for specific charset encodings must implement this function\n *    to get characters according to the rules of their encoding scheme.\n *\n *  This function is not a method of class iteratedChar only because\n *   that would require a lot of extra derived classes, which is awkward.\n * @param it  The iteratedChar 'struct' into which the returned char is placed.\n * @param det The charset detector, which is needed to get at the input byte data\n *            being iterated over.\n * @return    True if a character was returned, false at end of input.\n */\n\nmbcs.prototype.nextChar = function(iter, det) {};\n\n\n\n/**\n * Shift-JIS charset recognizer.\n */\nmodule.exports.sjis = function() {\n  this.name = function() {\n    return 'Shift-JIS';\n  };\n  this.language = function() {\n    return 'ja';\n  };\n\n  // TODO:  This set of data comes from the character frequency-\n  //        of-occurence analysis tool.  The data needs to be moved\n  //        into a resource and loaded from there.\n  this.commonChars = [\n    0x8140, 0x8141, 0x8142, 0x8145, 0x815b, 0x8169, 0x816a, 0x8175, 0x8176, 0x82a0,\n    0x82a2, 0x82a4, 0x82a9, 0x82aa, 0x82ab, 0x82ad, 0x82af, 0x82b1, 0x82b3, 0x82b5,\n    0x82b7, 0x82bd, 0x82be, 0x82c1, 0x82c4, 0x82c5, 0x82c6, 0x82c8, 0x82c9, 0x82cc,\n    0x82cd, 0x82dc, 0x82e0, 0x82e7, 0x82e8, 0x82e9, 0x82ea, 0x82f0, 0x82f1, 0x8341,\n    0x8343, 0x834e, 0x834f, 0x8358, 0x835e, 0x8362, 0x8367, 0x8375, 0x8376, 0x8389,\n    0x838a, 0x838b, 0x838d, 0x8393, 0x8e96, 0x93fa, 0x95aa\n  ];\n\n  this.nextChar = function(iter, det) {\n    iter.index = iter.nextIndex;\n    iter.error = false;\n\n    var firstByte;\n    firstByte = iter.charValue = iter.nextByte(det);\n    if (firstByte < 0)\n      return false;\n\n    if (firstByte <= 0x7f || (firstByte > 0xa0 && firstByte <= 0xdf))\n      return true;\n\n    var secondByte = iter.nextByte(det);\n    if (secondByte < 0)\n      return false;\n\n    iter.charValue = (firstByte << 8) | secondByte;\n    if (! ((secondByte >= 0x40 && secondByte <= 0x7f) || (secondByte >= 0x80 && secondByte <= 0xff))) {\n      // Illegal second byte value.\n      iter.error = true;\n    }\n    return true;\n  };\n};\nutil.inherits(module.exports.sjis, mbcs);\n\n\n\n/**\n *   Big5 charset recognizer.\n */\nmodule.exports.big5 = function() {\n  this.name = function() {\n    return 'Big5';\n  };\n  this.language = function() {\n    return 'zh';\n  };\n  // TODO:  This set of data comes from the character frequency-\n  //        of-occurence analysis tool.  The data needs to be moved\n  //        into a resource and loaded from there.\n  this.commonChars = [\n    0xa140, 0xa141, 0xa142, 0xa143, 0xa147, 0xa149, 0xa175, 0xa176, 0xa440, 0xa446,\n    0xa447, 0xa448, 0xa451, 0xa454, 0xa457, 0xa464, 0xa46a, 0xa46c, 0xa477, 0xa4a3,\n    0xa4a4, 0xa4a7, 0xa4c1, 0xa4ce, 0xa4d1, 0xa4df, 0xa4e8, 0xa4fd, 0xa540, 0xa548,\n    0xa558, 0xa569, 0xa5cd, 0xa5e7, 0xa657, 0xa661, 0xa662, 0xa668, 0xa670, 0xa6a8,\n    0xa6b3, 0xa6b9, 0xa6d3, 0xa6db, 0xa6e6, 0xa6f2, 0xa740, 0xa751, 0xa759, 0xa7da,\n    0xa8a3, 0xa8a5, 0xa8ad, 0xa8d1, 0xa8d3, 0xa8e4, 0xa8fc, 0xa9c0, 0xa9d2, 0xa9f3,\n    0xaa6b, 0xaaba, 0xaabe, 0xaacc, 0xaafc, 0xac47, 0xac4f, 0xacb0, 0xacd2, 0xad59,\n    0xaec9, 0xafe0, 0xb0ea, 0xb16f, 0xb2b3, 0xb2c4, 0xb36f, 0xb44c, 0xb44e, 0xb54c,\n    0xb5a5, 0xb5bd, 0xb5d0, 0xb5d8, 0xb671, 0xb7ed, 0xb867, 0xb944, 0xbad8, 0xbb44,\n    0xbba1, 0xbdd1, 0xc2c4, 0xc3b9, 0xc440, 0xc45f\n  ];\n  this.nextChar = function(iter, det) {\n    iter.index = iter.nextIndex;\n    iter.error = false;\n\n    var firstByte = iter.charValue = iter.nextByte(det);\n\n    if (firstByte < 0)\n      return false;\n\n    // single byte character.\n    if (firstByte <= 0x7f || firstByte == 0xff)\n      return true;\n\n    var secondByte = iter.nextByte(det);\n\n    if (secondByte < 0)\n      return false;\n\n    iter.charValue = (iter.charValue << 8) | secondByte;\n\n    if (secondByte < 0x40 || secondByte == 0x7f || secondByte == 0xff)\n      iter.error = true;\n\n    return true;\n  };\n};\nutil.inherits(module.exports.big5, mbcs);\n\n\n\n/**\n *  EUC charset recognizers.  One abstract class that provides the common function\n *  for getting the next character according to the EUC encoding scheme,\n *  and nested derived classes for EUC_KR, EUC_JP, EUC_CN.\n *\n *  Get the next character value for EUC based encodings.\n *  Character 'value' is simply the raw bytes that make up the character\n *     packed into an int.\n */\nfunction eucNextChar(iter, det) {\n  iter.index = iter.nextIndex;\n  iter.error = false;\n  var firstByte  = 0;\n  var secondByte = 0;\n  var thirdByte  = 0;\n  //int fourthByte = 0;\n  buildChar: {\n    firstByte = iter.charValue = iter.nextByte(det);\n    if (firstByte < 0) {\n      // Ran off the end of the input data\n      iter.done = true;\n      break buildChar;\n    }\n    if (firstByte <= 0x8d) {\n      // single byte char\n      break buildChar;\n    }\n    secondByte = iter.nextByte(det);\n    iter.charValue = (iter.charValue << 8) | secondByte;\n    if (firstByte >= 0xA1 && firstByte <= 0xfe) {\n      // Two byte Char\n      if (secondByte < 0xa1) {\n        iter.error = true;\n      }\n      break buildChar;\n    }\n    if (firstByte == 0x8e) {\n      // Code Set 2.\n      //   In EUC-JP, total char size is 2 bytes, only one byte of actual char value.\n      //   In EUC-TW, total char size is 4 bytes, three bytes contribute to char value.\n      // We don't know which we've got.\n      // Treat it like EUC-JP.  If the data really was EUC-TW, the following two\n      //   bytes will look like a well formed 2 byte char.\n      if (secondByte < 0xa1) {\n        iter.error = true;\n      }\n      break buildChar;\n    }\n    if (firstByte == 0x8f) {\n      // Code set 3.\n      // Three byte total char size, two bytes of actual char value.\n      thirdByte = iter.nextByte(det);\n      iter.charValue = (iter.charValue << 8) | thirdByte;\n      if (thirdByte < 0xa1) {\n        iter.error = true;\n      }\n    }\n  }\n  return iter.done == false;\n};\n\n\n\n/**\n * The charset recognize for EUC-JP.  A singleton instance of this class\n *    is created and kept by the public CharsetDetector class\n */\nmodule.exports.euc_jp = function() {\n  this.name = function() {\n    return 'EUC-JP';\n  };\n  this.language = function() {\n    return 'ja';\n  };\n\n  // TODO:  This set of data comes from the character frequency-\n  //        of-occurence analysis tool.  The data needs to be moved\n  //        into a resource and loaded from there.\n  this.commonChars = [\n    0xa1a1, 0xa1a2, 0xa1a3, 0xa1a6, 0xa1bc, 0xa1ca, 0xa1cb, 0xa1d6, 0xa1d7, 0xa4a2,\n    0xa4a4, 0xa4a6, 0xa4a8, 0xa4aa, 0xa4ab, 0xa4ac, 0xa4ad, 0xa4af, 0xa4b1, 0xa4b3,\n    0xa4b5, 0xa4b7, 0xa4b9, 0xa4bb, 0xa4bd, 0xa4bf, 0xa4c0, 0xa4c1, 0xa4c3, 0xa4c4,\n    0xa4c6, 0xa4c7, 0xa4c8, 0xa4c9, 0xa4ca, 0xa4cb, 0xa4ce, 0xa4cf, 0xa4d0, 0xa4de,\n    0xa4df, 0xa4e1, 0xa4e2, 0xa4e4, 0xa4e8, 0xa4e9, 0xa4ea, 0xa4eb, 0xa4ec, 0xa4ef,\n    0xa4f2, 0xa4f3, 0xa5a2, 0xa5a3, 0xa5a4, 0xa5a6, 0xa5a7, 0xa5aa, 0xa5ad, 0xa5af,\n    0xa5b0, 0xa5b3, 0xa5b5, 0xa5b7, 0xa5b8, 0xa5b9, 0xa5bf, 0xa5c3, 0xa5c6, 0xa5c7,\n    0xa5c8, 0xa5c9, 0xa5cb, 0xa5d0, 0xa5d5, 0xa5d6, 0xa5d7, 0xa5de, 0xa5e0, 0xa5e1,\n    0xa5e5, 0xa5e9, 0xa5ea, 0xa5eb, 0xa5ec, 0xa5ed, 0xa5f3, 0xb8a9, 0xb9d4, 0xbaee,\n    0xbbc8, 0xbef0, 0xbfb7, 0xc4ea, 0xc6fc, 0xc7bd, 0xcab8, 0xcaf3, 0xcbdc, 0xcdd1\n  ];\n\n  this.nextChar = eucNextChar;\n};\nutil.inherits(module.exports.euc_jp, mbcs);\n\n\n\n/**\n * The charset recognize for EUC-KR.  A singleton instance of this class\n *    is created and kept by the public CharsetDetector class\n */\nmodule.exports.euc_kr = function() {\n  this.name = function() {\n    return 'EUC-KR';\n  };\n  this.language = function() {\n    return 'ko';\n  };\n\n  // TODO:  This set of data comes from the character frequency-\n  //        of-occurence analysis tool.  The data needs to be moved\n  //        into a resource and loaded from there.\n  this.commonChars = [\n    0xb0a1, 0xb0b3, 0xb0c5, 0xb0cd, 0xb0d4, 0xb0e6, 0xb0ed, 0xb0f8, 0xb0fa, 0xb0fc,\n    0xb1b8, 0xb1b9, 0xb1c7, 0xb1d7, 0xb1e2, 0xb3aa, 0xb3bb, 0xb4c2, 0xb4cf, 0xb4d9,\n    0xb4eb, 0xb5a5, 0xb5b5, 0xb5bf, 0xb5c7, 0xb5e9, 0xb6f3, 0xb7af, 0xb7c2, 0xb7ce,\n    0xb8a6, 0xb8ae, 0xb8b6, 0xb8b8, 0xb8bb, 0xb8e9, 0xb9ab, 0xb9ae, 0xb9cc, 0xb9ce,\n    0xb9fd, 0xbab8, 0xbace, 0xbad0, 0xbaf1, 0xbbe7, 0xbbf3, 0xbbfd, 0xbcad, 0xbcba,\n    0xbcd2, 0xbcf6, 0xbdba, 0xbdc0, 0xbdc3, 0xbdc5, 0xbec6, 0xbec8, 0xbedf, 0xbeee,\n    0xbef8, 0xbefa, 0xbfa1, 0xbfa9, 0xbfc0, 0xbfe4, 0xbfeb, 0xbfec, 0xbff8, 0xc0a7,\n    0xc0af, 0xc0b8, 0xc0ba, 0xc0bb, 0xc0bd, 0xc0c7, 0xc0cc, 0xc0ce, 0xc0cf, 0xc0d6,\n    0xc0da, 0xc0e5, 0xc0fb, 0xc0fc, 0xc1a4, 0xc1a6, 0xc1b6, 0xc1d6, 0xc1df, 0xc1f6,\n    0xc1f8, 0xc4a1, 0xc5cd, 0xc6ae, 0xc7cf, 0xc7d1, 0xc7d2, 0xc7d8, 0xc7e5, 0xc8ad\n  ];\n\n  this.nextChar = eucNextChar;\n};\nutil.inherits(module.exports.euc_kr, mbcs);\n\n\n\n/**\n *   GB-18030 recognizer. Uses simplified Chinese statistics.\n */\nmodule.exports.gb_18030 = function() {\n  this.name = function() {\n    return 'GB18030';\n  };\n  this.language = function() {\n    return 'zh';\n  };\n\n  /*\n   *  Get the next character value for EUC based encodings.\n   *  Character 'value' is simply the raw bytes that make up the character\n   *     packed into an int.\n   */\n  this.nextChar = function(iter, det) {\n    iter.index = iter.nextIndex;\n    iter.error = false;\n    var firstByte  = 0;\n    var secondByte = 0;\n    var thirdByte  = 0;\n    var fourthByte = 0;\n    buildChar: {\n      firstByte = iter.charValue = iter.nextByte(det);\n      if (firstByte < 0) {\n        // Ran off the end of the input data\n        iter.done = true;\n        break buildChar;\n      }\n      if (firstByte <= 0x80) {\n        // single byte char\n        break buildChar;\n      }\n      secondByte = iter.nextByte(det);\n      iter.charValue = (iter.charValue << 8) | secondByte;\n      if (firstByte >= 0x81 && firstByte <= 0xFE) {\n        // Two byte Char\n        if ((secondByte >= 0x40 && secondByte <= 0x7E) || (secondByte >=80 && secondByte <= 0xFE)) {\n          break buildChar;\n        }\n        // Four byte char\n        if (secondByte >= 0x30 && secondByte <= 0x39) {\n          thirdByte = iter.nextByte(det);\n          if (thirdByte >= 0x81 && thirdByte <= 0xFE) {\n            fourthByte = iter.nextByte(det);\n            if (fourthByte >= 0x30 && fourthByte <= 0x39) {\n              iter.charValue = (iter.charValue << 16) | (thirdByte << 8) | fourthByte;\n              break buildChar;\n            }\n          }\n        }\n        iter.error = true;\n        break buildChar;\n      }\n    }\n    return iter.done == false;\n  };\n\n  // TODO:  This set of data comes from the character frequency-\n  //        of-occurence analysis tool.  The data needs to be moved\n  //        into a resource and loaded from there.\n  this.commonChars = [\n    0xa1a1, 0xa1a2, 0xa1a3, 0xa1a4, 0xa1b0, 0xa1b1, 0xa1f1, 0xa1f3, 0xa3a1, 0xa3ac,\n    0xa3ba, 0xb1a8, 0xb1b8, 0xb1be, 0xb2bb, 0xb3c9, 0xb3f6, 0xb4f3, 0xb5bd, 0xb5c4,\n    0xb5e3, 0xb6af, 0xb6d4, 0xb6e0, 0xb7a2, 0xb7a8, 0xb7bd, 0xb7d6, 0xb7dd, 0xb8b4,\n    0xb8df, 0xb8f6, 0xb9ab, 0xb9c9, 0xb9d8, 0xb9fa, 0xb9fd, 0xbacd, 0xbba7, 0xbbd6,\n    0xbbe1, 0xbbfa, 0xbcbc, 0xbcdb, 0xbcfe, 0xbdcc, 0xbecd, 0xbedd, 0xbfb4, 0xbfc6,\n    0xbfc9, 0xc0b4, 0xc0ed, 0xc1cb, 0xc2db, 0xc3c7, 0xc4dc, 0xc4ea, 0xc5cc, 0xc6f7,\n    0xc7f8, 0xc8ab, 0xc8cb, 0xc8d5, 0xc8e7, 0xc9cf, 0xc9fa, 0xcab1, 0xcab5, 0xcac7,\n    0xcad0, 0xcad6, 0xcaf5, 0xcafd, 0xccec, 0xcdf8, 0xceaa, 0xcec4, 0xced2, 0xcee5,\n    0xcfb5, 0xcfc2, 0xcfd6, 0xd0c2, 0xd0c5, 0xd0d0, 0xd0d4, 0xd1a7, 0xd2aa, 0xd2b2,\n    0xd2b5, 0xd2bb, 0xd2d4, 0xd3c3, 0xd3d0, 0xd3fd, 0xd4c2, 0xd4da, 0xd5e2, 0xd6d0\n  ];\n};\nutil.inherits(module.exports.gb_18030, mbcs);\n"]},"metadata":{},"sourceType":"script"}