{"ast":null,"code":"var Stream = require('stream');\n\nvar Parse = require('./parse');\n\nvar duplexer2 = require('duplexer2');\n\nvar BufferStream = require('./BufferStream'); // Backwards compatibility for node versions < 8\n\n\nif (!Stream.Writable || !Stream.Writable.prototype.destroy) Stream = require('readable-stream');\n\nfunction parseOne(match, opts) {\n  var inStream = Stream.PassThrough({\n    objectMode: true\n  });\n  var outStream = Stream.PassThrough();\n  var transform = Stream.Transform({\n    objectMode: true\n  });\n  var re = match instanceof RegExp ? match : match && new RegExp(match);\n  var found;\n\n  transform._transform = function (entry, e, cb) {\n    if (found || re && !re.exec(entry.path)) {\n      entry.autodrain();\n      return cb();\n    } else {\n      found = true;\n      out.emit('entry', entry);\n      entry.on('error', function (e) {\n        outStream.emit('error', e);\n      });\n      entry.pipe(outStream).on('error', function (err) {\n        cb(err);\n      }).on('finish', function (d) {\n        cb(null, d);\n      });\n    }\n  };\n\n  inStream.pipe(Parse(opts)).on('error', function (err) {\n    outStream.emit('error', err);\n  }).pipe(transform).on('error', Object) // Silence error as its already addressed in transform\n  .on('finish', function () {\n    if (!found) outStream.emit('error', new Error('PATTERN_NOT_FOUND'));else outStream.end();\n  });\n  var out = duplexer2(inStream, outStream);\n\n  out.buffer = function () {\n    return BufferStream(outStream);\n  };\n\n  return out;\n}\n\nmodule.exports = parseOne;","map":{"version":3,"sources":["/home/dev/Documentos/Projects/github-clone/node_modules/unzipper/lib/parseOne.js"],"names":["Stream","require","Parse","duplexer2","BufferStream","Writable","prototype","destroy","parseOne","match","opts","inStream","PassThrough","objectMode","outStream","transform","Transform","re","RegExp","found","_transform","entry","e","cb","exec","path","autodrain","out","emit","on","pipe","err","d","Object","Error","end","buffer","module","exports"],"mappings":"AAAA,IAAIA,MAAM,GAAGC,OAAO,CAAC,QAAD,CAApB;;AACA,IAAIC,KAAK,GAAGD,OAAO,CAAC,SAAD,CAAnB;;AACA,IAAIE,SAAS,GAAGF,OAAO,CAAC,WAAD,CAAvB;;AACA,IAAIG,YAAY,GAAGH,OAAO,CAAC,gBAAD,CAA1B,C,CAEA;;;AACA,IAAI,CAACD,MAAM,CAACK,QAAR,IAAoB,CAACL,MAAM,CAACK,QAAP,CAAgBC,SAAhB,CAA0BC,OAAnD,EACEP,MAAM,GAAGC,OAAO,CAAC,iBAAD,CAAhB;;AAEF,SAASO,QAAT,CAAkBC,KAAlB,EAAwBC,IAAxB,EAA8B;AAC5B,MAAIC,QAAQ,GAAGX,MAAM,CAACY,WAAP,CAAmB;AAACC,IAAAA,UAAU,EAAC;AAAZ,GAAnB,CAAf;AACA,MAAIC,SAAS,GAAGd,MAAM,CAACY,WAAP,EAAhB;AACA,MAAIG,SAAS,GAAGf,MAAM,CAACgB,SAAP,CAAiB;AAACH,IAAAA,UAAU,EAAC;AAAZ,GAAjB,CAAhB;AACA,MAAII,EAAE,GAAGR,KAAK,YAAYS,MAAjB,GAA0BT,KAA1B,GAAmCA,KAAK,IAAI,IAAIS,MAAJ,CAAWT,KAAX,CAArD;AACA,MAAIU,KAAJ;;AAEAJ,EAAAA,SAAS,CAACK,UAAV,GAAuB,UAASC,KAAT,EAAeC,CAAf,EAAiBC,EAAjB,EAAqB;AAC1C,QAAIJ,KAAK,IAAKF,EAAE,IAAI,CAACA,EAAE,CAACO,IAAH,CAAQH,KAAK,CAACI,IAAd,CAArB,EAA2C;AACzCJ,MAAAA,KAAK,CAACK,SAAN;AACA,aAAOH,EAAE,EAAT;AACD,KAHD,MAGO;AACLJ,MAAAA,KAAK,GAAG,IAAR;AACAQ,MAAAA,GAAG,CAACC,IAAJ,CAAS,OAAT,EAAiBP,KAAjB;AACAA,MAAAA,KAAK,CAACQ,EAAN,CAAS,OAAT,EAAiB,UAASP,CAAT,EAAY;AAC3BR,QAAAA,SAAS,CAACc,IAAV,CAAe,OAAf,EAAuBN,CAAvB;AACD,OAFD;AAGAD,MAAAA,KAAK,CAACS,IAAN,CAAWhB,SAAX,EACGe,EADH,CACM,OADN,EACc,UAASE,GAAT,EAAc;AACxBR,QAAAA,EAAE,CAACQ,GAAD,CAAF;AACD,OAHH,EAIGF,EAJH,CAIM,QAJN,EAIe,UAASG,CAAT,EAAY;AACvBT,QAAAA,EAAE,CAAC,IAAD,EAAMS,CAAN,CAAF;AACD,OANH;AAOD;AACF,GAlBD;;AAoBArB,EAAAA,QAAQ,CAACmB,IAAT,CAAc5B,KAAK,CAACQ,IAAD,CAAnB,EACGmB,EADH,CACM,OADN,EACc,UAASE,GAAT,EAAc;AACxBjB,IAAAA,SAAS,CAACc,IAAV,CAAe,OAAf,EAAuBG,GAAvB;AACD,GAHH,EAIGD,IAJH,CAIQf,SAJR,EAKGc,EALH,CAKM,OALN,EAKcI,MALd,EAKuB;AALvB,GAMGJ,EANH,CAMM,QANN,EAMe,YAAW;AACtB,QAAI,CAACV,KAAL,EACEL,SAAS,CAACc,IAAV,CAAe,OAAf,EAAuB,IAAIM,KAAJ,CAAU,mBAAV,CAAvB,EADF,KAGEpB,SAAS,CAACqB,GAAV;AACH,GAXH;AAaA,MAAIR,GAAG,GAAGxB,SAAS,CAACQ,QAAD,EAAUG,SAAV,CAAnB;;AACAa,EAAAA,GAAG,CAACS,MAAJ,GAAa,YAAW;AACtB,WAAOhC,YAAY,CAACU,SAAD,CAAnB;AACD,GAFD;;AAIA,SAAOa,GAAP;AACD;;AAEDU,MAAM,CAACC,OAAP,GAAiB9B,QAAjB","sourcesContent":["var Stream = require('stream');\nvar Parse = require('./parse');\nvar duplexer2 = require('duplexer2');\nvar BufferStream = require('./BufferStream');\n\n// Backwards compatibility for node versions < 8\nif (!Stream.Writable || !Stream.Writable.prototype.destroy)\n  Stream = require('readable-stream');\n\nfunction parseOne(match,opts) {\n  var inStream = Stream.PassThrough({objectMode:true});\n  var outStream = Stream.PassThrough();\n  var transform = Stream.Transform({objectMode:true});\n  var re = match instanceof RegExp ? match : (match && new RegExp(match));\n  var found;\n\n  transform._transform = function(entry,e,cb) {\n    if (found || (re && !re.exec(entry.path))) {\n      entry.autodrain();\n      return cb();\n    } else {\n      found = true;\n      out.emit('entry',entry);\n      entry.on('error',function(e) {\n        outStream.emit('error',e);\n      });\n      entry.pipe(outStream)\n        .on('error',function(err) {\n          cb(err);\n        })\n        .on('finish',function(d) {\n          cb(null,d);\n        });\n    }\n  };\n\n  inStream.pipe(Parse(opts))\n    .on('error',function(err) {\n      outStream.emit('error',err);\n    })\n    .pipe(transform)\n    .on('error',Object)  // Silence error as its already addressed in transform\n    .on('finish',function() {\n      if (!found)\n        outStream.emit('error',new Error('PATTERN_NOT_FOUND'));\n      else\n        outStream.end();\n    });\n\n  var out = duplexer2(inStream,outStream);\n  out.buffer = function() {\n    return BufferStream(outStream);\n  };\n\n  return out;\n}\n\nmodule.exports = parseOne;\n"]},"metadata":{},"sourceType":"script"}