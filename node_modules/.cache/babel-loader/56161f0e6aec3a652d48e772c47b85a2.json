{"ast":null,"code":"\"use strict\";\n\nmodule.exports = $Ref;\n\nconst Pointer = require(\"./pointer\");\n\nconst {\n  InvalidPointerError,\n  isHandledError,\n  normalizeError\n} = require(\"./util/errors\");\n\nconst {\n  safePointerToPath,\n  stripHash,\n  getHash\n} = require(\"./util/url\");\n/**\n * This class represents a single JSON reference and its resolved value.\n *\n * @class\n */\n\n\nfunction $Ref() {\n  /**\n   * The file path or URL of the referenced file.\n   * This path is relative to the path of the main JSON schema file.\n   *\n   * This path does NOT contain document fragments (JSON pointers). It always references an ENTIRE file.\n   * Use methods such as {@link $Ref#get}, {@link $Ref#resolve}, and {@link $Ref#exists} to get\n   * specific JSON pointers within the file.\n   *\n   * @type {string}\n   */\n  this.path = undefined;\n  /**\n   * The resolved value of the JSON reference.\n   * Can be any JSON type, not just objects. Unknown file types are represented as Buffers (byte arrays).\n   *\n   * @type {?*}\n   */\n\n  this.value = undefined;\n  /**\n   * The {@link $Refs} object that contains this {@link $Ref} object.\n   *\n   * @type {$Refs}\n   */\n\n  this.$refs = undefined;\n  /**\n   * Indicates the type of {@link $Ref#path} (e.g. \"file\", \"http\", etc.)\n   *\n   * @type {?string}\n   */\n\n  this.pathType = undefined;\n  /**\n   * List of all errors. Undefined if no errors.\n   *\n   * @type {Array<JSONParserError | ResolverError | ParserError | MissingPointerError>}\n   */\n\n  this.errors = undefined;\n}\n/**\n * Pushes an error to errors array.\n *\n * @param {Array<JSONParserError | JSONParserErrorGroup>} err - The error to be pushed\n * @returns {void}\n */\n\n\n$Ref.prototype.addError = function (err) {\n  if (this.errors === undefined) {\n    this.errors = [];\n  }\n\n  const existingErrors = this.errors.map(({\n    footprint\n  }) => footprint); // the path has been almost certainly set at this point,\n  // but just in case something went wrong, normalizeError injects path if necessary\n  // moreover, certain errors might point at the same spot, so filter them out to reduce noise\n\n  if (Array.isArray(err.errors)) {\n    this.errors.push(...err.errors.map(normalizeError).filter(({\n      footprint\n    }) => !existingErrors.includes(footprint)));\n  } else if (!existingErrors.includes(err.footprint)) {\n    this.errors.push(normalizeError(err));\n  }\n};\n/**\n * Determines whether the given JSON reference exists within this {@link $Ref#value}.\n *\n * @param {string} path - The full path being resolved, optionally with a JSON pointer in the hash\n * @param {$RefParserOptions} options\n * @returns {boolean}\n */\n\n\n$Ref.prototype.exists = function (path, options) {\n  try {\n    this.resolve(path, options);\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n/**\n * Resolves the given JSON reference within this {@link $Ref#value} and returns the resolved value.\n *\n * @param {string} path - The full path being resolved, optionally with a JSON pointer in the hash\n * @param {$RefParserOptions} options\n * @returns {*} - Returns the resolved value\n */\n\n\n$Ref.prototype.get = function (path, options) {\n  return this.resolve(path, options).value;\n};\n/**\n * Resolves the given JSON reference within this {@link $Ref#value}.\n *\n * @param {string} path - The full path being resolved, optionally with a JSON pointer in the hash\n * @param {$RefParserOptions} options\n * @param {string} friendlyPath - The original user-specified path (used for error messages)\n *  @param {string} pathFromRoot - The path of `obj` from the schema root\n * @returns {Pointer | null}\n */\n\n\n$Ref.prototype.resolve = function (path, options, friendlyPath, pathFromRoot) {\n  let pointer = new Pointer(this, path, friendlyPath);\n\n  try {\n    return pointer.resolve(this.value, options, pathFromRoot);\n  } catch (err) {\n    if (!options || !options.continueOnError || !isHandledError(err)) {\n      throw err;\n    }\n\n    if (err.path === null) {\n      err.path = safePointerToPath(getHash(pathFromRoot));\n    }\n\n    if (err instanceof InvalidPointerError) {\n      // this is a special case - InvalidPointerError is thrown when dereferencing external file,\n      // but the issue is caused by the source file that referenced the file that undergoes dereferencing\n      err.source = stripHash(pathFromRoot);\n    }\n\n    this.addError(err);\n    return null;\n  }\n};\n/**\n * Sets the value of a nested property within this {@link $Ref#value}.\n * If the property, or any of its parents don't exist, they will be created.\n *\n * @param {string} path - The full path of the property to set, optionally with a JSON pointer in the hash\n * @param {*} value - The value to assign\n */\n\n\n$Ref.prototype.set = function (path, value) {\n  let pointer = new Pointer(this, path);\n  this.value = pointer.set(this.value, value);\n};\n/**\n * Determines whether the given value is a JSON reference.\n *\n * @param {*} value - The value to inspect\n * @returns {boolean}\n */\n\n\n$Ref.is$Ref = function (value) {\n  return value && typeof value === \"object\" && typeof value.$ref === \"string\" && value.$ref.length > 0;\n};\n/**\n * Determines whether the given value is an external JSON reference.\n *\n * @param {*} value - The value to inspect\n * @returns {boolean}\n */\n\n\n$Ref.isExternal$Ref = function (value) {\n  return $Ref.is$Ref(value) && value.$ref[0] !== \"#\";\n};\n/**\n * Determines whether the given value is a JSON reference, and whether it is allowed by the options.\n * For example, if it references an external file, then options.resolve.external must be true.\n *\n * @param {*} value - The value to inspect\n * @param {$RefParserOptions} options\n * @returns {boolean}\n */\n\n\n$Ref.isAllowed$Ref = function (value, options) {\n  if ($Ref.is$Ref(value)) {\n    if (value.$ref.substr(0, 2) === \"#/\" || value.$ref === \"#\") {\n      // It's a JSON Pointer reference, which is always allowed\n      return true;\n    } else if (value.$ref[0] !== \"#\" && (!options || options.resolve.external)) {\n      // It's an external reference, which is allowed by the options\n      return true;\n    }\n  }\n};\n/**\n * Determines whether the given value is a JSON reference that \"extends\" its resolved value.\n * That is, it has extra properties (in addition to \"$ref\"), so rather than simply pointing to\n * an existing value, this $ref actually creates a NEW value that is a shallow copy of the resolved\n * value, plus the extra properties.\n *\n * @example:\n *  {\n *    person: {\n *      properties: {\n *        firstName: { type: string }\n *        lastName: { type: string }\n *      }\n *    }\n *    employee: {\n *      properties: {\n *        $ref: #/person/properties\n *        salary: { type: number }\n *      }\n *    }\n *  }\n *\n *  In this example, \"employee\" is an extended $ref, since it extends \"person\" with an additional\n *  property (salary).  The result is a NEW value that looks like this:\n *\n *  {\n *    properties: {\n *      firstName: { type: string }\n *      lastName: { type: string }\n *      salary: { type: number }\n *    }\n *  }\n *\n * @param {*} value - The value to inspect\n * @returns {boolean}\n */\n\n\n$Ref.isExtended$Ref = function (value) {\n  return $Ref.is$Ref(value) && Object.keys(value).length > 1;\n};\n/**\n * Returns the resolved value of a JSON Reference.\n * If necessary, the resolved value is merged with the JSON Reference to create a new object\n *\n * @example:\n *  {\n *    person: {\n *      properties: {\n *        firstName: { type: string }\n *        lastName: { type: string }\n *      }\n *    }\n *    employee: {\n *      properties: {\n *        $ref: #/person/properties\n *        salary: { type: number }\n *      }\n *    }\n *  }\n *\n *  When \"person\" and \"employee\" are merged, you end up with the following object:\n *\n *  {\n *    properties: {\n *      firstName: { type: string }\n *      lastName: { type: string }\n *      salary: { type: number }\n *    }\n *  }\n *\n * @param {object} $ref - The JSON reference object (the one with the \"$ref\" property)\n * @param {*} resolvedValue - The resolved value, which can be any type\n * @returns {*} - Returns the dereferenced value\n */\n\n\n$Ref.dereference = function ($ref, resolvedValue) {\n  if (resolvedValue && typeof resolvedValue === \"object\" && $Ref.isExtended$Ref($ref)) {\n    let merged = {};\n\n    for (let key of Object.keys($ref)) {\n      if (key !== \"$ref\") {\n        merged[key] = $ref[key];\n      }\n    }\n\n    for (let key of Object.keys(resolvedValue)) {\n      if (!(key in merged)) {\n        merged[key] = resolvedValue[key];\n      }\n    }\n\n    return merged;\n  } else {\n    // Completely replace the original reference with the resolved value\n    return resolvedValue;\n  }\n};","map":{"version":3,"sources":["/home/dev/Documentos/Projects/github-clone/node_modules/@apidevtools/json-schema-ref-parser/lib/ref.js"],"names":["module","exports","$Ref","Pointer","require","InvalidPointerError","isHandledError","normalizeError","safePointerToPath","stripHash","getHash","path","undefined","value","$refs","pathType","errors","prototype","addError","err","existingErrors","map","footprint","Array","isArray","push","filter","includes","exists","options","resolve","e","get","friendlyPath","pathFromRoot","pointer","continueOnError","source","set","is$Ref","$ref","length","isExternal$Ref","isAllowed$Ref","substr","external","isExtended$Ref","Object","keys","dereference","resolvedValue","merged","key"],"mappings":"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","sourcesContent":["\"use strict\";\n\nmodule.exports = $Ref;\n\nconst Pointer = require(\"./pointer\");\nconst { InvalidPointerError, isHandledError, normalizeError } = require(\"./util/errors\");\nconst { safePointerToPath, stripHash, getHash } = require(\"./util/url\");\n\n/**\n * This class represents a single JSON reference and its resolved value.\n *\n * @class\n */\nfunction $Ref () {\n  /**\n   * The file path or URL of the referenced file.\n   * This path is relative to the path of the main JSON schema file.\n   *\n   * This path does NOT contain document fragments (JSON pointers). It always references an ENTIRE file.\n   * Use methods such as {@link $Ref#get}, {@link $Ref#resolve}, and {@link $Ref#exists} to get\n   * specific JSON pointers within the file.\n   *\n   * @type {string}\n   */\n  this.path = undefined;\n\n  /**\n   * The resolved value of the JSON reference.\n   * Can be any JSON type, not just objects. Unknown file types are represented as Buffers (byte arrays).\n   *\n   * @type {?*}\n   */\n  this.value = undefined;\n\n  /**\n   * The {@link $Refs} object that contains this {@link $Ref} object.\n   *\n   * @type {$Refs}\n   */\n  this.$refs = undefined;\n\n  /**\n   * Indicates the type of {@link $Ref#path} (e.g. \"file\", \"http\", etc.)\n   *\n   * @type {?string}\n   */\n  this.pathType = undefined;\n\n  /**\n   * List of all errors. Undefined if no errors.\n   *\n   * @type {Array<JSONParserError | ResolverError | ParserError | MissingPointerError>}\n   */\n  this.errors = undefined;\n}\n\n/**\n * Pushes an error to errors array.\n *\n * @param {Array<JSONParserError | JSONParserErrorGroup>} err - The error to be pushed\n * @returns {void}\n */\n$Ref.prototype.addError = function (err) {\n  if (this.errors === undefined) {\n    this.errors = [];\n  }\n\n  const existingErrors = this.errors.map(({ footprint }) => footprint);\n\n  // the path has been almost certainly set at this point,\n  // but just in case something went wrong, normalizeError injects path if necessary\n  // moreover, certain errors might point at the same spot, so filter them out to reduce noise\n  if (Array.isArray(err.errors)) {\n    this.errors.push(...err.errors\n      .map(normalizeError)\n      .filter(({ footprint }) => !existingErrors.includes(footprint)),\n    );\n  }\n  else if (!existingErrors.includes(err.footprint)) {\n    this.errors.push(normalizeError(err));\n  }\n};\n\n/**\n * Determines whether the given JSON reference exists within this {@link $Ref#value}.\n *\n * @param {string} path - The full path being resolved, optionally with a JSON pointer in the hash\n * @param {$RefParserOptions} options\n * @returns {boolean}\n */\n$Ref.prototype.exists = function (path, options) {\n  try {\n    this.resolve(path, options);\n    return true;\n  }\n  catch (e) {\n    return false;\n  }\n};\n\n/**\n * Resolves the given JSON reference within this {@link $Ref#value} and returns the resolved value.\n *\n * @param {string} path - The full path being resolved, optionally with a JSON pointer in the hash\n * @param {$RefParserOptions} options\n * @returns {*} - Returns the resolved value\n */\n$Ref.prototype.get = function (path, options) {\n  return this.resolve(path, options).value;\n};\n\n/**\n * Resolves the given JSON reference within this {@link $Ref#value}.\n *\n * @param {string} path - The full path being resolved, optionally with a JSON pointer in the hash\n * @param {$RefParserOptions} options\n * @param {string} friendlyPath - The original user-specified path (used for error messages)\n *  @param {string} pathFromRoot - The path of `obj` from the schema root\n * @returns {Pointer | null}\n */\n$Ref.prototype.resolve = function (path, options, friendlyPath, pathFromRoot) {\n  let pointer = new Pointer(this, path, friendlyPath);\n  try {\n    return pointer.resolve(this.value, options, pathFromRoot);\n  }\n  catch (err) {\n    if (!options || !options.continueOnError || !isHandledError(err)) {\n      throw err;\n    }\n\n    if (err.path === null) {\n      err.path = safePointerToPath(getHash(pathFromRoot));\n    }\n\n    if (err instanceof InvalidPointerError) {\n      // this is a special case - InvalidPointerError is thrown when dereferencing external file,\n      // but the issue is caused by the source file that referenced the file that undergoes dereferencing\n      err.source = stripHash(pathFromRoot);\n    }\n\n    this.addError(err);\n    return null;\n  }\n};\n\n/**\n * Sets the value of a nested property within this {@link $Ref#value}.\n * If the property, or any of its parents don't exist, they will be created.\n *\n * @param {string} path - The full path of the property to set, optionally with a JSON pointer in the hash\n * @param {*} value - The value to assign\n */\n$Ref.prototype.set = function (path, value) {\n  let pointer = new Pointer(this, path);\n  this.value = pointer.set(this.value, value);\n};\n\n/**\n * Determines whether the given value is a JSON reference.\n *\n * @param {*} value - The value to inspect\n * @returns {boolean}\n */\n$Ref.is$Ref = function (value) {\n  return value && typeof value === \"object\" && typeof value.$ref === \"string\" && value.$ref.length > 0;\n};\n\n/**\n * Determines whether the given value is an external JSON reference.\n *\n * @param {*} value - The value to inspect\n * @returns {boolean}\n */\n$Ref.isExternal$Ref = function (value) {\n  return $Ref.is$Ref(value) && value.$ref[0] !== \"#\";\n};\n\n/**\n * Determines whether the given value is a JSON reference, and whether it is allowed by the options.\n * For example, if it references an external file, then options.resolve.external must be true.\n *\n * @param {*} value - The value to inspect\n * @param {$RefParserOptions} options\n * @returns {boolean}\n */\n$Ref.isAllowed$Ref = function (value, options) {\n  if ($Ref.is$Ref(value)) {\n    if (value.$ref.substr(0, 2) === \"#/\" || value.$ref === \"#\") {\n      // It's a JSON Pointer reference, which is always allowed\n      return true;\n    }\n    else if (value.$ref[0] !== \"#\" && (!options || options.resolve.external)) {\n      // It's an external reference, which is allowed by the options\n      return true;\n    }\n  }\n};\n\n/**\n * Determines whether the given value is a JSON reference that \"extends\" its resolved value.\n * That is, it has extra properties (in addition to \"$ref\"), so rather than simply pointing to\n * an existing value, this $ref actually creates a NEW value that is a shallow copy of the resolved\n * value, plus the extra properties.\n *\n * @example:\n *  {\n *    person: {\n *      properties: {\n *        firstName: { type: string }\n *        lastName: { type: string }\n *      }\n *    }\n *    employee: {\n *      properties: {\n *        $ref: #/person/properties\n *        salary: { type: number }\n *      }\n *    }\n *  }\n *\n *  In this example, \"employee\" is an extended $ref, since it extends \"person\" with an additional\n *  property (salary).  The result is a NEW value that looks like this:\n *\n *  {\n *    properties: {\n *      firstName: { type: string }\n *      lastName: { type: string }\n *      salary: { type: number }\n *    }\n *  }\n *\n * @param {*} value - The value to inspect\n * @returns {boolean}\n */\n$Ref.isExtended$Ref = function (value) {\n  return $Ref.is$Ref(value) && Object.keys(value).length > 1;\n};\n\n/**\n * Returns the resolved value of a JSON Reference.\n * If necessary, the resolved value is merged with the JSON Reference to create a new object\n *\n * @example:\n *  {\n *    person: {\n *      properties: {\n *        firstName: { type: string }\n *        lastName: { type: string }\n *      }\n *    }\n *    employee: {\n *      properties: {\n *        $ref: #/person/properties\n *        salary: { type: number }\n *      }\n *    }\n *  }\n *\n *  When \"person\" and \"employee\" are merged, you end up with the following object:\n *\n *  {\n *    properties: {\n *      firstName: { type: string }\n *      lastName: { type: string }\n *      salary: { type: number }\n *    }\n *  }\n *\n * @param {object} $ref - The JSON reference object (the one with the \"$ref\" property)\n * @param {*} resolvedValue - The resolved value, which can be any type\n * @returns {*} - Returns the dereferenced value\n */\n$Ref.dereference = function ($ref, resolvedValue) {\n  if (resolvedValue && typeof resolvedValue === \"object\" && $Ref.isExtended$Ref($ref)) {\n    let merged = {};\n    for (let key of Object.keys($ref)) {\n      if (key !== \"$ref\") {\n        merged[key] = $ref[key];\n      }\n    }\n\n    for (let key of Object.keys(resolvedValue)) {\n      if (!(key in merged)) {\n        merged[key] = resolvedValue[key];\n      }\n    }\n\n    return merged;\n  }\n  else {\n    // Completely replace the original reference with the resolved value\n    return resolvedValue;\n  }\n};\n"]},"metadata":{},"sourceType":"script"}