{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst lodash_1 = __importDefault(require(\"lodash\"));\n\nconst validators_1 = require(\"./Schema/validators\");\n\nconst urlEncodedBodyParser = __importStar(require(\"./urlEncodedBodyParser\"));\n\nfunction generateAddDefaultParser(parser, def) {\n  return {\n    parseReq(req, res, next) {\n      parser.parseReq(req, res, (err, result) => {\n        if (err) {\n          return next(err);\n        } // TODO: How to test this?  How do you even get here?  If there's\n        // no 'content-type' you'll never get to a RequestMediaType in\n        // the first place.  If the type is `application/json`, a 0-length\n        // body will be invalid.  If the type is `text/plain`, a 0-length\n        // body is the empty string, which is not undefined.  I don't\n        // think this is ever going to be called.\n\n\n        if (result === undefined && req.body === undefined) {\n          req.body = lodash_1.default.cloneDeep(def);\n          next(null, req.body);\n        } else {\n          next(err, result);\n        }\n      });\n    }\n\n  };\n}\n\nclass RequestMediaType {\n  constructor(context, oaMediaType, mediaType, parameterLocation, parameterRequired) {\n    this.context = context;\n    this.oaMediaType = oaMediaType;\n    let parser = this.context.options.bodyParsers.get(mediaType); // OAS3 has special handling for 'application/x-www-form-urlencoded'.\n\n    if (!parser && mediaType === 'application/x-www-form-urlencoded') {\n      parser = urlEncodedBodyParser.generateBodyParser(context, oaMediaType, parameterLocation);\n    }\n\n    if (!parser) {\n      throw new Error('Unable to find suitable mime type parser for ' + `type ${mediaType} in ${context.jsonPointer}`);\n    }\n\n    const schema = oaMediaType.schema && context.resolveRef(oaMediaType.schema);\n\n    if (schema && 'default' in schema) {\n      this.parser = generateAddDefaultParser(parser, schema.default);\n    } else {\n      this.parser = parser;\n    }\n\n    if (schema) {\n      const schemaContext = context.childContext('schema');\n      this.validator = validators_1.generateRequestValidator(schemaContext, parameterLocation, parameterRequired, mediaType);\n    } else {\n      this.validator = value => ({\n        errors: null,\n        value\n      });\n    }\n  }\n\n}\n\nexports.default = RequestMediaType;","map":{"version":3,"sources":["../../src/oas3/RequestMediaType.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,MAAA,QAAA,GAAA,eAAA,CAAA,OAAA,CAAA,QAAA,CAAA,CAAA;;AAIA,MAAA,YAAA,GAAA,OAAA,CAAA,qBAAA,CAAA;;AAEA,MAAA,oBAAA,GAAA,YAAA,CAAA,OAAA,CAAA,wBAAA,CAAA,CAAA;;AAEA,SAAS,wBAAT,CAAkC,MAAlC,EAAsD,GAAtD,EAA8D;AAC1D,SAAO;AACH,IAAA,QAAQ,CAAC,GAAD,EAAM,GAAN,EAAW,IAAX,EAAe;AACnB,MAAA,MAAM,CAAC,QAAP,CAAgB,GAAhB,EAAqB,GAArB,EAA0B,CAAC,GAAD,EAAM,MAAN,KAAgB;AACtC,YAAI,GAAJ,EAAS;AACL,iBAAO,IAAI,CAAC,GAAD,CAAX;AACH,SAHqC,CAItC;AACA;AACA;AACA;AACA;AACA;;;AACA,YAAI,MAAM,KAAK,SAAX,IAAwB,GAAG,CAAC,IAAJ,KAAa,SAAzC,EAAoD;AAChD,UAAA,GAAG,CAAC,IAAJ,GAAW,QAAA,CAAA,OAAA,CAAG,SAAH,CAAa,GAAb,CAAX;AACA,UAAA,IAAI,CAAC,IAAD,EAAO,GAAG,CAAC,IAAX,CAAJ;AACH,SAHD,MAGO;AACH,UAAA,IAAI,CAAC,GAAD,EAAM,MAAN,CAAJ;AACH;AACJ,OAhBD;AAiBH;;AAnBE,GAAP;AAqBH;;AAED,MAAqB,gBAArB,CAAqC;AAMjC,EAAA,WAAA,CACI,OADJ,EAEI,WAFJ,EAGI,SAHJ,EAII,iBAJJ,EAKI,iBALJ,EAK8B;AAE1B,SAAK,OAAL,GAAe,OAAf;AACA,SAAK,WAAL,GAAmB,WAAnB;AAEA,QAAI,MAAM,GAAG,KAAK,OAAL,CAAa,OAAb,CAAqB,WAArB,CAAiC,GAAjC,CAAqC,SAArC,CAAb,CAL0B,CAO1B;;AACA,QAAI,CAAC,MAAD,IAAW,SAAS,KAAK,mCAA7B,EAAkE;AAC9D,MAAA,MAAM,GAAG,oBAAoB,CAAC,kBAArB,CACL,OADK,EAEL,WAFK,EAGL,iBAHK,CAAT;AAKH;;AAED,QAAI,CAAC,MAAL,EAAa;AACT,YAAM,IAAI,KAAJ,CACF,kDACI,QAAQ,SAAS,OAAO,OAAO,CAAC,WAAW,EAF7C,CAAN;AAIH;;AAED,UAAM,MAAM,GAAG,WAAW,CAAC,MAAZ,IAAsB,OAAO,CAAC,UAAR,CAAmB,WAAW,CAAC,MAA/B,CAArC;;AAEA,QAAI,MAAM,IAAI,aAAa,MAA3B,EAAmC;AAC/B,WAAK,MAAL,GAAc,wBAAwB,CAAC,MAAD,EAAS,MAAM,CAAC,OAAhB,CAAtC;AACH,KAFD,MAEO;AACH,WAAK,MAAL,GAAc,MAAd;AACH;;AAED,QAAI,MAAJ,EAAY;AACR,YAAM,aAAa,GAAG,OAAO,CAAC,YAAR,CAAqB,QAArB,CAAtB;AACA,WAAK,SAAL,GAAiB,YAAA,CAAA,wBAAA,CACb,aADa,EAEb,iBAFa,EAGb,iBAHa,EAIb,SAJa,CAAjB;AAMH,KARD,MAQO;AACH,WAAK,SAAL,GAAkB,KAAD,KAAY;AAAE,QAAA,MAAM,EAAE,IAAV;AAAgB,QAAA;AAAhB,OAAZ,CAAjB;AACH;AACJ;;AArDgC;;AAArC,OAAA,CAAA,OAAA,GAAA,gBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst lodash_1 = __importDefault(require(\"lodash\"));\nconst validators_1 = require(\"./Schema/validators\");\nconst urlEncodedBodyParser = __importStar(require(\"./urlEncodedBodyParser\"));\nfunction generateAddDefaultParser(parser, def) {\n    return {\n        parseReq(req, res, next) {\n            parser.parseReq(req, res, (err, result) => {\n                if (err) {\n                    return next(err);\n                }\n                // TODO: How to test this?  How do you even get here?  If there's\n                // no 'content-type' you'll never get to a RequestMediaType in\n                // the first place.  If the type is `application/json`, a 0-length\n                // body will be invalid.  If the type is `text/plain`, a 0-length\n                // body is the empty string, which is not undefined.  I don't\n                // think this is ever going to be called.\n                if (result === undefined && req.body === undefined) {\n                    req.body = lodash_1.default.cloneDeep(def);\n                    next(null, req.body);\n                }\n                else {\n                    next(err, result);\n                }\n            });\n        },\n    };\n}\nclass RequestMediaType {\n    constructor(context, oaMediaType, mediaType, parameterLocation, parameterRequired) {\n        this.context = context;\n        this.oaMediaType = oaMediaType;\n        let parser = this.context.options.bodyParsers.get(mediaType);\n        // OAS3 has special handling for 'application/x-www-form-urlencoded'.\n        if (!parser && mediaType === 'application/x-www-form-urlencoded') {\n            parser = urlEncodedBodyParser.generateBodyParser(context, oaMediaType, parameterLocation);\n        }\n        if (!parser) {\n            throw new Error('Unable to find suitable mime type parser for ' +\n                `type ${mediaType} in ${context.jsonPointer}`);\n        }\n        const schema = oaMediaType.schema && context.resolveRef(oaMediaType.schema);\n        if (schema && 'default' in schema) {\n            this.parser = generateAddDefaultParser(parser, schema.default);\n        }\n        else {\n            this.parser = parser;\n        }\n        if (schema) {\n            const schemaContext = context.childContext('schema');\n            this.validator = validators_1.generateRequestValidator(schemaContext, parameterLocation, parameterRequired, mediaType);\n        }\n        else {\n            this.validator = (value) => ({ errors: null, value });\n        }\n    }\n}\nexports.default = RequestMediaType;\n//# sourceMappingURL=RequestMediaType.js.map"]},"metadata":{},"sourceType":"script"}