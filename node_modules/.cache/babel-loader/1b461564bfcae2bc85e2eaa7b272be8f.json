{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WorkQueue = void 0;\n\nconst utils = require(\"../utils\");\n\nconst error_1 = require(\"../error\");\n\nconst emulatorLogger_1 = require(\"./emulatorLogger\");\n\nconst types_1 = require(\"./types\");\n\nclass WorkQueue {\n  constructor(mode = types_1.FunctionsExecutionMode.AUTO, maxParallelWork = WorkQueue.DEFAULT_MAX_PARALLEL) {\n    this.mode = mode;\n    this.maxParallelWork = maxParallelWork;\n    this.logger = emulatorLogger_1.EmulatorLogger.forEmulator(types_1.Emulators.FUNCTIONS);\n    this.queue = [];\n    this.workRunningCount = 0;\n\n    this.notifyQueue = () => {};\n\n    this.notifyWorkFinish = () => {};\n\n    this.stopped = true;\n\n    if (maxParallelWork < 1) {\n      throw new error_1.FirebaseError(`Cannot run Functions emulator with less than 1 parallel worker (${WorkQueue.MAX_PARALLEL_ENV}=${process.env[WorkQueue.MAX_PARALLEL_ENV]})`);\n    }\n  }\n\n  submit(entry) {\n    this.queue.push(entry);\n    this.notifyQueue();\n    this.logState();\n  }\n\n  async start() {\n    if (!this.stopped) {\n      return;\n    }\n\n    this.stopped = false;\n\n    while (!this.stopped) {\n      if (!this.queue.length) {\n        await new Promise(res => {\n          this.notifyQueue = res;\n        });\n      }\n\n      if (this.workRunningCount >= this.maxParallelWork) {\n        this.logger.logLabeled(\"DEBUG\", \"work-queue\", `waiting for work to finish (running=${this.workRunningCount})`);\n        await new Promise(res => {\n          this.notifyWorkFinish = res;\n        });\n      }\n\n      const workPromise = this.runNext();\n\n      if (this.mode === types_1.FunctionsExecutionMode.SEQUENTIAL) {\n        await workPromise;\n      }\n    }\n  }\n\n  stop() {\n    this.stopped = true;\n  }\n\n  async flush(timeoutMs = 60000) {\n    if (!this.isWorking()) {\n      return;\n    }\n\n    this.logger.logLabeled(\"BULLET\", \"functions\", \"Waiting for all functions to finish...\");\n    return new Promise((res, rej) => {\n      const delta = 100;\n      let elapsed = 0;\n      const interval = setInterval(() => {\n        elapsed += delta;\n\n        if (elapsed >= timeoutMs) {\n          rej(new Error(`Functions work queue not empty after ${timeoutMs}ms`));\n        }\n\n        if (!this.isWorking()) {\n          clearInterval(interval);\n          res();\n        }\n      }, delta);\n    });\n  }\n\n  getState() {\n    return {\n      queueLength: this.queue.length,\n      workRunningCount: this.workRunningCount\n    };\n  }\n\n  isWorking() {\n    const state = this.getState();\n    return state.queueLength > 0 || state.workRunningCount > 0;\n  }\n\n  async runNext() {\n    const next = this.queue.shift();\n\n    if (next) {\n      this.workRunningCount++;\n      this.logState();\n\n      try {\n        await next();\n      } catch (e) {\n        this.logger.log(\"DEBUG\", e);\n      } finally {\n        this.workRunningCount--;\n        this.notifyWorkFinish();\n        this.logState();\n      }\n    }\n  }\n\n  logState() {\n    this.logger.logLabeled(\"DEBUG\", \"work-queue\", JSON.stringify(this.getState()));\n  }\n\n}\n\nexports.WorkQueue = WorkQueue;\nWorkQueue.MAX_PARALLEL_ENV = \"FUNCTIONS_EMULATOR_PARALLEL\";\nWorkQueue.DEFAULT_MAX_PARALLEL = Number.parseInt(utils.envOverride(WorkQueue.MAX_PARALLEL_ENV, \"50\"));","map":{"version":3,"sources":["/home/dev/Documentos/Projects/github-clone/node_modules/firebase-tools/lib/emulator/workQueue.js"],"names":["Object","defineProperty","exports","value","WorkQueue","utils","require","error_1","emulatorLogger_1","types_1","constructor","mode","FunctionsExecutionMode","AUTO","maxParallelWork","DEFAULT_MAX_PARALLEL","logger","EmulatorLogger","forEmulator","Emulators","FUNCTIONS","queue","workRunningCount","notifyQueue","notifyWorkFinish","stopped","FirebaseError","MAX_PARALLEL_ENV","process","env","submit","entry","push","logState","start","length","Promise","res","logLabeled","workPromise","runNext","SEQUENTIAL","stop","flush","timeoutMs","isWorking","rej","delta","elapsed","interval","setInterval","Error","clearInterval","getState","queueLength","state","next","shift","e","log","JSON","stringify","Number","parseInt","envOverride"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WorkQueue = void 0;\nconst utils = require(\"../utils\");\nconst error_1 = require(\"../error\");\nconst emulatorLogger_1 = require(\"./emulatorLogger\");\nconst types_1 = require(\"./types\");\nclass WorkQueue {\n    constructor(mode = types_1.FunctionsExecutionMode.AUTO, maxParallelWork = WorkQueue.DEFAULT_MAX_PARALLEL) {\n        this.mode = mode;\n        this.maxParallelWork = maxParallelWork;\n        this.logger = emulatorLogger_1.EmulatorLogger.forEmulator(types_1.Emulators.FUNCTIONS);\n        this.queue = [];\n        this.workRunningCount = 0;\n        this.notifyQueue = () => {\n        };\n        this.notifyWorkFinish = () => {\n        };\n        this.stopped = true;\n        if (maxParallelWork < 1) {\n            throw new error_1.FirebaseError(`Cannot run Functions emulator with less than 1 parallel worker (${WorkQueue.MAX_PARALLEL_ENV}=${process.env[WorkQueue.MAX_PARALLEL_ENV]})`);\n        }\n    }\n    submit(entry) {\n        this.queue.push(entry);\n        this.notifyQueue();\n        this.logState();\n    }\n    async start() {\n        if (!this.stopped) {\n            return;\n        }\n        this.stopped = false;\n        while (!this.stopped) {\n            if (!this.queue.length) {\n                await new Promise((res) => {\n                    this.notifyQueue = res;\n                });\n            }\n            if (this.workRunningCount >= this.maxParallelWork) {\n                this.logger.logLabeled(\"DEBUG\", \"work-queue\", `waiting for work to finish (running=${this.workRunningCount})`);\n                await new Promise((res) => {\n                    this.notifyWorkFinish = res;\n                });\n            }\n            const workPromise = this.runNext();\n            if (this.mode === types_1.FunctionsExecutionMode.SEQUENTIAL) {\n                await workPromise;\n            }\n        }\n    }\n    stop() {\n        this.stopped = true;\n    }\n    async flush(timeoutMs = 60000) {\n        if (!this.isWorking()) {\n            return;\n        }\n        this.logger.logLabeled(\"BULLET\", \"functions\", \"Waiting for all functions to finish...\");\n        return new Promise((res, rej) => {\n            const delta = 100;\n            let elapsed = 0;\n            const interval = setInterval(() => {\n                elapsed += delta;\n                if (elapsed >= timeoutMs) {\n                    rej(new Error(`Functions work queue not empty after ${timeoutMs}ms`));\n                }\n                if (!this.isWorking()) {\n                    clearInterval(interval);\n                    res();\n                }\n            }, delta);\n        });\n    }\n    getState() {\n        return {\n            queueLength: this.queue.length,\n            workRunningCount: this.workRunningCount,\n        };\n    }\n    isWorking() {\n        const state = this.getState();\n        return state.queueLength > 0 || state.workRunningCount > 0;\n    }\n    async runNext() {\n        const next = this.queue.shift();\n        if (next) {\n            this.workRunningCount++;\n            this.logState();\n            try {\n                await next();\n            }\n            catch (e) {\n                this.logger.log(\"DEBUG\", e);\n            }\n            finally {\n                this.workRunningCount--;\n                this.notifyWorkFinish();\n                this.logState();\n            }\n        }\n    }\n    logState() {\n        this.logger.logLabeled(\"DEBUG\", \"work-queue\", JSON.stringify(this.getState()));\n    }\n}\nexports.WorkQueue = WorkQueue;\nWorkQueue.MAX_PARALLEL_ENV = \"FUNCTIONS_EMULATOR_PARALLEL\";\nWorkQueue.DEFAULT_MAX_PARALLEL = Number.parseInt(utils.envOverride(WorkQueue.MAX_PARALLEL_ENV, \"50\"));\n"]},"metadata":{},"sourceType":"script"}