{"ast":null,"code":"/*\n * portfinder.js: A simple tool to find an open port on the current machine.\n *\n * (C) 2011, Charlie Robbins\n *\n */\n\"use strict\";\n\nvar fs = require('fs'),\n    os = require('os'),\n    net = require('net'),\n    path = require('path'),\n    _async = require('async'),\n    debug = require('debug'),\n    mkdirp = require('mkdirp').mkdirp;\n\nvar debugTestPort = debug('portfinder:testPort'),\n    debugGetPort = debug('portfinder:getPort'),\n    debugDefaultHosts = debug('portfinder:defaultHosts');\nvar internals = {};\n\ninternals.testPort = function (options, callback) {\n  if (!callback) {\n    callback = options;\n    options = {};\n  }\n\n  options.server = options.server || net.createServer(function () {//\n    // Create an empty listener for the port testing server.\n    //\n  });\n  debugTestPort(\"entered testPort(): trying\", options.host, \"port\", options.port);\n\n  function onListen() {\n    debugTestPort(\"done w/ testPort(): OK\", options.host, \"port\", options.port);\n    options.server.removeListener('error', onError);\n    options.server.close();\n    callback(null, options.port);\n  }\n\n  function onError(err) {\n    debugTestPort(\"done w/ testPort(): failed\", options.host, \"w/ port\", options.port, \"with error\", err.code);\n    options.server.removeListener('listening', onListen);\n\n    if (!(err.code == 'EADDRINUSE' || err.code == 'EACCES')) {\n      return callback(err);\n    }\n\n    var nextPort = exports.nextPort(options.port);\n\n    if (nextPort > exports.highestPort) {\n      return callback(new Error('No open ports available'));\n    }\n\n    internals.testPort({\n      port: nextPort,\n      host: options.host,\n      server: options.server\n    }, callback);\n  }\n\n  options.server.once('error', onError);\n  options.server.once('listening', onListen);\n\n  if (options.host) {\n    options.server.listen(options.port, options.host);\n  } else {\n    /*\n      Judgement of service without host\n      example:\n        express().listen(options.port)\n    */\n    options.server.listen(options.port);\n  }\n}; //\n// ### @basePort {Number}\n// The lowest port to begin any port search from\n//\n\n\nexports.basePort = 8000; //\n// ### @highestPort {Number}\n// Largest port number is an unsigned short 2**16 -1=65335\n//\n\nexports.highestPort = 65535; //\n// ### @basePath {string}\n// Default path to begin any socket search from\n//\n\nexports.basePath = '/tmp/portfinder'; //\n// ### function getPort (options, callback)\n// #### @options {Object} Settings to use when finding the necessary port\n// #### @callback {function} Continuation to respond to when complete.\n// Responds with a unbound port on the current machine.\n//\n\nexports.getPort = function (options, callback) {\n  if (!callback) {\n    callback = options;\n    options = {};\n  }\n\n  options.port = Number(options.port) || Number(exports.basePort);\n  options.host = options.host || null;\n  options.stopPort = Number(options.stopPort) || Number(exports.highestPort);\n\n  if (!options.startPort) {\n    options.startPort = Number(options.port);\n\n    if (options.startPort < 0) {\n      throw Error('Provided options.startPort(' + options.startPort + ') is less than 0, which are cannot be bound.');\n    }\n\n    if (options.stopPort < options.startPort) {\n      throw Error('Provided options.stopPort(' + options.stopPort + 'is less than options.startPort (' + options.startPort + ')');\n    }\n  }\n\n  if (options.host) {\n    var hasUserGivenHost;\n\n    for (var i = 0; i < exports._defaultHosts.length; i++) {\n      if (exports._defaultHosts[i] === options.host) {\n        hasUserGivenHost = true;\n        break;\n      }\n    }\n\n    if (!hasUserGivenHost) {\n      exports._defaultHosts.push(options.host);\n    }\n  }\n\n  var openPorts = [],\n      currentHost;\n  return _async.eachSeries(exports._defaultHosts, function (host, next) {\n    debugGetPort(\"in eachSeries() iteration callback: host is\", host);\n    return internals.testPort({\n      host: host,\n      port: options.port\n    }, function (err, port) {\n      if (err) {\n        debugGetPort(\"in eachSeries() iteration callback testPort() callback\", \"with an err:\", err.code);\n        currentHost = host;\n        return next(err);\n      } else {\n        debugGetPort(\"in eachSeries() iteration callback testPort() callback\", \"with a success for port\", port);\n        openPorts.push(port);\n        return next();\n      }\n    });\n  }, function (err) {\n    if (err) {\n      debugGetPort(\"in eachSeries() result callback: err is\", err); // If we get EADDRNOTAVAIL it means the host is not bindable, so remove it\n      // from exports._defaultHosts and start over. For ubuntu, we use EINVAL for the same\n\n      if (err.code === 'EADDRNOTAVAIL' || err.code === 'EINVAL') {\n        if (options.host === currentHost) {\n          // if bad address matches host given by user, tell them\n          //\n          // NOTE: We may need to one day handle `my-non-existent-host.local` if users\n          // report frustration with passing in hostnames that DONT map to bindable\n          // hosts, without showing them a good error.\n          var msg = 'Provided host ' + options.host + ' could NOT be bound. Please provide a different host address or hostname';\n          return callback(Error(msg));\n        } else {\n          var idx = exports._defaultHosts.indexOf(currentHost);\n\n          exports._defaultHosts.splice(idx, 1);\n\n          return exports.getPort(options, callback);\n        }\n      } else {\n        // error is not accounted for, file ticket, handle special case\n        return callback(err);\n      }\n    } // sort so we can compare first host to last host\n\n\n    openPorts.sort(function (a, b) {\n      return a - b;\n    });\n    debugGetPort(\"in eachSeries() result callback: openPorts is\", openPorts);\n\n    if (openPorts[0] === openPorts[openPorts.length - 1]) {\n      // if first === last, we found an open port\n      if (openPorts[0] <= options.stopPort) {\n        return callback(null, openPorts[0]);\n      } else {\n        var msg = 'No open ports found in between ' + options.startPort + ' and ' + options.stopPort;\n        return callback(Error(msg));\n      }\n    } else {\n      // otherwise, try again, using sorted port, aka, highest open for >= 1 host\n      return exports.getPort({\n        port: openPorts.pop(),\n        host: options.host,\n        startPort: options.startPort,\n        stopPort: options.stopPort\n      }, callback);\n    }\n  });\n}; //\n// ### function getPortPromise (options)\n// #### @options {Object} Settings to use when finding the necessary port\n// Responds a promise to an unbound port on the current machine.\n//\n\n\nexports.getPortPromise = function (options) {\n  if (typeof Promise !== 'function') {\n    throw Error('Native promise support is not available in this version of node.' + 'Please install a polyfill and assign Promise to global.Promise before calling this method');\n  }\n\n  if (!options) {\n    options = {};\n  }\n\n  return new Promise(function (resolve, reject) {\n    exports.getPort(options, function (err, port) {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve(port);\n    });\n  });\n}; //\n// ### function getPorts (count, options, callback)\n// #### @count {Number} The number of ports to find\n// #### @options {Object} Settings to use when finding the necessary port\n// #### @callback {function} Continuation to respond to when complete.\n// Responds with an array of unbound ports on the current machine.\n//\n\n\nexports.getPorts = function (count, options, callback) {\n  if (!callback) {\n    callback = options;\n    options = {};\n  }\n\n  var lastPort = null;\n\n  _async.timesSeries(count, function (index, asyncCallback) {\n    if (lastPort) {\n      options.port = exports.nextPort(lastPort);\n    }\n\n    exports.getPort(options, function (err, port) {\n      if (err) {\n        asyncCallback(err);\n      } else {\n        lastPort = port;\n        asyncCallback(null, port);\n      }\n    });\n  }, callback);\n}; //\n// ### function getSocket (options, callback)\n// #### @options {Object} Settings to use when finding the necessary port\n// #### @callback {function} Continuation to respond to when complete.\n// Responds with a unbound socket using the specified directory and base\n// name on the current machine.\n//\n\n\nexports.getSocket = function (options, callback) {\n  if (!callback) {\n    callback = options;\n    options = {};\n  }\n\n  options.mod = options.mod || parseInt(755, 8);\n  options.path = options.path || exports.basePath + '.sock'; //\n  // Tests the specified socket\n  //\n\n  function testSocket() {\n    fs.stat(options.path, function (err) {\n      //\n      // If file we're checking doesn't exist (thus, stating it emits ENOENT),\n      // we should be OK with listening on this socket.\n      //\n      if (err) {\n        if (err.code == 'ENOENT') {\n          callback(null, options.path);\n        } else {\n          callback(err);\n        }\n      } else {\n        //\n        // This file exists, so it isn't possible to listen on it. Lets try\n        // next socket.\n        //\n        options.path = exports.nextSocket(options.path);\n        exports.getSocket(options, callback);\n      }\n    });\n  } //\n  // Create the target `dir` then test connection\n  // against the socket.\n  //\n\n\n  function createAndTestSocket(dir) {\n    mkdirp(dir, options.mod, function (err) {\n      if (err) {\n        return callback(err);\n      }\n\n      options.exists = true;\n      testSocket();\n    });\n  } //\n  // Check if the parent directory of the target\n  // socket path exists. If it does, test connection\n  // against the socket. Otherwise, create the directory\n  // then test connection.\n  //\n\n\n  function checkAndTestSocket() {\n    var dir = path.dirname(options.path);\n    fs.stat(dir, function (err, stats) {\n      if (err || !stats.isDirectory()) {\n        return createAndTestSocket(dir);\n      }\n\n      options.exists = true;\n      testSocket();\n    });\n  } //\n  // If it has been explicitly stated that the\n  // target `options.path` already exists, then\n  // simply test the socket.\n  //\n\n\n  return options.exists ? testSocket() : checkAndTestSocket();\n}; //\n// ### function nextPort (port)\n// #### @port {Number} Port to increment from.\n// Gets the next port in sequence from the\n// specified `port`.\n//\n\n\nexports.nextPort = function (port) {\n  return port + 1;\n}; //\n// ### function nextSocket (socketPath)\n// #### @socketPath {string} Path to increment from\n// Gets the next socket path in sequence from the\n// specified `socketPath`.\n//\n\n\nexports.nextSocket = function (socketPath) {\n  var dir = path.dirname(socketPath),\n      name = path.basename(socketPath, '.sock'),\n      match = name.match(/^([a-zA-z]+)(\\d*)$/i),\n      index = parseInt(match[2]),\n      base = match[1];\n\n  if (isNaN(index)) {\n    index = 0;\n  }\n\n  index += 1;\n  return path.join(dir, base + index + '.sock');\n};\n/**\n * @desc List of internal hostnames provided by your machine. A user\n *       provided hostname may also be provided when calling portfinder.getPort,\n *       which would then be added to the default hosts we lookup and return here.\n *\n * @return {array}\n *\n * Long Form Explantion:\n *\n *    - Input: (os.networkInterfaces() w/ MacOS 10.11.5+ and running a VM)\n *\n *        { lo0:\n *         [ { address: '::1',\n *             netmask: 'ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff',\n *             family: 'IPv6',\n *             mac: '00:00:00:00:00:00',\n *             scopeid: 0,\n *             internal: true },\n *           { address: '127.0.0.1',\n *             netmask: '255.0.0.0',\n *             family: 'IPv4',\n *             mac: '00:00:00:00:00:00',\n *             internal: true },\n *           { address: 'fe80::1',\n *             netmask: 'ffff:ffff:ffff:ffff::',\n *             family: 'IPv6',\n *             mac: '00:00:00:00:00:00',\n *             scopeid: 1,\n *             internal: true } ],\n *        en0:\n *         [ { address: 'fe80::a299:9bff:fe17:766d',\n *             netmask: 'ffff:ffff:ffff:ffff::',\n *             family: 'IPv6',\n *             mac: 'a0:99:9b:17:76:6d',\n *             scopeid: 4,\n *             internal: false },\n *           { address: '10.0.1.22',\n *             netmask: '255.255.255.0',\n *             family: 'IPv4',\n *             mac: 'a0:99:9b:17:76:6d',\n *             internal: false } ],\n *        awdl0:\n *         [ { address: 'fe80::48a8:37ff:fe34:aaef',\n *             netmask: 'ffff:ffff:ffff:ffff::',\n *             family: 'IPv6',\n *             mac: '4a:a8:37:34:aa:ef',\n *             scopeid: 8,\n *             internal: false } ],\n *        vnic0:\n *         [ { address: '10.211.55.2',\n *             netmask: '255.255.255.0',\n *             family: 'IPv4',\n *             mac: '00:1c:42:00:00:08',\n *             internal: false } ],\n *        vnic1:\n *         [ { address: '10.37.129.2',\n *             netmask: '255.255.255.0',\n *             family: 'IPv4',\n *             mac: '00:1c:42:00:00:09',\n *             internal: false } ] }\n *\n *    - Output:\n *\n *         [\n *          '0.0.0.0',\n *          '::1',\n *          '127.0.0.1',\n *          'fe80::1',\n *          '10.0.1.22',\n *          'fe80::48a8:37ff:fe34:aaef',\n *          '10.211.55.2',\n *          '10.37.129.2'\n *         ]\n *\n *     Note we export this so we can use it in our tests, otherwise this API is private\n */\n\n\nexports._defaultHosts = function () {\n  var interfaces = {};\n\n  try {\n    interfaces = os.networkInterfaces();\n  } catch (e) {\n    // As of October 2016, Windows Subsystem for Linux (WSL) does not support\n    // the os.networkInterfaces() call and throws instead. For this platform,\n    // assume 0.0.0.0 as the only address\n    //\n    // - https://github.com/Microsoft/BashOnWindows/issues/468\n    //\n    // - Workaround is a mix of good work from the community:\n    //   - https://github.com/http-party/node-portfinder/commit/8d7e30a648ff5034186551fa8a6652669dec2f2f\n    //   - https://github.com/yarnpkg/yarn/pull/772/files\n    if (e.syscall === 'uv_interface_addresses') {// swallow error because we're just going to use defaults\n      // documented @ https://github.com/nodejs/node/blob/4b65a65e75f48ff447cabd5500ce115fb5ad4c57/doc/api/net.md#L231\n    } else {\n      throw e;\n    }\n  }\n\n  var interfaceNames = Object.keys(interfaces),\n      hiddenButImportantHost = '0.0.0.0',\n      // !important - dont remove, hence the naming :)\n  results = [hiddenButImportantHost];\n\n  for (var i = 0; i < interfaceNames.length; i++) {\n    var _interface = interfaces[interfaceNames[i]];\n\n    for (var j = 0; j < _interface.length; j++) {\n      var curr = _interface[j];\n      results.push(curr.address);\n    }\n  } // add null value, For createServer function, do not use host.\n\n\n  results.push(null);\n  debugDefaultHosts(\"exports._defaultHosts is: %o\", results);\n  return results;\n}();","map":{"version":3,"sources":["/home/dev/Documentos/Projects/github-clone/node_modules/portfinder/lib/portfinder.js"],"names":["fs","require","os","net","path","_async","debug","mkdirp","debugTestPort","debugGetPort","debugDefaultHosts","internals","testPort","options","callback","server","createServer","host","port","onListen","removeListener","onError","close","err","code","nextPort","exports","highestPort","Error","once","listen","basePort","basePath","getPort","Number","stopPort","startPort","hasUserGivenHost","i","_defaultHosts","length","push","openPorts","currentHost","eachSeries","next","msg","idx","indexOf","splice","sort","a","b","pop","getPortPromise","Promise","resolve","reject","getPorts","count","lastPort","timesSeries","index","asyncCallback","getSocket","mod","parseInt","testSocket","stat","nextSocket","createAndTestSocket","dir","exists","checkAndTestSocket","dirname","stats","isDirectory","socketPath","name","basename","match","base","isNaN","join","interfaces","networkInterfaces","e","syscall","interfaceNames","Object","keys","hiddenButImportantHost","results","_interface","j","curr","address"],"mappings":"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","sourcesContent":["/*\n * portfinder.js: A simple tool to find an open port on the current machine.\n *\n * (C) 2011, Charlie Robbins\n *\n */\n\n\"use strict\";\n\nvar fs = require('fs'),\n    os = require('os'),\n    net = require('net'),\n    path = require('path'),\n    _async = require('async'),\n    debug = require('debug'),\n    mkdirp = require('mkdirp').mkdirp;\n\nvar debugTestPort = debug('portfinder:testPort'),\n    debugGetPort = debug('portfinder:getPort'),\n    debugDefaultHosts = debug('portfinder:defaultHosts');\n\nvar internals = {};\n\ninternals.testPort = function(options, callback) {\n  if (!callback) {\n    callback = options;\n    options = {};\n  }\n\n  options.server = options.server  || net.createServer(function () {\n    //\n    // Create an empty listener for the port testing server.\n    //\n  });\n\n  debugTestPort(\"entered testPort(): trying\", options.host, \"port\", options.port);\n\n  function onListen () {\n    debugTestPort(\"done w/ testPort(): OK\", options.host, \"port\", options.port);\n\n        options.server.removeListener('error', onError);\n        options.server.close();\n      callback(null, options.port);\n  }\n\n  function onError (err) {\n    debugTestPort(\"done w/ testPort(): failed\", options.host, \"w/ port\", options.port, \"with error\", err.code);\n\n    options.server.removeListener('listening', onListen);\n\n    if (!(err.code == 'EADDRINUSE' || err.code == 'EACCES')) {\n      return callback(err);\n    }\n\n    var nextPort = exports.nextPort(options.port);\n\n    if (nextPort > exports.highestPort) {\n      return callback(new Error('No open ports available'));\n    }\n\n    internals.testPort({\n      port: nextPort,\n      host: options.host,\n      server: options.server\n    }, callback);\n  }\n\n  options.server.once('error', onError);\n  options.server.once('listening', onListen);\n\n  if (options.host) {\n    options.server.listen(options.port, options.host);\n  } else {\n    /*\n      Judgement of service without host\n      example:\n        express().listen(options.port)\n    */\n    options.server.listen(options.port);\n  }\n};\n\n//\n// ### @basePort {Number}\n// The lowest port to begin any port search from\n//\nexports.basePort = 8000;\n\n//\n// ### @highestPort {Number}\n// Largest port number is an unsigned short 2**16 -1=65335\n//\nexports.highestPort = 65535;\n\n//\n// ### @basePath {string}\n// Default path to begin any socket search from\n//\nexports.basePath = '/tmp/portfinder'\n\n//\n// ### function getPort (options, callback)\n// #### @options {Object} Settings to use when finding the necessary port\n// #### @callback {function} Continuation to respond to when complete.\n// Responds with a unbound port on the current machine.\n//\nexports.getPort = function (options, callback) {\n  if (!callback) {\n    callback = options;\n    options = {};\n\n  }\n\n  options.port   = Number(options.port) || Number(exports.basePort);\n  options.host   = options.host    || null;\n  options.stopPort = Number(options.stopPort) || Number(exports.highestPort);\n\n  if(!options.startPort) {\n    options.startPort = Number(options.port);\n    if(options.startPort < 0) {\n      throw Error('Provided options.startPort(' + options.startPort + ') is less than 0, which are cannot be bound.');\n    }\n    if(options.stopPort < options.startPort) {\n      throw Error('Provided options.stopPort(' + options.stopPort + 'is less than options.startPort (' + options.startPort + ')');\n    }\n  }\n\n  if (options.host) {\n\n    var hasUserGivenHost;\n    for (var i = 0; i < exports._defaultHosts.length; i++) {\n      if (exports._defaultHosts[i] === options.host) {\n        hasUserGivenHost = true;\n        break;\n      }\n    }\n\n    if (!hasUserGivenHost) {\n      exports._defaultHosts.push(options.host);\n    }\n\n  }\n\n  var openPorts = [], currentHost;\n  return _async.eachSeries(exports._defaultHosts, function(host, next) {\n    debugGetPort(\"in eachSeries() iteration callback: host is\", host);\n\n    return internals.testPort({ host: host, port: options.port }, function(err, port) {\n      if (err) {\n        debugGetPort(\"in eachSeries() iteration callback testPort() callback\", \"with an err:\", err.code);\n        currentHost = host;\n        return next(err);\n      } else {\n        debugGetPort(\"in eachSeries() iteration callback testPort() callback\",\n                    \"with a success for port\", port);\n        openPorts.push(port);\n        return next();\n      }\n    });\n  }, function(err) {\n\n    if (err) {\n      debugGetPort(\"in eachSeries() result callback: err is\", err);\n      // If we get EADDRNOTAVAIL it means the host is not bindable, so remove it\n      // from exports._defaultHosts and start over. For ubuntu, we use EINVAL for the same\n      if (err.code === 'EADDRNOTAVAIL' || err.code === 'EINVAL') {\n        if (options.host === currentHost) {\n          // if bad address matches host given by user, tell them\n          //\n          // NOTE: We may need to one day handle `my-non-existent-host.local` if users\n          // report frustration with passing in hostnames that DONT map to bindable\n          // hosts, without showing them a good error.\n          var msg = 'Provided host ' + options.host + ' could NOT be bound. Please provide a different host address or hostname';\n          return callback(Error(msg));\n        } else {\n          var idx = exports._defaultHosts.indexOf(currentHost);\n          exports._defaultHosts.splice(idx, 1);\n          return exports.getPort(options, callback);\n        }\n      } else {\n        // error is not accounted for, file ticket, handle special case\n        return callback(err);\n      }\n    }\n\n    // sort so we can compare first host to last host\n    openPorts.sort(function(a, b) {\n      return a - b;\n    });\n\n    debugGetPort(\"in eachSeries() result callback: openPorts is\", openPorts);\n\n    if (openPorts[0] === openPorts[openPorts.length-1]) {\n      // if first === last, we found an open port\n      if(openPorts[0] <= options.stopPort) {\n        return callback(null, openPorts[0]);\n      }\n      else {\n        var msg = 'No open ports found in between '+ options.startPort + ' and ' + options.stopPort;\n        return callback(Error(msg));\n      }\n    } else {\n      // otherwise, try again, using sorted port, aka, highest open for >= 1 host\n      return exports.getPort({ port: openPorts.pop(), host: options.host, startPort: options.startPort, stopPort: options.stopPort }, callback);\n    }\n\n  });\n};\n\n//\n// ### function getPortPromise (options)\n// #### @options {Object} Settings to use when finding the necessary port\n// Responds a promise to an unbound port on the current machine.\n//\nexports.getPortPromise = function (options) {\n  if (typeof Promise !== 'function') {\n    throw Error('Native promise support is not available in this version of node.' +\n      'Please install a polyfill and assign Promise to global.Promise before calling this method');\n  }\n  if (!options) {\n    options = {};\n  }\n  return new Promise(function(resolve, reject) {\n    exports.getPort(options, function(err, port) {\n      if (err) {\n        return reject(err);\n      }\n      resolve(port);\n    });\n  });\n}\n\n//\n// ### function getPorts (count, options, callback)\n// #### @count {Number} The number of ports to find\n// #### @options {Object} Settings to use when finding the necessary port\n// #### @callback {function} Continuation to respond to when complete.\n// Responds with an array of unbound ports on the current machine.\n//\nexports.getPorts = function (count, options, callback) {\n  if (!callback) {\n    callback = options;\n    options = {};\n  }\n\n  var lastPort = null;\n  _async.timesSeries(count, function(index, asyncCallback) {\n    if (lastPort) {\n      options.port = exports.nextPort(lastPort);\n    }\n\n    exports.getPort(options, function (err, port) {\n      if (err) {\n        asyncCallback(err);\n      } else {\n        lastPort = port;\n        asyncCallback(null, port);\n      }\n    });\n  }, callback);\n};\n\n//\n// ### function getSocket (options, callback)\n// #### @options {Object} Settings to use when finding the necessary port\n// #### @callback {function} Continuation to respond to when complete.\n// Responds with a unbound socket using the specified directory and base\n// name on the current machine.\n//\nexports.getSocket = function (options, callback) {\n  if (!callback) {\n    callback = options;\n    options = {};\n  }\n\n  options.mod  = options.mod    || parseInt(755, 8);\n  options.path = options.path   || exports.basePath + '.sock';\n\n  //\n  // Tests the specified socket\n  //\n  function testSocket () {\n    fs.stat(options.path, function (err) {\n      //\n      // If file we're checking doesn't exist (thus, stating it emits ENOENT),\n      // we should be OK with listening on this socket.\n      //\n      if (err) {\n        if (err.code == 'ENOENT') {\n          callback(null, options.path);\n        }\n        else {\n          callback(err);\n        }\n      }\n      else {\n        //\n        // This file exists, so it isn't possible to listen on it. Lets try\n        // next socket.\n        //\n        options.path = exports.nextSocket(options.path);\n        exports.getSocket(options, callback);\n      }\n    });\n  }\n\n  //\n  // Create the target `dir` then test connection\n  // against the socket.\n  //\n  function createAndTestSocket (dir) {\n    mkdirp(dir, options.mod, function (err) {\n      if (err) {\n        return callback(err);\n      }\n\n      options.exists = true;\n      testSocket();\n    });\n  }\n\n  //\n  // Check if the parent directory of the target\n  // socket path exists. If it does, test connection\n  // against the socket. Otherwise, create the directory\n  // then test connection.\n  //\n  function checkAndTestSocket () {\n    var dir = path.dirname(options.path);\n\n    fs.stat(dir, function (err, stats) {\n      if (err || !stats.isDirectory()) {\n        return createAndTestSocket(dir);\n      }\n\n      options.exists = true;\n      testSocket();\n    });\n  }\n\n  //\n  // If it has been explicitly stated that the\n  // target `options.path` already exists, then\n  // simply test the socket.\n  //\n  return options.exists\n    ? testSocket()\n    : checkAndTestSocket();\n};\n\n//\n// ### function nextPort (port)\n// #### @port {Number} Port to increment from.\n// Gets the next port in sequence from the\n// specified `port`.\n//\nexports.nextPort = function (port) {\n  return port + 1;\n};\n\n//\n// ### function nextSocket (socketPath)\n// #### @socketPath {string} Path to increment from\n// Gets the next socket path in sequence from the\n// specified `socketPath`.\n//\nexports.nextSocket = function (socketPath) {\n  var dir = path.dirname(socketPath),\n      name = path.basename(socketPath, '.sock'),\n      match = name.match(/^([a-zA-z]+)(\\d*)$/i),\n      index = parseInt(match[2]),\n      base = match[1];\n  if (isNaN(index)) {\n    index = 0;\n  }\n\n  index += 1;\n  return path.join(dir, base + index + '.sock');\n};\n\n/**\n * @desc List of internal hostnames provided by your machine. A user\n *       provided hostname may also be provided when calling portfinder.getPort,\n *       which would then be added to the default hosts we lookup and return here.\n *\n * @return {array}\n *\n * Long Form Explantion:\n *\n *    - Input: (os.networkInterfaces() w/ MacOS 10.11.5+ and running a VM)\n *\n *        { lo0:\n *         [ { address: '::1',\n *             netmask: 'ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff',\n *             family: 'IPv6',\n *             mac: '00:00:00:00:00:00',\n *             scopeid: 0,\n *             internal: true },\n *           { address: '127.0.0.1',\n *             netmask: '255.0.0.0',\n *             family: 'IPv4',\n *             mac: '00:00:00:00:00:00',\n *             internal: true },\n *           { address: 'fe80::1',\n *             netmask: 'ffff:ffff:ffff:ffff::',\n *             family: 'IPv6',\n *             mac: '00:00:00:00:00:00',\n *             scopeid: 1,\n *             internal: true } ],\n *        en0:\n *         [ { address: 'fe80::a299:9bff:fe17:766d',\n *             netmask: 'ffff:ffff:ffff:ffff::',\n *             family: 'IPv6',\n *             mac: 'a0:99:9b:17:76:6d',\n *             scopeid: 4,\n *             internal: false },\n *           { address: '10.0.1.22',\n *             netmask: '255.255.255.0',\n *             family: 'IPv4',\n *             mac: 'a0:99:9b:17:76:6d',\n *             internal: false } ],\n *        awdl0:\n *         [ { address: 'fe80::48a8:37ff:fe34:aaef',\n *             netmask: 'ffff:ffff:ffff:ffff::',\n *             family: 'IPv6',\n *             mac: '4a:a8:37:34:aa:ef',\n *             scopeid: 8,\n *             internal: false } ],\n *        vnic0:\n *         [ { address: '10.211.55.2',\n *             netmask: '255.255.255.0',\n *             family: 'IPv4',\n *             mac: '00:1c:42:00:00:08',\n *             internal: false } ],\n *        vnic1:\n *         [ { address: '10.37.129.2',\n *             netmask: '255.255.255.0',\n *             family: 'IPv4',\n *             mac: '00:1c:42:00:00:09',\n *             internal: false } ] }\n *\n *    - Output:\n *\n *         [\n *          '0.0.0.0',\n *          '::1',\n *          '127.0.0.1',\n *          'fe80::1',\n *          '10.0.1.22',\n *          'fe80::48a8:37ff:fe34:aaef',\n *          '10.211.55.2',\n *          '10.37.129.2'\n *         ]\n *\n *     Note we export this so we can use it in our tests, otherwise this API is private\n */\nexports._defaultHosts = (function() {\n  var interfaces = {};\n  try{\n    interfaces = os.networkInterfaces();\n  }\n  catch(e) {\n    // As of October 2016, Windows Subsystem for Linux (WSL) does not support\n    // the os.networkInterfaces() call and throws instead. For this platform,\n    // assume 0.0.0.0 as the only address\n    //\n    // - https://github.com/Microsoft/BashOnWindows/issues/468\n    //\n    // - Workaround is a mix of good work from the community:\n    //   - https://github.com/http-party/node-portfinder/commit/8d7e30a648ff5034186551fa8a6652669dec2f2f\n    //   - https://github.com/yarnpkg/yarn/pull/772/files\n    if (e.syscall === 'uv_interface_addresses') {\n      // swallow error because we're just going to use defaults\n      // documented @ https://github.com/nodejs/node/blob/4b65a65e75f48ff447cabd5500ce115fb5ad4c57/doc/api/net.md#L231\n    } else {\n      throw e;\n    }\n  }\n\n  var interfaceNames = Object.keys(interfaces),\n      hiddenButImportantHost = '0.0.0.0', // !important - dont remove, hence the naming :)\n      results = [hiddenButImportantHost];\n  for (var i = 0; i < interfaceNames.length; i++) {\n    var _interface = interfaces[interfaceNames[i]];\n    for (var j = 0; j < _interface.length; j++) {\n      var curr = _interface[j];\n      results.push(curr.address);\n    }\n  }\n\n  // add null value, For createServer function, do not use host.\n  results.push(null);\n\n  debugDefaultHosts(\"exports._defaultHosts is: %o\", results);\n\n  return results;\n}());\n"]},"metadata":{},"sourceType":"script"}