{"ast":null,"code":"/*!\n * router\n * Copyright(c) 2013 Roman Shtylman\n * Copyright(c) 2014 Douglas Christopher Wilson\n * MIT Licensed\n */\n'use strict';\n/**\n * Module dependencies.\n * @private\n */\n\nvar debug = require('debug')('router');\n\nvar flatten = require('array-flatten').flatten;\n\nvar Layer = require('./lib/layer');\n\nvar methods = require('methods');\n\nvar mixin = require('utils-merge');\n\nvar parseUrl = require('parseurl');\n\nvar Route = require('./lib/route');\n\nvar setPrototypeOf = require('setprototypeof');\n/**\n * Module variables.\n * @private\n */\n\n\nvar slice = Array.prototype.slice;\n/* istanbul ignore next */\n\nvar defer = typeof setImmediate === 'function' ? setImmediate : function (fn) {\n  process.nextTick(fn.bind.apply(fn, arguments));\n};\n/**\n * Expose `Router`.\n */\n\nmodule.exports = Router;\n/**\n * Expose `Route`.\n */\n\nmodule.exports.Route = Route;\n/**\n * Initialize a new `Router` with the given `options`.\n *\n * @param {object} [options]\n * @return {Router} which is a callable function\n * @public\n */\n\nfunction Router(options) {\n  if (!(this instanceof Router)) {\n    return new Router(options);\n  }\n\n  var opts = options || {};\n\n  function router(req, res, next) {\n    router.handle(req, res, next);\n  } // inherit from the correct prototype\n\n\n  setPrototypeOf(router, this);\n  router.caseSensitive = opts.caseSensitive;\n  router.mergeParams = opts.mergeParams;\n  router.params = {};\n  router.strict = opts.strict;\n  router.stack = [];\n  return router;\n}\n/**\n * Router prototype inherits from a Function.\n */\n\n/* istanbul ignore next */\n\n\nRouter.prototype = function () {};\n/**\n * Map the given param placeholder `name`(s) to the given callback.\n *\n * Parameter mapping is used to provide pre-conditions to routes\n * which use normalized placeholders. For example a _:user_id_ parameter\n * could automatically load a user's information from the database without\n * any additional code.\n *\n * The callback uses the same signature as middleware, the only difference\n * being that the value of the placeholder is passed, in this case the _id_\n * of the user. Once the `next()` function is invoked, just like middleware\n * it will continue on to execute the route, or subsequent parameter functions.\n *\n * Just like in middleware, you must either respond to the request or call next\n * to avoid stalling the request.\n *\n *  router.param('user_id', function(req, res, next, id){\n *    User.find(id, function(err, user){\n *      if (err) {\n *        return next(err)\n *      } else if (!user) {\n *        return next(new Error('failed to load user'))\n *      }\n *      req.user = user\n *      next()\n *    })\n *  })\n *\n * @param {string} name\n * @param {function} fn\n * @public\n */\n\n\nRouter.prototype.param = function param(name, fn) {\n  if (!name) {\n    throw new TypeError('argument name is required');\n  }\n\n  if (typeof name !== 'string') {\n    throw new TypeError('argument name must be a string');\n  }\n\n  if (!fn) {\n    throw new TypeError('argument fn is required');\n  }\n\n  if (typeof fn !== 'function') {\n    throw new TypeError('argument fn must be a function');\n  }\n\n  var params = this.params[name];\n\n  if (!params) {\n    params = this.params[name] = [];\n  }\n\n  params.push(fn);\n  return this;\n};\n/**\n * Dispatch a req, res into the router.\n *\n * @private\n */\n\n\nRouter.prototype.handle = function handle(req, res, callback) {\n  if (!callback) {\n    throw new TypeError('argument callback is required');\n  }\n\n  debug('dispatching %s %s', req.method, req.url);\n  var idx = 0;\n  var methods;\n  var protohost = getProtohost(req.url) || '';\n  var removed = '';\n  var self = this;\n  var slashAdded = false;\n  var paramcalled = {}; // middleware and routes\n\n  var stack = this.stack; // manage inter-router variables\n\n  var parentParams = req.params;\n  var parentUrl = req.baseUrl || '';\n  var done = restore(callback, req, 'baseUrl', 'next', 'params'); // setup next layer\n\n  req.next = next; // for options requests, respond with a default if nothing else responds\n\n  if (req.method === 'OPTIONS') {\n    methods = [];\n    done = wrap(done, generateOptionsResponder(res, methods));\n  } // setup basic req values\n\n\n  req.baseUrl = parentUrl;\n  req.originalUrl = req.originalUrl || req.url;\n  next();\n\n  function next(err) {\n    var layerError = err === 'route' ? null : err; // remove added slash\n\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    } // restore altered req.url\n\n\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    } // signal to exit router\n\n\n    if (layerError === 'router') {\n      defer(done, null);\n      return;\n    } // no more matching layers\n\n\n    if (idx >= stack.length) {\n      defer(done, layerError);\n      return;\n    } // get pathname of request\n\n\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    } // find next matching layer\n\n\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n\n      var has_method = route._handles_method(method); // build up automatic options response\n\n\n      if (!has_method && method === 'OPTIONS' && methods) {\n        methods.push.apply(methods, route._methods());\n      } // don't even bother matching route\n\n\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    } // no match\n\n\n    if (match !== true) {\n      return done(layerError);\n    } // store route for dispatch on change\n\n\n    if (route) {\n      req.route = route;\n    } // Capture one-time layer values\n\n\n    req.params = self.mergeParams ? mergeParams(layer.params, parentParams) : layer.params;\n    var layerPath = layer.path; // this should be done for the layer\n\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  }\n\n  function trim_prefix(layer, layerError, layerPath, path) {\n    if (layerPath.length !== 0) {\n      // Validate path is a prefix match\n      if (layerPath !== path.substr(0, layerPath.length)) {\n        next(layerError);\n        return;\n      } // Validate path breaks on a path separator\n\n\n      var c = path[layerPath.length];\n\n      if (c && c !== '/') {\n        next(layerError);\n        return;\n      } // Trim off the part of the url that matches the route\n      // middleware (.use stuff) needs to have the path stripped\n\n\n      debug('trim prefix (%s) from url %s', layerPath, req.url);\n      removed = layerPath;\n      req.url = protohost + req.url.substr(protohost.length + removed.length); // Ensure leading slash\n\n      if (!protohost && req.url[0] !== '/') {\n        req.url = '/' + req.url;\n        slashAdded = true;\n      } // Setup base URL (no trailing slash)\n\n\n      req.baseUrl = parentUrl + (removed[removed.length - 1] === '/' ? removed.substring(0, removed.length - 1) : removed);\n    }\n\n    debug('%s %s : %s', layer.name, layerPath, req.originalUrl);\n\n    if (layerError) {\n      layer.handle_error(layerError, req, res, next);\n    } else {\n      layer.handle_request(req, res, next);\n    }\n  }\n};\n/**\n * Process any parameters for the layer.\n *\n * @private\n */\n\n\nRouter.prototype.process_params = function process_params(layer, called, req, res, done) {\n  var params = this.params; // captured parameters from the layer, keys and values\n\n  var keys = layer.keys; // fast track\n\n  if (!keys || keys.length === 0) {\n    return done();\n  }\n\n  var i = 0;\n  var name;\n  var paramIndex = 0;\n  var key;\n  var paramVal;\n  var paramCallbacks;\n  var paramCalled; // process params in order\n  // param callbacks can be async\n\n  function param(err) {\n    if (err) {\n      return done(err);\n    }\n\n    if (i >= keys.length) {\n      return done();\n    }\n\n    paramIndex = 0;\n    key = keys[i++];\n    name = key.name;\n    paramVal = req.params[name];\n    paramCallbacks = params[name];\n    paramCalled = called[name];\n\n    if (paramVal === undefined || !paramCallbacks) {\n      return param();\n    } // param previously called with same value or error occurred\n\n\n    if (paramCalled && (paramCalled.match === paramVal || paramCalled.error && paramCalled.error !== 'route')) {\n      // restore value\n      req.params[name] = paramCalled.value; // next param\n\n      return param(paramCalled.error);\n    }\n\n    called[name] = paramCalled = {\n      error: null,\n      match: paramVal,\n      value: paramVal\n    };\n    paramCallback();\n  } // single param callbacks\n\n\n  function paramCallback(err) {\n    var fn = paramCallbacks[paramIndex++]; // store updated value\n\n    paramCalled.value = req.params[key.name];\n\n    if (err) {\n      // store error\n      paramCalled.error = err;\n      param(err);\n      return;\n    }\n\n    if (!fn) return param();\n\n    try {\n      fn(req, res, paramCallback, paramVal, key.name);\n    } catch (e) {\n      paramCallback(e);\n    }\n  }\n\n  param();\n};\n/**\n * Use the given middleware function, with optional path, defaulting to \"/\".\n *\n * Use (like `.all`) will run for any http METHOD, but it will not add\n * handlers for those methods so OPTIONS requests will not consider `.use`\n * functions even if they could respond.\n *\n * The other difference is that _route_ path is stripped and not visible\n * to the handler function. The main effect of this feature is that mounted\n * handlers can operate without any code changes regardless of the \"prefix\"\n * pathname.\n *\n * @public\n */\n\n\nRouter.prototype.use = function use(handler) {\n  var offset = 0;\n  var path = '/'; // default path to '/'\n  // disambiguate router.use([handler])\n\n  if (typeof handler !== 'function') {\n    var arg = handler;\n\n    while (Array.isArray(arg) && arg.length !== 0) {\n      arg = arg[0];\n    } // first arg is the path\n\n\n    if (typeof arg !== 'function') {\n      offset = 1;\n      path = handler;\n    }\n  }\n\n  var callbacks = flatten(slice.call(arguments, offset));\n\n  if (callbacks.length === 0) {\n    throw new TypeError('argument handler is required');\n  }\n\n  for (var i = 0; i < callbacks.length; i++) {\n    var fn = callbacks[i];\n\n    if (typeof fn !== 'function') {\n      throw new TypeError('argument handler must be a function');\n    } // add the middleware\n\n\n    debug('use %o %s', path, fn.name || '<anonymous>');\n    var layer = new Layer(path, {\n      sensitive: this.caseSensitive,\n      strict: false,\n      end: false\n    }, fn);\n    layer.route = undefined;\n    this.stack.push(layer);\n  }\n\n  return this;\n};\n/**\n * Create a new Route for the given path.\n *\n * Each route contains a separate middleware stack and VERB handlers.\n *\n * See the Route api documentation for details on adding handlers\n * and middleware to routes.\n *\n * @param {string} path\n * @return {Route}\n * @public\n */\n\n\nRouter.prototype.route = function route(path) {\n  var route = new Route(path);\n  var layer = new Layer(path, {\n    sensitive: this.caseSensitive,\n    strict: this.strict,\n    end: true\n  }, handle);\n\n  function handle(req, res, next) {\n    route.dispatch(req, res, next);\n  }\n\n  layer.route = route;\n  this.stack.push(layer);\n  return route;\n}; // create Router#VERB functions\n\n\nmethods.concat('all').forEach(function (method) {\n  Router.prototype[method] = function (path) {\n    var route = this.route(path);\n    route[method].apply(route, slice.call(arguments, 1));\n    return this;\n  };\n});\n/**\n * Generate a callback that will make an OPTIONS response.\n *\n * @param {OutgoingMessage} res\n * @param {array} methods\n * @private\n */\n\nfunction generateOptionsResponder(res, methods) {\n  return function onDone(fn, err) {\n    if (err || methods.length === 0) {\n      return fn(err);\n    }\n\n    trySendOptionsResponse(res, methods, fn);\n  };\n}\n/**\n * Get pathname of request.\n *\n * @param {IncomingMessage} req\n * @private\n */\n\n\nfunction getPathname(req) {\n  try {\n    return parseUrl(req).pathname;\n  } catch (err) {\n    return undefined;\n  }\n}\n/**\n * Get get protocol + host for a URL.\n *\n * @param {string} url\n * @private\n */\n\n\nfunction getProtohost(url) {\n  if (typeof url !== 'string' || url.length === 0 || url[0] === '/') {\n    return undefined;\n  }\n\n  var searchIndex = url.indexOf('?');\n  var pathLength = searchIndex !== -1 ? searchIndex : url.length;\n  var fqdnIndex = url.substr(0, pathLength).indexOf('://');\n  return fqdnIndex !== -1 ? url.substr(0, url.indexOf('/', 3 + fqdnIndex)) : undefined;\n}\n/**\n * Match path to a layer.\n *\n * @param {Layer} layer\n * @param {string} path\n * @private\n */\n\n\nfunction matchLayer(layer, path) {\n  try {\n    return layer.match(path);\n  } catch (err) {\n    return err;\n  }\n}\n/**\n * Merge params with parent params\n *\n * @private\n */\n\n\nfunction mergeParams(params, parent) {\n  if (typeof parent !== 'object' || !parent) {\n    return params;\n  } // make copy of parent for base\n\n\n  var obj = mixin({}, parent); // simple non-numeric merging\n\n  if (!(0 in params) || !(0 in parent)) {\n    return mixin(obj, params);\n  }\n\n  var i = 0;\n  var o = 0; // determine numeric gap in params\n\n  while (i in params) {\n    i++;\n  } // determine numeric gap in parent\n\n\n  while (o in parent) {\n    o++;\n  } // offset numeric indices in params before merge\n\n\n  for (i--; i >= 0; i--) {\n    params[i + o] = params[i]; // create holes for the merge when necessary\n\n    if (i < o) {\n      delete params[i];\n    }\n  }\n\n  return mixin(obj, params);\n}\n/**\n * Restore obj props after function\n *\n * @private\n */\n\n\nfunction restore(fn, obj) {\n  var props = new Array(arguments.length - 2);\n  var vals = new Array(arguments.length - 2);\n\n  for (var i = 0; i < props.length; i++) {\n    props[i] = arguments[i + 2];\n    vals[i] = obj[props[i]];\n  }\n\n  return function () {\n    // restore vals\n    for (var i = 0; i < props.length; i++) {\n      obj[props[i]] = vals[i];\n    }\n\n    return fn.apply(this, arguments);\n  };\n}\n/**\n * Send an OPTIONS response.\n *\n * @private\n */\n\n\nfunction sendOptionsResponse(res, methods) {\n  var options = Object.create(null); // build unique method map\n\n  for (var i = 0; i < methods.length; i++) {\n    options[methods[i]] = true;\n  } // construct the allow list\n\n\n  var allow = Object.keys(options).sort().join(', '); // send response\n\n  res.setHeader('Allow', allow);\n  res.setHeader('Content-Length', Buffer.byteLength(allow));\n  res.setHeader('Content-Type', 'text/plain');\n  res.setHeader('X-Content-Type-Options', 'nosniff');\n  res.end(allow);\n}\n/**\n * Try to send an OPTIONS response.\n *\n * @private\n */\n\n\nfunction trySendOptionsResponse(res, methods, next) {\n  try {\n    sendOptionsResponse(res, methods);\n  } catch (err) {\n    next(err);\n  }\n}\n/**\n * Wrap a function\n *\n * @private\n */\n\n\nfunction wrap(old, fn) {\n  return function proxy() {\n    var args = new Array(arguments.length + 1);\n    args[0] = old;\n\n    for (var i = 0, len = arguments.length; i < len; i++) {\n      args[i + 1] = arguments[i];\n    }\n\n    fn.apply(this, args);\n  };\n}","map":{"version":3,"sources":["/home/dev/Documentos/Projects/github-clone/node_modules/router/index.js"],"names":["debug","require","flatten","Layer","methods","mixin","parseUrl","Route","setPrototypeOf","slice","Array","prototype","defer","setImmediate","fn","process","nextTick","bind","apply","arguments","module","exports","Router","options","opts","router","req","res","next","handle","caseSensitive","mergeParams","params","strict","stack","param","name","TypeError","push","callback","method","url","idx","protohost","getProtohost","removed","self","slashAdded","paramcalled","parentParams","parentUrl","baseUrl","done","restore","wrap","generateOptionsResponder","originalUrl","err","layerError","substr","length","path","getPathname","layer","match","route","matchLayer","has_method","_handles_method","_methods","layerPath","process_params","handle_request","trim_prefix","c","substring","handle_error","called","keys","i","paramIndex","key","paramVal","paramCallbacks","paramCalled","undefined","error","value","paramCallback","e","use","handler","offset","arg","isArray","callbacks","call","sensitive","end","dispatch","concat","forEach","onDone","trySendOptionsResponse","pathname","searchIndex","indexOf","pathLength","fqdnIndex","parent","obj","o","props","vals","sendOptionsResponse","Object","create","allow","sort","join","setHeader","Buffer","byteLength","old","proxy","args","len"],"mappings":"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","sourcesContent":["/*!\n * router\n * Copyright(c) 2013 Roman Shtylman\n * Copyright(c) 2014 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar debug = require('debug')('router')\nvar flatten = require('array-flatten').flatten\nvar Layer = require('./lib/layer')\nvar methods = require('methods')\nvar mixin = require('utils-merge')\nvar parseUrl = require('parseurl')\nvar Route = require('./lib/route')\nvar setPrototypeOf = require('setprototypeof')\n\n/**\n * Module variables.\n * @private\n */\n\nvar slice = Array.prototype.slice\n\n/* istanbul ignore next */\nvar defer = typeof setImmediate === 'function'\n  ? setImmediate\n  : function(fn){ process.nextTick(fn.bind.apply(fn, arguments)) }\n\n/**\n * Expose `Router`.\n */\n\nmodule.exports = Router\n\n/**\n * Expose `Route`.\n */\n\nmodule.exports.Route = Route\n\n/**\n * Initialize a new `Router` with the given `options`.\n *\n * @param {object} [options]\n * @return {Router} which is a callable function\n * @public\n */\n\nfunction Router(options) {\n  if (!(this instanceof Router)) {\n    return new Router(options)\n  }\n\n  var opts = options || {}\n\n  function router(req, res, next) {\n    router.handle(req, res, next)\n  }\n\n  // inherit from the correct prototype\n  setPrototypeOf(router, this)\n\n  router.caseSensitive = opts.caseSensitive\n  router.mergeParams = opts.mergeParams\n  router.params = {}\n  router.strict = opts.strict\n  router.stack = []\n\n  return router\n}\n\n/**\n * Router prototype inherits from a Function.\n */\n\n/* istanbul ignore next */\nRouter.prototype = function () {}\n\n/**\n * Map the given param placeholder `name`(s) to the given callback.\n *\n * Parameter mapping is used to provide pre-conditions to routes\n * which use normalized placeholders. For example a _:user_id_ parameter\n * could automatically load a user's information from the database without\n * any additional code.\n *\n * The callback uses the same signature as middleware, the only difference\n * being that the value of the placeholder is passed, in this case the _id_\n * of the user. Once the `next()` function is invoked, just like middleware\n * it will continue on to execute the route, or subsequent parameter functions.\n *\n * Just like in middleware, you must either respond to the request or call next\n * to avoid stalling the request.\n *\n *  router.param('user_id', function(req, res, next, id){\n *    User.find(id, function(err, user){\n *      if (err) {\n *        return next(err)\n *      } else if (!user) {\n *        return next(new Error('failed to load user'))\n *      }\n *      req.user = user\n *      next()\n *    })\n *  })\n *\n * @param {string} name\n * @param {function} fn\n * @public\n */\n\nRouter.prototype.param = function param(name, fn) {\n  if (!name) {\n    throw new TypeError('argument name is required')\n  }\n\n  if (typeof name !== 'string') {\n    throw new TypeError('argument name must be a string')\n  }\n\n  if (!fn) {\n    throw new TypeError('argument fn is required')\n  }\n\n  if (typeof fn !== 'function') {\n    throw new TypeError('argument fn must be a function')\n  }\n\n  var params = this.params[name]\n\n  if (!params) {\n    params = this.params[name] = []\n  }\n\n  params.push(fn)\n\n  return this\n}\n\n/**\n * Dispatch a req, res into the router.\n *\n * @private\n */\n\nRouter.prototype.handle = function handle(req, res, callback) {\n  if (!callback) {\n    throw new TypeError('argument callback is required')\n  }\n\n  debug('dispatching %s %s', req.method, req.url)\n\n  var idx = 0\n  var methods\n  var protohost = getProtohost(req.url) || ''\n  var removed = ''\n  var self = this\n  var slashAdded = false\n  var paramcalled = {}\n\n  // middleware and routes\n  var stack = this.stack\n\n  // manage inter-router variables\n  var parentParams = req.params\n  var parentUrl = req.baseUrl || ''\n  var done = restore(callback, req, 'baseUrl', 'next', 'params')\n\n  // setup next layer\n  req.next = next\n\n  // for options requests, respond with a default if nothing else responds\n  if (req.method === 'OPTIONS') {\n    methods = []\n    done = wrap(done, generateOptionsResponder(res, methods))\n  }\n\n  // setup basic req values\n  req.baseUrl = parentUrl\n  req.originalUrl = req.originalUrl || req.url\n\n  next()\n\n  function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1)\n      slashAdded = false\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl\n      req.url = protohost + removed + req.url.substr(protohost.length)\n      removed = ''\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      defer(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      defer(done, layerError)\n      return\n    }\n\n    // get pathname of request\n    var path = getPathname(req)\n\n    if (path == null) {\n      return done(layerError)\n    }\n\n    // find next matching layer\n    var layer\n    var match\n    var route\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++]\n      match = matchLayer(layer, path)\n      route = layer.route\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match\n      }\n\n      if (match !== true) {\n        continue\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false\n        continue\n      }\n\n      var method = req.method\n      var has_method = route._handles_method(method)\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS' && methods) {\n        methods.push.apply(methods, route._methods())\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false\n        continue\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError)\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params\n    var layerPath = layer.path\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err)\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next)\n      }\n\n      trim_prefix(layer, layerError, layerPath, path)\n    })\n  }\n\n  function trim_prefix(layer, layerError, layerPath, path) {\n    if (layerPath.length !== 0) {\n      // Validate path is a prefix match\n      if (layerPath !== path.substr(0, layerPath.length)) {\n        next(layerError)\n        return\n      }\n\n      // Validate path breaks on a path separator\n      var c = path[layerPath.length]\n      if (c && c !== '/') {\n        next(layerError)\n        return\n      }\n\n      // Trim off the part of the url that matches the route\n      // middleware (.use stuff) needs to have the path stripped\n      debug('trim prefix (%s) from url %s', layerPath, req.url)\n      removed = layerPath\n      req.url = protohost + req.url.substr(protohost.length + removed.length)\n\n      // Ensure leading slash\n      if (!protohost && req.url[0] !== '/') {\n        req.url = '/' + req.url\n        slashAdded = true\n      }\n\n      // Setup base URL (no trailing slash)\n      req.baseUrl = parentUrl + (removed[removed.length - 1] === '/'\n        ? removed.substring(0, removed.length - 1)\n        : removed)\n    }\n\n    debug('%s %s : %s', layer.name, layerPath, req.originalUrl)\n\n    if (layerError) {\n      layer.handle_error(layerError, req, res, next)\n    } else {\n      layer.handle_request(req, res, next)\n    }\n  }\n}\n\n/**\n * Process any parameters for the layer.\n *\n * @private\n */\n\nRouter.prototype.process_params = function process_params(layer, called, req, res, done) {\n  var params = this.params\n\n  // captured parameters from the layer, keys and values\n  var keys = layer.keys\n\n  // fast track\n  if (!keys || keys.length === 0) {\n    return done()\n  }\n\n  var i = 0\n  var name\n  var paramIndex = 0\n  var key\n  var paramVal\n  var paramCallbacks\n  var paramCalled\n\n  // process params in order\n  // param callbacks can be async\n  function param(err) {\n    if (err) {\n      return done(err)\n    }\n\n    if (i >= keys.length ) {\n      return done()\n    }\n\n    paramIndex = 0\n    key = keys[i++]\n    name = key.name\n    paramVal = req.params[name]\n    paramCallbacks = params[name]\n    paramCalled = called[name]\n\n    if (paramVal === undefined || !paramCallbacks) {\n      return param()\n    }\n\n    // param previously called with same value or error occurred\n    if (paramCalled && (paramCalled.match === paramVal\n      || (paramCalled.error && paramCalled.error !== 'route'))) {\n      // restore value\n      req.params[name] = paramCalled.value\n\n      // next param\n      return param(paramCalled.error)\n    }\n\n    called[name] = paramCalled = {\n      error: null,\n      match: paramVal,\n      value: paramVal\n    }\n\n    paramCallback()\n  }\n\n  // single param callbacks\n  function paramCallback(err) {\n    var fn = paramCallbacks[paramIndex++]\n\n    // store updated value\n    paramCalled.value = req.params[key.name]\n\n    if (err) {\n      // store error\n      paramCalled.error = err\n      param(err)\n      return\n    }\n\n    if (!fn) return param()\n\n    try {\n      fn(req, res, paramCallback, paramVal, key.name)\n    } catch (e) {\n      paramCallback(e)\n    }\n  }\n\n  param()\n}\n\n/**\n * Use the given middleware function, with optional path, defaulting to \"/\".\n *\n * Use (like `.all`) will run for any http METHOD, but it will not add\n * handlers for those methods so OPTIONS requests will not consider `.use`\n * functions even if they could respond.\n *\n * The other difference is that _route_ path is stripped and not visible\n * to the handler function. The main effect of this feature is that mounted\n * handlers can operate without any code changes regardless of the \"prefix\"\n * pathname.\n *\n * @public\n */\n\nRouter.prototype.use = function use(handler) {\n  var offset = 0\n  var path = '/'\n\n  // default path to '/'\n  // disambiguate router.use([handler])\n  if (typeof handler !== 'function') {\n    var arg = handler\n\n    while (Array.isArray(arg) && arg.length !== 0) {\n      arg = arg[0]\n    }\n\n    // first arg is the path\n    if (typeof arg !== 'function') {\n      offset = 1\n      path = handler\n    }\n  }\n\n  var callbacks = flatten(slice.call(arguments, offset))\n\n  if (callbacks.length === 0) {\n    throw new TypeError('argument handler is required')\n  }\n\n  for (var i = 0; i < callbacks.length; i++) {\n    var fn = callbacks[i]\n\n    if (typeof fn !== 'function') {\n      throw new TypeError('argument handler must be a function')\n    }\n\n    // add the middleware\n    debug('use %o %s', path, fn.name || '<anonymous>')\n\n    var layer = new Layer(path, {\n      sensitive: this.caseSensitive,\n      strict: false,\n      end: false\n    }, fn)\n\n    layer.route = undefined\n\n    this.stack.push(layer)\n  }\n\n  return this\n}\n\n/**\n * Create a new Route for the given path.\n *\n * Each route contains a separate middleware stack and VERB handlers.\n *\n * See the Route api documentation for details on adding handlers\n * and middleware to routes.\n *\n * @param {string} path\n * @return {Route}\n * @public\n */\n\nRouter.prototype.route = function route(path) {\n  var route = new Route(path)\n\n  var layer = new Layer(path, {\n    sensitive: this.caseSensitive,\n    strict: this.strict,\n    end: true\n  }, handle)\n\n  function handle(req, res, next) {\n    route.dispatch(req, res, next)\n  }\n\n  layer.route = route\n\n  this.stack.push(layer)\n  return route\n}\n\n// create Router#VERB functions\nmethods.concat('all').forEach(function(method){\n  Router.prototype[method] = function (path) {\n    var route = this.route(path)\n    route[method].apply(route, slice.call(arguments, 1))\n    return this\n  }\n})\n\n/**\n * Generate a callback that will make an OPTIONS response.\n *\n * @param {OutgoingMessage} res\n * @param {array} methods\n * @private\n */\n\nfunction generateOptionsResponder(res, methods) {\n  return function onDone(fn, err) {\n    if (err || methods.length === 0) {\n      return fn(err)\n    }\n\n    trySendOptionsResponse(res, methods, fn)\n  }\n}\n\n/**\n * Get pathname of request.\n *\n * @param {IncomingMessage} req\n * @private\n */\n\nfunction getPathname(req) {\n  try {\n    return parseUrl(req).pathname\n  } catch (err) {\n    return undefined\n  }\n}\n\n/**\n * Get get protocol + host for a URL.\n *\n * @param {string} url\n * @private\n */\n\nfunction getProtohost(url) {\n  if (typeof url !== 'string' || url.length === 0 || url[0] === '/') {\n    return undefined\n  }\n\n  var searchIndex = url.indexOf('?')\n  var pathLength = searchIndex !== -1\n    ? searchIndex\n    : url.length\n  var fqdnIndex = url.substr(0, pathLength).indexOf('://')\n\n  return fqdnIndex !== -1\n    ? url.substr(0, url.indexOf('/', 3 + fqdnIndex))\n    : undefined\n}\n\n/**\n * Match path to a layer.\n *\n * @param {Layer} layer\n * @param {string} path\n * @private\n */\n\nfunction matchLayer(layer, path) {\n  try {\n    return layer.match(path)\n  } catch (err) {\n    return err\n  }\n}\n\n/**\n * Merge params with parent params\n *\n * @private\n */\n\nfunction mergeParams(params, parent) {\n  if (typeof parent !== 'object' || !parent) {\n    return params\n  }\n\n  // make copy of parent for base\n  var obj = mixin({}, parent)\n\n  // simple non-numeric merging\n  if (!(0 in params) || !(0 in parent)) {\n    return mixin(obj, params)\n  }\n\n  var i = 0\n  var o = 0\n\n  // determine numeric gap in params\n  while (i in params) {\n    i++\n  }\n\n  // determine numeric gap in parent\n  while (o in parent) {\n    o++\n  }\n\n  // offset numeric indices in params before merge\n  for (i--; i >= 0; i--) {\n    params[i + o] = params[i]\n\n    // create holes for the merge when necessary\n    if (i < o) {\n      delete params[i]\n    }\n  }\n\n  return mixin(obj, params)\n}\n\n/**\n * Restore obj props after function\n *\n * @private\n */\n\nfunction restore(fn, obj) {\n  var props = new Array(arguments.length - 2)\n  var vals = new Array(arguments.length - 2)\n\n  for (var i = 0; i < props.length; i++) {\n    props[i] = arguments[i + 2]\n    vals[i] = obj[props[i]]\n  }\n\n  return function(){\n    // restore vals\n    for (var i = 0; i < props.length; i++) {\n      obj[props[i]] = vals[i]\n    }\n\n    return fn.apply(this, arguments)\n  }\n}\n\n/**\n * Send an OPTIONS response.\n *\n * @private\n */\n\nfunction sendOptionsResponse(res, methods) {\n  var options = Object.create(null)\n\n  // build unique method map\n  for (var i = 0; i < methods.length; i++) {\n    options[methods[i]] = true\n  }\n\n  // construct the allow list\n  var allow = Object.keys(options).sort().join(', ')\n\n  // send response\n  res.setHeader('Allow', allow)\n  res.setHeader('Content-Length', Buffer.byteLength(allow))\n  res.setHeader('Content-Type', 'text/plain')\n  res.setHeader('X-Content-Type-Options', 'nosniff')\n  res.end(allow)\n}\n\n/**\n * Try to send an OPTIONS response.\n *\n * @private\n */\n\nfunction trySendOptionsResponse(res, methods, next) {\n  try {\n    sendOptionsResponse(res, methods)\n  } catch (err) {\n    next(err)\n  }\n}\n\n/**\n * Wrap a function\n *\n * @private\n */\n\nfunction wrap(old, fn) {\n  return function proxy() {\n    var args = new Array(arguments.length + 1)\n\n    args[0] = old\n    for (var i = 0, len = arguments.length; i < len; i++) {\n      args[i + 1] = arguments[i]\n    }\n\n    fn.apply(this, args)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}